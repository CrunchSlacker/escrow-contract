/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-eth-abi";
exports.ids = ["vendor-chunks/web3-eth-abi"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-eth-abi/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/web3-eth-abi/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/web3-utils/lib/index.js\");\nvar EthersAbiCoder = (__webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\").AbiCoder);\nvar ParamType = (__webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\").ParamType);\nvar ethersAbiCoder = new EthersAbiCoder(function(type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === \"object\") || value.constructor.name !== \"BN\")) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */ var ABICoder = function() {};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */ ABICoder.prototype.encodeFunctionSignature = function(functionName) {\n    if (typeof functionName === \"function\" || typeof functionName === \"object\" && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */ ABICoder.prototype.encodeEventSignature = function(functionName) {\n    if (typeof functionName === \"function\" || typeof functionName === \"object\" && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */ ABICoder.prototype.encodeParameter = function(type, param) {\n    return this.encodeParameters([\n        type\n    ], [\n        param\n    ]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */ ABICoder.prototype.encodeParameters = function(types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function(param, index) {\n        let type = types[index];\n        if (typeof type === \"object\" && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === \"string\" && type.includes(\"tuple\")) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param)=>{\n                if (coder.name === \"array\") {\n                    if (!coder.type.match(/\\[(\\d+)\\]/)) {\n                        return param.map((p)=>modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(\"[]\", \"\"))), p));\n                    }\n                    const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n                    if (param.length !== arrayLength) {\n                        throw new Error(\"Array length does not matches with the given input\");\n                    }\n                    return param.map((p)=>modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, \"\"))), p));\n                }\n                coder.coders.forEach((c, i)=>{\n                    if (c.name === \"tuple\") {\n                        modifyParams(c, param[i]);\n                    } else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */ ABICoder.prototype.mapTypes = function(types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function(type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === \"object\" && type.type === \"function\") {\n            type = Object.assign({}, type, {\n                type: \"bytes24\"\n            });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */ ABICoder.prototype.isSimplifiedStructFormat = function(type) {\n    return typeof type === \"object\" && typeof type.components === \"undefined\" && typeof type.name === \"undefined\";\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */ ABICoder.prototype.mapStructNameAndType = function(structName) {\n    var type = \"tuple\";\n    if (structName.indexOf(\"[]\") > -1) {\n        type = \"tuple[]\";\n        structName = structName.slice(0, -2);\n    }\n    return {\n        type: type,\n        name: structName\n    };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */ ABICoder.prototype.mapStructToCoderFormat = function(struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function(key) {\n        if (typeof struct[key] === \"object\") {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */ ABICoder.prototype.formatParam = function(type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map((p)=>this.formatParam(type.replace(\"[]\", \"\"), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            param = param.startsWith(\"-\") ? `-${utils.leftPad(param.substring(1), size)}` : utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === \"0x\") {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = \"0x0\" + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */ ABICoder.prototype.encodeFunctionCall = function(jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace(\"0x\", \"\");\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */ ABICoder.prototype.decodeParameter = function(type, bytes) {\n    return this.decodeParameters([\n        type\n    ], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */ ABICoder.prototype.decodeParameters = function(outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */ ABICoder.prototype.decodeParametersWith = function(outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === \"0x\" || bytes === \"0X\")) {\n        throw new Error(\"Returned values aren't valid, did it run Out of Gas? \" + \"You might also see this error if you are not using the \" + \"correct ABI for the contract you are retrieving data from, \" + \"requesting data from a block number that does not exist, \" + \"or querying a node which is not fully synced.\");\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), \"0x\" + bytes.replace(/0x/i, \"\"), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function(output, i) {\n        var decodedValue = res[returnValue.__length__];\n        const isStringObject = typeof output === \"object\" && output.type && output.type === \"string\";\n        const isStringType = typeof output === \"string\" && output === \"string\";\n        // only convert `0x` to null if it's not string value\n        decodedValue = decodedValue === \"0x\" && !isStringObject && !isStringType ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === \"function\" || !!output && typeof output === \"object\") && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */ ABICoder.prototype.decodeLog = function(inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [\n        topics\n    ];\n    data = data || \"\";\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function(input, i) {\n        if (input.indexed) {\n            indexedParams[i] = [\n                \"bool\",\n                \"int\",\n                \"uint\",\n                \"address\",\n                \"fixed\",\n                \"ufixed\"\n            ].find(function(staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        } else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function(res, i) {\n        returnValue[i] = res.type === \"string\" ? \"\" : null;\n        if (typeof notIndexedParams[i] !== \"undefined\") {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== \"undefined\") {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Ozs7Q0FLQyxHQUNELElBQUlBLFNBQVNDLG9EQUF3QjtBQUNyQyxJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxpQkFBaUJGLG9IQUFzQztBQUMzRCxJQUFJSSxZQUFZSixxSEFBdUM7QUFDdkQsSUFBSUssaUJBQWlCLElBQUlILGVBQWUsU0FBVUksSUFBSSxFQUFFQyxLQUFLO0lBQ3pELElBQUlELEtBQUtFLEtBQUssQ0FBQyxhQUFhLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0gsVUFBVyxFQUFFLEVBQUMsQ0FBQ0EsU0FBUyxPQUFPQSxVQUFVLFFBQU8sS0FBTUEsTUFBTUksV0FBVyxDQUFDQyxJQUFJLEtBQUssSUFBRyxHQUFJO1FBQy9ILE9BQU9MLE1BQU1NLFFBQVE7SUFDekI7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsZ0JBQWdCO0FBQ2hCLFNBQVNPLFVBQ1Q7QUFDQTs7Q0FFQyxHQUNELElBQUlDLFdBQVcsWUFDZjtBQUNBOzs7Ozs7Q0FNQyxHQUNEQSxTQUFTQyxTQUFTLENBQUNDLHVCQUF1QixHQUFHLFNBQVVDLFlBQVk7SUFDL0QsSUFBSSxPQUFPQSxpQkFBaUIsY0FBYyxPQUFPQSxpQkFBaUIsWUFBWUEsY0FBYztRQUN4RkEsZUFBZWpCLE1BQU1rQiw0QkFBNEIsQ0FBQ0Q7SUFDdEQ7SUFDQSxPQUFPakIsTUFBTW1CLElBQUksQ0FBQ0YsY0FBY0csS0FBSyxDQUFDLEdBQUc7QUFDN0M7QUFDQTs7Ozs7O0NBTUMsR0FDRE4sU0FBU0MsU0FBUyxDQUFDTSxvQkFBb0IsR0FBRyxTQUFVSixZQUFZO0lBQzVELElBQUksT0FBT0EsaUJBQWlCLGNBQWMsT0FBT0EsaUJBQWlCLFlBQVlBLGNBQWM7UUFDeEZBLGVBQWVqQixNQUFNa0IsNEJBQTRCLENBQUNEO0lBQ3REO0lBQ0EsT0FBT2pC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QyxJQUFJLEtBQUssV0FBWSxLQUFLO1FBQ2hELElBQUksT0FBT29HLGdCQUFnQixDQUFDM0QsRUFBRSxLQUFLLGFBQWE7WUFDNUN5QyxXQUFXLENBQUN6QyxFQUFFLEdBQUcyRCxnQkFBZ0IsQ0FBQzNELEVBQUU7UUFDeEM7UUFDQSxJQUFJLE9BQU9vRCxhQUFhLENBQUNwRCxFQUFFLEtBQUssYUFBYTtZQUN6Q3lDLFdBQVcsQ0FBQ3pDLEVBQUUsR0FBR29ELGFBQWEsQ0FBQ3BELEVBQUU7UUFDckM7UUFDQSxJQUFJdUMsSUFBSTFFLElBQUksRUFBRTtZQUNWNEUsV0FBVyxDQUFDRixJQUFJMUUsSUFBSSxDQUFDLEdBQUc0RSxXQUFXLENBQUN6QyxFQUFFO1FBQzFDO1FBQ0F5QyxZQUFZQyxVQUFVO0lBQzFCO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBLElBQUl0RCxRQUFRLElBQUluQjtBQUNoQjRGLE9BQU9DLE9BQU8sR0FBRzFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcz84ZmNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZnJvemVtYW4uZGU+XG4gKiBAZGF0ZSAyMDE4XG4gKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgRXRoZXJzQWJpQ29kZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYmknKS5BYmlDb2RlcjtcbnZhciBQYXJhbVR5cGUgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYmknKS5QYXJhbVR5cGU7XG52YXIgZXRoZXJzQWJpQ29kZXIgPSBuZXcgRXRoZXJzQWJpQ29kZXIoZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAoISghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdCTicpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59KTtcbi8vIHJlc3VsdCBtZXRob2RcbmZ1bmN0aW9uIFJlc3VsdCgpIHtcbn1cbi8qKlxuICogQUJJQ29kZXIgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGFueSB0eXBlXG4gKi9cbnZhciBBQklDb2RlciA9IGZ1bmN0aW9uICgpIHtcbn07XG4vKipcbiAqIEVuY29kZXMgdGhlIGZ1bmN0aW9uIG5hbWUgdG8gaXRzIEFCSSByZXByZXNlbnRhdGlvbiwgd2hpY2ggYXJlIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBzaGEzIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGluY2x1ZGluZyAgdHlwZXMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVGdW5jdGlvblNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBmdW5jdGlvbiBuYW1lXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnb2JqZWN0JyAmJiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpLnNsaWNlKDAsIDEwKTtcbn07XG4vKipcbiAqIEVuY29kZXMgdGhlIGZ1bmN0aW9uIG5hbWUgdG8gaXRzIEFCSSByZXByZXNlbnRhdGlvbiwgd2hpY2ggYXJlIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBzaGEzIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGluY2x1ZGluZyAgdHlwZXMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVFdmVudFNpZ25hdHVyZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmdW5jdGlvbk5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBmdW5jdGlvbiBuYW1lXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVFdmVudFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnb2JqZWN0JyAmJiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gdXRpbHMuX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyhmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2hhMyhmdW5jdGlvbk5hbWUpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHR5cGVcbiAqIEBwYXJhbSB7YW55fSBwYXJhbVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1ldGVycyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdHJpbmd8T2JqZWN0Pn0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gcGFyYW1zXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHlwZXMgPSBzZWxmLm1hcFR5cGVzKHR5cGVzKTtcbiAgICBwYXJhbXMgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpbmRleF07XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlKSB7XG4gICAgICAgICAgICAvLyBXZSBtYXkgZ2V0IGEgbmFtZWQgdHlwZSBvZiBzaGFwZSB7bmFtZSwgdHlwZX1cbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW0gPSBzZWxmLmZvcm1hdFBhcmFtKHR5cGUsIHBhcmFtKTtcbiAgICAgICAgLy8gRm9ybWF0IHBhcmFtcyBmb3IgdHVwbGVzXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZS5pbmNsdWRlcygndHVwbGUnKSkge1xuICAgICAgICAgICAgY29uc3QgY29kZXIgPSBldGhlcnNBYmlDb2Rlci5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZ5UGFyYW1zID0gKGNvZGVyLCBwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rlci5uYW1lID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXIudHlwZS5tYXRjaCgvXFxbKFxcZCspXFxdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiBtb2RpZnlQYXJhbXMoZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKGNvZGVyLnR5cGUucmVwbGFjZSgnW10nLCAnJykpKSwgcCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcGFyc2VJbnQoY29kZXIudHlwZS5tYXRjaCgvXFxbKFxcZCspXFxdLylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoICE9PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBsZW5ndGggZG9lcyBub3QgbWF0Y2hlcyB3aXRoIHRoZSBnaXZlbiBpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiBtb2RpZnlQYXJhbXMoZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKGNvZGVyLnR5cGUucmVwbGFjZSgvXFxbXFxkK1xcXS8sICcnKSkpLCBwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGVyLmNvZGVycy5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLm5hbWUgPT09ICd0dXBsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeVBhcmFtcyhjLCBwYXJhbVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVtpXSA9IHNlbGYuZm9ybWF0UGFyYW0oYy5uYW1lLCBwYXJhbVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtb2RpZnlQYXJhbXMoY29kZXIsIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG4gICAgcmV0dXJuIGV0aGVyc0FiaUNvZGVyLmVuY29kZSh0eXBlcywgcGFyYW1zKTtcbn07XG4vKipcbiAqIE1hcCB0eXBlcyBpZiBzaW1wbGlmaWVkIGZvcm1hdCBpcyB1c2VkXG4gKlxuICogQG1ldGhvZCBtYXBUeXBlc1xuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUubWFwVHlwZXMgPSBmdW5jdGlvbiAodHlwZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hcHBlZFR5cGVzID0gW107XG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAvLyBSZW1hcCBgZnVuY3Rpb25gIHR5cGUgcGFyYW1zIHRvIGJ5dGVzMjQgc2luY2UgRXRoZXJzIGRvZXMgbm90XG4gICAgICAgIC8vIHJlY29nbml6ZSBmb3JtZXIgdHlwZS4gU29saWRpdHkgZG9jcyBzYXkgYEZ1bmN0aW9uYCBpcyBhIGJ5dGVzMjRcbiAgICAgICAgLy8gZW5jb2RpbmcgdGhlIGNvbnRyYWN0IGFkZHJlc3MgZm9sbG93ZWQgYnkgdGhlIGZ1bmN0aW9uIHNlbGVjdG9yIGhhc2guXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0eXBlID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZSwgeyB0eXBlOiBcImJ5dGVzMjRcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pc1NpbXBsaWZpZWRTdHJ1Y3RGb3JtYXQodHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBzdHJ1Y3ROYW1lID0gT2JqZWN0LmtleXModHlwZSlbMF07XG4gICAgICAgICAgICBtYXBwZWRUeXBlcy5wdXNoKE9iamVjdC5hc3NpZ24oc2VsZi5tYXBTdHJ1Y3ROYW1lQW5kVHlwZShzdHJ1Y3ROYW1lKSwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHNlbGYubWFwU3RydWN0VG9Db2RlckZvcm1hdCh0eXBlW3N0cnVjdE5hbWVdKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcHBlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcHBlZFR5cGVzO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdHlwZSBpcyBzaW1wbGlmaWVkIHN0cnVjdCBmb3JtYXRcbiAqXG4gKiBAbWV0aG9kIGlzU2ltcGxpZmllZFN0cnVjdEZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmcgfCBPYmplY3R9IHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0eXBlLmNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLm5hbWUgPT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogTWFwcyB0aGUgY29ycmVjdCB0dXBsZSB0eXBlIGFuZCBuYW1lIHdoZW4gdGhlIHNpbXBsaWZpZWQgZm9ybWF0IGluIGVuY29kZS9kZWNvZGVQYXJhbWV0ZXIgaXMgdXNlZFxuICpcbiAqIEBtZXRob2QgbWFwU3RydWN0TmFtZUFuZFR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJ1Y3ROYW1lXG4gKiBAcmV0dXJuIHt7dHlwZTogc3RyaW5nLCBuYW1lOiAqfX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFN0cnVjdE5hbWVBbmRUeXBlID0gZnVuY3Rpb24gKHN0cnVjdE5hbWUpIHtcbiAgICB2YXIgdHlwZSA9ICd0dXBsZSc7XG4gICAgaWYgKHN0cnVjdE5hbWUuaW5kZXhPZignW10nKSA+IC0xKSB7XG4gICAgICAgIHR5cGUgPSAndHVwbGVbXSc7XG4gICAgICAgIHN0cnVjdE5hbWUgPSBzdHJ1Y3ROYW1lLnNsaWNlKDAsIC0yKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgbmFtZTogc3RydWN0TmFtZSB9O1xufTtcbi8qKlxuICogTWFwcyB0aGUgc2ltcGxpZmllZCBmb3JtYXQgaW4gdG8gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgQUJJQ29kZXJcbiAqXG4gKiBAbWV0aG9kIG1hcFN0cnVjdFRvQ29kZXJGb3JtYXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJ1Y3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUubWFwU3RydWN0VG9Db2RlckZvcm1hdCA9IGZ1bmN0aW9uIChzdHJ1Y3QpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhzdHJ1Y3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cnVjdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKE9iamVjdC5hc3NpZ24oc2VsZi5tYXBTdHJ1Y3ROYW1lQW5kVHlwZShrZXkpLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogc2VsZi5tYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0KHN0cnVjdFtrZXldKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICB0eXBlOiBzdHJ1Y3Rba2V5XVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn07XG4vKipcbiAqIEhhbmRsZSBzb21lIGZvcm1hdHRpbmcgb2YgcGFyYW1zIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eSB3aXRoIEV0aGVycyBWNFxuICpcbiAqIEBtZXRob2QgZm9ybWF0UGFyYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSAtIHR5cGVcbiAqIEBwYXJhbSB7YW55fSAtIHBhcmFtXG4gKiBAcmV0dXJuIHthbnl9IC0gVGhlIGZvcm1hdHRlZCBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZm9ybWF0UGFyYW0gPSBmdW5jdGlvbiAodHlwZSwgcGFyYW0pIHtcbiAgICBjb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuICAgIGNvbnN0IHBhcmFtVHlwZUJ5dGVzQXJyYXkgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKVxcW1xcXSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xuICAgIGNvbnN0IHBhcmFtVHlwZU51bWJlckFycmF5ID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKVxcW1xcXSQvKTtcbiAgICAvLyBGb3JtYXQgQk4gdG8gc3RyaW5nXG4gICAgaWYgKHV0aWxzLmlzQk4ocGFyYW0pIHx8IHV0aWxzLmlzQmlnTnVtYmVyKHBhcmFtKSkge1xuICAgICAgICByZXR1cm4gcGFyYW0udG9TdHJpbmcoMTApO1xuICAgIH1cbiAgICBpZiAodHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlc0FycmF5KSB8fCB0eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlckFycmF5KSkge1xuICAgICAgICByZXR1cm4gcGFyYW0ubWFwKHAgPT4gdGhpcy5mb3JtYXRQYXJhbSh0eXBlLnJlcGxhY2UoJ1tdJywgJycpLCBwKSk7XG4gICAgfVxuICAgIC8vIEZvcm1hdCBjb3JyZWN0IHdpZHRoIGZvciB1P2ludFswLTldKlxuICAgIGxldCBtYXRjaCA9IHR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgaWYgKHNpemUgLyA4IDwgcGFyYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtLnN0YXJ0c1dpdGgoXCItXCIpXG4gICAgICAgICAgICAgICAgLy8gcGFkIHRvIGNvcnJlY3QgYml0IHdpZHRoLCB3aXRoIC0gYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgID8gYC0ke3V0aWxzLmxlZnRQYWQocGFyYW0uc3Vic3RyaW5nKDEpLCBzaXplKX1gXG4gICAgICAgICAgICAgICAgLy8gcGFkIHRvIGNvcnJlY3QgYml0IHdpZHRoXG4gICAgICAgICAgICAgICAgOiB1dGlscy5sZWZ0UGFkKHBhcmFtLCBzaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGb3JtYXQgY29ycmVjdCBsZW5ndGggZm9yIGJ5dGVzWzAtOV0rXG4gICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXJhbSkpIHtcbiAgICAgICAgICAgIHBhcmFtID0gdXRpbHMudG9IZXgocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcm1hdCB0byBjb3JyZWN0IGxlbmd0aFxuICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIGxldCBtYXhTaXplID0gc2l6ZSAqIDI7XG4gICAgICAgICAgICBpZiAocGFyYW0uc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLmxlbmd0aCA8IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWQgdG8gY29ycmVjdCBsZW5ndGhcbiAgICAgICAgICAgICAgICBwYXJhbSA9IHV0aWxzLnJpZ2h0UGFkKHBhcmFtLCBzaXplICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9ybWF0IG9kZC1sZW5ndGggYnl0ZXMgdG8gZXZlbi1sZW5ndGhcbiAgICAgICAgaWYgKHBhcmFtLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIHBhcmFtID0gJzB4MCcgKyBwYXJhbS5zdWJzdHJpbmcoMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xufTtcbi8qKlxuICogRW5jb2RlcyBhIGZ1bmN0aW9uIGNhbGwgZnJvbSBpdHMganNvbiBpbnRlcmZhY2UgYW5kIHBhcmFtZXRlcnMuXG4gKlxuICogQG1ldGhvZCBlbmNvZGVGdW5jdGlvbkNhbGxcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25JbnRlcmZhY2VcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfSBUaGUgZW5jb2RlZCBBQkkgZm9yIHRoaXMgZnVuY3Rpb24gY2FsbFxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGpzb25JbnRlcmZhY2UsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLmVuY29kZUZ1bmN0aW9uU2lnbmF0dXJlKGpzb25JbnRlcmZhY2UpICsgdGhpcy5lbmNvZGVQYXJhbWV0ZXJzKGpzb25JbnRlcmZhY2UuaW5wdXRzLCBwYXJhbXMpLnJlcGxhY2UoJzB4JywgJycpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGJ5dGVzIHRvIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbWV0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcGxhaW4gcGFyYW1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtZXRlciA9IGZ1bmN0aW9uICh0eXBlLCBieXRlcykge1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBhcmFtZXRlcnMoW3R5cGVdLCBieXRlcylbMF07XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtZXRlclxuICogQHBhcmFtIHtBcnJheX0gb3V0cHV0c1xuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG91dHB1dHMsIGJ5dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1ldGVyc1dpdGgob3V0cHV0cywgYnl0ZXMsIGZhbHNlKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlUGFyYW1ldGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvdXRwdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9vc2VcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwbGFpbiBwYXJhbXNcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtZXRlcnNXaXRoID0gZnVuY3Rpb24gKG91dHB1dHMsIGJ5dGVzLCBsb29zZSkge1xuICAgIGlmIChvdXRwdXRzLmxlbmd0aCA+IDAgJiYgKCFieXRlcyB8fCBieXRlcyA9PT0gJzB4JyB8fCBieXRlcyA9PT0gJzBYJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXR1cm5lZCB2YWx1ZXMgYXJlblxcJ3QgdmFsaWQsIGRpZCBpdCBydW4gT3V0IG9mIEdhcz8gJyArXG4gICAgICAgICAgICAnWW91IG1pZ2h0IGFsc28gc2VlIHRoaXMgZXJyb3IgaWYgeW91IGFyZSBub3QgdXNpbmcgdGhlICcgK1xuICAgICAgICAgICAgJ2NvcnJlY3QgQUJJIGZvciB0aGUgY29udHJhY3QgeW91IGFyZSByZXRyaWV2aW5nIGRhdGEgZnJvbSwgJyArXG4gICAgICAgICAgICAncmVxdWVzdGluZyBkYXRhIGZyb20gYSBibG9jayBudW1iZXIgdGhhdCBkb2VzIG5vdCBleGlzdCwgJyArXG4gICAgICAgICAgICAnb3IgcXVlcnlpbmcgYSBub2RlIHdoaWNoIGlzIG5vdCBmdWxseSBzeW5jZWQuJyk7XG4gICAgfVxuICAgIHZhciByZXMgPSBldGhlcnNBYmlDb2Rlci5kZWNvZGUodGhpcy5tYXBUeXBlcyhvdXRwdXRzKSwgJzB4JyArIGJ5dGVzLnJlcGxhY2UoLzB4L2ksICcnKSwgbG9vc2UpO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IG5ldyBSZXN1bHQoKTtcbiAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fID0gMDtcbiAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCwgaSkge1xuICAgICAgICB2YXIgZGVjb2RlZFZhbHVlID0gcmVzW3JldHVyblZhbHVlLl9fbGVuZ3RoX19dO1xuICAgICAgICBjb25zdCBpc1N0cmluZ09iamVjdCA9IHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnICYmIG91dHB1dC50eXBlICYmIG91dHB1dC50eXBlID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgaXNTdHJpbmdUeXBlID0gdHlwZW9mIG91dHB1dCA9PT0gJ3N0cmluZycgJiYgb3V0cHV0ID09PSAnc3RyaW5nJztcbiAgICAgICAgLy8gb25seSBjb252ZXJ0IGAweGAgdG8gbnVsbCBpZiBpdCdzIG5vdCBzdHJpbmcgdmFsdWVcbiAgICAgICAgZGVjb2RlZFZhbHVlID0gKGRlY29kZWRWYWx1ZSA9PT0gJzB4JyAmJiAhaXNTdHJpbmdPYmplY3QgJiYgIWlzU3RyaW5nVHlwZSkgPyBudWxsIDogZGVjb2RlZFZhbHVlO1xuICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nIHx8ICEhb3V0cHV0ICYmIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnKSAmJiBvdXRwdXQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWVbb3V0cHV0Lm5hbWVdID0gZGVjb2RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18rKztcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGV2ZW50cyBub24tIGFuZCBpbmRleGVkIHBhcmFtZXRlcnMuXG4gKlxuICogQG1ldGhvZCBkZWNvZGVMb2dcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSB0b3BpY3NcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwbGFpbiBwYXJhbXNcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmRlY29kZUxvZyA9IGZ1bmN0aW9uIChpbnB1dHMsIGRhdGEsIHRvcGljcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdG9waWNzID0gQXJyYXkuaXNBcnJheSh0b3BpY3MpID8gdG9waWNzIDogW3RvcGljc107XG4gICAgZGF0YSA9IGRhdGEgfHwgJyc7XG4gICAgdmFyIG5vdEluZGV4ZWRJbnB1dHMgPSBbXTtcbiAgICB2YXIgaW5kZXhlZFBhcmFtcyA9IFtdO1xuICAgIHZhciB0b3BpY0NvdW50ID0gMDtcbiAgICAvLyBUT0RPIGNoZWNrIGZvciBhbm9ueW1vdXMgbG9ncz9cbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgaWYgKGlucHV0LmluZGV4ZWQpIHtcbiAgICAgICAgICAgIGluZGV4ZWRQYXJhbXNbaV0gPSAoWydib29sJywgJ2ludCcsICd1aW50JywgJ2FkZHJlc3MnLCAnZml4ZWQnLCAndWZpeGVkJ10uZmluZChmdW5jdGlvbiAoc3RhdGljVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC50eXBlLmluZGV4T2Yoc3RhdGljVHlwZSkgIT09IC0xO1xuICAgICAgICAgICAgfSkpID8gX3RoaXMuZGVjb2RlUGFyYW1ldGVyKGlucHV0LnR5cGUsIHRvcGljc1t0b3BpY0NvdW50XSkgOiB0b3BpY3NbdG9waWNDb3VudF07XG4gICAgICAgICAgICB0b3BpY0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3RJbmRleGVkSW5wdXRzW2ldID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbm9uSW5kZXhlZERhdGEgPSBkYXRhO1xuICAgIHZhciBub3RJbmRleGVkUGFyYW1zID0gKG5vbkluZGV4ZWREYXRhKSA/IHRoaXMuZGVjb2RlUGFyYW1ldGVyc1dpdGgobm90SW5kZXhlZElucHV0cywgbm9uSW5kZXhlZERhdGEsIHRydWUpIDogW107XG4gICAgdmFyIHJldHVyblZhbHVlID0gbmV3IFJlc3VsdCgpO1xuICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18gPSAwO1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXMsIGkpIHtcbiAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSAocmVzLnR5cGUgPT09ICdzdHJpbmcnKSA/ICcnIDogbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBub3RJbmRleGVkUGFyYW1zW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBub3RJbmRleGVkUGFyYW1zW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhlZFBhcmFtc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW2ldID0gaW5kZXhlZFBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW3Jlcy5uYW1lXSA9IHJldHVyblZhbHVlW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18rKztcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xudmFyIGNvZGVyID0gbmV3IEFCSUNvZGVyKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGNvZGVyO1xuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJ1dGlscyIsIkV0aGVyc0FiaUNvZGVyIiwiQWJpQ29kZXIiLCJQYXJhbVR5cGUiLCJldGhlcnNBYmlDb2RlciIsInR5cGUiLCJ2YWx1ZSIsIm1hdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uc3RydWN0b3IiLCJuYW1lIiwidG9TdHJpbmciLCJSZXN1bHQiLCJBQklDb2RlciIsInByb3RvdHlwZSIsImVuY29kZUZ1bmN0aW9uU2lnbmF0dXJlIiwiZnVuY3Rpb25OYW1lIiwiX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyIsInNoYTMiLCJzbGljZSIsImVuY29kZUV2ZW50U2lnbmF0dXJlIiwiZW5jb2RlUGFyYW1ldGVyIiwicGFyYW0iLCJlbmNvZGVQYXJhbWV0ZXJzIiwidHlwZXMiLCJwYXJhbXMiLCJzZWxmIiwibWFwVHlwZXMiLCJtYXAiLCJpbmRleCIsImZvcm1hdFBhcmFtIiwiaW5jbHVkZXMiLCJjb2RlciIsIl9nZXRDb2RlciIsImZyb20iLCJtb2RpZnlQYXJhbXMiLCJwIiwicmVwbGFjZSIsImFycmF5TGVuZ3RoIiwicGFyc2VJbnQiLCJsZW5ndGgiLCJFcnJvciIsImNvZGVycyIsImZvckVhY2giLCJjIiwiaSIsImVuY29kZSIsIm1hcHBlZFR5cGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0Iiwic3RydWN0TmFtZSIsImtleXMiLCJwdXNoIiwibWFwU3RydWN0TmFtZUFuZFR5cGUiLCJjb21wb25lbnRzIiwibWFwU3RydWN0VG9Db2RlckZvcm1hdCIsImluZGV4T2YiLCJzdHJ1Y3QiLCJrZXkiLCJwYXJhbVR5cGVCeXRlcyIsIlJlZ0V4cCIsInBhcmFtVHlwZUJ5dGVzQXJyYXkiLCJwYXJhbVR5cGVOdW1iZXIiLCJwYXJhbVR5cGVOdW1iZXJBcnJheSIsImlzQk4iLCJpc0JpZ051bWJlciIsInNpemUiLCJzdGFydHNXaXRoIiwibGVmdFBhZCIsInN1YnN0cmluZyIsImlzQnVmZmVyIiwidG9IZXgiLCJtYXhTaXplIiwicmlnaHRQYWQiLCJlbmNvZGVGdW5jdGlvbkNhbGwiLCJqc29uSW50ZXJmYWNlIiwiaW5wdXRzIiwiZGVjb2RlUGFyYW1ldGVyIiwiYnl0ZXMiLCJkZWNvZGVQYXJhbWV0ZXJzIiwib3V0cHV0cyIsImRlY29kZVBhcmFtZXRlcnNXaXRoIiwibG9vc2UiLCJyZXMiLCJkZWNvZGUiLCJyZXR1cm5WYWx1ZSIsIl9fbGVuZ3RoX18iLCJvdXRwdXQiLCJkZWNvZGVkVmFsdWUiLCJpc1N0cmluZ09iamVjdCIsImlzU3RyaW5nVHlwZSIsImRlY29kZUxvZyIsImRhdGEiLCJ0b3BpY3MiLCJfdGhpcyIsIm5vdEluZGV4ZWRJbnB1dHMiLCJpbmRleGVkUGFyYW1zIiwidG9waWNDb3VudCIsImlucHV0IiwiaW5kZXhlZCIsImZpbmQiLCJzdGF0aWNUeXBlIiwibm9uSW5kZXhlZERhdGEiLCJub3RJbmRleGVkUGFyYW1zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-eth-abi/lib/index.js\n");

/***/ })

};
;