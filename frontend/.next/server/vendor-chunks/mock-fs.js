/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mock-fs";
exports.ids = ["vendor-chunks/mock-fs"];
exports.modules = {

/***/ "(ssr)/./node_modules/mock-fs/lib/binding.js":
/*!*********************************************!*\
  !*** ./node_modules/mock-fs/lib/binding.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst File = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/mock-fs/lib/file.js\");\nconst FileDescriptor = __webpack_require__(/*! ./descriptor */ \"(ssr)/./node_modules/mock-fs/lib/descriptor.js\");\nconst Directory = __webpack_require__(/*! ./directory */ \"(ssr)/./node_modules/mock-fs/lib/directory.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(ssr)/./node_modules/mock-fs/lib/symlink.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst constants = __webpack_require__(/*! constants */ \"constants\");\nconst getPathParts = (__webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\").getPathParts);\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").alloc);\nconst MODE_TO_KTYPE = {\n    [constants.S_IFREG]: constants.UV_DIRENT_FILE,\n    [constants.S_IFDIR]: constants.UV_DIRENT_DIR,\n    [constants.S_IFBLK]: constants.UV_DIRENT_BLOCK,\n    [constants.S_IFCHR]: constants.UV_DIRENT_CHAR,\n    [constants.S_IFLNK]: constants.UV_DIRENT_LINK,\n    [constants.S_IFIFO]: constants.UV_DIRENT_FIFO,\n    [constants.S_IFSOCK]: constants.UV_DIRENT_SOCKET\n};\n/** Workaround for optimizations in node 8+ */ const fsBinding = process.binding(\"fs\");\nconst kUsePromises = fsBinding.kUsePromises;\nlet statValues;\nif (fsBinding.statValues) {\n    statValues = fsBinding.statValues; // node 10+\n} else if (fsBinding.getStatValues) {\n    statValues = fsBinding.getStatValues(); // node 8\n} else {\n    statValues = [];\n}\n// nodejs v6,8,10 and v12 before v12.10.0 has length 28\n// nodejs v12.10.0+ has length 36\nconst statContainsNs = statValues.length > 28;\n/** Introduction of BigUint64Array in 10.5 */ let BigUint64Array;\nif (global.BigUint64Array) {\n    BigUint64Array = global.BigUint64Array;\n} else {\n    BigUint64Array = function() {};\n}\nconst MAX_LINKS = 50;\n/**\n * Call the provided function and either return the result or call the callback\n * with it (depending on if a callback is provided).\n * @param {function()} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {Object} thisArg This argument for the following function.\n * @param {function()} func Function to call.\n * @return {*} Return (if callback is not provided).\n */ function maybeCallback(callback, ctx, thisArg, func) {\n    let err = null;\n    let val;\n    if (kUsePromises && callback === kUsePromises) {\n        // support nodejs v10+ fs.promises\n        try {\n            val = func.call(thisArg);\n        } catch (e) {\n            err = e;\n        }\n        return new Promise(function(resolve, reject) {\n            process.nextTick(function() {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(val);\n                }\n            });\n        });\n    } else if (callback && typeof callback === \"function\") {\n        try {\n            val = func.call(thisArg);\n        } catch (e) {\n            err = e;\n        }\n        process.nextTick(function() {\n            if (val === undefined) {\n                callback(err);\n            } else {\n                callback(err, val);\n            }\n        });\n    } else if (ctx && typeof ctx === \"object\") {\n        try {\n            return func.call(thisArg);\n        } catch (e) {\n            // default to errno for UNKNOWN\n            ctx.code = e.code || \"UNKNOWN\";\n            ctx.errno = e.errno || FSError.codes.UNKNOWN.errno;\n        }\n    } else {\n        return func.call(thisArg);\n    }\n}\n/**\n * set syscall property on context object, only for nodejs v10+.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {String} syscall Name of syscall.\n */ function markSyscall(ctx, syscall) {\n    if (ctx && typeof ctx === \"object\") {\n        ctx.syscall = syscall;\n    }\n}\n/**\n * Handle FSReqWrap oncomplete.\n * @param {Function} callback The callback.\n * @return {Function} The normalized callback.\n */ function normalizeCallback(callback) {\n    if (callback && typeof callback.oncomplete === \"function\") {\n        // Unpack callback from FSReqWrap\n        callback = callback.oncomplete.bind(callback);\n    }\n    return callback;\n}\n/**\n * Handle stat optimizations introduced in Node 8.\n * See https://github.com/nodejs/node/pull/11665.\n * @param {Function} callback The callback.\n * @return {Function} The wrapped callback.\n */ function wrapStatsCallback(callback) {\n    if (callback && typeof callback.oncomplete === \"function\") {\n        // Unpack callback from FSReqWrap\n        callback = callback.oncomplete.bind(callback);\n    }\n    if (typeof callback === \"function\") {\n        return function(err, stats) {\n            if (stats) {\n                fillStatsArray(stats, statValues);\n            }\n            callback.apply(this, arguments);\n        };\n    } else {\n        return callback;\n    }\n}\nfunction getDirentType(mode) {\n    const ktype = MODE_TO_KTYPE[mode & constants.S_IFMT];\n    if (ktype === undefined) {\n        return constants.UV_DIRENT_UNKNOWN;\n    }\n    return ktype;\n}\nfunction notImplemented() {\n    throw new Error(\"Method not implemented\");\n}\nfunction deBuffer(p) {\n    return Buffer.isBuffer(p) ? p.toString() : p;\n}\n/**\n * Create a new stats object.\n * @param {Object} config Stats properties.\n * @constructor\n */ function Stats(config) {\n    for(const key in config){\n        this[key] = config[key];\n    }\n    // node 10 expects an array internally\n    // see https://github.com/nodejs/node/pull/19714\n    fillStatsArray(config, this);\n}\n/**\n * Check if mode indicates property.\n * @param {number} property Property to check.\n * @return {boolean} Property matches mode.\n */ Stats.prototype._checkModeProperty = function(property) {\n    return (this.mode & constants.S_IFMT) === property;\n};\n/**\n * @return {Boolean} Is a directory.\n */ Stats.prototype.isDirectory = function() {\n    return this._checkModeProperty(constants.S_IFDIR);\n};\n/**\n * @return {Boolean} Is a regular file.\n */ Stats.prototype.isFile = function() {\n    return this._checkModeProperty(constants.S_IFREG);\n};\n/**\n * @return {Boolean} Is a block device.\n */ Stats.prototype.isBlockDevice = function() {\n    return this._checkModeProperty(constants.S_IFBLK);\n};\n/**\n * @return {Boolean} Is a character device.\n */ Stats.prototype.isCharacterDevice = function() {\n    return this._checkModeProperty(constants.S_IFCHR);\n};\n/**\n * @return {Boolean} Is a symbolic link.\n */ Stats.prototype.isSymbolicLink = function() {\n    return this._checkModeProperty(constants.S_IFLNK);\n};\n/**\n * @return {Boolean} Is a named pipe.\n */ Stats.prototype.isFIFO = function() {\n    return this._checkModeProperty(constants.S_IFIFO);\n};\n/**\n * @return {Boolean} Is a socket.\n */ Stats.prototype.isSocket = function() {\n    return this._checkModeProperty(constants.S_IFSOCK);\n};\n/**\n * Create a new binding with the given file system.\n * @param {FileSystem} system Mock file system.\n * @constructor\n */ function Binding(system) {\n    /**\n   * Mock file system.\n   * @type {FileSystem}\n   */ this._system = system;\n    /**\n   * Stats constructor.\n   * @type {function}\n   */ this.Stats = Stats;\n    /**\n   * Lookup of open files.\n   * @type {Object.<number, FileDescriptor>}\n   */ this._openFiles = {};\n    /**\n   * Counter for file descriptors.\n   * @type {number}\n   */ this._counter = -1;\n    const stdin = new FileDescriptor(constants.O_RDWR);\n    stdin.setItem(new File.StandardInput());\n    this.trackDescriptor(stdin);\n    const stdout = new FileDescriptor(constants.O_RDWR);\n    stdout.setItem(new File.StandardOutput());\n    this.trackDescriptor(stdout);\n    const stderr = new FileDescriptor(constants.O_RDWR);\n    stderr.setItem(new File.StandardError());\n    this.trackDescriptor(stderr);\n}\n/**\n * Get the file system underlying this binding.\n * @return {FileSystem} The underlying file system.\n */ Binding.prototype.getSystem = function() {\n    return this._system;\n};\n/**\n * Reset the file system underlying this binding.\n * @param {FileSystem} system The new file system.\n */ Binding.prototype.setSystem = function(system) {\n    this._system = system;\n};\n/**\n * Get a file descriptor.\n * @param {number} fd File descriptor identifier.\n * @return {FileDescriptor} File descriptor.\n */ Binding.prototype.getDescriptorById = function(fd) {\n    if (!this._openFiles.hasOwnProperty(fd)) {\n        throw new FSError(\"EBADF\");\n    }\n    return this._openFiles[fd];\n};\n/**\n * Keep track of a file descriptor as open.\n * @param {FileDescriptor} descriptor The file descriptor.\n * @return {number} Identifier for file descriptor.\n */ Binding.prototype.trackDescriptor = function(descriptor) {\n    const fd = ++this._counter;\n    this._openFiles[fd] = descriptor;\n    return fd;\n};\n/**\n * Stop tracking a file descriptor as open.\n * @param {number} fd Identifier for file descriptor.\n */ Binding.prototype.untrackDescriptorById = function(fd) {\n    if (!this._openFiles.hasOwnProperty(fd)) {\n        throw new FSError(\"EBADF\");\n    }\n    delete this._openFiles[fd];\n};\n/**\n * Resolve the canonicalized absolute pathname.\n * @param {string|Buffer} filepath The file path.\n * @param {string} encoding The encoding for the return.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} The real path.\n */ Binding.prototype.realpath = function(filepath, encoding, callback, ctx) {\n    markSyscall(ctx, \"realpath\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        let realPath;\n        filepath = deBuffer(filepath);\n        const resolved = path.resolve(filepath);\n        const parts = getPathParts(resolved);\n        let item = this._system.getRoot();\n        let itemPath = \"/\";\n        let name, i, ii;\n        for(i = 0, ii = parts.length; i < ii; ++i){\n            name = parts[i];\n            while(item instanceof SymbolicLink){\n                itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n                item = this._system.getItem(itemPath);\n            }\n            if (!item) {\n                throw new FSError(\"ENOENT\", filepath);\n            }\n            if (item instanceof Directory) {\n                itemPath = path.resolve(itemPath, name);\n                item = item.getItem(name);\n            } else {\n                throw new FSError(\"ENOTDIR\", filepath);\n            }\n        }\n        if (item) {\n            while(item instanceof SymbolicLink){\n                itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n                item = this._system.getItem(itemPath);\n            }\n            realPath = itemPath;\n        } else {\n            throw new FSError(\"ENOENT\", filepath);\n        }\n        if (process.platform === \"win32\" && realPath.startsWith(\"\\\\\\\\?\\\\\")) {\n            // Remove win32 file namespace prefix \\\\?\\\n            realPath = realPath.slice(4);\n        }\n        if (encoding === \"buffer\") {\n            realPath = bufferFrom(realPath);\n        }\n        return realPath;\n    });\n};\n/**\n * Fill a Float64Array with stat information\n * This is based on the internal FillStatsArray function in Node.\n * https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n * @param {Object} stats An object with file stats\n * @param {Float64Array} statValues A Float64Array where stat values should be inserted\n * @returns {void}\n */ function fillStatsArray(stats, statValues) {\n    statValues[0] = stats.dev;\n    statValues[1] = stats.mode;\n    statValues[2] = stats.nlink;\n    statValues[3] = stats.uid;\n    statValues[4] = stats.gid;\n    statValues[5] = stats.rdev;\n    statValues[6] = stats.blksize;\n    statValues[7] = stats.ino;\n    statValues[8] = stats.size;\n    statValues[9] = stats.blocks;\n    if (statContainsNs) {\n        // nodejs v12.10.0+\n        // This is based on the internal FillStatsArray function in Node.\n        // https://github.com/nodejs/node/blob/3a2e75d9a5c31d20e429d505b82dd182e33f459a/src/node_file.h#L153-L187\n        statValues[10] = Math.floor(stats.atimeMs / 1000);\n        statValues[11] = stats.atimeMs % 1000 * 1000000;\n        statValues[12] = Math.floor(stats.mtimeMs / 1000);\n        statValues[13] = stats.mtimeMs % 1000 * 1000000;\n        statValues[14] = Math.floor(stats.ctimeMs / 1000);\n        statValues[15] = stats.ctimeMs % 1000 * 1000000;\n        statValues[16] = Math.floor(stats.birthtimeMs / 1000);\n        statValues[17] = stats.birthtimeMs % 1000 * 1000000;\n    } else {\n        // nodejs before v12.10.0\n        // This is based on the internal FillStatsArray function in Node.\n        // https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n        statValues[10] = stats.atimeMs;\n        statValues[11] = stats.mtimeMs;\n        statValues[12] = stats.ctimeMs;\n        statValues[13] = stats.birthtimeMs;\n    }\n}\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */ Binding.prototype.stat = function(filepath, options, callback, ctx) {\n    // this seems wound not happen in nodejs v10+\n    if (arguments.length < 3) {\n        callback = options;\n        options = {};\n    }\n    markSyscall(ctx, \"stat\");\n    return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n        filepath = deBuffer(filepath);\n        let item = this._system.getItem(filepath);\n        if (item instanceof SymbolicLink) {\n            item = this._system.getItem(path.resolve(path.dirname(filepath), item.getPath()));\n        }\n        if (!item) {\n            throw new FSError(\"ENOENT\", filepath);\n        }\n        const stats = item.getStats();\n        // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n        // which should be filled with stat values.\n        // In prior versions of Node, binding.stat simply returns a Stats instance.\n        if (callback instanceof Float64Array || callback instanceof BigUint64Array) {\n            fillStatsArray(stats, callback);\n        } else {\n            fillStatsArray(stats, statValues);\n            return new Stats(stats);\n        }\n    });\n};\n/**\n * Stat an item.\n * @param {number} fd File descriptor.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */ Binding.prototype.fstat = function(fd, options, callback, ctx) {\n    if (arguments.length < 3) {\n        callback = options;\n        options = {};\n    }\n    markSyscall(ctx, \"fstat\");\n    return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        const item = descriptor.getItem();\n        const stats = item.getStats();\n        // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n        // which should be filled with stat values.\n        // In prior versions of Node, binding.stat simply returns a Stats instance.\n        if (callback instanceof Float64Array || callback instanceof BigUint64Array) {\n            fillStatsArray(stats, callback);\n        } else {\n            fillStatsArray(stats, statValues);\n            return new Stats(stats);\n        }\n    });\n};\n/**\n * Close a file descriptor.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.close = function(fd, callback, ctx) {\n    markSyscall(ctx, \"close\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        this.untrackDescriptorById(fd);\n    });\n};\n/**\n * Open and possibly create a file.\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function(Error, string)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string} File descriptor (if sync).\n */ Binding.prototype.open = function(pathname, flags, mode, callback, ctx) {\n    markSyscall(ctx, \"open\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const descriptor = new FileDescriptor(flags);\n        let item = this._system.getItem(pathname);\n        while(item instanceof SymbolicLink){\n            item = this._system.getItem(path.resolve(path.dirname(pathname), item.getPath()));\n        }\n        if (descriptor.isExclusive() && item) {\n            throw new FSError(\"EEXIST\", pathname);\n        }\n        if (descriptor.isCreate() && !item) {\n            const parent = this._system.getItem(path.dirname(pathname));\n            if (!parent) {\n                throw new FSError(\"ENOENT\", pathname);\n            }\n            if (!(parent instanceof Directory)) {\n                throw new FSError(\"ENOTDIR\", pathname);\n            }\n            item = new File();\n            if (mode) {\n                item.setMode(mode);\n            }\n            parent.addItem(path.basename(pathname), item);\n        }\n        if (descriptor.isRead()) {\n            if (!item) {\n                throw new FSError(\"ENOENT\", pathname);\n            }\n            if (!item.canRead()) {\n                throw new FSError(\"EACCES\", pathname);\n            }\n        }\n        if (descriptor.isWrite() && !item.canWrite()) {\n            throw new FSError(\"EACCES\", pathname);\n        }\n        if (item instanceof Directory && (descriptor.isTruncate() || descriptor.isAppend())) {\n            throw new FSError(\"EISDIR\", pathname);\n        }\n        if (descriptor.isTruncate()) {\n            if (!(item instanceof File)) {\n                throw new FSError(\"EBADF\");\n            }\n            item.setContent(\"\");\n        }\n        if (descriptor.isTruncate() || descriptor.isAppend()) {\n            descriptor.setPosition(item.getContent().length);\n        }\n        descriptor.setItem(item);\n        return this.trackDescriptor(descriptor);\n    });\n};\n/**\n * Open a file handler. A new api in nodejs v10+ for fs.promises\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function} callback Callback (optional), expecting kUsePromises in nodejs v10+.\n */ Binding.prototype.openFileHandle = function(pathname, flags, mode, callback) {\n    const self = this;\n    return this.open(pathname, flags, mode, kUsePromises).then(function(fd) {\n        // nodejs v10+ fs.promises FileHandler constructor only ask these three properties.\n        return {\n            getAsyncId: notImplemented,\n            fd: fd,\n            close: function() {\n                return self.close(fd, kUsePromises);\n            }\n        };\n    });\n};\n/**\n * Read from a file descriptor.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer that the contents will be written to.\n * @param {number} offset Offset in the buffer to start writing to.\n * @param {number} length Number of bytes to read.\n * @param {?number} position Where to begin reading in the file.  If null,\n *     data will be read from the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes read, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes read (if sync).\n */ Binding.prototype.read = function(fd, buffer, offset, length, position, callback, ctx) {\n    markSyscall(ctx, \"read\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        if (!descriptor.isRead()) {\n            throw new FSError(\"EBADF\");\n        }\n        const file = descriptor.getItem();\n        if (file instanceof Directory) {\n            throw new FSError(\"EISDIR\");\n        }\n        if (!(file instanceof File)) {\n            // deleted or not a regular file\n            throw new FSError(\"EBADF\");\n        }\n        if (typeof position !== \"number\" || position < 0) {\n            position = descriptor.getPosition();\n        }\n        const content = file.getContent();\n        const start = Math.min(position, content.length);\n        const end = Math.min(position + length, content.length);\n        const read = start < end ? content.copy(buffer, offset, start, end) : 0;\n        descriptor.setPosition(position + read);\n        return read;\n    });\n};\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} src Source file.\n * @param {string} dest Destination file.\n * @param {number} flags Modifiers for copy operation.\n * @param {function(Error)} callback Callback (optional) called\n *     with any error.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.copyFile = function(src, dest, flags, callback, ctx) {\n    markSyscall(ctx, \"copyfile\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        src = deBuffer(src);\n        dest = deBuffer(dest);\n        const srcFd = this.open(src, constants.O_RDONLY);\n        try {\n            const srcDescriptor = this.getDescriptorById(srcFd);\n            if (!srcDescriptor.isRead()) {\n                throw new FSError(\"EBADF\");\n            }\n            const srcFile = srcDescriptor.getItem();\n            if (!(srcFile instanceof File)) {\n                throw new FSError(\"EBADF\");\n            }\n            const srcContent = srcFile.getContent();\n            let destFlags = constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n            if ((flags & constants.COPYFILE_EXCL) === constants.COPYFILE_EXCL) {\n                destFlags |= constants.O_EXCL;\n            }\n            const destFd = this.open(dest, destFlags);\n            try {\n                this.write(destFd, srcContent, 0, srcContent.length, 0);\n            } finally{\n                this.close(destFd);\n            }\n        } finally{\n            this.close(srcFd);\n        }\n    });\n};\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Array<Buffer>} buffers Array of buffers with contents to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */ Binding.prototype.writeBuffers = function(fd, buffers, position, callback, ctx) {\n    markSyscall(ctx, \"write\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        if (!descriptor.isWrite()) {\n            throw new FSError(\"EBADF\");\n        }\n        const file = descriptor.getItem();\n        if (!(file instanceof File)) {\n            // not a regular file\n            throw new FSError(\"EBADF\");\n        }\n        if (typeof position !== \"number\" || position < 0) {\n            position = descriptor.getPosition();\n        }\n        let content = file.getContent();\n        const newContent = Buffer.concat(buffers);\n        const newLength = position + newContent.length;\n        if (content.length < newLength) {\n            const tempContent = bufferAlloc(newLength);\n            content.copy(tempContent);\n            content = tempContent;\n        }\n        const written = newContent.copy(content, position);\n        file.setContent(content);\n        descriptor.setPosition(newLength);\n        return written;\n    });\n};\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */ Binding.prototype.writeBuffer = function(fd, buffer, offset, length, position, callback, ctx) {\n    markSyscall(ctx, \"write\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        if (!descriptor.isWrite()) {\n            throw new FSError(\"EBADF\");\n        }\n        const file = descriptor.getItem();\n        if (!(file instanceof File)) {\n            // not a regular file\n            throw new FSError(\"EBADF\");\n        }\n        if (typeof position !== \"number\" || position < 0) {\n            position = descriptor.getPosition();\n        }\n        let content = file.getContent();\n        const newLength = position + length;\n        if (content.length < newLength) {\n            const newContent = bufferAlloc(newLength);\n            content.copy(newContent);\n            content = newContent;\n        }\n        const sourceEnd = Math.min(offset + length, buffer.length);\n        const written = bufferFrom(buffer).copy(content, position, offset, sourceEnd);\n        file.setContent(content);\n        descriptor.setPosition(newLength);\n        return written;\n    });\n};\n/**\n * Alias for writeBuffer (used in Node <= 0.10).\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */ Binding.prototype.write = Binding.prototype.writeBuffer;\n/**\n * Write to a file descriptor given a string.\n * @param {string} fd File descriptor.\n * @param {string} string String with contents to write.\n * @param {number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {string} encoding String encoding.\n * @param {function(Error, number, string)} callback Callback (optional) called\n *     with any error, number of bytes written, and the string.\n * @return {number} Number of bytes written (if sync).\n */ Binding.prototype.writeString = function(fd, string, position, encoding, callback, ctx) {\n    markSyscall(ctx, \"write\");\n    const buffer = bufferFrom(string, encoding);\n    let wrapper;\n    if (callback && callback !== kUsePromises) {\n        if (callback.oncomplete) {\n            callback = callback.oncomplete.bind(callback);\n        }\n        wrapper = function(err, written, returned) {\n            callback(err, written, returned && string);\n        };\n    }\n    return this.writeBuffer(fd, buffer, 0, string.length, position, wrapper, ctx);\n};\n/**\n * Rename a file.\n * @param {string} oldPath Old pathname.\n * @param {string} newPath New pathname.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {undefined}\n */ Binding.prototype.rename = function(oldPath, newPath, callback, ctx) {\n    markSyscall(ctx, \"rename\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        oldPath = deBuffer(oldPath);\n        newPath = deBuffer(newPath);\n        const oldItem = this._system.getItem(oldPath);\n        if (!oldItem) {\n            throw new FSError(\"ENOENT\", oldPath);\n        }\n        const oldParent = this._system.getItem(path.dirname(oldPath));\n        const oldName = path.basename(oldPath);\n        const newItem = this._system.getItem(newPath);\n        const newParent = this._system.getItem(path.dirname(newPath));\n        const newName = path.basename(newPath);\n        if (newItem) {\n            // make sure they are the same type\n            if (oldItem instanceof File) {\n                if (newItem instanceof Directory) {\n                    throw new FSError(\"EISDIR\", newPath);\n                }\n            } else if (oldItem instanceof Directory) {\n                if (!(newItem instanceof Directory)) {\n                    throw new FSError(\"ENOTDIR\", newPath);\n                }\n                if (newItem.list().length > 0) {\n                    throw new FSError(\"ENOTEMPTY\", newPath);\n                }\n            }\n            newParent.removeItem(newName);\n        } else {\n            if (!newParent) {\n                throw new FSError(\"ENOENT\", newPath);\n            }\n            if (!(newParent instanceof Directory)) {\n                throw new FSError(\"ENOTDIR\", newPath);\n            }\n        }\n        oldParent.removeItem(oldName);\n        newParent.addItem(newName, oldItem);\n    });\n};\n/**\n * Read a directory.\n * @param {string} dirpath Path to directory.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {boolean} withFileTypes whether or not to return fs.Dirent objects\n * @param {function(Error, (Array.<string>|Array.<Buffer>)} callback Callback\n *     (optional) called with any error or array of items in the directory.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Array.<string>|Array.<Buffer>} Array of items in directory (if sync).\n */ Binding.prototype.readdir = function(dirpath, encoding, withFileTypes, callback, ctx) {\n    // again, the shorter arguments would not happen in nodejs v10+\n    if (arguments.length === 2) {\n        callback = encoding;\n        encoding = \"utf-8\";\n    } else if (arguments.length === 3) {\n        callback = withFileTypes;\n    }\n    markSyscall(ctx, \"scandir\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        dirpath = deBuffer(dirpath);\n        let dpath = dirpath;\n        let dir = this._system.getItem(dirpath);\n        while(dir instanceof SymbolicLink){\n            dpath = path.resolve(path.dirname(dpath), dir.getPath());\n            dir = this._system.getItem(dpath);\n        }\n        if (!dir) {\n            throw new FSError(\"ENOENT\", dirpath);\n        }\n        if (!(dir instanceof Directory)) {\n            throw new FSError(\"ENOTDIR\", dirpath);\n        }\n        if (!dir.canRead()) {\n            throw new FSError(\"EACCES\", dirpath);\n        }\n        let list = dir.list();\n        if (encoding === \"buffer\") {\n            list = list.map(function(item) {\n                return bufferFrom(item);\n            });\n        }\n        if (withFileTypes === true) {\n            const types = list.map(function(name) {\n                const stats = dir.getItem(name).getStats();\n                return getDirentType(stats.mode);\n            });\n            list = [\n                list,\n                types\n            ];\n        }\n        return list;\n    });\n};\n/**\n * Create a directory.\n * @param {string} pathname Path to new directory.\n * @param {number} mode Permissions.\n * @param {boolean} recursive Recursively create deep directory. (added in nodejs v10+)\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.mkdir = function(pathname, mode, recursive, callback, ctx) {\n    if (typeof recursive !== \"boolean\") {\n        // when running nodejs < 10\n        ctx = callback;\n        callback = recursive;\n        recursive = false;\n    }\n    markSyscall(ctx, \"mkdir\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const item = this._system.getItem(pathname);\n        if (item) {\n            if (recursive && item instanceof Directory) {\n                // silently pass existing folder in recursive mode\n                return;\n            }\n            throw new FSError(\"EEXIST\", pathname);\n        }\n        const _mkdir = (function(_pathname) {\n            const parentDir = path.dirname(_pathname);\n            let parent = this._system.getItem(parentDir);\n            if (!parent) {\n                if (!recursive) {\n                    throw new FSError(\"ENOENT\", _pathname);\n                }\n                parent = _mkdir(parentDir, true);\n            }\n            this.access(parentDir, parseInt(\"0002\", 8));\n            const dir = new Directory();\n            if (mode) {\n                dir.setMode(mode);\n            }\n            return parent.addItem(path.basename(_pathname), dir);\n        }).bind(this);\n        _mkdir(pathname);\n    });\n};\n/**\n * Remove a directory.\n * @param {string} pathname Path to directory.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.rmdir = function(pathname, callback, ctx) {\n    markSyscall(ctx, \"rmdir\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const item = this._system.getItem(pathname);\n        if (!item) {\n            throw new FSError(\"ENOENT\", pathname);\n        }\n        if (!(item instanceof Directory)) {\n            throw new FSError(\"ENOTDIR\", pathname);\n        }\n        if (item.list().length > 0) {\n            throw new FSError(\"ENOTEMPTY\", pathname);\n        }\n        this.access(path.dirname(pathname), parseInt(\"0002\", 8));\n        const parent = this._system.getItem(path.dirname(pathname));\n        parent.removeItem(path.basename(pathname));\n    });\n};\nconst PATH_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nconst MAX_ATTEMPTS = 62 * 62 * 62;\n/**\n * Create a directory based on a template.\n * See http://web.mit.edu/freebsd/head/lib/libc/stdio/mktemp.c\n * @param {string} template Path template (trailing Xs will be replaced).\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, string)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.mkdtemp = function(prefix, encoding, callback, ctx) {\n    if (encoding && typeof encoding !== \"string\") {\n        callback = encoding;\n        encoding = \"utf-8\";\n    }\n    markSyscall(ctx, \"mkdtemp\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        prefix = prefix.replace(/X{0,6}$/, \"XXXXXX\");\n        const parentPath = path.dirname(prefix);\n        const parent = this._system.getItem(parentPath);\n        if (!parent) {\n            throw new FSError(\"ENOENT\", prefix);\n        }\n        if (!(parent instanceof Directory)) {\n            throw new FSError(\"ENOTDIR\", prefix);\n        }\n        this.access(parentPath, parseInt(\"0002\", 8));\n        const template = path.basename(prefix);\n        let unique = false;\n        let count = 0;\n        let name;\n        while(!unique && count < MAX_ATTEMPTS){\n            let position = template.length - 1;\n            let replacement = \"\";\n            while(template.charAt(position) === \"X\"){\n                replacement += PATH_CHARS.charAt(Math.floor(PATH_CHARS.length * Math.random()));\n                position -= 1;\n            }\n            const candidate = template.slice(0, position + 1) + replacement;\n            if (!parent.getItem(candidate)) {\n                name = candidate;\n                unique = true;\n            }\n            count += 1;\n        }\n        if (!name) {\n            throw new FSError(\"EEXIST\", prefix);\n        }\n        const dir = new Directory();\n        parent.addItem(name, dir);\n        let uniquePath = path.join(parentPath, name);\n        if (encoding === \"buffer\") {\n            uniquePath = bufferFrom(uniquePath);\n        }\n        return uniquePath;\n    });\n};\n/**\n * Truncate a file.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.ftruncate = function(fd, len, callback, ctx) {\n    markSyscall(ctx, \"ftruncate\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        if (!descriptor.isWrite()) {\n            throw new FSError(\"EINVAL\");\n        }\n        const file = descriptor.getItem();\n        if (!(file instanceof File)) {\n            throw new FSError(\"EINVAL\");\n        }\n        const content = file.getContent();\n        const newContent = bufferAlloc(len);\n        content.copy(newContent);\n        file.setContent(newContent);\n    });\n};\n/**\n * Legacy support.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.truncate = Binding.prototype.ftruncate;\n/**\n * Change user and group owner.\n * @param {string} pathname Path.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.chown = function(pathname, uid, gid, callback, ctx) {\n    markSyscall(ctx, \"chown\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const item = this._system.getItem(pathname);\n        if (!item) {\n            throw new FSError(\"ENOENT\", pathname);\n        }\n        item.setUid(uid);\n        item.setGid(gid);\n    });\n};\n/**\n * Change user and group owner.\n * @param {number} fd File descriptor.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.fchown = function(fd, uid, gid, callback, ctx) {\n    markSyscall(ctx, \"fchown\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        const item = descriptor.getItem();\n        item.setUid(uid);\n        item.setGid(gid);\n    });\n};\n/**\n * Change permissions.\n * @param {string} pathname Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.chmod = function(pathname, mode, callback, ctx) {\n    markSyscall(ctx, \"chmod\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const item = this._system.getItem(pathname);\n        if (!item) {\n            throw new FSError(\"ENOENT\", pathname);\n        }\n        item.setMode(mode);\n    });\n};\n/**\n * Change permissions.\n * @param {number} fd File descriptor.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.fchmod = function(fd, mode, callback, ctx) {\n    markSyscall(ctx, \"fchmod\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        const item = descriptor.getItem();\n        item.setMode(mode);\n    });\n};\n/**\n * Delete a named item.\n * @param {string} pathname Path to item.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.unlink = function(pathname, callback, ctx) {\n    markSyscall(ctx, \"unlink\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const item = this._system.getItem(pathname);\n        if (!item) {\n            throw new FSError(\"ENOENT\", pathname);\n        }\n        if (item instanceof Directory) {\n            throw new FSError(\"EPERM\", pathname);\n        }\n        const parent = this._system.getItem(path.dirname(pathname));\n        parent.removeItem(path.basename(pathname));\n    });\n};\n/**\n * Update timestamps.\n * @param {string} pathname Path to item.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.utimes = function(pathname, atime, mtime, callback, ctx) {\n    markSyscall(ctx, \"utimes\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const item = this._system.getItem(pathname);\n        if (!item) {\n            throw new FSError(\"ENOENT\", pathname);\n        }\n        item.setATime(new Date(atime * 1000));\n        item.setMTime(new Date(mtime * 1000));\n    });\n};\n/**\n * Update timestamps.\n * @param {number} fd File descriptor.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.futimes = function(fd, atime, mtime, callback, ctx) {\n    markSyscall(ctx, \"futimes\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        const descriptor = this.getDescriptorById(fd);\n        const item = descriptor.getItem();\n        item.setATime(new Date(atime * 1000));\n        item.setMTime(new Date(mtime * 1000));\n    });\n};\n/**\n * Synchronize in-core state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.fsync = function(fd, callback, ctx) {\n    markSyscall(ctx, \"fsync\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        this.getDescriptorById(fd);\n    });\n};\n/**\n * Synchronize in-core metadata state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.fdatasync = function(fd, callback, ctx) {\n    markSyscall(ctx, \"fdatasync\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        this.getDescriptorById(fd);\n    });\n};\n/**\n * Create a hard link.\n * @param {string} srcPath The existing file.\n * @param {string} destPath The new link to create.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.link = function(srcPath, destPath, callback, ctx) {\n    markSyscall(ctx, \"link\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        srcPath = deBuffer(srcPath);\n        destPath = deBuffer(destPath);\n        const item = this._system.getItem(srcPath);\n        if (!item) {\n            throw new FSError(\"ENOENT\", srcPath);\n        }\n        if (item instanceof Directory) {\n            throw new FSError(\"EPERM\", srcPath);\n        }\n        if (this._system.getItem(destPath)) {\n            throw new FSError(\"EEXIST\", destPath);\n        }\n        const parent = this._system.getItem(path.dirname(destPath));\n        if (!parent) {\n            throw new FSError(\"ENOENT\", destPath);\n        }\n        if (!(parent instanceof Directory)) {\n            throw new FSError(\"ENOTDIR\", destPath);\n        }\n        parent.addItem(path.basename(destPath), item);\n    });\n};\n/**\n * Create a symbolic link.\n * @param {string} srcPath Path from link to the source file.\n * @param {string} destPath Path for the generated link.\n * @param {string} type Ignored (used for Windows only).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.symlink = function(srcPath, destPath, type, callback, ctx) {\n    markSyscall(ctx, \"symlink\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        srcPath = deBuffer(srcPath);\n        destPath = deBuffer(destPath);\n        if (this._system.getItem(destPath)) {\n            throw new FSError(\"EEXIST\", destPath);\n        }\n        const parent = this._system.getItem(path.dirname(destPath));\n        if (!parent) {\n            throw new FSError(\"ENOENT\", destPath);\n        }\n        if (!(parent instanceof Directory)) {\n            throw new FSError(\"ENOTDIR\", destPath);\n        }\n        const link = new SymbolicLink();\n        link.setPath(srcPath);\n        parent.addItem(path.basename(destPath), link);\n    });\n};\n/**\n * Read the contents of a symbolic link.\n * @param {string} pathname Path to symbolic link.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, (string|Buffer))} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} Symbolic link contents (path to source).\n */ Binding.prototype.readlink = function(pathname, encoding, callback, ctx) {\n    if (encoding && typeof encoding !== \"string\") {\n        // this would not happend in nodejs v10+\n        callback = encoding;\n        encoding = \"utf-8\";\n    }\n    markSyscall(ctx, \"readlink\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        pathname = deBuffer(pathname);\n        const link = this._system.getItem(pathname);\n        if (!link) {\n            throw new FSError(\"ENOENT\", pathname);\n        }\n        if (!(link instanceof SymbolicLink)) {\n            throw new FSError(\"EINVAL\", pathname);\n        }\n        let linkPath = link.getPath();\n        if (encoding === \"buffer\") {\n            linkPath = bufferFrom(linkPath);\n        }\n        return linkPath;\n    });\n};\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */ Binding.prototype.lstat = function(filepath, options, callback, ctx) {\n    if (arguments.length < 3) {\n        // this would not happend in nodejs v10+\n        callback = options;\n        options = {};\n    }\n    markSyscall(ctx, \"lstat\");\n    return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n        filepath = deBuffer(filepath);\n        const item = this._system.getItem(filepath);\n        if (!item) {\n            throw new FSError(\"ENOENT\", filepath);\n        }\n        const stats = item.getStats();\n        // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n        // which should be filled with stat values.\n        // In prior versions of Node, binding.stat simply returns a Stats instance.\n        if (callback instanceof Float64Array || callback instanceof BigUint64Array) {\n            fillStatsArray(stats, callback);\n        } else {\n            fillStatsArray(stats, statValues);\n            return new Stats(item.getStats());\n        }\n    });\n};\n/**\n * Tests user permissions.\n * @param {string} filepath Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */ Binding.prototype.access = function(filepath, mode, callback, ctx) {\n    markSyscall(ctx, \"access\");\n    return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n        filepath = deBuffer(filepath);\n        let item = this._system.getItem(filepath);\n        let links = 0;\n        while(item instanceof SymbolicLink){\n            if (links > MAX_LINKS) {\n                throw new FSError(\"ELOOP\", filepath);\n            }\n            filepath = path.resolve(path.dirname(filepath), item.getPath());\n            item = this._system.getItem(filepath);\n            ++links;\n        }\n        if (!item) {\n            throw new FSError(\"ENOENT\", filepath);\n        }\n        if (mode && process.getuid && process.getgid) {\n            const itemMode = item.getMode();\n            if (item.getUid() === process.getuid()) {\n                if ((itemMode & mode * 64) !== mode * 64) {\n                    throw new FSError(\"EACCES\", filepath);\n                }\n            } else if (item.getGid() === process.getgid()) {\n                if ((itemMode & mode * 8) !== mode * 8) {\n                    throw new FSError(\"EACCES\", filepath);\n                }\n            } else {\n                if ((itemMode & mode) !== mode) {\n                    throw new FSError(\"EACCES\", filepath);\n                }\n            }\n        }\n    });\n};\n/**\n * Not yet implemented.\n * @type {function()}\n */ Binding.prototype.StatWatcher = notImplemented;\n/**\n * Export the binding constructor.\n * @type {function()}\n */ exports = module.exports = Binding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYmluZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUM7QUFDL0IsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUksZUFBZUosbUJBQU9BLENBQUM7QUFDN0IsTUFBTUssVUFBVUwsbUJBQU9BLENBQUM7QUFDeEIsTUFBTU0sWUFBWU4sbUJBQU9BLENBQUM7QUFDMUIsTUFBTU8sZUFBZVAsd0dBQW9DO0FBQ3pELE1BQU1RLGFBQWFSLHdGQUF3QjtBQUMzQyxNQUFNVSxjQUFjVix5RkFBeUI7QUFFN0MsTUFBTVksZ0JBQWdCO0lBQ3BCLENBQUNOLFVBQVVPLE9BQU8sQ0FBQyxFQUFFUCxVQUFVUSxjQUFjO0lBQzdDLENBQUNSLFVBQVVTLE9BQU8sQ0FBQyxFQUFFVCxVQUFVVSxhQUFhO0lBQzVDLENBQUNWLFVBQVVXLE9BQU8sQ0FBQyxFQUFFWCxVQUFVWSxlQUFlO0lBQzlDLENBQUNaLFVBQVVhLE9BQU8sQ0FBQyxFQUFFYixVQUFVYyxjQUFjO0lBQzdDLENBQUNkLFVBQVVlLE9BQU8sQ0FBQyxFQUFFZixVQUFVZ0IsY0FBYztJQUM3QyxDQUFDaEIsVUFBVWlCLE9BQU8sQ0FBQyxFQUFFakIsVUFBVWtCLGNBQWM7SUFDN0MsQ0FBQ2xCLFVBQVVtQixRQUFRLENBQUMsRUFBRW5CLFVBQVVvQixnQkFBZ0I7QUFDbEQ7QUFFQSw0Q0FBNEMsR0FDNUMsTUFBTUMsWUFBWUMsUUFBUUMsT0FBTyxDQUFDO0FBQ2xDLE1BQU1DLGVBQWVILFVBQVVHLFlBQVk7QUFDM0MsSUFBSUM7QUFDSixJQUFJSixVQUFVSSxVQUFVLEVBQUU7SUFDeEJBLGFBQWFKLFVBQVVJLFVBQVUsRUFBRSxXQUFXO0FBQ2hELE9BQU8sSUFBSUosVUFBVUssYUFBYSxFQUFF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LGFBQWM7WUFDbkMsSUFBSXNSLFFBQVFyUCxXQUFXO2dCQUNyQixNQUFNLElBQUloQyxRQUFRLFNBQVM0RztZQUM3QjtZQUNBQSxXQUFXbEgsS0FBS2lELE9BQU8sQ0FBQ2pELEtBQUs2SCxPQUFPLENBQUNYLFdBQVdLLEtBQUtPLE9BQU87WUFDNURQLE9BQU8sSUFBSSxDQUFDekIsT0FBTyxDQUFDaUMsT0FBTyxDQUFDYjtZQUM1QixFQUFFeUs7UUFDSjtRQUNBLElBQUksQ0FBQ3BLLE1BQU07WUFDVCxNQUFNLElBQUlqSCxRQUFRLFVBQVU0RztRQUM5QjtRQUNBLElBQUk5QyxRQUFRdkMsUUFBUStQLE1BQU0sSUFBSS9QLFFBQVFnUSxNQUFNLEVBQUU7WUFDNUMsTUFBTUMsV0FBV3ZLLEtBQUt3SyxPQUFPO1lBQzdCLElBQUl4SyxLQUFLeUssTUFBTSxPQUFPblEsUUFBUStQLE1BQU0sSUFBSTtnQkFDdEMsSUFBSSxDQUFDRSxXQUFZMU4sT0FBTyxFQUFFLE1BQU9BLE9BQU8sSUFBSTtvQkFDMUMsTUFBTSxJQUFJOUQsUUFBUSxVQUFVNEc7Z0JBQzlCO1lBQ0YsT0FBTyxJQUFJSyxLQUFLMEssTUFBTSxPQUFPcFEsUUFBUWdRLE1BQU0sSUFBSTtnQkFDN0MsSUFBSSxDQUFDQyxXQUFZMU4sT0FBTyxDQUFDLE1BQU9BLE9BQU8sR0FBRztvQkFDeEMsTUFBTSxJQUFJOUQsUUFBUSxVQUFVNEc7Z0JBQzlCO1lBQ0YsT0FBTztnQkFDTCxJQUFJLENBQUM0SyxXQUFXMU4sSUFBRyxNQUFPQSxNQUFNO29CQUM5QixNQUFNLElBQUk5RCxRQUFRLFVBQVU0RztnQkFDOUI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7Q0FHQyxHQUNEdEIsUUFBUVYsU0FBUyxDQUFDZ04sV0FBVyxHQUFHMU47QUFFaEM7OztDQUdDLEdBQ0QyTixVQUFVQyxPQUFPRCxPQUFPLEdBQUd2TSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2JpbmRpbmcuanM/YjZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IEZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKTtcbmNvbnN0IEZpbGVEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9kZXNjcmlwdG9yJyk7XG5jb25zdCBEaXJlY3RvcnkgPSByZXF1aXJlKCcuL2RpcmVjdG9yeScpO1xuY29uc3QgU3ltYm9saWNMaW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJyk7XG5jb25zdCBGU0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5jb25zdCBnZXRQYXRoUGFydHMgPSByZXF1aXJlKCcuL2ZpbGVzeXN0ZW0nKS5nZXRQYXRoUGFydHM7XG5jb25zdCBidWZmZXJGcm9tID0gcmVxdWlyZSgnLi9idWZmZXInKS5mcm9tO1xuY29uc3QgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCcuL2J1ZmZlcicpLmFsbG9jO1xuXG5jb25zdCBNT0RFX1RPX0tUWVBFID0ge1xuICBbY29uc3RhbnRzLlNfSUZSRUddOiBjb25zdGFudHMuVVZfRElSRU5UX0ZJTEUsXG4gIFtjb25zdGFudHMuU19JRkRJUl06IGNvbnN0YW50cy5VVl9ESVJFTlRfRElSLFxuICBbY29uc3RhbnRzLlNfSUZCTEtdOiBjb25zdGFudHMuVVZfRElSRU5UX0JMT0NLLFxuICBbY29uc3RhbnRzLlNfSUZDSFJdOiBjb25zdGFudHMuVVZfRElSRU5UX0NIQVIsXG4gIFtjb25zdGFudHMuU19JRkxOS106IGNvbnN0YW50cy5VVl9ESVJFTlRfTElOSyxcbiAgW2NvbnN0YW50cy5TX0lGSUZPXTogY29uc3RhbnRzLlVWX0RJUkVOVF9GSUZPLFxuICBbY29uc3RhbnRzLlNfSUZTT0NLXTogY29uc3RhbnRzLlVWX0RJUkVOVF9TT0NLRVRcbn07XG5cbi8qKiBXb3JrYXJvdW5kIGZvciBvcHRpbWl6YXRpb25zIGluIG5vZGUgOCsgKi9cbmNvbnN0IGZzQmluZGluZyA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbmNvbnN0IGtVc2VQcm9taXNlcyA9IGZzQmluZGluZy5rVXNlUHJvbWlzZXM7XG5sZXQgc3RhdFZhbHVlcztcbmlmIChmc0JpbmRpbmcuc3RhdFZhbHVlcykge1xuICBzdGF0VmFsdWVzID0gZnNCaW5kaW5nLnN0YXRWYWx1ZXM7IC8vIG5vZGUgMTArXG59IGVsc2UgaWYgKGZzQmluZGluZy5nZXRTdGF0VmFsdWVzKSB7XG4gIHN0YXRWYWx1ZXMgPSBmc0JpbmRpbmcuZ2V0U3RhdFZhbHVlcygpOyAvLyBub2RlIDhcbn0gZWxzZSB7XG4gIHN0YXRWYWx1ZXMgPSBbXTtcbn1cblxuLy8gbm9kZWpzIHY2LDgsMTAgYW5kIHYxMiBiZWZvcmUgdjEyLjEwLjAgaGFzIGxlbmd0aCAyOFxuLy8gbm9kZWpzIHYxMi4xMC4wKyBoYXMgbGVuZ3RoIDM2XG5jb25zdCBzdGF0Q29udGFpbnNOcyA9IHN0YXRWYWx1ZXMubGVuZ3RoID4gMjg7XG5cbi8qKiBJbnRyb2R1Y3Rpb24gb2YgQmlnVWludDY0QXJyYXkgaW4gMTAuNSAqL1xubGV0IEJpZ1VpbnQ2NEFycmF5O1xuaWYgKGdsb2JhbC5CaWdVaW50NjRBcnJheSkge1xuICBCaWdVaW50NjRBcnJheSA9IGdsb2JhbC5CaWdVaW50NjRBcnJheTtcbn0gZWxzZSB7XG4gIEJpZ1VpbnQ2NEFycmF5ID0gZnVuY3Rpb24oKSB7fTtcbn1cblxuY29uc3QgTUFYX0xJTktTID0gNTA7XG5cbi8qKlxuICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gYW5kIGVpdGhlciByZXR1cm4gdGhlIHJlc3VsdCBvciBjYWxsIHRoZSBjYWxsYmFja1xuICogd2l0aCBpdCAoZGVwZW5kaW5nIG9uIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQpLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGlzIGFyZ3VtZW50IGZvciB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmdW5jIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm4gKGlmIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCkuXG4gKi9cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2FsbGJhY2ssIGN0eCwgdGhpc0FyZywgZnVuYykge1xuICBsZXQgZXJyID0gbnVsbDtcbiAgbGV0IHZhbDtcblxuICBpZiAoa1VzZVByb21pc2VzICYmIGNhbGxiYWNrID09PSBrVXNlUHJvbWlzZXMpIHtcbiAgICAvLyBzdXBwb3J0IG5vZGVqcyB2MTArIGZzLnByb21pc2VzXG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFsID0gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgdmFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjdHggJiYgdHlwZW9mIGN0eCA9PT0gJ29iamVjdCcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBkZWZhdWx0IHRvIGVycm5vIGZvciBVTktOT1dOXG4gICAgICBjdHguY29kZSA9IGUuY29kZSB8fCAnVU5LTk9XTic7XG4gICAgICBjdHguZXJybm8gPSBlLmVycm5vIHx8IEZTRXJyb3IuY29kZXMuVU5LTk9XTi5lcnJubztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIHNldCBzeXNjYWxsIHByb3BlcnR5IG9uIGNvbnRleHQgb2JqZWN0LCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3lzY2FsbCBOYW1lIG9mIHN5c2NhbGwuXG4gKi9cbmZ1bmN0aW9uIG1hcmtTeXNjYWxsKGN0eCwgc3lzY2FsbCkge1xuICBpZiAoY3R4ICYmIHR5cGVvZiBjdHggPT09ICdvYmplY3QnKSB7XG4gICAgY3R4LnN5c2NhbGwgPSBzeXNjYWxsO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIEZTUmVxV3JhcCBvbmNvbXBsZXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBub3JtYWxpemVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrLm9uY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVbnBhY2sgY2FsbGJhY2sgZnJvbSBGU1JlcVdyYXBcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrLm9uY29tcGxldGUuYmluZChjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzdGF0IG9wdGltaXphdGlvbnMgaW50cm9kdWNlZCBpbiBOb2RlIDguXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMTE2NjUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHdyYXBTdGF0c0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sub25jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVucGFjayBjYWxsYmFjayBmcm9tIEZTUmVxV3JhcFxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sub25jb21wbGV0ZS5iaW5kKGNhbGxiYWNrKTtcbiAgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVyciwgc3RhdHMpIHtcbiAgICAgIGlmIChzdGF0cykge1xuICAgICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERpcmVudFR5cGUobW9kZSkge1xuICBjb25zdCBrdHlwZSA9IE1PREVfVE9fS1RZUEVbbW9kZSAmIGNvbnN0YW50cy5TX0lGTVRdO1xuXG4gIGlmIChrdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5VVl9ESVJFTlRfVU5LTk9XTjtcbiAgfVxuXG4gIHJldHVybiBrdHlwZTtcbn1cblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuXG5mdW5jdGlvbiBkZUJ1ZmZlcihwKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIocCkgPyBwLnRvU3RyaW5nKCkgOiBwO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdGF0cyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFN0YXRzIHByb3BlcnRpZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdHMoY29uZmlnKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xuICB9XG4gIC8vIG5vZGUgMTAgZXhwZWN0cyBhbiBhcnJheSBpbnRlcm5hbGx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8xOTcxNFxuICBmaWxsU3RhdHNBcnJheShjb25maWcsIHRoaXMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIG1vZGUgaW5kaWNhdGVzIHByb3BlcnR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnR5IFByb3BlcnR5IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUHJvcGVydHkgbWF0Y2hlcyBtb2RlLlxuICovXG5TdGF0cy5wcm90b3R5cGUuX2NoZWNrTW9kZVByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgcmV0dXJuICh0aGlzLm1vZGUgJiBjb25zdGFudHMuU19JRk1UKSA9PT0gcHJvcGVydHk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgZGlyZWN0b3J5LlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNEaXJlY3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGRElSKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSByZWd1bGFyIGZpbGUuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGUkVHKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBibG9jayBkZXZpY2UuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0Jsb2NrRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkJMSyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgY2hhcmFjdGVyIGRldmljZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzQ2hhcmFjdGVyRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkNIUik7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgc3ltYm9saWMgbGluay5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzU3ltYm9saWNMaW5rID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkxOSyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgbmFtZWQgcGlwZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzRklGTyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZJRk8pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIHNvY2tldC5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzU29ja2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRlNPQ0spO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmluZGluZyB3aXRoIHRoZSBnaXZlbiBmaWxlIHN5c3RlbS5cbiAqIEBwYXJhbSB7RmlsZVN5c3RlbX0gc3lzdGVtIE1vY2sgZmlsZSBzeXN0ZW0uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmluZGluZyhzeXN0ZW0pIHtcbiAgLyoqXG4gICAqIE1vY2sgZmlsZSBzeXN0ZW0uXG4gICAqIEB0eXBlIHtGaWxlU3lzdGVtfVxuICAgKi9cbiAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xuXG4gIC8qKlxuICAgKiBTdGF0cyBjb25zdHJ1Y3Rvci5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy5TdGF0cyA9IFN0YXRzO1xuXG4gIC8qKlxuICAgKiBMb29rdXAgb2Ygb3BlbiBmaWxlcy5cbiAgICogQHR5cGUge09iamVjdC48bnVtYmVyLCBGaWxlRGVzY3JpcHRvcj59XG4gICAqL1xuICB0aGlzLl9vcGVuRmlsZXMgPSB7fTtcblxuICAvKipcbiAgICogQ291bnRlciBmb3IgZmlsZSBkZXNjcmlwdG9ycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2NvdW50ZXIgPSAtMTtcblxuICBjb25zdCBzdGRpbiA9IG5ldyBGaWxlRGVzY3JpcHRvcihjb25zdGFudHMuT19SRFdSKTtcbiAgc3RkaW4uc2V0SXRlbShuZXcgRmlsZS5TdGFuZGFyZElucHV0KCkpO1xuICB0aGlzLnRyYWNrRGVzY3JpcHRvcihzdGRpbik7XG5cbiAgY29uc3Qgc3Rkb3V0ID0gbmV3IEZpbGVEZXNjcmlwdG9yKGNvbnN0YW50cy5PX1JEV1IpO1xuICBzdGRvdXQuc2V0SXRlbShuZXcgRmlsZS5TdGFuZGFyZE91dHB1dCgpKTtcbiAgdGhpcy50cmFja0Rlc2NyaXB0b3Ioc3Rkb3V0KTtcblxuICBjb25zdCBzdGRlcnIgPSBuZXcgRmlsZURlc2NyaXB0b3IoY29uc3RhbnRzLk9fUkRXUik7XG4gIHN0ZGVyci5zZXRJdGVtKG5ldyBGaWxlLlN0YW5kYXJkRXJyb3IoKSk7XG4gIHRoaXMudHJhY2tEZXNjcmlwdG9yKHN0ZGVycik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaWxlIHN5c3RlbSB1bmRlcmx5aW5nIHRoaXMgYmluZGluZy5cbiAqIEByZXR1cm4ge0ZpbGVTeXN0ZW19IFRoZSB1bmRlcmx5aW5nIGZpbGUgc3lzdGVtLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5nZXRTeXN0ZW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N5c3RlbTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIGZpbGUgc3lzdGVtIHVuZGVybHlpbmcgdGhpcyBiaW5kaW5nLlxuICogQHBhcmFtIHtGaWxlU3lzdGVtfSBzeXN0ZW0gVGhlIG5ldyBmaWxlIHN5c3RlbS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuc2V0U3lzdGVtID0gZnVuY3Rpb24oc3lzdGVtKSB7XG4gIHRoaXMuX3N5c3RlbSA9IHN5c3RlbTtcbn07XG5cbi8qKlxuICogR2V0IGEgZmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvciBpZGVudGlmaWVyLlxuICogQHJldHVybiB7RmlsZURlc2NyaXB0b3J9IEZpbGUgZGVzY3JpcHRvci5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZ2V0RGVzY3JpcHRvckJ5SWQgPSBmdW5jdGlvbihmZCkge1xuICBpZiAoIXRoaXMuX29wZW5GaWxlcy5oYXNPd25Qcm9wZXJ0eShmZCkpIHtcbiAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fb3BlbkZpbGVzW2ZkXTtcbn07XG5cbi8qKlxuICogS2VlcCB0cmFjayBvZiBhIGZpbGUgZGVzY3JpcHRvciBhcyBvcGVuLlxuICogQHBhcmFtIHtGaWxlRGVzY3JpcHRvcn0gZGVzY3JpcHRvciBUaGUgZmlsZSBkZXNjcmlwdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBJZGVudGlmaWVyIGZvciBmaWxlIGRlc2NyaXB0b3IuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnRyYWNrRGVzY3JpcHRvciA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgY29uc3QgZmQgPSArK3RoaXMuX2NvdW50ZXI7XG4gIHRoaXMuX29wZW5GaWxlc1tmZF0gPSBkZXNjcmlwdG9yO1xuICByZXR1cm4gZmQ7XG59O1xuXG4vKipcbiAqIFN0b3AgdHJhY2tpbmcgYSBmaWxlIGRlc2NyaXB0b3IgYXMgb3Blbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBJZGVudGlmaWVyIGZvciBmaWxlIGRlc2NyaXB0b3IuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnVudHJhY2tEZXNjcmlwdG9yQnlJZCA9IGZ1bmN0aW9uKGZkKSB7XG4gIGlmICghdGhpcy5fb3BlbkZpbGVzLmhhc093blByb3BlcnR5KGZkKSkge1xuICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9vcGVuRmlsZXNbZmRdO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBjYW5vbmljYWxpemVkIGFic29sdXRlIHBhdGhuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBmaWxlcGF0aCBUaGUgZmlsZSBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyBmb3IgdGhlIHJldHVybi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSBUaGUgcmVhbCBwYXRoLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZWFscGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBlbmNvZGluZywgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdyZWFscGF0aCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgcmVhbFBhdGg7XG4gICAgZmlsZXBhdGggPSBkZUJ1ZmZlcihmaWxlcGF0aCk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBwYXRoLnJlc29sdmUoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKHJlc29sdmVkKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRSb290KCk7XG4gICAgbGV0IGl0ZW1QYXRoID0gJy8nO1xuICAgIGxldCBuYW1lLCBpLCBpaTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG5hbWUgPSBwYXJ0c1tpXTtcbiAgICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShpdGVtUGF0aCksIGl0ZW0uZ2V0UGF0aCgpKTtcbiAgICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGl0ZW1QYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUoaXRlbVBhdGgsIG5hbWUpO1xuICAgICAgICBpdGVtID0gaXRlbS5nZXRJdGVtKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtKSB7XG4gICAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgICBpdGVtUGF0aCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoaXRlbVBhdGgpLCBpdGVtLmdldFBhdGgoKSk7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShpdGVtUGF0aCk7XG4gICAgICB9XG4gICAgICByZWFsUGF0aCA9IGl0ZW1QYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIHJlYWxQYXRoLnN0YXJ0c1dpdGgoJ1xcXFxcXFxcP1xcXFwnKSkge1xuICAgICAgLy8gUmVtb3ZlIHdpbjMyIGZpbGUgbmFtZXNwYWNlIHByZWZpeCBcXFxcP1xcXG4gICAgICByZWFsUGF0aCA9IHJlYWxQYXRoLnNsaWNlKDQpO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIHJlYWxQYXRoID0gYnVmZmVyRnJvbShyZWFsUGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWxQYXRoO1xuICB9KTtcbn07XG5cbi8qKlxuICogRmlsbCBhIEZsb2F0NjRBcnJheSB3aXRoIHN0YXQgaW5mb3JtYXRpb25cbiAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIGludGVybmFsIEZpbGxTdGF0c0FycmF5IGZ1bmN0aW9uIGluIE5vZGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi80ZTA1OTUyYThhNzVhZjZkZjYyNTQxNWRiNjEyZDNhOWExMzIyNjgyL3NyYy9ub2RlX2ZpbGUuY2MjTDUzM1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRzIEFuIG9iamVjdCB3aXRoIGZpbGUgc3RhdHNcbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBzdGF0VmFsdWVzIEEgRmxvYXQ2NEFycmF5IHdoZXJlIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBpbnNlcnRlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKSB7XG4gIHN0YXRWYWx1ZXNbMF0gPSBzdGF0cy5kZXY7XG4gIHN0YXRWYWx1ZXNbMV0gPSBzdGF0cy5tb2RlO1xuICBzdGF0VmFsdWVzWzJdID0gc3RhdHMubmxpbms7XG4gIHN0YXRWYWx1ZXNbM10gPSBzdGF0cy51aWQ7XG4gIHN0YXRWYWx1ZXNbNF0gPSBzdGF0cy5naWQ7XG4gIHN0YXRWYWx1ZXNbNV0gPSBzdGF0cy5yZGV2O1xuICBzdGF0VmFsdWVzWzZdID0gc3RhdHMuYmxrc2l6ZTtcbiAgc3RhdFZhbHVlc1s3XSA9IHN0YXRzLmlubztcbiAgc3RhdFZhbHVlc1s4XSA9IHN0YXRzLnNpemU7XG4gIHN0YXRWYWx1ZXNbOV0gPSBzdGF0cy5ibG9ja3M7XG5cbiAgaWYgKHN0YXRDb250YWluc05zKSB7XG4gICAgLy8gbm9kZWpzIHYxMi4xMC4wK1xuICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGludGVybmFsIEZpbGxTdGF0c0FycmF5IGZ1bmN0aW9uIGluIE5vZGUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvM2EyZTc1ZDlhNWMzMWQyMGU0MjlkNTA1YjgyZGQxODJlMzNmNDU5YS9zcmMvbm9kZV9maWxlLmgjTDE1My1MMTg3XG4gICAgc3RhdFZhbHVlc1sxMF0gPSBNYXRoLmZsb29yKHN0YXRzLmF0aW1lTXMgLyAxMDAwKTtcbiAgICBzdGF0VmFsdWVzWzExXSA9IChzdGF0cy5hdGltZU1zICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIHN0YXRWYWx1ZXNbMTJdID0gTWF0aC5mbG9vcihzdGF0cy5tdGltZU1zIC8gMTAwMCk7XG4gICAgc3RhdFZhbHVlc1sxM10gPSAoc3RhdHMubXRpbWVNcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICBzdGF0VmFsdWVzWzE0XSA9IE1hdGguZmxvb3Ioc3RhdHMuY3RpbWVNcyAvIDEwMDApO1xuICAgIHN0YXRWYWx1ZXNbMTVdID0gKHN0YXRzLmN0aW1lTXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgc3RhdFZhbHVlc1sxNl0gPSBNYXRoLmZsb29yKHN0YXRzLmJpcnRodGltZU1zIC8gMTAwMCk7XG4gICAgc3RhdFZhbHVlc1sxN10gPSAoc3RhdHMuYmlydGh0aW1lTXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9kZWpzIGJlZm9yZSB2MTIuMTAuMFxuICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGludGVybmFsIEZpbGxTdGF0c0FycmF5IGZ1bmN0aW9uIGluIE5vZGUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNGUwNTk1MmE4YTc1YWY2ZGY2MjU0MTVkYjYxMmQzYTlhMTMyMjY4Mi9zcmMvbm9kZV9maWxlLmNjI0w1MzNcbiAgICBzdGF0VmFsdWVzWzEwXSA9IHN0YXRzLmF0aW1lTXM7XG4gICAgc3RhdFZhbHVlc1sxMV0gPSBzdGF0cy5tdGltZU1zO1xuICAgIHN0YXRWYWx1ZXNbMTJdID0gc3RhdHMuY3RpbWVNcztcbiAgICBzdGF0VmFsdWVzWzEzXSA9IHN0YXRzLmJpcnRodGltZU1zO1xuICB9XG59XG5cbi8qKlxuICogU3RhdCBhbiBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIFBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBTdGF0cyl8RmxvYXQ2NEFycmF5fEJpZ1VpbnQ2NEFycmF5fSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLiBJbiBOb2RlIDcuNy4wKyB0aGlzIHdpbGwgYmUgYSBGbG9hdDY0QXJyYXlcbiAqIHRoYXQgc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge1N0YXRzfHVuZGVmaW5lZH0gU3RhdHMgb3IgdW5kZWZpbmVkIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBvcHRpb25zLCBjYWxsYmFjaywgY3R4KSB7XG4gIC8vIHRoaXMgc2VlbXMgd291bmQgbm90IGhhcHBlbiBpbiBub2RlanMgdjEwK1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnc3RhdCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKHdyYXBTdGF0c0NhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBmaWxlcGF0aCA9IGRlQnVmZmVyKGZpbGVwYXRoKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKFxuICAgICAgICBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZpbGVwYXRoKSwgaXRlbS5nZXRQYXRoKCkpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBmaWxlcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzID0gaXRlbS5nZXRTdGF0cygpO1xuXG4gICAgLy8gSW4gTm9kZSA3LjcuMCssIGJpbmRpbmcuc3RhdCBhY2NlcHRzIGEgRmxvYXQ2NEFycmF5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsXG4gICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICAgIC8vIEluIHByaW9yIHZlcnNpb25zIG9mIE5vZGUsIGJpbmRpbmcuc3RhdCBzaW1wbHkgcmV0dXJucyBhIFN0YXRzIGluc3RhbmNlLlxuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8XG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEJpZ1VpbnQ2NEFycmF5XG4gICAgKSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFN0YXRzKHN0YXRzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdGF0IGFuIGl0ZW0uXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgU3RhdHMpfEZsb2F0NjRBcnJheXxCaWdVaW50NjRBcnJheX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS4gSW4gTm9kZSA3LjcuMCsgdGhpcyB3aWxsIGJlIGEgRmxvYXQ2NEFycmF5XG4gKiB0aGF0IHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtTdGF0c3x1bmRlZmluZWR9IFN0YXRzIG9yIHVuZGVmaW5lZCAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZzdGF0ID0gZnVuY3Rpb24oZmQsIG9wdGlvbnMsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZzdGF0Jyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sod3JhcFN0YXRzQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBjb25zdCBpdGVtID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgY29uc3Qgc3RhdHMgPSBpdGVtLmdldFN0YXRzKCk7XG5cbiAgICAvLyBJbiBOb2RlIDcuNy4wKywgYmluZGluZy5zdGF0IGFjY2VwdHMgYSBGbG9hdDY0QXJyYXkgYXMgdGhlIHNlY29uZCBhcmd1bWVudCxcbiAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gICAgLy8gSW4gcHJpb3IgdmVyc2lvbnMgb2YgTm9kZSwgYmluZGluZy5zdGF0IHNpbXBseSByZXR1cm5zIGEgU3RhdHMgaW5zdGFuY2UuXG4gICAgaWYgKFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXlcbiAgICApIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgU3RhdHMoc3RhdHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIENsb3NlIGEgZmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihmZCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdjbG9zZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVudHJhY2tEZXNjcmlwdG9yQnlJZChmZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBPcGVuIGFuZCBwb3NzaWJseSBjcmVhdGUgYSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIEZpbGUgcGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBGbGFncy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBzdHJpbmcpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRmlsZSBkZXNjcmlwdG9yIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBmbGFncywgbW9kZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdvcGVuJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBuZXcgRmlsZURlc2NyaXB0b3IoZmxhZ3MpO1xuICAgIGxldCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oXG4gICAgICAgIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUocGF0aG5hbWUpLCBpdGVtLmdldFBhdGgoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzRXhjbHVzaXZlKCkgJiYgaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VFWElTVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNDcmVhdGUoKSAmJiAhaXRlbSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKHBhdGhuYW1lKSk7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBuZXcgRmlsZSgpO1xuICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgaXRlbS5zZXRNb2RlKG1vZGUpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShwYXRobmFtZSksIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc1JlYWQoKSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW0uY2FuUmVhZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBwYXRobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzV3JpdGUoKSAmJiAhaXRlbS5jYW5Xcml0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5ICYmXG4gICAgICAoZGVzY3JpcHRvci5pc1RydW5jYXRlKCkgfHwgZGVzY3JpcHRvci5pc0FwcGVuZCgpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJU0RJUicsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNUcnVuY2F0ZSgpKSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgICB9XG4gICAgICBpdGVtLnNldENvbnRlbnQoJycpO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc1RydW5jYXRlKCkgfHwgZGVzY3JpcHRvci5pc0FwcGVuZCgpKSB7XG4gICAgICBkZXNjcmlwdG9yLnNldFBvc2l0aW9uKGl0ZW0uZ2V0Q29udGVudCgpLmxlbmd0aCk7XG4gICAgfVxuICAgIGRlc2NyaXB0b3Iuc2V0SXRlbShpdGVtKTtcbiAgICByZXR1cm4gdGhpcy50cmFja0Rlc2NyaXB0b3IoZGVzY3JpcHRvcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBPcGVuIGEgZmlsZSBoYW5kbGVyLiBBIG5ldyBhcGkgaW4gbm9kZWpzIHYxMCsgZm9yIGZzLnByb21pc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgRmlsZSBwYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIEZsYWdzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCksIGV4cGVjdGluZyBrVXNlUHJvbWlzZXMgaW4gbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLm9wZW5GaWxlSGFuZGxlID0gZnVuY3Rpb24ocGF0aG5hbWUsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICByZXR1cm4gdGhpcy5vcGVuKHBhdGhuYW1lLCBmbGFncywgbW9kZSwga1VzZVByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGZkKSB7XG4gICAgLy8gbm9kZWpzIHYxMCsgZnMucHJvbWlzZXMgRmlsZUhhbmRsZXIgY29uc3RydWN0b3Igb25seSBhc2sgdGhlc2UgdGhyZWUgcHJvcGVydGllcy5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0QXN5bmNJZDogbm90SW1wbGVtZW50ZWQsXG4gICAgICBmZDogZmQsXG4gICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsb3NlKGZkLCBrVXNlUHJvbWlzZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWFkIGZyb20gYSBmaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdGhhdCB0aGUgY29udGVudHMgd2lsbCBiZSB3cml0dGVuIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gcmVhZGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgbnVtYmVyLCBCdWZmZXIpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLCBudW1iZXIgb2YgYnl0ZXMgcmVhZCwgYW5kIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVhZCAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihcbiAgZmQsXG4gIGJ1ZmZlcixcbiAgb2Zmc2V0LFxuICBsZW5ndGgsXG4gIHBvc2l0aW9uLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAncmVhZCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgaWYgKCFkZXNjcmlwdG9yLmlzUmVhZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlTRElSJyk7XG4gICAgfVxuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgLy8gZGVsZXRlZCBvciBub3QgYSByZWd1bGFyIGZpbGVcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gZGVzY3JpcHRvci5nZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihwb3NpdGlvbiwgY29udGVudC5sZW5ndGgpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uICsgbGVuZ3RoLCBjb250ZW50Lmxlbmd0aCk7XG4gICAgY29uc3QgcmVhZCA9IHN0YXJ0IDwgZW5kID8gY29udGVudC5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCBzdGFydCwgZW5kKSA6IDA7XG4gICAgZGVzY3JpcHRvci5zZXRQb3NpdGlvbihwb3NpdGlvbiArIHJlYWQpO1xuICAgIHJldHVybiByZWFkO1xuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3QgRGVzdGluYXRpb24gZmlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBNb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5jb3B5RmlsZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCwgZmxhZ3MsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY29weWZpbGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgc3JjID0gZGVCdWZmZXIoc3JjKTtcbiAgICBkZXN0ID0gZGVCdWZmZXIoZGVzdCk7XG4gICAgY29uc3Qgc3JjRmQgPSB0aGlzLm9wZW4oc3JjLCBjb25zdGFudHMuT19SRE9OTFkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNyY0Rlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKHNyY0ZkKTtcbiAgICAgIGlmICghc3JjRGVzY3JpcHRvci5pc1JlYWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNyY0ZpbGUgPSBzcmNEZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICAgIGlmICghKHNyY0ZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNyY0NvbnRlbnQgPSBzcmNGaWxlLmdldENvbnRlbnQoKTtcblxuICAgICAgbGV0IGRlc3RGbGFncyA9XG4gICAgICAgIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX0NSRUFUIHwgY29uc3RhbnRzLk9fVFJVTkM7XG5cbiAgICAgIGlmICgoZmxhZ3MgJiBjb25zdGFudHMuQ09QWUZJTEVfRVhDTCkgPT09IGNvbnN0YW50cy5DT1BZRklMRV9FWENMKSB7XG4gICAgICAgIGRlc3RGbGFncyB8PSBjb25zdGFudHMuT19FWENMO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXN0RmQgPSB0aGlzLm9wZW4oZGVzdCwgZGVzdEZsYWdzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53cml0ZShkZXN0RmQsIHNyY0NvbnRlbnQsIDAsIHNyY0NvbnRlbnQubGVuZ3RoLCAwKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuY2xvc2UoZGVzdEZkKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5jbG9zZShzcmNGZCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBidWZmZXJzIEFycmF5IG9mIGJ1ZmZlcnMgd2l0aCBjb250ZW50cyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgQnVmZmVyKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIGFuZCB0aGUgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZUJ1ZmZlcnMgPSBmdW5jdGlvbihcbiAgZmQsXG4gIGJ1ZmZlcnMsXG4gIHBvc2l0aW9uLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnd3JpdGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1dyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAvLyBub3QgYSByZWd1bGFyIGZpbGVcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gZGVzY3JpcHRvci5nZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IHBvc2l0aW9uICsgbmV3Q29udGVudC5sZW5ndGg7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgbmV3TGVuZ3RoKSB7XG4gICAgICBjb25zdCB0ZW1wQ29udGVudCA9IGJ1ZmZlckFsbG9jKG5ld0xlbmd0aCk7XG4gICAgICBjb250ZW50LmNvcHkodGVtcENvbnRlbnQpO1xuICAgICAgY29udGVudCA9IHRlbXBDb250ZW50O1xuICAgIH1cbiAgICBjb25zdCB3cml0dGVuID0gbmV3Q29udGVudC5jb3B5KGNvbnRlbnQsIHBvc2l0aW9uKTtcbiAgICBmaWxlLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgZGVzY3JpcHRvci5zZXRQb3NpdGlvbihuZXdMZW5ndGgpO1xuICAgIHJldHVybiB3cml0dGVuO1xuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgd2l0aCBjb250ZW50cyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgd3JpdGluZyBmcm9tLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gKiBAcGFyYW0gez9udW1iZXJ9IHBvc2l0aW9uIFdoZXJlIHRvIGJlZ2luIHdyaXRpbmcgaW4gdGhlIGZpbGUuICBJZiBudWxsLFxuICogICAgIGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIEJ1ZmZlcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBhbmQgdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbihcbiAgZmQsXG4gIGJ1ZmZlcixcbiAgb2Zmc2V0LFxuICBsZW5ndGgsXG4gIHBvc2l0aW9uLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnd3JpdGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1dyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAvLyBub3QgYSByZWd1bGFyIGZpbGVcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gZGVzY3JpcHRvci5nZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA8IG5ld0xlbmd0aCkge1xuICAgICAgY29uc3QgbmV3Q29udGVudCA9IGJ1ZmZlckFsbG9jKG5ld0xlbmd0aCk7XG4gICAgICBjb250ZW50LmNvcHkobmV3Q29udGVudCk7XG4gICAgICBjb250ZW50ID0gbmV3Q29udGVudDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlRW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgbGVuZ3RoLCBidWZmZXIubGVuZ3RoKTtcbiAgICBjb25zdCB3cml0dGVuID0gYnVmZmVyRnJvbShidWZmZXIpLmNvcHkoXG4gICAgICBjb250ZW50LFxuICAgICAgcG9zaXRpb24sXG4gICAgICBvZmZzZXQsXG4gICAgICBzb3VyY2VFbmRcbiAgICApO1xuICAgIGZpbGUuc2V0Q29udGVudChjb250ZW50KTtcbiAgICBkZXNjcmlwdG9yLnNldFBvc2l0aW9uKG5ld0xlbmd0aCk7XG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Igd3JpdGVCdWZmZXIgKHVzZWQgaW4gTm9kZSA8PSAwLjEwKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB3aXRoIGNvbnRlbnRzIHRvIHdyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgQnVmZmVyKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIGFuZCB0aGUgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZSA9IEJpbmRpbmcucHJvdG90eXBlLndyaXRlQnVmZmVyO1xuXG4vKipcbiAqIFdyaXRlIHRvIGEgZmlsZSBkZXNjcmlwdG9yIGdpdmVuIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHdpdGggY29udGVudHMgdG8gd3JpdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBTdHJpbmcgZW5jb2RpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIHN0cmluZyl9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBhbmQgdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKFxuICBmZCxcbiAgc3RyaW5nLFxuICBwb3NpdGlvbixcbiAgZW5jb2RpbmcsXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICBtYXJrU3lzY2FsbChjdHgsICd3cml0ZScpO1xuXG4gIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlckZyb20oc3RyaW5nLCBlbmNvZGluZyk7XG4gIGxldCB3cmFwcGVyO1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGtVc2VQcm9taXNlcykge1xuICAgIGlmIChjYWxsYmFjay5vbmNvbXBsZXRlKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrLm9uY29tcGxldGUuYmluZChjYWxsYmFjayk7XG4gICAgfVxuICAgIHdyYXBwZXIgPSBmdW5jdGlvbihlcnIsIHdyaXR0ZW4sIHJldHVybmVkKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIHdyaXR0ZW4sIHJldHVybmVkICYmIHN0cmluZyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGhpcy53cml0ZUJ1ZmZlcihmZCwgYnVmZmVyLCAwLCBzdHJpbmcubGVuZ3RoLCBwb3NpdGlvbiwgd3JhcHBlciwgY3R4KTtcbn07XG5cbi8qKlxuICogUmVuYW1lIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvbGRQYXRoIE9sZCBwYXRobmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXRoIE5ldyBwYXRobmFtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24ob2xkUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdyZW5hbWUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgb2xkUGF0aCA9IGRlQnVmZmVyKG9sZFBhdGgpO1xuICAgIG5ld1BhdGggPSBkZUJ1ZmZlcihuZXdQYXRoKTtcbiAgICBjb25zdCBvbGRJdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ob2xkUGF0aCk7XG4gICAgaWYgKCFvbGRJdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgb2xkUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShvbGRQYXRoKSk7XG4gICAgY29uc3Qgb2xkTmFtZSA9IHBhdGguYmFzZW5hbWUob2xkUGF0aCk7XG4gICAgY29uc3QgbmV3SXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKG5ld1BhdGgpO1xuICAgIGNvbnN0IG5ld1BhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShuZXdQYXRoKSk7XG4gICAgY29uc3QgbmV3TmFtZSA9IHBhdGguYmFzZW5hbWUobmV3UGF0aCk7XG4gICAgaWYgKG5ld0l0ZW0pIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFyZSB0aGUgc2FtZSB0eXBlXG4gICAgICBpZiAob2xkSXRlbSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaWYgKG5ld0l0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlTRElSJywgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkSXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICBpZiAoIShuZXdJdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0l0ZW0ubGlzdCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVEVNUFRZJywgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5ld1BhcmVudC5yZW1vdmVJdGVtKG5ld05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW5ld1BhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgbmV3UGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoIShuZXdQYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgbmV3UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZFBhcmVudC5yZW1vdmVJdGVtKG9sZE5hbWUpO1xuICAgIG5ld1BhcmVudC5hZGRJdGVtKG5ld05hbWUsIG9sZEl0ZW0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVhZCBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJwYXRoIFBhdGggdG8gZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyAoJ3V0Zi04JyBvciAnYnVmZmVyJykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhGaWxlVHlwZXMgd2hldGhlciBvciBub3QgdG8gcmV0dXJuIGZzLkRpcmVudCBvYmplY3RzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoQXJyYXkuPHN0cmluZz58QXJyYXkuPEJ1ZmZlcj4pfSBjYWxsYmFjayBDYWxsYmFja1xuICogICAgIChvcHRpb25hbCkgY2FsbGVkIHdpdGggYW55IGVycm9yIG9yIGFycmF5IG9mIGl0ZW1zIGluIHRoZSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz58QXJyYXkuPEJ1ZmZlcj59IEFycmF5IG9mIGl0ZW1zIGluIGRpcmVjdG9yeSAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihcbiAgZGlycGF0aCxcbiAgZW5jb2RpbmcsXG4gIHdpdGhGaWxlVHlwZXMsXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICAvLyBhZ2FpbiwgdGhlIHNob3J0ZXIgYXJndW1lbnRzIHdvdWxkIG5vdCBoYXBwZW4gaW4gbm9kZWpzIHYxMCtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gJ3V0Zi04JztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgY2FsbGJhY2sgPSB3aXRoRmlsZVR5cGVzO1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnc2NhbmRpcicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBkaXJwYXRoID0gZGVCdWZmZXIoZGlycGF0aCk7XG4gICAgbGV0IGRwYXRoID0gZGlycGF0aDtcbiAgICBsZXQgZGlyID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZGlycGF0aCk7XG4gICAgd2hpbGUgKGRpciBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgZHBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRwYXRoKSwgZGlyLmdldFBhdGgoKSk7XG4gICAgICBkaXIgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkcGF0aCk7XG4gICAgfVxuICAgIGlmICghZGlyKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZGlycGF0aCk7XG4gICAgfVxuICAgIGlmICghKGRpciBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZGlycGF0aCk7XG4gICAgfVxuICAgIGlmICghZGlyLmNhblJlYWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGRpcnBhdGgpO1xuICAgIH1cblxuICAgIGxldCBsaXN0ID0gZGlyLmxpc3QoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICBsaXN0ID0gbGlzdC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyRnJvbShpdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh3aXRoRmlsZVR5cGVzID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IGxpc3QubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBkaXIuZ2V0SXRlbShuYW1lKS5nZXRTdGF0cygpO1xuXG4gICAgICAgIHJldHVybiBnZXREaXJlbnRUeXBlKHN0YXRzLm1vZGUpO1xuICAgICAgfSk7XG4gICAgICBsaXN0ID0gW2xpc3QsIHR5cGVzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIG5ldyBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBQZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFJlY3Vyc2l2ZWx5IGNyZWF0ZSBkZWVwIGRpcmVjdG9yeS4gKGFkZGVkIGluIG5vZGVqcyB2MTArKVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihwYXRobmFtZSwgbW9kZSwgcmVjdXJzaXZlLCBjYWxsYmFjaywgY3R4KSB7XG4gIGlmICh0eXBlb2YgcmVjdXJzaXZlICE9PSAnYm9vbGVhbicpIHtcbiAgICAvLyB3aGVuIHJ1bm5pbmcgbm9kZWpzIDwgMTBcbiAgICBjdHggPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IHJlY3Vyc2l2ZTtcbiAgICByZWN1cnNpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ21rZGlyJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGlmIChyZWN1cnNpdmUgJiYgaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICAvLyBzaWxlbnRseSBwYXNzIGV4aXN0aW5nIGZvbGRlciBpbiByZWN1cnNpdmUgbW9kZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgcGF0aG5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IF9ta2RpciA9IGZ1bmN0aW9uKF9wYXRobmFtZSkge1xuICAgICAgY29uc3QgcGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKF9wYXRobmFtZSk7XG4gICAgICBsZXQgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGFyZW50RGlyKTtcbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGlmICghcmVjdXJzaXZlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIF9wYXRobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gX21rZGlyKHBhcmVudERpciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjY2VzcyhwYXJlbnREaXIsIHBhcnNlSW50KCcwMDAyJywgOCkpO1xuICAgICAgY29uc3QgZGlyID0gbmV3IERpcmVjdG9yeSgpO1xuICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgZGlyLnNldE1vZGUobW9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShfcGF0aG5hbWUpLCBkaXIpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIF9ta2RpcihwYXRobmFtZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JtZGlyJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChpdGVtLmxpc3QoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVEVNUFRZJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLmFjY2VzcyhwYXRoLmRpcm5hbWUocGF0aG5hbWUpLCBwYXJzZUludCgnMDAwMicsIDgpKTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUocGF0aG5hbWUpKTtcbiAgICBwYXJlbnQucmVtb3ZlSXRlbShwYXRoLmJhc2VuYW1lKHBhdGhuYW1lKSk7XG4gIH0pO1xufTtcblxuY29uc3QgUEFUSF9DSEFSUyA9XG4gICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDYyICogNjIgKiA2MjtcblxuLyoqXG4gKiBDcmVhdGUgYSBkaXJlY3RvcnkgYmFzZWQgb24gYSB0ZW1wbGF0ZS5cbiAqIFNlZSBodHRwOi8vd2ViLm1pdC5lZHUvZnJlZWJzZC9oZWFkL2xpYi9saWJjL3N0ZGlvL21rdGVtcC5jXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgUGF0aCB0ZW1wbGF0ZSAodHJhaWxpbmcgWHMgd2lsbCBiZSByZXBsYWNlZCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgVGhlIGVuY29kaW5nICgndXRmLTgnIG9yICdidWZmZXInKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIHN0cmluZyl9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubWtkdGVtcCA9IGZ1bmN0aW9uKHByZWZpeCwgZW5jb2RpbmcsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKGVuY29kaW5nICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gJ3V0Zi04JztcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ21rZHRlbXAnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1h7MCw2fSQvLCAnWFhYWFhYJyk7XG4gICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguZGlybmFtZShwcmVmaXgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhcmVudFBhdGgpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcHJlZml4KTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBwcmVmaXgpO1xuICAgIH1cbiAgICB0aGlzLmFjY2VzcyhwYXJlbnRQYXRoLCBwYXJzZUludCgnMDAwMicsIDgpKTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHBhdGguYmFzZW5hbWUocHJlZml4KTtcbiAgICBsZXQgdW5pcXVlID0gZmFsc2U7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgbmFtZTtcbiAgICB3aGlsZSAoIXVuaXF1ZSAmJiBjb3VudCA8IE1BWF9BVFRFTVBUUykge1xuICAgICAgbGV0IHBvc2l0aW9uID0gdGVtcGxhdGUubGVuZ3RoIC0gMTtcbiAgICAgIGxldCByZXBsYWNlbWVudCA9ICcnO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmNoYXJBdChwb3NpdGlvbikgPT09ICdYJykge1xuICAgICAgICByZXBsYWNlbWVudCArPSBQQVRIX0NIQVJTLmNoYXJBdChcbiAgICAgICAgICBNYXRoLmZsb29yKFBBVEhfQ0hBUlMubGVuZ3RoICogTWF0aC5yYW5kb20oKSlcbiAgICAgICAgKTtcbiAgICAgICAgcG9zaXRpb24gLT0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRlbXBsYXRlLnNsaWNlKDAsIHBvc2l0aW9uICsgMSkgKyByZXBsYWNlbWVudDtcbiAgICAgIGlmICghcGFyZW50LmdldEl0ZW0oY2FuZGlkYXRlKSkge1xuICAgICAgICBuYW1lID0gY2FuZGlkYXRlO1xuICAgICAgICB1bmlxdWUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgcHJlZml4KTtcbiAgICB9XG4gICAgY29uc3QgZGlyID0gbmV3IERpcmVjdG9yeSgpO1xuICAgIHBhcmVudC5hZGRJdGVtKG5hbWUsIGRpcik7XG4gICAgbGV0IHVuaXF1ZVBhdGggPSBwYXRoLmpvaW4ocGFyZW50UGF0aCwgbmFtZSk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgdW5pcXVlUGF0aCA9IGJ1ZmZlckZyb20odW5pcXVlUGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVQYXRoO1xuICB9KTtcbn07XG5cbi8qKlxuICogVHJ1bmNhdGUgYSBmaWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gTnVtYmVyIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZnRydW5jYXRlID0gZnVuY3Rpb24oZmQsIGxlbiwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmdHJ1bmNhdGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1dyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSU5WQUwnKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJTlZBTCcpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3Q29udGVudCA9IGJ1ZmZlckFsbG9jKGxlbik7XG4gICAgY29udGVudC5jb3B5KG5ld0NvbnRlbnQpO1xuICAgIGZpbGUuc2V0Q29udGVudChuZXdDb250ZW50KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIExlZ2FjeSBzdXBwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gTnVtYmVyIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudHJ1bmNhdGUgPSBCaW5kaW5nLnByb3RvdHlwZS5mdHJ1bmNhdGU7XG5cbi8qKlxuICogQ2hhbmdlIHVzZXIgYW5kIGdyb3VwIG93bmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkIFVzZXIgaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2lkIEdyb3VwIGlkLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuY2hvd24gPSBmdW5jdGlvbihwYXRobmFtZSwgdWlkLCBnaWQsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY2hvd24nKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGl0ZW0uc2V0VWlkKHVpZCk7XG4gICAgaXRlbS5zZXRHaWQoZ2lkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoYW5nZSB1c2VyIGFuZCBncm91cCBvd25lci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkIFVzZXIgaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2lkIEdyb3VwIGlkLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZmNob3duID0gZnVuY3Rpb24oZmQsIHVpZCwgZ2lkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZjaG93bicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgY29uc3QgaXRlbSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGl0ZW0uc2V0VWlkKHVpZCk7XG4gICAgaXRlbS5zZXRHaWQoZ2lkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmNobW9kID0gZnVuY3Rpb24ocGF0aG5hbWUsIG1vZGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY2htb2QnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGl0ZW0uc2V0TW9kZShtb2RlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBNb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZmNobW9kID0gZnVuY3Rpb24oZmQsIG1vZGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZmNobW9kJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBjb25zdCBpdGVtID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaXRlbS5zZXRNb2RlKG1vZGUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgbmFtZWQgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihwYXRobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICd1bmxpbmsnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRVBFUk0nLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShwYXRobmFtZSkpO1xuICAgIHBhcmVudC5yZW1vdmVJdGVtKHBhdGguYmFzZW5hbWUocGF0aG5hbWUpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aW1lc3RhbXBzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gaXRlbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdGltZSBBY2Nlc3MgdGltZSAoaW4gc2Vjb25kcykuXG4gKiBAcGFyYW0ge251bWJlcn0gbXRpbWUgTW9kaWZpY2F0aW9uIHRpbWUgKGluIHNlY29uZHMpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudXRpbWVzID0gZnVuY3Rpb24ocGF0aG5hbWUsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICd1dGltZXMnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGl0ZW0uc2V0QVRpbWUobmV3IERhdGUoYXRpbWUgKiAxMDAwKSk7XG4gICAgaXRlbS5zZXRNVGltZShuZXcgRGF0ZShtdGltZSAqIDEwMDApKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aW1lc3RhbXBzLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdGltZSBBY2Nlc3MgdGltZSAoaW4gc2Vjb25kcykuXG4gKiBAcGFyYW0ge251bWJlcn0gbXRpbWUgTW9kaWZpY2F0aW9uIHRpbWUgKGluIHNlY29uZHMpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZnV0aW1lcyA9IGZ1bmN0aW9uKGZkLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZnV0aW1lcycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgY29uc3QgaXRlbSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGl0ZW0uc2V0QVRpbWUobmV3IERhdGUoYXRpbWUgKiAxMDAwKSk7XG4gICAgaXRlbS5zZXRNVGltZShuZXcgRGF0ZShtdGltZSAqIDEwMDApKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9uaXplIGluLWNvcmUgc3RhdGUgd2l0aCBzdG9yYWdlIGRldmljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mc3luYyA9IGZ1bmN0aW9uKGZkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZzeW5jJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogU3luY2hyb25pemUgaW4tY29yZSBtZXRhZGF0YSBzdGF0ZSB3aXRoIHN0b3JhZ2UgZGV2aWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZkYXRhc3luYyA9IGZ1bmN0aW9uKGZkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZkYXRhc3luYycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGhhcmQgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNQYXRoIFRoZSBleGlzdGluZyBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RQYXRoIFRoZSBuZXcgbGluayB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oc3JjUGF0aCwgZGVzdFBhdGgsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnbGluaycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBzcmNQYXRoID0gZGVCdWZmZXIoc3JjUGF0aCk7XG4gICAgZGVzdFBhdGggPSBkZUJ1ZmZlcihkZXN0UGF0aCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHNyY1BhdGgpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHNyY1BhdGgpO1xuICAgIH1cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VQRVJNJywgc3JjUGF0aCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkZXN0UGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShkZXN0UGF0aCkpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShkZXN0UGF0aCksIGl0ZW0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc3ltYm9saWMgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNQYXRoIFBhdGggZnJvbSBsaW5rIHRvIHRoZSBzb3VyY2UgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0UGF0aCBQYXRoIGZvciB0aGUgZ2VuZXJhdGVkIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBJZ25vcmVkICh1c2VkIGZvciBXaW5kb3dzIG9ubHkpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHNyY1BhdGgsIGRlc3RQYXRoLCB0eXBlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3N5bWxpbmsnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgc3JjUGF0aCA9IGRlQnVmZmVyKHNyY1BhdGgpO1xuICAgIGRlc3RQYXRoID0gZGVCdWZmZXIoZGVzdFBhdGgpO1xuICAgIGlmICh0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkZXN0UGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShkZXN0UGF0aCkpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbGluayA9IG5ldyBTeW1ib2xpY0xpbmsoKTtcbiAgICBsaW5rLnNldFBhdGgoc3JjUGF0aCk7XG4gICAgcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShkZXN0UGF0aCksIGxpbmspO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVhZCB0aGUgY29udGVudHMgb2YgYSBzeW1ib2xpYyBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gc3ltYm9saWMgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2RpbmcgKCd1dGYtOCcgb3IgJ2J1ZmZlcicpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKHN0cmluZ3xCdWZmZXIpKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gU3ltYm9saWMgbGluayBjb250ZW50cyAocGF0aCB0byBzb3VyY2UpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBlbmNvZGluZywgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAoZW5jb2RpbmcgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIC8vIHRoaXMgd291bGQgbm90IGhhcHBlbmQgaW4gbm9kZWpzIHYxMCtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gJ3V0Zi04JztcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JlYWRsaW5rJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGxpbmsgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIShsaW5rIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJTlZBTCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgbGV0IGxpbmtQYXRoID0gbGluay5nZXRQYXRoKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgbGlua1BhdGggPSBidWZmZXJGcm9tKGxpbmtQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmtQYXRoO1xuICB9KTtcbn07XG5cbi8qKlxuICogU3RhdCBhbiBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIFBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBTdGF0cyl8RmxvYXQ2NEFycmF5fEJpZ1VpbnQ2NEFycmF5fSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLiBJbiBOb2RlIDcuNy4wKyB0aGlzIHdpbGwgYmUgYSBGbG9hdDY0QXJyYXlcbiAqIHRoYXQgc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge1N0YXRzfHVuZGVmaW5lZH0gU3RhdHMgb3IgdW5kZWZpbmVkIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihmaWxlcGF0aCwgb3B0aW9ucywgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAvLyB0aGlzIHdvdWxkIG5vdCBoYXBwZW5kIGluIG5vZGVqcyB2MTArXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2xzdGF0Jyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sod3JhcFN0YXRzQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGZpbGVwYXRoID0gZGVCdWZmZXIoZmlsZXBhdGgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShmaWxlcGF0aCk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGl0ZW0uZ2V0U3RhdHMoKTtcblxuICAgIC8vIEluIE5vZGUgNy43LjArLCBiaW5kaW5nLnN0YXQgYWNjZXB0cyBhIEZsb2F0NjRBcnJheSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LFxuICAgIC8vIHdoaWNoIHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAgICAvLyBJbiBwcmlvciB2ZXJzaW9ucyBvZiBOb2RlLCBiaW5kaW5nLnN0YXQgc2ltcGx5IHJldHVybnMgYSBTdGF0cyBpbnN0YW5jZS5cbiAgICBpZiAoXG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheVxuICAgICkge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIHN0YXRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBTdGF0cyhpdGVtLmdldFN0YXRzKCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFRlc3RzIHVzZXIgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggUGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmFjY2VzcyA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBtb2RlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2FjY2VzcycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBmaWxlcGF0aCA9IGRlQnVmZmVyKGZpbGVwYXRoKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICBsZXQgbGlua3MgPSAwO1xuICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICBpZiAobGlua3MgPiBNQVhfTElOS1MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VMT09QJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgICAgZmlsZXBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZpbGVwYXRoKSwgaXRlbS5nZXRQYXRoKCkpO1xuICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICAgICsrbGlua3M7XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGZpbGVwYXRoKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgJiYgcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXRnaWQpIHtcbiAgICAgIGNvbnN0IGl0ZW1Nb2RlID0gaXRlbS5nZXRNb2RlKCk7XG4gICAgICBpZiAoaXRlbS5nZXRVaWQoKSA9PT0gcHJvY2Vzcy5nZXR1aWQoKSkge1xuICAgICAgICBpZiAoKGl0ZW1Nb2RlICYgKG1vZGUgKiA2NCkpICE9PSBtb2RlICogNjQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZ2V0R2lkKCkgPT09IHByb2Nlc3MuZ2V0Z2lkKCkpIHtcbiAgICAgICAgaWYgKChpdGVtTW9kZSAmIChtb2RlICogOCkpICE9PSBtb2RlICogOCkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoaXRlbU1vZGUgJiBtb2RlKSAhPT0gbW9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBOb3QgeWV0IGltcGxlbWVudGVkLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLlN0YXRXYXRjaGVyID0gbm90SW1wbGVtZW50ZWQ7XG5cbi8qKlxuICogRXhwb3J0IHRoZSBiaW5kaW5nIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJpbmRpbmc7XG4iXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJGaWxlIiwiRmlsZURlc2NyaXB0b3IiLCJEaXJlY3RvcnkiLCJTeW1ib2xpY0xpbmsiLCJGU0Vycm9yIiwiY29uc3RhbnRzIiwiZ2V0UGF0aFBhcnRzIiwiYnVmZmVyRnJvbSIsImZyb20iLCJidWZmZXJBbGxvYyIsImFsbG9jIiwiTU9ERV9UT19LVFlQRSIsIlNfSUZSRUciLCJVVl9ESVJFTlRfRklMRSIsIlNfSUZESVIiLCJVVl9ESVJFTlRfRElSIiwiU19JRkJMSyIsIlVWX0RJUkVOVF9CTE9DSyIsIlNfSUZDSFIiLCJVVl9ESVJFTlRfQ0hBUiIsIlNfSUZMTksiLCJVVl9ESVJFTlRfTElOSyIsIlNfSUZJRk8iLCJVVl9ESVJFTlRfRklGTyIsIlNfSUZTT0NLIiwiVVZfRElSRU5UX1NPQ0tFVCIsImZzQmluZGluZyIsInByb2Nlc3MiLCJiaW5kaW5nIiwia1VzZVByb21pc2VzIiwic3RhdFZhbHVlcyIsImdldFN0YXRWYWx1ZXMiLCJzdGF0Q29udGFpbnNOcyIsImxlbmd0aCIsIkJpZ1VpbnQ2NEFycmF5IiwiZ2xvYmFsIiwiTUFYX0xJTktTIiwibWF5YmVDYWxsYmFjayIsImNhbGxiYWNrIiwiY3R4IiwidGhpc0FyZyIsImZ1bmMiLCJlcnIiLCJ2YWwiLCJjYWxsIiwiZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibmV4dFRpY2siLCJ1bmRlZmluZWQiLCJjb2RlIiwiZXJybm8iLCJjb2RlcyIsIlVOS05PV04iLCJtYXJrU3lzY2FsbCIsInN5c2NhbGwiLCJub3JtYWxpemVDYWxsYmFjayIsIm9uY29tcGxldGUiLCJiaW5kIiwid3JhcFN0YXRzQ2FsbGJhY2siLCJzdGF0cyIsImZpbGxTdGF0c0FycmF5IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJnZXREaXJlbnRUeXBlIiwibW9kZSIsImt0eXBlIiwiU19JRk1UIiwiVVZfRElSRU5UX1VOS05PV04iLCJub3RJbXBsZW1lbnRlZCIsIkVycm9yIiwiZGVCdWZmZXIiLCJwIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsIlN0YXRzIiwiY29uZmlnIiwia2V5IiwicHJvdG90eXBlIiwiX2NoZWNrTW9kZVByb3BlcnR5IiwicHJvcGVydHkiLCJpc0RpcmVjdG9yeSIsImlzRmlsZSIsImlzQmxvY2tEZXZpY2UiLCJpc0NoYXJhY3RlckRldmljZSIsImlzU3ltYm9saWNMaW5rIiwiaXNGSUZPIiwiaXNTb2NrZXQiLCJCaW5kaW5nIiwic3lzdGVtIiwiX3N5c3RlbSIsIl9vcGVuRmlsZXMiLCJfY291bnRlciIsInN0ZGluIiwiT19SRFdSIiwic2V0SXRlbSIsIlN0YW5kYXJkSW5wdXQiLCJ0cmFja0Rlc2NyaXB0b3IiLCJzdGRvdXQiLCJTdGFuZGFyZE91dHB1dCIsInN0ZGVyciIsIlN0YW5kYXJkRXJyb3IiLCJnZXRTeXN0ZW0iLCJzZXRTeXN0ZW0iLCJnZXREZXNjcmlwdG9yQnlJZCIsImZkIiwiaGFzT3duUHJvcGVydHkiLCJkZXNjcmlwdG9yIiwidW50cmFja0Rlc2NyaXB0b3JCeUlkIiwicmVhbHBhdGgiLCJmaWxlcGF0aCIsImVuY29kaW5nIiwicmVhbFBhdGgiLCJyZXNvbHZlZCIsInBhcnRzIiwiaXRlbSIsImdldFJvb3QiLCJpdGVtUGF0aCIsIm5hbWUiLCJpIiwiaWkiLCJkaXJuYW1lIiwiZ2V0UGF0aCIsImdldEl0ZW0iLCJwbGF0Zm9ybSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImRldiIsIm5saW5rIiwidWlkIiwiZ2lkIiwicmRldiIsImJsa3NpemUiLCJpbm8iLCJzaXplIiwiYmxvY2tzIiwiTWF0aCIsImZsb29yIiwiYXRpbWVNcyIsIm10aW1lTXMiLCJjdGltZU1zIiwiYmlydGh0aW1lTXMiLCJzdGF0Iiwib3B0aW9ucyIsImdldFN0YXRzIiwiRmxvYXQ2NEFycmF5IiwiZnN0YXQiLCJjbG9zZSIsIm9wZW4iLCJwYXRobmFtZSIsImZsYWdzIiwiaXNFeGNsdXNpdmUiLCJpc0NyZWF0ZSIsInBhcmVudCIsInNldE1vZGUiLCJhZGRJdGVtIiwiYmFzZW5hbWUiLCJpc1JlYWQiLCJjYW5SZWFkIiwiaXNXcml0ZSIsImNhbldyaXRlIiwiaXNUcnVuY2F0ZSIsImlzQXBwZW5kIiwic2V0Q29udGVudCIsInNldFBvc2l0aW9uIiwiZ2V0Q29udGVudCIsIm9wZW5GaWxlSGFuZGxlIiwic2VsZiIsInRoZW4iLCJnZXRBc3luY0lkIiwicmVhZCIsImJ1ZmZlciIsIm9mZnNldCIsInBvc2l0aW9uIiwiZmlsZSIsImdldFBvc2l0aW9uIiwiY29udGVudCIsInN0YXJ0IiwibWluIiwiZW5kIiwiY29weSIsImNvcHlGaWxlIiwic3JjIiwiZGVzdCIsInNyY0ZkIiwiT19SRE9OTFkiLCJzcmNEZXNjcmlwdG9yIiwic3JjRmlsZSIsInNyY0NvbnRlbnQiLCJkZXN0RmxhZ3MiLCJPX1dST05MWSIsIk9fQ1JFQVQiLCJPX1RSVU5DIiwiQ09QWUZJTEVfRVhDTCIsIk9fRVhDTCIsImRlc3RGZCIsIndyaXRlIiwid3JpdGVCdWZmZXJzIiwiYnVmZmVycyIsIm5ld0NvbnRlbnQiLCJjb25jYXQiLCJuZXdMZW5ndGgiLCJ0ZW1wQ29udGVudCIsIndyaXR0ZW4iLCJ3cml0ZUJ1ZmZlciIsInNvdXJjZUVuZCIsIndyaXRlU3RyaW5nIiwic3RyaW5nIiwid3JhcHBlciIsInJldHVybmVkIiwicmVuYW1lIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJvbGRJdGVtIiwib2xkUGFyZW50Iiwib2xkTmFtZSIsIm5ld0l0ZW0iLCJuZXdQYXJlbnQiLCJuZXdOYW1lIiwibGlzdCIsInJlbW92ZUl0ZW0iLCJyZWFkZGlyIiwiZGlycGF0aCIsIndpdGhGaWxlVHlwZXMiLCJkcGF0aCIsImRpciIsIm1hcCIsInR5cGVzIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJfbWtkaXIiLCJfcGF0aG5hbWUiLCJwYXJlbnREaXIiLCJhY2Nlc3MiLCJwYXJzZUludCIsInJtZGlyIiwiUEFUSF9DSEFSUyIsIk1BWF9BVFRFTVBUUyIsIm1rZHRlbXAiLCJwcmVmaXgiLCJyZXBsYWNlIiwicGFyZW50UGF0aCIsInRlbXBsYXRlIiwidW5pcXVlIiwiY291bnQiLCJyZXBsYWNlbWVudCIsImNoYXJBdCIsInJhbmRvbSIsImNhbmRpZGF0ZSIsInVuaXF1ZVBhdGgiLCJqb2luIiwiZnRydW5jYXRlIiwibGVuIiwidHJ1bmNhdGUiLCJjaG93biIsInNldFVpZCIsInNldEdpZCIsImZjaG93biIsImNobW9kIiwiZmNobW9kIiwidW5saW5rIiwidXRpbWVzIiwiYXRpbWUiLCJtdGltZSIsInNldEFUaW1lIiwiRGF0ZSIsInNldE1UaW1lIiwiZnV0aW1lcyIsImZzeW5jIiwiZmRhdGFzeW5jIiwibGluayIsInNyY1BhdGgiLCJkZXN0UGF0aCIsInN5bWxpbmsiLCJ0eXBlIiwic2V0UGF0aCIsInJlYWRsaW5rIiwibGlua1BhdGgiLCJsc3RhdCIsImxpbmtzIiwiZ2V0dWlkIiwiZ2V0Z2lkIiwiaXRlbU1vZGUiLCJnZXRNb2RlIiwiZ2V0VWlkIiwiZ2V0R2lkIiwiU3RhdFdhdGNoZXIiLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/binding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/buffer.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/buffer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.from = Buffer.from || function(value, encoding) {\n    if (encoding) {\n        return new Buffer(value, encoding);\n    }\n    return new Buffer(value);\n};\nexports.alloc = Buffer.alloc || function(size) {\n    return new Buffer(size);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBQSxZQUFZLEdBQ1ZFLE9BQU9ELElBQUksSUFDWCxTQUFTRSxLQUFLLEVBQUVDLFFBQVE7SUFDdEIsSUFBSUEsVUFBVTtRQUNaLE9BQU8sSUFBSUYsT0FBT0MsT0FBT0M7SUFDM0I7SUFDQSxPQUFPLElBQUlGLE9BQU9DO0FBQ3BCO0FBRUZILGFBQWEsR0FDWEUsT0FBT0csS0FBSyxJQUNaLFNBQVNDLElBQUk7SUFDWCxPQUFPLElBQUlKLE9BQU9JO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnVmZmVyLmpzPzk2NmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mcm9tID1cbiAgQnVmZmVyLmZyb20gfHxcbiAgZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gIH07XG5cbmV4cG9ydHMuYWxsb2MgPVxuICBCdWZmZXIuYWxsb2MgfHxcbiAgZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICB9O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJmcm9tIiwiQnVmZmVyIiwidmFsdWUiLCJlbmNvZGluZyIsImFsbG9jIiwic2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/bypass.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/bypass.js ***!
  \********************************************/
/***/ ((module, exports) => {

eval("const realBinding = process.binding(\"fs\");\nlet storedBinding;\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */ exports = module.exports = function bypass(fn) {\n    if (typeof fn !== \"function\") {\n        throw new Error(`Must provide a function to perform for mock.bypass()`);\n    }\n    disable();\n    let result;\n    try {\n        result = fn();\n    } finally{\n        if (result && typeof result.then === \"function\") {\n            result.then((r)=>{\n                enable();\n                return r;\n            }, (err)=>{\n                enable();\n                throw err;\n            });\n        } else {\n            enable();\n        }\n    }\n    return result;\n};\n/**\n * Temporarily disable Mocked FS\n */ function disable() {\n    if (realBinding._mockedBinding) {\n        storedBinding = realBinding._mockedBinding;\n        delete realBinding._mockedBinding;\n    }\n}\n/**\n * Enables Mocked FS after being disabled by disable()\n */ function enable() {\n    if (storedBinding) {\n        realBinding._mockedBinding = storedBinding;\n        storedBinding = undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9ieXBhc3MuanM/MDY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWFsQmluZGluZyA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbmxldCBzdG9yZWRCaW5kaW5nO1xuXG4vKipcbiAqIFBlcmZvcm0gYWN0aW9uLCBieXBhc3NpbmcgbW9jayBGU1xuICogQGV4YW1wbGVcbiAqIC8vIFRoaXMgZmlsZSBleGlzdHMgb24gdGhlIHJlYWwgRlMsIG5vdCBvbiB0aGUgbW9ja2VkIEZTXG4gKiBjb25zdCBmaWxlUGF0aCA9ICcvcGF0aC9maWxlLmpzb24nO1xuICogY29uc3QgZGF0YSA9IG1vY2suYnlwYXNzKCgpID0+IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04JykpO1xuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBieXBhc3MoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTXVzdCBwcm92aWRlIGEgZnVuY3Rpb24gdG8gcGVyZm9ybSBmb3IgbW9jay5ieXBhc3MoKWApO1xuICB9XG5cbiAgZGlzYWJsZSgpO1xuXG4gIGxldCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0LnRoZW4oXG4gICAgICAgIHIgPT4ge1xuICAgICAgICAgIGVuYWJsZSgpO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9LFxuICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgIGVuYWJsZSgpO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5hYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGVtcG9yYXJpbHkgZGlzYWJsZSBNb2NrZWQgRlNcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgc3RvcmVkQmluZGluZyA9IHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nO1xuICAgIGRlbGV0ZSByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZztcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgTW9ja2VkIEZTIGFmdGVyIGJlaW5nIGRpc2FibGVkIGJ5IGRpc2FibGUoKVxuICovXG5mdW5jdGlvbiBlbmFibGUoKSB7XG4gIGlmIChzdG9yZWRCaW5kaW5nKSB7XG4gICAgcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcgPSBzdG9yZWRCaW5kaW5nO1xuICAgIHN0b3JlZEJpbmRpbmcgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJyZWFsQmluZGluZyIsInByb2Nlc3MiLCJiaW5kaW5nIiwic3RvcmVkQmluZGluZyIsImV4cG9ydHMiLCJtb2R1bGUiLCJieXBhc3MiLCJmbiIsIkVycm9yIiwiZGlzYWJsZSIsInJlc3VsdCIsInRoZW4iLCJyIiwiZW5hYmxlIiwiZXJyIiwiX21vY2tlZEJpbmRpbmciLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLGNBQWNDLFFBQVFDLE9BQU8sQ0FBQztBQUNwQyxJQUFJQztBQUVKOzs7Ozs7Q0FNQyxHQUNEQyxVQUFVQyxPQUFPRCxPQUFPLEdBQUcsU0FBU0UsT0FBT0MsRUFBRTtJQUMzQyxJQUFJLE9BQU9BLE9BQU8sWUFBWTtRQUM1QixNQUFNLElBQUlDLE1BQU0sQ0FBQyxvREFBb0QsQ0FBQztJQUN4RTtJQUVBQztJQUVBLElBQUlDO0lBQ0osSUFBSTtRQUNGQSxTQUFTSDtJQUNYLFNBQVU7UUFDUixJQUFJRyxVQUFVLE9BQU9BLE9BQU9DLElBQUksS0FBSyxZQUFZO1lBQy9DRCxPQUFPQyxJQUFJLENBQ1RDLENBQUFBO2dCQUNFQztnQkFDQSxPQUFPRDtZQUNULEdBQ0FFLENBQUFBO2dCQUNFRDtnQkFDQSxNQUFNQztZQUNSO1FBRUosT0FBTztZQUNMRDtRQUNGO0lBQ0Y7SUFFQSxPQUFPSDtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTRDtJQUNQLElBQUlULFlBQVllLGNBQWMsRUFBRTtRQUM5QlosZ0JBQWdCSCxZQUFZZSxjQUFjO1FBQzFDLE9BQU9mLFlBQVllLGNBQWM7SUFDbkM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU0Y7SUFDUCxJQUFJVixlQUFlO1FBQ2pCSCxZQUFZZSxjQUFjLEdBQUdaO1FBQzdCQSxnQkFBZ0JhO0lBQ2xCO0FBQ0YiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnlwYXNzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/bypass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/descriptor.js":
/*!************************************************!*\
  !*** ./node_modules/mock-fs/lib/descriptor.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n/**\n * Create a new file descriptor.\n * @param {number} flags Flags.\n * @constructor\n */ function FileDescriptor(flags) {\n    /**\n   * Flags.\n   * @type {number}\n   */ this._flags = flags;\n    /**\n   * File system item.\n   * @type {Item}\n   */ this._item = null;\n    /**\n   * Current file position.\n   * @type {number}\n   */ this._position = 0;\n}\n/**\n * Set the item.\n * @param {Item} item File system item.\n */ FileDescriptor.prototype.setItem = function(item) {\n    this._item = item;\n};\n/**\n * Get the item.\n * @return {Item} File system item.\n */ FileDescriptor.prototype.getItem = function() {\n    return this._item;\n};\n/**\n * Get the current file position.\n * @return {number} File position.\n */ FileDescriptor.prototype.getPosition = function() {\n    return this._position;\n};\n/**\n * Set the current file position.\n * @param {number} position File position.\n */ FileDescriptor.prototype.setPosition = function(position) {\n    this._position = position;\n};\n/**\n * Check if file opened for appending.\n * @return {boolean} Opened for appending.\n */ FileDescriptor.prototype.isAppend = function() {\n    return (this._flags & constants.O_APPEND) === constants.O_APPEND;\n};\n/**\n * Check if file opened for creation.\n * @return {boolean} Opened for creation.\n */ FileDescriptor.prototype.isCreate = function() {\n    return (this._flags & constants.O_CREAT) === constants.O_CREAT;\n};\n/**\n * Check if file opened for reading.\n * @return {boolean} Opened for reading.\n */ FileDescriptor.prototype.isRead = function() {\n    return (this._flags & constants.O_WRONLY) !== constants.O_WRONLY;\n};\n/**\n * Check if file opened for writing.\n * @return {boolean} Opened for writing.\n */ FileDescriptor.prototype.isWrite = function() {\n    return (this._flags & constants.O_WRONLY) === constants.O_WRONLY || (this._flags & constants.O_RDWR) === constants.O_RDWR;\n};\n/**\n * Check if file opened for truncating.\n * @return {boolean} Opened for truncating.\n */ FileDescriptor.prototype.isTruncate = function() {\n    return (this._flags & constants.O_TRUNC) === constants.O_TRUNC;\n};\n/**\n * Check if file opened with exclusive flag.\n * @return {boolean} Opened with exclusive.\n */ FileDescriptor.prototype.isExclusive = function() {\n    return (this._flags & constants.O_EXCL) === constants.O_EXCL;\n};\n/**\n * Export the constructor.\n * @type {function()}\n */ exports = module.exports = FileDescriptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGVzY3JpcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBRTFCOzs7O0NBSUMsR0FDRCxTQUFTQyxlQUFlQyxLQUFLO0lBQzNCOzs7R0FHQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUVkOzs7R0FHQyxHQUNELElBQUksQ0FBQ0UsS0FBSyxHQUFHO0lBRWI7OztHQUdDLEdBQ0QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7QUFDbkI7QUFFQTs7O0NBR0MsR0FDREosZUFBZUssU0FBUyxDQUFDQyxPQUFPLEdBQUcsU0FBU0MsSUFBSTtJQUM5QyxJQUFJLENBQUNKLEtBQUssR0FBR0k7QUFDZjtBQUVBOzs7Q0FHQyxHQUNEUCxlQUFlSyxTQUFTLENBQUNHLE9BQU8sR0FBRztJQUNqQyxPQUFPLElBQUksQ0FBQ0wsS0FBSztBQUNuQjtBQUVBOzs7Q0FHQyxHQUNESCxlQUFlSyxTQUFTLENBQUNJLFdBQVcsR0FBRztJQUNyQyxPQUFPLElBQUksQ0FBQ0wsU0FBUztBQUN2QjtBQUVBOzs7Q0FHQyxHQUNESixlQUFlSyxTQUFTLENBQUNLLFdBQVcsR0FBRyxTQUFTQyxRQUFRO0lBQ3RELElBQUksQ0FBQ1AsU0FBUyxHQUFHTztBQUNuQjtBQUVBOzs7Q0FHQyxHQUNEWCxlQUFlSyxTQUFTLENBQUNPLFFBQVEsR0FBRztJQUNsQyxPQUFPLENBQUMsSUFBSSxDQUFDVixNQUFNLEdBQUdKLFVBQVVlLFFBQVEsTUFBTWYsVUFBVWUsUUFBUTtBQUNsRTtBQUVBOzs7Q0FHQyxHQUNEYixlQUFlSyxTQUFTLENBQUNTLFFBQVEsR0FBRztJQUNsQyxPQUFPLENBQUMsSUFBSSxDQUFDWixNQUFNLEdBQUdKLFVBQVVpQixPQUFPLE1BQU1qQixVQUFVaUIsT0FBTztBQUNoRTtBQUVBOzs7Q0FHQyxHQUNEZixlQUFlSyxTQUFTLENBQUNXLE1BQU0sR0FBRztJQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDZCxNQUFNLEdBQUdKLFVBQVVtQixRQUFRLE1BQU1uQixVQUFVbUIsUUFBUTtBQUNsRTtBQUVBOzs7Q0FHQyxHQUNEakIsZUFBZUssU0FBUyxDQUFDYSxPQUFPLEdBQUc7SUFDakMsT0FDRSxDQUFDLElBQUksQ0FBQ2hCLE1BQU0sR0FBR0osVUFBVW1CLFFBQVEsTUFBTW5CLFVBQVVtQixRQUFRLElBQ3pELENBQUMsSUFBSSxDQUFDZixNQUFNLEdBQUdKLFVBQVVxQixNQUFNLE1BQU1yQixVQUFVcUIsTUFBTTtBQUV6RDtBQUVBOzs7Q0FHQyxHQUNEbkIsZUFBZUssU0FBUyxDQUFDZSxVQUFVLEdBQUc7SUFDcEMsT0FBTyxDQUFDLElBQUksQ0FBQ2xCLE1BQU0sR0FBR0osVUFBVXVCLE9BQU8sTUFBTXZCLFVBQVV1QixPQUFPO0FBQ2hFO0FBRUE7OztDQUdDLEdBQ0RyQixlQUFlSyxTQUFTLENBQUNpQixXQUFXLEdBQUc7SUFDckMsT0FBTyxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sR0FBR0osVUFBVXlCLE1BQU0sTUFBTXpCLFVBQVV5QixNQUFNO0FBQzlEO0FBRUE7OztDQUdDLEdBQ0RDLFVBQVVDLE9BQU9ELE9BQU8sR0FBR3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGVzY3JpcHRvci5qcz9jODhjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBGbGFncy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlRGVzY3JpcHRvcihmbGFncykge1xuICAvKipcbiAgICogRmxhZ3MuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9mbGFncyA9IGZsYWdzO1xuXG4gIC8qKlxuICAgKiBGaWxlIHN5c3RlbSBpdGVtLlxuICAgKiBAdHlwZSB7SXRlbX1cbiAgICovXG4gIHRoaXMuX2l0ZW0gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9wb3NpdGlvbiA9IDA7XG59XG5cbi8qKlxuICogU2V0IHRoZSBpdGVtLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtIEZpbGUgc3lzdGVtIGl0ZW0uXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLl9pdGVtID0gaXRlbTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpdGVtLlxuICogQHJldHVybiB7SXRlbX0gRmlsZSBzeXN0ZW0gaXRlbS5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBGaWxlIHBvc2l0aW9uLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBGaWxlIHBvc2l0aW9uLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3IgYXBwZW5kaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciBhcHBlbmRpbmcuXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc0FwcGVuZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fQVBQRU5EKSA9PT0gY29uc3RhbnRzLk9fQVBQRU5EO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3IgY3JlYXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgZm9yIGNyZWF0aW9uLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNDcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX0NSRUFUKSA9PT0gY29uc3RhbnRzLk9fQ1JFQVQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciByZWFkaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciByZWFkaW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNSZWFkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19XUk9OTFkpICE9PSBjb25zdGFudHMuT19XUk9OTFk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciB3cml0aW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciB3cml0aW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNXcml0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKFxuICAgICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX1dST05MWSkgPT09IGNvbnN0YW50cy5PX1dST05MWSB8fFxuICAgICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX1JEV1IpID09PSBjb25zdGFudHMuT19SRFdSXG4gICk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciB0cnVuY2F0aW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciB0cnVuY2F0aW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNUcnVuY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fVFJVTkMpID09PSBjb25zdGFudHMuT19UUlVOQztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgd2l0aCBleGNsdXNpdmUgZmxhZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCB3aXRoIGV4Y2x1c2l2ZS5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzRXhjbHVzaXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19FWENMKSA9PT0gY29uc3RhbnRzLk9fRVhDTDtcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWxlRGVzY3JpcHRvcjtcbiJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJyZXF1aXJlIiwiRmlsZURlc2NyaXB0b3IiLCJmbGFncyIsIl9mbGFncyIsIl9pdGVtIiwiX3Bvc2l0aW9uIiwicHJvdG90eXBlIiwic2V0SXRlbSIsIml0ZW0iLCJnZXRJdGVtIiwiZ2V0UG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsInBvc2l0aW9uIiwiaXNBcHBlbmQiLCJPX0FQUEVORCIsImlzQ3JlYXRlIiwiT19DUkVBVCIsImlzUmVhZCIsIk9fV1JPTkxZIiwiaXNXcml0ZSIsIk9fUkRXUiIsImlzVHJ1bmNhdGUiLCJPX1RSVU5DIiwiaXNFeGNsdXNpdmUiLCJPX0VYQ0wiLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/descriptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/directory.js":
/*!***********************************************!*\
  !*** ./node_modules/mock-fs/lib/directory.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n/**\n * A directory.\n * @constructor\n */ function Directory() {\n    Item.call(this);\n    /**\n   * Items in this directory.\n   * @type {Object.<string, Item>}\n   */ this._items = {};\n    /**\n   * Permissions.\n   */ this._mode = 511; // 0777\n}\nutil.inherits(Directory, Item);\n/**\n * Add an item to the directory.\n * @param {string} name The name to give the item.\n * @param {Item} item The item to add.\n * @return {Item} The added item.\n */ Directory.prototype.addItem = function(name, item) {\n    if (this._items.hasOwnProperty(name)) {\n        throw new Error(\"Item with the same name already exists: \" + name);\n    }\n    this._items[name] = item;\n    ++item.links;\n    if (item instanceof Directory) {\n        // for '.' entry\n        ++item.links;\n        // for subdirectory\n        ++this.links;\n    }\n    this.setMTime(new Date());\n    return item;\n};\n/**\n * Get a named item.\n * @param {string} name Item name.\n * @return {Item} The named item (or null if none).\n */ Directory.prototype.getItem = function(name) {\n    let item = null;\n    if (this._items.hasOwnProperty(name)) {\n        item = this._items[name];\n    }\n    return item;\n};\n/**\n * Remove an item.\n * @param {string} name Name of item to remove.\n * @return {Item} The orphan item.\n */ Directory.prototype.removeItem = function(name) {\n    if (!this._items.hasOwnProperty(name)) {\n        throw new Error(\"Item does not exist in directory: \" + name);\n    }\n    const item = this._items[name];\n    delete this._items[name];\n    --item.links;\n    if (item instanceof Directory) {\n        // for '.' entry\n        --item.links;\n        // for subdirectory\n        --this.links;\n    }\n    this.setMTime(new Date());\n    return item;\n};\n/**\n * Get list of item names in this directory.\n * @return {Array.<string>} Item names.\n */ Directory.prototype.list = function() {\n    return Object.keys(this._items).sort();\n};\n/**\n * Get directory stats.\n * @return {Object} Stats properties.\n */ Directory.prototype.getStats = function() {\n    const stats = Item.prototype.getStats.call(this);\n    stats.mode = this.getMode() | constants.S_IFDIR;\n    stats.size = 1;\n    stats.blocks = 1;\n    return stats;\n};\n/**\n * Export the constructor.\n * @type {function()}\n */ exports = module.exports = Directory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGlyZWN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFckIsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUM7QUFFMUI7OztDQUdDLEdBQ0QsU0FBU0c7SUFDUEYsS0FBS0csSUFBSSxDQUFDLElBQUk7SUFFZDs7O0dBR0MsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDO0lBRWY7O0dBRUMsR0FDRCxJQUFJLENBQUNDLEtBQUssR0FBRyxLQUFLLE9BQU87QUFDM0I7QUFDQVAsS0FBS1EsUUFBUSxDQUFDSixXQUFXRjtBQUV6Qjs7Ozs7Q0FLQyxHQUNERSxVQUFVSyxTQUFTLENBQUNDLE9BQU8sR0FBRyxTQUFTQyxJQUFJLEVBQUVDLElBQUk7SUFDL0MsSUFBSSxJQUFJLENBQUNOLE1BQU0sQ0FBQ08sY0FBYyxDQUFDRixPQUFPO1FBQ3BDLE1BQU0sSUFBSUcsTUFBTSw2Q0FBNkNIO0lBQy9EO0lBQ0EsSUFBSSxDQUFDTCxNQUFNLENBQUNLLEtBQUssR0FBR0M7SUFDcEIsRUFBRUEsS0FBS0csS0FBSztJQUNaLElBQUlILGdCQUFnQlIsV0FBVztRQUM3QixnQkFBZ0I7UUFDaEIsRUFBRVEsS0FBS0csS0FBSztRQUNaLG1CQUFtQjtRQUNuQixFQUFFLElBQUksQ0FBQ0EsS0FBSztJQUNkO0lBQ0EsSUFBSSxDQUFDQyxRQUFRLENBQUMsSUFBSUM7SUFDbEIsT0FBT0w7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRFIsVUFBVUssU0FBUyxDQUFDUyxPQUFPLEdBQUcsU0FBU1AsSUFBSTtJQUN6QyxJQUFJQyxPQUFPO0lBQ1gsSUFBSSxJQUFJLENBQUNOLE1BQU0sQ0FBQ08sY0FBYyxDQUFDRixPQUFPO1FBQ3BDQyxPQUFPLElBQUksQ0FBQ04sTUFBTSxDQUFDSyxLQUFLO0lBQzFCO0lBQ0EsT0FBT0M7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRFIsVUFBVUssU0FBUyxDQUFDVSxVQUFVLEdBQUcsU0FBU1IsSUFBSTtJQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDTCxNQUFNLENBQUNPLGNBQWMsQ0FBQ0YsT0FBTztRQUNyQyxNQUFNLElBQUlHLE1BQU0sdUNBQXVDSDtJQUN6RDtJQUNBLE1BQU1DLE9BQU8sSUFBSSxDQUFDTixNQUFNLENBQUNLLEtBQUs7SUFDOUIsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ0ssS0FBSztJQUN4QixFQUFFQyxLQUFLRyxLQUFLO0lBQ1osSUFBSUgsZ0JBQWdCUixXQUFXO1FBQzdCLGdCQUFnQjtRQUNoQixFQUFFUSxLQUFLRyxLQUFLO1FBQ1osbUJBQW1CO1FBQ25CLEVBQUUsSUFBSSxDQUFDQSxLQUFLO0lBQ2Q7SUFDQSxJQUFJLENBQUNDLFFBQVEsQ0FBQyxJQUFJQztJQUNsQixPQUFPTDtBQUNUO0FBRUE7OztDQUdDLEdBQ0RSLFVBQVVLLFNBQVMsQ0FBQ1csSUFBSSxHQUFHO0lBQ3pCLE9BQU9DLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNoQixNQUFNLEVBQUVpQixJQUFJO0FBQ3RDO0FBRUE7OztDQUdDLEdBQ0RuQixVQUFVSyxTQUFTLENBQUNlLFFBQVEsR0FBRztJQUM3QixNQUFNQyxRQUFRdkIsS0FBS08sU0FBUyxDQUFDZSxRQUFRLENBQUNuQixJQUFJLENBQUMsSUFBSTtJQUMvQ29CLE1BQU1DLElBQUksR0FBRyxJQUFJLENBQUNDLE9BQU8sS0FBS3hCLFVBQVV5QixPQUFPO0lBQy9DSCxNQUFNSSxJQUFJLEdBQUc7SUFDYkosTUFBTUssTUFBTSxHQUFHO0lBQ2YsT0FBT0w7QUFDVDtBQUVBOzs7Q0FHQyxHQUNETSxVQUFVQyxPQUFPRCxPQUFPLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2RpcmVjdG9yeS5qcz83MjA5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcblxuLyoqXG4gKiBBIGRpcmVjdG9yeS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEaXJlY3RvcnkoKSB7XG4gIEl0ZW0uY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogSXRlbXMgaW4gdGhpcyBkaXJlY3RvcnkuXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgSXRlbT59XG4gICAqL1xuICB0aGlzLl9pdGVtcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBQZXJtaXNzaW9ucy5cbiAgICovXG4gIHRoaXMuX21vZGUgPSA1MTE7IC8vIDA3Nzdcbn1cbnV0aWwuaW5oZXJpdHMoRGlyZWN0b3J5LCBJdGVtKTtcblxuLyoqXG4gKiBBZGQgYW4gaXRlbSB0byB0aGUgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgdG8gZ2l2ZSB0aGUgaXRlbS5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbSBUaGUgaXRlbSB0byBhZGQuXG4gKiBAcmV0dXJuIHtJdGVtfSBUaGUgYWRkZWQgaXRlbS5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24obmFtZSwgaXRlbSkge1xuICBpZiAodGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzOiAnICsgbmFtZSk7XG4gIH1cbiAgdGhpcy5faXRlbXNbbmFtZV0gPSBpdGVtO1xuICArK2l0ZW0ubGlua3M7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgLy8gZm9yICcuJyBlbnRyeVxuICAgICsraXRlbS5saW5rcztcbiAgICAvLyBmb3Igc3ViZGlyZWN0b3J5XG4gICAgKyt0aGlzLmxpbmtzO1xuICB9XG4gIHRoaXMuc2V0TVRpbWUobmV3IERhdGUoKSk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgYSBuYW1lZCBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSXRlbSBuYW1lLlxuICogQHJldHVybiB7SXRlbX0gVGhlIG5hbWVkIGl0ZW0gKG9yIG51bGwgaWYgbm9uZSkuXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbGV0IGl0ZW0gPSBudWxsO1xuICBpZiAodGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICBpdGVtID0gdGhpcy5faXRlbXNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBpdGVtIHRvIHJlbW92ZS5cbiAqIEByZXR1cm4ge0l0ZW19IFRoZSBvcnBoYW4gaXRlbS5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuX2l0ZW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIGRvZXMgbm90IGV4aXN0IGluIGRpcmVjdG9yeTogJyArIG5hbWUpO1xuICB9XG4gIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tuYW1lXTtcbiAgZGVsZXRlIHRoaXMuX2l0ZW1zW25hbWVdO1xuICAtLWl0ZW0ubGlua3M7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgLy8gZm9yICcuJyBlbnRyeVxuICAgIC0taXRlbS5saW5rcztcbiAgICAvLyBmb3Igc3ViZGlyZWN0b3J5XG4gICAgLS10aGlzLmxpbmtzO1xuICB9XG4gIHRoaXMuc2V0TVRpbWUobmV3IERhdGUoKSk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgbGlzdCBvZiBpdGVtIG5hbWVzIGluIHRoaXMgZGlyZWN0b3J5LlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEl0ZW0gbmFtZXMuXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faXRlbXMpLnNvcnQoKTtcbn07XG5cbi8qKlxuICogR2V0IGRpcmVjdG9yeSBzdGF0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RhdHMgcHJvcGVydGllcy5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdGF0cyA9IEl0ZW0ucHJvdG90eXBlLmdldFN0YXRzLmNhbGwodGhpcyk7XG4gIHN0YXRzLm1vZGUgPSB0aGlzLmdldE1vZGUoKSB8IGNvbnN0YW50cy5TX0lGRElSO1xuICBzdGF0cy5zaXplID0gMTtcbiAgc3RhdHMuYmxvY2tzID0gMTtcbiAgcmV0dXJuIHN0YXRzO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERpcmVjdG9yeTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsIkl0ZW0iLCJjb25zdGFudHMiLCJEaXJlY3RvcnkiLCJjYWxsIiwiX2l0ZW1zIiwiX21vZGUiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImFkZEl0ZW0iLCJuYW1lIiwiaXRlbSIsImhhc093blByb3BlcnR5IiwiRXJyb3IiLCJsaW5rcyIsInNldE1UaW1lIiwiRGF0ZSIsImdldEl0ZW0iLCJyZW1vdmVJdGVtIiwibGlzdCIsIk9iamVjdCIsImtleXMiLCJzb3J0IiwiZ2V0U3RhdHMiLCJzdGF0cyIsIm1vZGUiLCJnZXRNb2RlIiwiU19JRkRJUiIsInNpemUiLCJibG9ja3MiLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/directory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/mock-fs/lib/error.js ***!
  \*******************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nconst uvBinding = process.binding(\"uv\");\n/**\n * Error codes from libuv.\n * @enum {number}\n */ const codes = {};\nif (uvBinding.errmap) {\n    // nodejs v8+\n    uvBinding.errmap.forEach(function(value, errno) {\n        const code = value[0];\n        const message = value[1];\n        codes[code] = {\n            errno: errno,\n            message: message\n        };\n    });\n} else {\n    // nodejs v4 and v6\n    Object.keys(uvBinding).forEach(function(key) {\n        if (key.startsWith(\"UV_\")) {\n            const code = key.slice(3);\n            const errno = uvBinding[key];\n            codes[code] = {\n                errno: errno,\n                message: key\n            };\n        }\n    });\n}\n/**\n * Create an error.\n * @param {string} code Error code.\n * @param {string} path Path (optional).\n * @constructor\n */ function FSError(code, path) {\n    if (!codes.hasOwnProperty(code)) {\n        throw new Error(\"Programmer error, invalid error code: \" + code);\n    }\n    Error.call(this);\n    const details = codes[code];\n    let message = code + \", \" + details.message;\n    if (path) {\n        message += \" '\" + path + \"'\";\n    }\n    this.message = message;\n    this.code = code;\n    this.errno = details.errno;\n    if (path !== undefined) {\n        this.path = path;\n    }\n    Error.captureStackTrace(this, FSError);\n}\nFSError.prototype = new Error();\nFSError.codes = codes;\n/**\n * Error constructor.\n */ exports = module.exports = FSError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZQyxRQUFRQyxPQUFPLENBQUM7QUFDbEM7OztDQUdDLEdBQ0QsTUFBTUMsUUFBUSxDQUFDO0FBRWYsSUFBSUgsVUFBVUksTUFBTSxFQUFFO0lBQ3BCLGFBQWE7SUFDYkosVUFBVUksTUFBTSxDQUFDQyxPQUFPLENBQUMsU0FBU0MsS0FBSyxFQUFFQyxLQUFLO1FBQzVDLE1BQU1DLE9BQU9GLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE1BQU1HLFVBQVVILEtBQUssQ0FBQyxFQUFFO1FBQ3hCSCxLQUFLLENBQUNLLEtBQUssR0FBRztZQUFDRCxPQUFPQTtZQUFPRSxTQUFTQTtRQUFPO0lBQy9DO0FBQ0YsT0FBTztJQUNMLG1CQUFtQjtJQUNuQkMsT0FBT0MsSUFBSSxDQUFDWCxXQUFXSyxPQUFPLENBQUMsU0FBU08sR0FBRztRQUN6QyxJQUFJQSxJQUFJQyxVQUFVLENBQUMsUUFBUTtZQUN6QixNQUFNTCxPQUFPSSxJQUFJRSxLQUFLLENBQUM7WUFDdkIsTUFBTVAsUUFBUVAsU0FBUyxDQUFDWSxJQUFJO1lBQzVCVCxLQUFLLENBQUNLLEtBQUssR0FBRztnQkFBQ0QsT0FBT0E7Z0JBQU9FLFNBQVNHO1lBQUc7UUFDM0M7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTRyxRQUFRUCxJQUFJLEVBQUVRLElBQUk7SUFDekIsSUFBSSxDQUFDYixNQUFNYyxjQUFjLENBQUNULE9BQU87UUFDL0IsTUFBTSxJQUFJVSxNQUFNLDJDQUEyQ1Y7SUFDN0Q7SUFDQVUsTUFBTUMsSUFBSSxDQUFDLElBQUk7SUFDZixNQUFNQyxVQUFVakIsS0FBSyxDQUFDSyxLQUFLO0lBQzNCLElBQUlDLFVBQVVELE9BQU8sT0FBT1ksUUFBUVgsT0FBTztJQUMzQyxJQUFJTyxNQUFNO1FBQ1JQLFdBQVcsT0FBT08sT0FBTztJQUMzQjtJQUNBLElBQUksQ0FBQ1AsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtJQUNaLElBQUksQ0FBQ0QsS0FBSyxHQUFHYSxRQUFRYixLQUFLO0lBQzFCLElBQUlTLFNBQVNLLFdBQVc7UUFDdEIsSUFBSSxDQUFDTCxJQUFJLEdBQUdBO0lBQ2Q7SUFDQUUsTUFBTUksaUJBQWlCLENBQUMsSUFBSSxFQUFFUDtBQUNoQztBQUNBQSxRQUFRUSxTQUFTLEdBQUcsSUFBSUw7QUFDeEJILFFBQVFaLEtBQUssR0FBR0E7QUFFaEI7O0NBRUMsR0FDRHFCLFVBQVVDLE9BQU9ELE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9lcnJvci5qcz9kOGZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXZCaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCd1dicpO1xuLyoqXG4gKiBFcnJvciBjb2RlcyBmcm9tIGxpYnV2LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgY29kZXMgPSB7fTtcblxuaWYgKHV2QmluZGluZy5lcnJtYXApIHtcbiAgLy8gbm9kZWpzIHY4K1xuICB1dkJpbmRpbmcuZXJybWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGVycm5vKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlWzBdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWx1ZVsxXTtcbiAgICBjb2Rlc1tjb2RlXSA9IHtlcnJubzogZXJybm8sIG1lc3NhZ2U6IG1lc3NhZ2V9O1xuICB9KTtcbn0gZWxzZSB7XG4gIC8vIG5vZGVqcyB2NCBhbmQgdjZcbiAgT2JqZWN0LmtleXModXZCaW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnVVZfJykpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBrZXkuc2xpY2UoMyk7XG4gICAgICBjb25zdCBlcnJubyA9IHV2QmluZGluZ1trZXldO1xuICAgICAgY29kZXNbY29kZV0gPSB7ZXJybm86IGVycm5vLCBtZXNzYWdlOiBrZXl9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgRXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggKG9wdGlvbmFsKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGU0Vycm9yKGNvZGUsIHBhdGgpIHtcbiAgaWYgKCFjb2Rlcy5oYXNPd25Qcm9wZXJ0eShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvZ3JhbW1lciBlcnJvciwgaW52YWxpZCBlcnJvciBjb2RlOiAnICsgY29kZSk7XG4gIH1cbiAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgY29uc3QgZGV0YWlscyA9IGNvZGVzW2NvZGVdO1xuICBsZXQgbWVzc2FnZSA9IGNvZGUgKyAnLCAnICsgZGV0YWlscy5tZXNzYWdlO1xuICBpZiAocGF0aCkge1xuICAgIG1lc3NhZ2UgKz0gXCIgJ1wiICsgcGF0aCArIFwiJ1wiO1xuICB9XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuY29kZSA9IGNvZGU7XG4gIHRoaXMuZXJybm8gPSBkZXRhaWxzLmVycm5vO1xuICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBGU0Vycm9yKTtcbn1cbkZTRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5GU0Vycm9yLmNvZGVzID0gY29kZXM7XG5cbi8qKlxuICogRXJyb3IgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZTRXJyb3I7XG4iXSwibmFtZXMiOlsidXZCaW5kaW5nIiwicHJvY2VzcyIsImJpbmRpbmciLCJjb2RlcyIsImVycm1hcCIsImZvckVhY2giLCJ2YWx1ZSIsImVycm5vIiwiY29kZSIsIm1lc3NhZ2UiLCJPYmplY3QiLCJrZXlzIiwia2V5Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiRlNFcnJvciIsInBhdGgiLCJoYXNPd25Qcm9wZXJ0eSIsIkVycm9yIiwiY2FsbCIsImRldGFpbHMiLCJ1bmRlZmluZWQiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInByb3RvdHlwZSIsImV4cG9ydHMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/file.js":
/*!******************************************!*\
  !*** ./node_modules/mock-fs/lib/file.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").alloc);\nconst EMPTY = bufferAlloc(0);\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n/**\n * A file.\n * @constructor\n */ function File() {\n    Item.call(this);\n    /**\n   * File content.\n   * @type {Buffer}\n   */ this._content = EMPTY;\n}\nutil.inherits(File, Item);\n/**\n * Get the file contents.\n * @return {Buffer} File contents.\n */ File.prototype.getContent = function() {\n    this.setATime(new Date());\n    return this._content;\n};\n/**\n * Set the file contents.\n * @param {string|Buffer} content File contents.\n */ File.prototype.setContent = function(content) {\n    if (typeof content === \"string\") {\n        content = bufferFrom(content);\n    } else if (!Buffer.isBuffer(content)) {\n        throw new Error(\"File content must be a string or buffer\");\n    }\n    this._content = content;\n    const now = Date.now();\n    this.setCTime(new Date(now));\n    this.setMTime(new Date(now));\n};\n/**\n * Get file stats.\n * @return {Object} Stats properties.\n */ File.prototype.getStats = function() {\n    const size = this._content.length;\n    const stats = Item.prototype.getStats.call(this);\n    stats.mode = this.getMode() | constants.S_IFREG;\n    stats.size = size;\n    stats.blocks = Math.ceil(size / 512);\n    return stats;\n};\n/**\n * Export the constructor.\n * @type {function()}\n */ exports = module.exports = File;\n/**\n * Standard input.\n * @constructor\n */ function StandardInput() {\n    File.call(this);\n    this.setMode(438); // 0666\n}\nutil.inherits(StandardInput, File);\nexports.StandardInput = StandardInput;\n/**\n * Standard output.\n * @constructor\n */ function StandardOutput() {\n    File.call(this);\n    this.setMode(438); // 0666\n}\nutil.inherits(StandardOutput, File);\n/**\n * Write the contents to stdout.\n * @param {string|Buffer} content File contents.\n */ StandardOutput.prototype.setContent = function(content) {\n    if (process.stdout.isTTY) {\n        process.stdout.write(content);\n    }\n};\nexports.StandardOutput = StandardOutput;\n/**\n * Standard error.\n * @constructor\n */ function StandardError() {\n    File.call(this);\n    this.setMode(438); // 0666\n}\nutil.inherits(StandardError, File);\n/**\n * Write the contents to stderr.\n * @param {string|Buffer} content File contents.\n */ StandardError.prototype.setContent = function(content) {\n    if (process.stderr.isTTY) {\n        process.stderr.write(content);\n    }\n};\nexports.StandardError = StandardError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLGFBQWFGLHdGQUF3QjtBQUMzQyxNQUFNSSxjQUFjSix5RkFBeUI7QUFFN0MsTUFBTU0sUUFBUUYsWUFBWTtBQUMxQixNQUFNRyxZQUFZUCxtQkFBT0EsQ0FBQztBQUUxQjs7O0NBR0MsR0FDRCxTQUFTUTtJQUNQUCxLQUFLUSxJQUFJLENBQUMsSUFBSTtJQUVkOzs7R0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHSjtBQUNsQjtBQUNBUCxLQUFLWSxRQUFRLENBQUNILE1BQU1QO0FBRXBCOzs7Q0FHQyxHQUNETyxLQUFLSSxTQUFTLENBQUNDLFVBQVUsR0FBRztJQUMxQixJQUFJLENBQUNDLFFBQVEsQ0FBQyxJQUFJQztJQUNsQixPQUFPLElBQUksQ0FBQ0wsUUFBUTtBQUN0QjtBQUVBOzs7Q0FHQyxHQUNERixLQUFLSSxTQUFTLENBQUNJLFVBQVUsR0FBRyxTQUFTQyxPQUFPO0lBQzFDLElBQUksT0FBT0EsWUFBWSxVQUFVO1FBQy9CQSxVQUFVZixXQUFXZTtJQUN2QixPQUFPLElBQUksQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDRixVQUFVO1FBQ3BDLE1BQU0sSUFBSUcsTUFBTTtJQUNsQjtJQUNBLElBQUksQ0FBQ1YsUUFBUSxHQUFHTztJQUNoQixNQUFNSSxNQUFNTixLQUFLTSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsUUFBUSxDQUFDLElBQUlQLEtBQUtNO0lBQ3ZCLElBQUksQ0FBQ0UsUUFBUSxDQUFDLElBQUlSLEtBQUtNO0FBQ3pCO0FBRUE7OztDQUdDLEdBQ0RiLEtBQUtJLFNBQVMsQ0FBQ1ksUUFBUSxHQUFHO0lBQ3hCLE1BQU1DLE9BQU8sSUFBSSxDQUFDZixRQUFRLENBQUNnQixNQUFNO0lBQ2pDLE1BQU1DLFFBQVExQixLQUFLVyxTQUFTLENBQUNZLFFBQVEsQ0FBQ2YsSUFBSSxDQUFDLElBQUk7SUFDL0NrQixNQUFNQyxJQUFJLEdBQUcsSUFBSSxDQUFDQyxPQUFPLEtBQUt0QixVQUFVdUIsT0FBTztJQUMvQ0gsTUFBTUYsSUFBSSxHQUFHQTtJQUNiRSxNQUFNSSxNQUFNLEdBQUdDLEtBQUtDLElBQUksQ0FBQ1IsT0FBTztJQUNoQyxPQUFPRTtBQUNUO0FBRUE7OztDQUdDLEdBQ0RPLFVBQVVDLE9BQU9ELE9BQU8sR0FBRzFCO0FBRTNCOzs7Q0FHQyxHQUNELFNBQVM0QjtJQUNQNUIsS0FBS0MsSUFBSSxDQUFDLElBQUk7SUFDZCxJQUFJLENBQUM0QixPQUFPLENBQUMsTUFBTSxPQUFPO0FBQzVCO0FBQ0F0QyxLQUFLWSxRQUFRLENBQUN5QixlQUFlNUI7QUFFN0IwQixxQkFBcUIsR0FBR0U7QUFFeEI7OztDQUdDLEdBQ0QsU0FBU0U7SUFDUDlCLEtBQUtDLElBQUksQ0FBQyxJQUFJO0lBQ2QsSUFBSSxDQUFDNEIsT0FBTyxDQUFDLE1BQU0sT0FBTztBQUM1QjtBQUNBdEMsS0FBS1ksUUFBUSxDQUFDMkIsZ0JBQWdCOUI7QUFFOUI7OztDQUdDLEdBQ0Q4QixlQUFlMUIsU0FBUyxDQUFDSSxVQUFVLEdBQUcsU0FBU0MsT0FBTztJQUNwRCxJQUFJc0IsUUFBUUMsTUFBTSxDQUFDQyxLQUFLLEVBQUU7UUFDeEJGLFFBQVFDLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDekI7SUFDdkI7QUFDRjtBQUVBaUIsc0JBQXNCLEdBQUdJO0FBRXpCOzs7Q0FHQyxHQUNELFNBQVNLO0lBQ1BuQyxLQUFLQyxJQUFJLENBQUMsSUFBSTtJQUNkLElBQUksQ0FBQzRCLE9BQU8sQ0FBQyxNQUFNLE9BQU87QUFDNUI7QUFDQXRDLEtBQUtZLFFBQVEsQ0FBQ2dDLGVBQWVuQztBQUU3Qjs7O0NBR0MsR0FDRG1DLGNBQWMvQixTQUFTLENBQUNJLFVBQVUsR0FBRyxTQUFTQyxPQUFPO0lBQ25ELElBQUlzQixRQUFRSyxNQUFNLENBQUNILEtBQUssRUFBRTtRQUN4QkYsUUFBUUssTUFBTSxDQUFDRixLQUFLLENBQUN6QjtJQUN2QjtBQUNGO0FBRUFpQixxQkFBcUIsR0FBR1MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9maWxlLmpzP2JjODciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJyk7XG5jb25zdCBidWZmZXJGcm9tID0gcmVxdWlyZSgnLi9idWZmZXInKS5mcm9tO1xuY29uc3QgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCcuL2J1ZmZlcicpLmFsbG9jO1xuXG5jb25zdCBFTVBUWSA9IGJ1ZmZlckFsbG9jKDApO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5cbi8qKlxuICogQSBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGUoKSB7XG4gIEl0ZW0uY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogRmlsZSBjb250ZW50LlxuICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgKi9cbiAgdGhpcy5fY29udGVudCA9IEVNUFRZO1xufVxudXRpbC5pbmhlcml0cyhGaWxlLCBJdGVtKTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpbGUgY29udGVudHMuXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IEZpbGUgY29udGVudHMuXG4gKi9cbkZpbGUucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXRBVGltZShuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZmlsZSBjb250ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gY29udGVudCBGaWxlIGNvbnRlbnRzLlxuICovXG5GaWxlLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29udGVudCA9IGJ1ZmZlckZyb20oY29udGVudCk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG4gIH1cbiAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUobm93KSk7XG4gIHRoaXMuc2V0TVRpbWUobmV3IERhdGUobm93KSk7XG59O1xuXG4vKipcbiAqIEdldCBmaWxlIHN0YXRzLlxuICogQHJldHVybiB7T2JqZWN0fSBTdGF0cyBwcm9wZXJ0aWVzLlxuICovXG5GaWxlLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzaXplID0gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gIGNvbnN0IHN0YXRzID0gSXRlbS5wcm90b3R5cGUuZ2V0U3RhdHMuY2FsbCh0aGlzKTtcbiAgc3RhdHMubW9kZSA9IHRoaXMuZ2V0TW9kZSgpIHwgY29uc3RhbnRzLlNfSUZSRUc7XG4gIHN0YXRzLnNpemUgPSBzaXplO1xuICBzdGF0cy5ibG9ja3MgPSBNYXRoLmNlaWwoc2l6ZSAvIDUxMik7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWxlO1xuXG4vKipcbiAqIFN0YW5kYXJkIGlucHV0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YW5kYXJkSW5wdXQoKSB7XG4gIEZpbGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbn1cbnV0aWwuaW5oZXJpdHMoU3RhbmRhcmRJbnB1dCwgRmlsZSk7XG5cbmV4cG9ydHMuU3RhbmRhcmRJbnB1dCA9IFN0YW5kYXJkSW5wdXQ7XG5cbi8qKlxuICogU3RhbmRhcmQgb3V0cHV0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YW5kYXJkT3V0cHV0KCkge1xuICBGaWxlLmNhbGwodGhpcyk7XG4gIHRoaXMuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG59XG51dGlsLmluaGVyaXRzKFN0YW5kYXJkT3V0cHV0LCBGaWxlKTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudHMgdG8gc3Rkb3V0LlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBjb250ZW50IEZpbGUgY29udGVudHMuXG4gKi9cblN0YW5kYXJkT3V0cHV0LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICBpZiAocHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb250ZW50KTtcbiAgfVxufTtcblxuZXhwb3J0cy5TdGFuZGFyZE91dHB1dCA9IFN0YW5kYXJkT3V0cHV0O1xuXG4vKipcbiAqIFN0YW5kYXJkIGVycm9yLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YW5kYXJkRXJyb3IoKSB7XG4gIEZpbGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbn1cbnV0aWwuaW5oZXJpdHMoU3RhbmRhcmRFcnJvciwgRmlsZSk7XG5cbi8qKlxuICogV3JpdGUgdGhlIGNvbnRlbnRzIHRvIHN0ZGVyci5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gY29udGVudCBGaWxlIGNvbnRlbnRzLlxuICovXG5TdGFuZGFyZEVycm9yLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICBpZiAocHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShjb250ZW50KTtcbiAgfVxufTtcblxuZXhwb3J0cy5TdGFuZGFyZEVycm9yID0gU3RhbmRhcmRFcnJvcjtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsIkl0ZW0iLCJidWZmZXJGcm9tIiwiZnJvbSIsImJ1ZmZlckFsbG9jIiwiYWxsb2MiLCJFTVBUWSIsImNvbnN0YW50cyIsIkZpbGUiLCJjYWxsIiwiX2NvbnRlbnQiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImdldENvbnRlbnQiLCJzZXRBVGltZSIsIkRhdGUiLCJzZXRDb250ZW50IiwiY29udGVudCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiRXJyb3IiLCJub3ciLCJzZXRDVGltZSIsInNldE1UaW1lIiwiZ2V0U3RhdHMiLCJzaXplIiwibGVuZ3RoIiwic3RhdHMiLCJtb2RlIiwiZ2V0TW9kZSIsIlNfSUZSRUciLCJibG9ja3MiLCJNYXRoIiwiY2VpbCIsImV4cG9ydHMiLCJtb2R1bGUiLCJTdGFuZGFyZElucHV0Iiwic2V0TW9kZSIsIlN0YW5kYXJkT3V0cHV0IiwicHJvY2VzcyIsInN0ZG91dCIsImlzVFRZIiwid3JpdGUiLCJTdGFuZGFyZEVycm9yIiwic3RkZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/filesystem.js":
/*!************************************************!*\
  !*** ./node_modules/mock-fs/lib/filesystem.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Directory = __webpack_require__(/*! ./directory */ \"(ssr)/./node_modules/mock-fs/lib/directory.js\");\nconst File = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/mock-fs/lib/file.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(ssr)/./node_modules/mock-fs/lib/symlink.js\");\nconst isWindows = process.platform === \"win32\";\nfunction toNamespacedPath(filePath) {\n    return path.toNamespacedPath ? path.toNamespacedPath(filePath) : path._makeLong(filePath);\n}\nfunction getPathParts(filepath) {\n    const parts = toNamespacedPath(path.resolve(filepath)).split(path.sep);\n    parts.shift();\n    if (isWindows) {\n        // parts currently looks like ['', '?', 'c:', ...]\n        parts.shift();\n        const q = parts.shift(); // should be '?'\n        const base = \"\\\\\\\\\" + q + \"\\\\\" + parts.shift().toLowerCase();\n        parts.unshift(base);\n    }\n    if (parts[parts.length - 1] === \"\") {\n        parts.pop();\n    }\n    return parts;\n}\n/**\n * Create a new file system.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @constructor\n */ function FileSystem(options) {\n    options = options || {};\n    const createCwd = \"createCwd\" in options ? options.createCwd : true;\n    const createTmp = \"createTmp\" in options ? options.createTmp : true;\n    const root = new Directory();\n    // populate with default directories\n    const defaults = [];\n    if (createCwd) {\n        defaults.push(process.cwd());\n    }\n    if (createTmp) {\n        defaults.push(os.tmpdir && os.tmpdir() || os.tmpDir());\n    }\n    defaults.forEach(function(dir) {\n        const parts = getPathParts(dir);\n        let directory = root;\n        for(let i = 0, ii = parts.length; i < ii; ++i){\n            const name = parts[i];\n            const candidate = directory.getItem(name);\n            if (!candidate) {\n                directory = directory.addItem(name, new Directory());\n            } else if (candidate instanceof Directory) {\n                directory = candidate;\n            } else {\n                throw new Error(\"Failed to create directory: \" + dir);\n            }\n        }\n    });\n    /**\n   * Root directory.\n   * @type {Directory}\n   */ this._root = root;\n}\n/**\n * Get the root directory.\n * @return {Directory} The root directory.\n */ FileSystem.prototype.getRoot = function() {\n    return this._root;\n};\n/**\n * Get a file system item.\n * @param {string} filepath Path to item.\n * @return {Item} The item (or null if not found).\n */ FileSystem.prototype.getItem = function(filepath) {\n    const parts = getPathParts(filepath);\n    const currentParts = getPathParts(process.cwd());\n    let item = this._root;\n    let itemPath = \"/\";\n    for(let i = 0, ii = parts.length; i < ii; ++i){\n        const name = parts[i];\n        while(item instanceof SymbolicLink){\n            // Symbolic link being traversed as a directory --- If link targets\n            // another symbolic link, resolve target's path relative to the original\n            // link's target, otherwise relative to the current item.\n            itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n            item = this.getItem(itemPath);\n        }\n        if (item) {\n            if (item instanceof Directory && name !== currentParts[i]) {\n                // make sure traversal is allowed\n                // This fails for Windows directories which do not have execute permission, by default. It may be a good idea\n                // to change this logic to windows-friendly. See notes in mock.createDirectoryInfoFromPaths()\n                if (!item.canExecute()) {\n                    throw new FSError(\"EACCES\", filepath);\n                }\n            }\n            if (item instanceof File) {\n                throw new FSError(\"ENOTDIR\", filepath);\n            }\n            item = item.getItem(name);\n        }\n        if (!item) {\n            break;\n        }\n        itemPath = path.resolve(itemPath, name);\n    }\n    return item;\n};\n/**\n * Populate a directory with an item.\n * @param {Directory} directory The directory to populate.\n * @param {string} name The name of the item.\n * @param {string|Buffer|function|Object} obj Instructions for creating the\n *     item.\n */ function populate(directory, name, obj) {\n    let item;\n    if (typeof obj === \"string\" || Buffer.isBuffer(obj)) {\n        // contents for a file\n        item = new File();\n        item.setContent(obj);\n    } else if (typeof obj === \"function\") {\n        // item factory\n        item = obj();\n    } else if (typeof obj === \"object\") {\n        // directory with more to populate\n        item = new Directory();\n        for(const key in obj){\n            populate(item, key, obj[key]);\n        }\n    } else {\n        throw new Error(\"Unsupported type: \" + typeof obj + \" of item \" + name);\n    }\n    /**\n   * Special exception for redundant adding of empty directories.\n   */ if (item instanceof Directory && item.list().length === 0 && directory.getItem(name) instanceof Directory) {\n    // pass\n    } else {\n        directory.addItem(name, item);\n    }\n}\n/**\n * Configure a mock file system.\n * @param {Object} paths Config object.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @return {FileSystem} Mock file system.\n */ FileSystem.create = function(paths, options) {\n    const system = new FileSystem(options);\n    for(const filepath in paths){\n        const parts = getPathParts(filepath);\n        let directory = system._root;\n        for(let i = 0, ii = parts.length - 1; i < ii; ++i){\n            const name = parts[i];\n            const candidate = directory.getItem(name);\n            if (!candidate) {\n                directory = directory.addItem(name, new Directory());\n            } else if (candidate instanceof Directory) {\n                directory = candidate;\n            } else {\n                throw new Error(\"Failed to create directory: \" + filepath);\n            }\n        }\n        populate(directory, parts[parts.length - 1], paths[filepath]);\n    }\n    return system;\n};\n/**\n * Generate a factory for new files.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new file.\n */ FileSystem.file = function(config) {\n    config = config || {};\n    return function() {\n        const file = new File();\n        if (config.hasOwnProperty(\"content\")) {\n            file.setContent(config.content);\n        }\n        if (config.hasOwnProperty(\"mode\")) {\n            file.setMode(config.mode);\n        } else {\n            file.setMode(438); // 0666\n        }\n        if (config.hasOwnProperty(\"uid\")) {\n            file.setUid(config.uid);\n        }\n        if (config.hasOwnProperty(\"gid\")) {\n            file.setGid(config.gid);\n        }\n        if (config.hasOwnProperty(\"atime\")) {\n            file.setATime(config.atime);\n        }\n        if (config.hasOwnProperty(\"ctime\")) {\n            file.setCTime(config.ctime);\n        }\n        if (config.hasOwnProperty(\"mtime\")) {\n            file.setMTime(config.mtime);\n        }\n        if (config.hasOwnProperty(\"birthtime\")) {\n            file.setBirthtime(config.birthtime);\n        }\n        return file;\n    };\n};\n/**\n * Generate a factory for new symbolic links.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new symbolic link.\n */ FileSystem.symlink = function(config) {\n    config = config || {};\n    return function() {\n        const link = new SymbolicLink();\n        if (config.hasOwnProperty(\"mode\")) {\n            link.setMode(config.mode);\n        } else {\n            link.setMode(438); // 0666\n        }\n        if (config.hasOwnProperty(\"uid\")) {\n            link.setUid(config.uid);\n        }\n        if (config.hasOwnProperty(\"gid\")) {\n            link.setGid(config.gid);\n        }\n        if (config.hasOwnProperty(\"path\")) {\n            link.setPath(config.path);\n        } else {\n            throw new Error('Missing \"path\" property');\n        }\n        if (config.hasOwnProperty(\"atime\")) {\n            link.setATime(config.atime);\n        }\n        if (config.hasOwnProperty(\"ctime\")) {\n            link.setCTime(config.ctime);\n        }\n        if (config.hasOwnProperty(\"mtime\")) {\n            link.setMTime(config.mtime);\n        }\n        if (config.hasOwnProperty(\"birthtime\")) {\n            link.setBirthtime(config.birthtime);\n        }\n        return link;\n    };\n};\n/**\n * Generate a factory for new directories.\n * @param {Object} config File config.\n * @return {function():Directory} Factory that creates a new directory.\n */ FileSystem.directory = function(config) {\n    config = config || {};\n    return function() {\n        const dir = new Directory();\n        if (config.hasOwnProperty(\"mode\")) {\n            dir.setMode(config.mode);\n        }\n        if (config.hasOwnProperty(\"uid\")) {\n            dir.setUid(config.uid);\n        }\n        if (config.hasOwnProperty(\"gid\")) {\n            dir.setGid(config.gid);\n        }\n        if (config.hasOwnProperty(\"items\")) {\n            for(const name in config.items){\n                populate(dir, name, config.items[name]);\n            }\n        }\n        if (config.hasOwnProperty(\"atime\")) {\n            dir.setATime(config.atime);\n        }\n        if (config.hasOwnProperty(\"ctime\")) {\n            dir.setCTime(config.ctime);\n        }\n        if (config.hasOwnProperty(\"mtime\")) {\n            dir.setMTime(config.mtime);\n        }\n        if (config.hasOwnProperty(\"birthtime\")) {\n            dir.setBirthtime(config.birthtime);\n        }\n        return dir;\n    };\n};\n/**\n * Module exports.\n * @type {function}\n */ exports = module.exports = FileSystem;\nexports.getPathParts = getPathParts;\nexports.toNamespacedPath = toNamespacedPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZXN5c3RlbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1NLFlBQVlDLFFBQVFDLFFBQVEsS0FBSztBQUV2QyxTQUFTQyxpQkFBaUJDLFFBQVE7SUFDaEMsT0FBT1QsS0FBS1EsZ0JBQWdCLEdBQ3hCUixLQUFLUSxnQkFBZ0IsQ0FBQ0MsWUFDdEJULEtBQUtVLFNBQVMsQ0FBQ0Q7QUFDckI7QUFFQSxTQUFTRSxhQUFhQyxRQUFRO0lBQzVCLE1BQU1DLFFBQVFMLGlCQUFpQlIsS0FBS2MsT0FBTyxDQUFDRixXQUFXRyxLQUFLLENBQUNmLEtBQUtnQixHQUFHO0lBQ3JFSCxNQUFNSSxLQUFLO0lBQ1gsSUFBSVosV0FBVztRQUNiLGtEQUFrRDtRQUNsRFEsTUFBTUksS0FBSztRQUNYLE1BQU1DLElBQUlMLE1BQU1JLEtBQUssSUFBSSxnQkFBZ0I7UUFDekMsTUFBTUUsT0FBTyxTQUFTRCxJQUFJLE9BQU9MLE1BQU1JLEtBQUssR0FBR0csV0FBVztRQUMxRFAsTUFBTVEsT0FBTyxDQUFDRjtJQUNoQjtJQUNBLElBQUlOLEtBQUssQ0FBQ0EsTUFBTVMsTUFBTSxHQUFHLEVBQUUsS0FBSyxJQUFJO1FBQ2xDVCxNQUFNVSxHQUFHO0lBQ1g7SUFDQSxPQUFPVjtBQUNUO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTVyxXQUFXQyxPQUFPO0lBQ3pCQSxVQUFVQSxXQUFXLENBQUM7SUFFdEIsTUFBTUMsWUFBWSxlQUFlRCxVQUFVQSxRQUFRQyxTQUFTLEdBQUc7SUFDL0QsTUFBTUMs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Q0FBQ0gsT0FBT0ksSUFBSTtRQUN6QjtRQUNBLElBQUlKLE9BQU9DLGNBQWMsQ0FBQyxRQUFRO1lBQ2hDOUIsSUFBSWtDLE1BQU0sQ0FBQ0wsT0FBT00sR0FBRztRQUN2QjtRQUNBLElBQUlOLE9BQU9DLGNBQWMsQ0FBQyxRQUFRO1lBQ2hDOUIsSUFBSW9DLE1BQU0sQ0FBQ1AsT0FBT1EsR0FBRztRQUN2QjtRQUNBLElBQUlSLE9BQU9DLGNBQWMsQ0FBQyxVQUFVO1lBQ2xDLElBQUssTUFBTTFCLFFBQVF5QixPQUFPb0IsS0FBSyxDQUFFO2dCQUMvQi9CLFNBQVNsQixLQUFLSSxNQUFNeUIsT0FBT29CLEtBQUssQ0FBQzdDLEtBQUs7WUFDeEM7UUFDRjtRQUNBLElBQUl5QixPQUFPQyxjQUFjLENBQUMsVUFBVTtZQUNsQzlCLElBQUlzQyxRQUFRLENBQUNULE9BQU9VLEtBQUs7UUFDM0I7UUFDQSxJQUFJVixPQUFPQyxjQUFjLENBQUMsVUFBVTtZQUNsQzlCLElBQUl3QyxRQUFRLENBQUNYLE9BQU9ZLEtBQUs7UUFDM0I7UUFDQSxJQUFJWixPQUFPQyxjQUFjLENBQUMsVUFBVTtZQUNsQzlCLElBQUkwQyxRQUFRLENBQUNiLE9BQU9jLEtBQUs7UUFDM0I7UUFDQSxJQUFJZCxPQUFPQyxjQUFjLENBQUMsY0FBYztZQUN0QzlCLElBQUk0QyxZQUFZLENBQUNmLE9BQU9nQixTQUFTO1FBQ25DO1FBQ0EsT0FBTzdDO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNEa0QsVUFBVUMsT0FBT0QsT0FBTyxHQUFHN0Q7QUFDM0I2RCxvQkFBb0IsR0FBRzFFO0FBQ3ZCMEUsd0JBQXdCLEdBQUc3RSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2ZpbGVzeXN0ZW0uanM/NTExMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IERpcmVjdG9yeSA9IHJlcXVpcmUoJy4vZGlyZWN0b3J5Jyk7XG5jb25zdCBGaWxlID0gcmVxdWlyZSgnLi9maWxlJyk7XG5jb25zdCBGU0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuY29uc3QgU3ltYm9saWNMaW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJyk7XG5cbmNvbnN0IGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5cbmZ1bmN0aW9uIHRvTmFtZXNwYWNlZFBhdGgoZmlsZVBhdGgpIHtcbiAgcmV0dXJuIHBhdGgudG9OYW1lc3BhY2VkUGF0aFxuICAgID8gcGF0aC50b05hbWVzcGFjZWRQYXRoKGZpbGVQYXRoKVxuICAgIDogcGF0aC5fbWFrZUxvbmcoZmlsZVBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoUGFydHMoZmlsZXBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSB0b05hbWVzcGFjZWRQYXRoKHBhdGgucmVzb2x2ZShmaWxlcGF0aCkpLnNwbGl0KHBhdGguc2VwKTtcbiAgcGFydHMuc2hpZnQoKTtcbiAgaWYgKGlzV2luZG93cykge1xuICAgIC8vIHBhcnRzIGN1cnJlbnRseSBsb29rcyBsaWtlIFsnJywgJz8nLCAnYzonLCAuLi5dXG4gICAgcGFydHMuc2hpZnQoKTtcbiAgICBjb25zdCBxID0gcGFydHMuc2hpZnQoKTsgLy8gc2hvdWxkIGJlICc/J1xuICAgIGNvbnN0IGJhc2UgPSAnXFxcXFxcXFwnICsgcSArICdcXFxcJyArIHBhcnRzLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICBwYXJ0cy51bnNoaWZ0KGJhc2UpO1xuICB9XG4gIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICBwYXJ0cy5wb3AoKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW55IGZpbGVzeXN0ZW0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVDd2QgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgcHJvY2Vzcy5jd2QoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVUbXAgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgb3MudG1wZGlyKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmlsZVN5c3RlbShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGNyZWF0ZUN3ZCA9ICdjcmVhdGVDd2QnIGluIG9wdGlvbnMgPyBvcHRpb25zLmNyZWF0ZUN3ZCA6IHRydWU7XG4gIGNvbnN0IGNyZWF0ZVRtcCA9ICdjcmVhdGVUbXAnIGluIG9wdGlvbnMgPyBvcHRpb25zLmNyZWF0ZVRtcCA6IHRydWU7XG5cbiAgY29uc3Qgcm9vdCA9IG5ldyBEaXJlY3RvcnkoKTtcblxuICAvLyBwb3B1bGF0ZSB3aXRoIGRlZmF1bHQgZGlyZWN0b3JpZXNcbiAgY29uc3QgZGVmYXVsdHMgPSBbXTtcbiAgaWYgKGNyZWF0ZUN3ZCkge1xuICAgIGRlZmF1bHRzLnB1c2gocHJvY2Vzcy5jd2QoKSk7XG4gIH1cblxuICBpZiAoY3JlYXRlVG1wKSB7XG4gICAgZGVmYXVsdHMucHVzaCgob3MudG1wZGlyICYmIG9zLnRtcGRpcigpKSB8fCBvcy50bXBEaXIoKSk7XG4gIH1cblxuICBkZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGRpcikge1xuICAgIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKGRpcik7XG4gICAgbGV0IGRpcmVjdG9yeSA9IHJvb3Q7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbmFtZSA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gZGlyZWN0b3J5LmdldEl0ZW0obmFtZSk7XG4gICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICBkaXJlY3RvcnkgPSBkaXJlY3RvcnkuYWRkSXRlbShuYW1lLCBuZXcgRGlyZWN0b3J5KCkpO1xuICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUgaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgZGlyZWN0b3J5ID0gY2FuZGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGRpcmVjdG9yeTogJyArIGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUm9vdCBkaXJlY3RvcnkuXG4gICAqIEB0eXBlIHtEaXJlY3Rvcnl9XG4gICAqL1xuICB0aGlzLl9yb290ID0gcm9vdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJvb3QgZGlyZWN0b3J5LlxuICogQHJldHVybiB7RGlyZWN0b3J5fSBUaGUgcm9vdCBkaXJlY3RvcnkuXG4gKi9cbkZpbGVTeXN0ZW0ucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59O1xuXG4vKipcbiAqIEdldCBhIGZpbGUgc3lzdGVtIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggUGF0aCB0byBpdGVtLlxuICogQHJldHVybiB7SXRlbX0gVGhlIGl0ZW0gKG9yIG51bGwgaWYgbm90IGZvdW5kKS5cbiAqL1xuRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XG4gIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKGZpbGVwYXRoKTtcbiAgY29uc3QgY3VycmVudFBhcnRzID0gZ2V0UGF0aFBhcnRzKHByb2Nlc3MuY3dkKCkpO1xuICBsZXQgaXRlbSA9IHRoaXMuX3Jvb3Q7XG4gIGxldCBpdGVtUGF0aCA9ICcvJztcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IG5hbWUgPSBwYXJ0c1tpXTtcbiAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgLy8gU3ltYm9saWMgbGluayBiZWluZyB0cmF2ZXJzZWQgYXMgYSBkaXJlY3RvcnkgLS0tIElmIGxpbmsgdGFyZ2V0c1xuICAgICAgLy8gYW5vdGhlciBzeW1ib2xpYyBsaW5rLCByZXNvbHZlIHRhcmdldCdzIHBhdGggcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsXG4gICAgICAvLyBsaW5rJ3MgdGFyZ2V0LCBvdGhlcndpc2UgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgaXRlbS5cbiAgICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShpdGVtUGF0aCksIGl0ZW0uZ2V0UGF0aCgpKTtcbiAgICAgIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaXRlbVBhdGgpO1xuICAgIH1cbiAgICBpZiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkgJiYgbmFtZSAhPT0gY3VycmVudFBhcnRzW2ldKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0cmF2ZXJzYWwgaXMgYWxsb3dlZFxuICAgICAgICAvLyBUaGlzIGZhaWxzIGZvciBXaW5kb3dzIGRpcmVjdG9yaWVzIHdoaWNoIGRvIG5vdCBoYXZlIGV4ZWN1dGUgcGVybWlzc2lvbiwgYnkgZGVmYXVsdC4gSXQgbWF5IGJlIGEgZ29vZCBpZGVhXG4gICAgICAgIC8vIHRvIGNoYW5nZSB0aGlzIGxvZ2ljIHRvIHdpbmRvd3MtZnJpZW5kbHkuIFNlZSBub3RlcyBpbiBtb2NrLmNyZWF0ZURpcmVjdG9yeUluZm9Gcm9tUGF0aHMoKVxuICAgICAgICBpZiAoIWl0ZW0uY2FuRXhlY3V0ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgICAgaXRlbSA9IGl0ZW0uZ2V0SXRlbShuYW1lKTtcbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUoaXRlbVBhdGgsIG5hbWUpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZSBhIGRpcmVjdG9yeSB3aXRoIGFuIGl0ZW0uXG4gKiBAcGFyYW0ge0RpcmVjdG9yeX0gZGlyZWN0b3J5IFRoZSBkaXJlY3RvcnkgdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxmdW5jdGlvbnxPYmplY3R9IG9iaiBJbnN0cnVjdGlvbnMgZm9yIGNyZWF0aW5nIHRoZVxuICogICAgIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlKGRpcmVjdG9yeSwgbmFtZSwgb2JqKSB7XG4gIGxldCBpdGVtO1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICAvLyBjb250ZW50cyBmb3IgYSBmaWxlXG4gICAgaXRlbSA9IG5ldyBGaWxlKCk7XG4gICAgaXRlbS5zZXRDb250ZW50KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGl0ZW0gZmFjdG9yeVxuICAgIGl0ZW0gPSBvYmooKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIC8vIGRpcmVjdG9yeSB3aXRoIG1vcmUgdG8gcG9wdWxhdGVcbiAgICBpdGVtID0gbmV3IERpcmVjdG9yeSgpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcG9wdWxhdGUoaXRlbSwga2V5LCBvYmpba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIHR5cGVvZiBvYmogKyAnIG9mIGl0ZW0gJyArIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpYWwgZXhjZXB0aW9uIGZvciByZWR1bmRhbnQgYWRkaW5nIG9mIGVtcHR5IGRpcmVjdG9yaWVzLlxuICAgKi9cbiAgaWYgKFxuICAgIGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkgJiZcbiAgICBpdGVtLmxpc3QoKS5sZW5ndGggPT09IDAgJiZcbiAgICBkaXJlY3RvcnkuZ2V0SXRlbShuYW1lKSBpbnN0YW5jZW9mIERpcmVjdG9yeVxuICApIHtcbiAgICAvLyBwYXNzXG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0b3J5LmFkZEl0ZW0obmFtZSwgaXRlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25maWd1cmUgYSBtb2NrIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IHBhdGhzIENvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbnkgZmlsZXN5c3RlbSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZUN3ZCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBwcm9jZXNzLmN3ZCgpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZVRtcCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBvcy50bXBkaXIoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEByZXR1cm4ge0ZpbGVTeXN0ZW19IE1vY2sgZmlsZSBzeXN0ZW0uXG4gKi9cbkZpbGVTeXN0ZW0uY3JlYXRlID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3lzdGVtID0gbmV3IEZpbGVTeXN0ZW0ob3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBmaWxlcGF0aCBpbiBwYXRocykge1xuICAgIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKGZpbGVwYXRoKTtcbiAgICBsZXQgZGlyZWN0b3J5ID0gc3lzdGVtLl9yb290O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGFydHNbaV07XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBkaXJlY3RvcnkuZ2V0SXRlbShuYW1lKTtcbiAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIGRpcmVjdG9yeSA9IGRpcmVjdG9yeS5hZGRJdGVtKG5hbWUsIG5ldyBEaXJlY3RvcnkoKSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICBkaXJlY3RvcnkgPSBjYW5kaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgZGlyZWN0b3J5OiAnICsgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3B1bGF0ZShkaXJlY3RvcnksIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLCBwYXRoc1tmaWxlcGF0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHN5c3RlbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWN0b3J5IGZvciBuZXcgZmlsZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEZpbGUgY29uZmlnLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKTpGaWxlfSBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBmaWxlLlxuICovXG5GaWxlU3lzdGVtLmZpbGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKCk7XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnY29udGVudCcpKSB7XG4gICAgICBmaWxlLnNldENvbnRlbnQoY29uZmlnLmNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGZpbGUuc2V0TW9kZShjb25maWcubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3VpZCcpKSB7XG4gICAgICBmaWxlLnNldFVpZChjb25maWcudWlkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnZ2lkJykpIHtcbiAgICAgIGZpbGUuc2V0R2lkKGNvbmZpZy5naWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdhdGltZScpKSB7XG4gICAgICBmaWxlLnNldEFUaW1lKGNvbmZpZy5hdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2N0aW1lJykpIHtcbiAgICAgIGZpbGUuc2V0Q1RpbWUoY29uZmlnLmN0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbXRpbWUnKSkge1xuICAgICAgZmlsZS5zZXRNVGltZShjb25maWcubXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdiaXJ0aHRpbWUnKSkge1xuICAgICAgZmlsZS5zZXRCaXJ0aHRpbWUoY29uZmlnLmJpcnRodGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZhY3RvcnkgZm9yIG5ldyBzeW1ib2xpYyBsaW5rcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgRmlsZSBjb25maWcuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpOkZpbGV9IEZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgbmV3IHN5bWJvbGljIGxpbmsuXG4gKi9cbkZpbGVTeXN0ZW0uc3ltbGluayA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBsaW5rID0gbmV3IFN5bWJvbGljTGluaygpO1xuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ21vZGUnKSkge1xuICAgICAgbGluay5zZXRNb2RlKGNvbmZpZy5tb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluay5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndWlkJykpIHtcbiAgICAgIGxpbmsuc2V0VWlkKGNvbmZpZy51aWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdnaWQnKSkge1xuICAgICAgbGluay5zZXRHaWQoY29uZmlnLmdpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgbGluay5zZXRQYXRoKGNvbmZpZy5wYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwicGF0aFwiIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2F0aW1lJykpIHtcbiAgICAgIGxpbmsuc2V0QVRpbWUoY29uZmlnLmF0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnY3RpbWUnKSkge1xuICAgICAgbGluay5zZXRDVGltZShjb25maWcuY3RpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBsaW5rLnNldE1UaW1lKGNvbmZpZy5tdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2JpcnRodGltZScpKSB7XG4gICAgICBsaW5rLnNldEJpcnRodGltZShjb25maWcuYmlydGh0aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmFjdG9yeSBmb3IgbmV3IGRpcmVjdG9yaWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBGaWxlIGNvbmZpZy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6RGlyZWN0b3J5fSBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBkaXJlY3RvcnkuXG4gKi9cbkZpbGVTeXN0ZW0uZGlyZWN0b3J5ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRpciA9IG5ldyBEaXJlY3RvcnkoKTtcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGRpci5zZXRNb2RlKGNvbmZpZy5tb2RlKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndWlkJykpIHtcbiAgICAgIGRpci5zZXRVaWQoY29uZmlnLnVpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2dpZCcpKSB7XG4gICAgICBkaXIuc2V0R2lkKGNvbmZpZy5naWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdpdGVtcycpKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY29uZmlnLml0ZW1zKSB7XG4gICAgICAgIHBvcHVsYXRlKGRpciwgbmFtZSwgY29uZmlnLml0ZW1zW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYXRpbWUnKSkge1xuICAgICAgZGlyLnNldEFUaW1lKGNvbmZpZy5hdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2N0aW1lJykpIHtcbiAgICAgIGRpci5zZXRDVGltZShjb25maWcuY3RpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBkaXIuc2V0TVRpbWUoY29uZmlnLm10aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYmlydGh0aW1lJykpIHtcbiAgICAgIGRpci5zZXRCaXJ0aHRpbWUoY29uZmlnLmJpcnRodGltZSk7XG4gICAgfVxuICAgIHJldHVybiBkaXI7XG4gIH07XG59O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWxlU3lzdGVtO1xuZXhwb3J0cy5nZXRQYXRoUGFydHMgPSBnZXRQYXRoUGFydHM7XG5leHBvcnRzLnRvTmFtZXNwYWNlZFBhdGggPSB0b05hbWVzcGFjZWRQYXRoO1xuIl0sIm5hbWVzIjpbIm9zIiwicmVxdWlyZSIsInBhdGgiLCJEaXJlY3RvcnkiLCJGaWxlIiwiRlNFcnJvciIsIlN5bWJvbGljTGluayIsImlzV2luZG93cyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInRvTmFtZXNwYWNlZFBhdGgiLCJmaWxlUGF0aCIsIl9tYWtlTG9uZyIsImdldFBhdGhQYXJ0cyIsImZpbGVwYXRoIiwicGFydHMiLCJyZXNvbHZlIiwic3BsaXQiLCJzZXAiLCJzaGlmdCIsInEiLCJiYXNlIiwidG9Mb3dlckNhc2UiLCJ1bnNoaWZ0IiwibGVuZ3RoIiwicG9wIiwiRmlsZVN5c3RlbSIsIm9wdGlvbnMiLCJjcmVhdGVDd2QiLCJjcmVhdGVUbXAiLCJyb290IiwiZGVmYXVsdHMiLCJwdXNoIiwiY3dkIiwidG1wZGlyIiwidG1wRGlyIiwiZm9yRWFjaCIsImRpciIsImRpcmVjdG9yeSIsImkiLCJpaSIsIm5hbWUiLCJjYW5kaWRhdGUiLCJnZXRJdGVtIiwiYWRkSXRlbSIsIkVycm9yIiwiX3Jvb3QiLCJwcm90b3R5cGUiLCJnZXRSb290IiwiY3VycmVudFBhcnRzIiwiaXRlbSIsIml0ZW1QYXRoIiwiZGlybmFtZSIsImdldFBhdGgiLCJjYW5FeGVjdXRlIiwicG9wdWxhdGUiLCJvYmoiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInNldENvbnRlbnQiLCJrZXkiLCJsaXN0IiwiY3JlYXRlIiwicGF0aHMiLCJzeXN0ZW0iLCJmaWxlIiwiY29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJjb250ZW50Iiwic2V0TW9kZSIsIm1vZGUiLCJzZXRVaWQiLCJ1aWQiLCJzZXRHaWQiLCJnaWQiLCJzZXRBVGltZSIsImF0aW1lIiwic2V0Q1RpbWUiLCJjdGltZSIsInNldE1UaW1lIiwibXRpbWUiLCJzZXRCaXJ0aHRpbWUiLCJiaXJ0aHRpbWUiLCJzeW1saW5rIiwibGluayIsInNldFBhdGgiLCJpdGVtcyIsImV4cG9ydHMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/filesystem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/mock-fs/lib/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst Binding = __webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/mock-fs/lib/binding.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\");\nconst realBinding = process.binding(\"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst loader = __webpack_require__(/*! ./loader */ \"(ssr)/./node_modules/mock-fs/lib/loader.js\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(ssr)/./node_modules/mock-fs/lib/bypass.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst toNamespacedPath = FileSystem.toNamespacedPath;\nconst realProcessProps = {\n    cwd: process.cwd,\n    chdir: process.chdir\n};\nconst realCreateWriteStream = fs.createWriteStream;\nconst realStats = realBinding.Stats;\nconst realStatWatcher = realBinding.StatWatcher;\n/**\n * Pre-patch fs binding.\n * This allows mock-fs to work properly under nodejs v10+ readFile\n * As ReadFileContext nodejs v10+ implementation traps original binding methods:\n * const { FSReqWrap, close, read } = process.binding('fs');\n * Note this patch only solves issue for readFile, as the require of\n * ReadFileContext is delayed by readFile implementation.\n * if (!ReadFileContext) ReadFileContext = require('internal/fs/read_file_context')\n *\n * @param {string} key Property name.\n */ function patch(key) {\n    const existingMethod = realBinding[key];\n    realBinding[key] = (function() {\n        if (this._mockedBinding) {\n            return this._mockedBinding[key].apply(this._mockedBinding, arguments);\n        } else {\n            return existingMethod.apply(this, arguments);\n        }\n    }).bind(realBinding);\n}\nfor(const key in Binding.prototype){\n    if (typeof realBinding[key] === \"function\") {\n        // Stats and StatWatcher are constructors\n        if (key !== \"Stats\" && key !== \"StatWatcher\") {\n            patch(key);\n        }\n    }\n}\nfunction overrideBinding(binding) {\n    realBinding._mockedBinding = binding;\n}\nfunction overrideProcess(cwd, chdir) {\n    process.cwd = cwd;\n    process.chdir = chdir;\n}\n/**\n * Have to disable write stream _writev on nodejs v10+.\n *\n * nodejs v8 lib/fs.js\n * note binding.writeBuffers will use mock-fs patched writeBuffers.\n *\n *   const binding = process.binding('fs');\n *   function writev(fd, chunks, position, callback) {\n *     // ...\n *     binding.writeBuffers(fd, chunks, position, req);\n *   }\n *\n * nodejs v10+ lib/internal/fs/streams.js\n * note it uses original writeBuffers, bypassed mock-fs patched writeBuffers.\n *\n *  const {writeBuffers} = internalBinding('fs');\n *  function writev(fd, chunks, position, callback) {\n *    // ...\n *    writeBuffers(fd, chunks, position, req);\n *  }\n *\n * Luckily _writev is an optional method on Writeable stream implementation.\n * When _writev is missing, it will fall back to make multiple _write calls.\n */ function overrideCreateWriteStream() {\n    fs.createWriteStream = function(path, options) {\n        const output = realCreateWriteStream(path, options);\n        // disable _writev, this will over shadow WriteStream.prototype._writev\n        if (realBinding._mockedBinding) {\n            output._writev = undefined;\n        }\n        return output;\n    };\n}\nfunction restoreBinding() {\n    delete realBinding._mockedBinding;\n    realBinding.Stats = realStats;\n    realBinding.StatWatcher = realStatWatcher;\n}\nfunction restoreProcess() {\n    for(const key in realProcessProps){\n        process[key] = realProcessProps[key];\n    }\n}\nfunction restoreCreateWriteStream() {\n    fs.createWriteStream = realCreateWriteStream;\n}\n/**\n * Swap out the fs bindings for a mock file system.\n * @param {Object} config Mock file system configuration.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n */ exports = module.exports = function mock(config, options) {\n    const system = FileSystem.create(config, options);\n    const binding = new Binding(system);\n    overrideBinding(binding);\n    let currentPath = process.cwd();\n    overrideProcess(function cwd() {\n        if (realBinding._mockedBinding) {\n            return currentPath;\n        }\n        return realProcessProps.cwd();\n    }, function chdir(directory) {\n        if (realBinding._mockedBinding) {\n            if (!binding.stat(toNamespacedPath(directory)).isDirectory()) {\n                throw new FSError(\"ENOTDIR\");\n            }\n            currentPath = path.resolve(currentPath, directory);\n        } else {\n            return realProcessProps.chdir(directory);\n        }\n    });\n    overrideCreateWriteStream();\n};\n/**\n * Get hold of the mocked filesystem's 'root'\n * If fs hasn't currently been replaced, this will return an empty object\n */ exports.getMockRoot = function() {\n    if (realBinding._mockedBinding) {\n        return realBinding._mockedBinding.getSystem().getRoot();\n    } else {\n        return {};\n    }\n};\n/**\n * Restore the fs bindings for the real file system.\n */ exports.restore = function() {\n    restoreBinding();\n    restoreProcess();\n    restoreCreateWriteStream();\n};\n/**\n * Create a file factory.\n */ exports.file = FileSystem.file;\n/**\n * Create a directory factory.\n */ exports.directory = FileSystem.directory;\n/**\n * Create a symbolic link factory.\n */ exports.symlink = FileSystem.symlink;\n/**\n * Automatically maps specified paths (for use with `mock()`)\n */ exports.load = loader.load;\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */ exports.bypass = bypass;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNRyxjQUFjQyxRQUFRQyxPQUFPLENBQUM7QUFDcEMsTUFBTUMsT0FBT04sbUJBQU9BLENBQUM7QUFDckIsTUFBTU8sU0FBU1AsbUJBQU9BLENBQUM7QUFDdkIsTUFBTVEsU0FBU1IsbUJBQU9BLENBQUM7QUFDdkIsTUFBTVMsS0FBS1QsbUJBQU9BLENBQUM7QUFFbkIsTUFBTVUsbUJBQW1CUixXQUFXUSxnQkFBZ0I7QUFFcEQsTUFBTUMsbUJBQW1CO0lBQ3ZCQyxLQUFLUixRQUFRUSxHQUFHO0lBQ2hCQyxPQUFPVCxRQUFRUyxLQUFLO0FBQ3RCO0FBQ0EsTUFBTUMsd0JBQXdCTCxHQUFHTSxpQkFBaUI7QUFDbEQsTUFBTUMsWUFBWWIsWUFBWWMsS0FBSztBQUNuQyxNQUFNQyxrQkFBa0JmLFlBQVlnQixXQUFXO0FBRS9DOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTQyxNQUFNQyxHQUFHO0lBQ2hCLE1BQU1DLGlCQUFpQm5CLFdBQVcsQ0FBQ2tCLElBQUk7SUFDdkNsQixXQUFXLENBQUNrQixJQUFJLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNFLGNBQWMsRUFBRTtZQUN2QixPQUFPLElBQUksQ0FBQ0EsY0FBYyxDQUFDRixJQUFJLENBQUNHLEtBQUssQ0FBQyxJQUFJLENBQUNELGNBQWMsRUFBRUU7UUFDN0QsT0FBTztZQUNMLE9BQU9ILGVBQWVFLEtBQUssQ0FBQyxJQUFJLEVBQUVDO1FBQ3BDO0lBQ0YsR0FBRUMsSUFBSSxDQUFDdkI7QUFDVDtBQUVBLElBQUssTUFBTWtCLE9BQU90QixRQUFRNEIsU0FBUyxDQUFFO0lBQ25DLElBQUksT0FBT3hCLFdBQVcsQ0FBQ2tCLElBQUksS0FBSyxZQUFZO1FBQzFDLHlDQUF5QztRQUN6QyxJQUFJQSxRQUFRLFdBQVdBLFFBQVEsZUFBZTtZQUM1Q0QsTUFBTUM7UUFDUjtJQUNGO0FBQ0Y7QUFFQSxTQUFTTyxnQkFBZ0J2QixPQUFPO0lBQzlCRixZQUFZb0IsY0FBYyxHQUFHbEI7QUFDL0I7QUFFQSxTQUFTd0IsZ0JBQWdCakIsR0FBRyxFQUFFQyxLQUFLO0lBQ2pDVCxRQUFRUSxHQUFHLEdBQUdBO0lBQ2RSLFFBQVFTLEtBQUssR0FBR0E7QUFDbEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTaUI7SUFDUHJCLEdBQUdNLGlCQUFpQixHQUFHLFNBQVNULElBQUksRUFBRXlCLE9BQU87UUFDM0MsTUFBTUMsU0FBU2xCLHNCQUFzQlIsTUFBTXlCO1FBQzNDLHVFQUF1RTtRQUN2RSxJQUFJNUIsWUFBWW9CLGNBQWMsRUFBRTtZQUM5QlMsT0FBT0MsT0FBTyxHQUFHQztRQUNuQjtRQUNBLE9BQU9GO0lBQ1Q7QUFDRjtBQUVBLFNBQVNHO0lBQ1AsT0FBT2hDLFlBQVlvQixjQUFjO0lBQ2pDcEIsWUFBWWMsS0FBSyxHQUFHRDtJQUNwQmIsWUFBWWdCLFdBQVcsR0FBR0Q7QUFDNUI7QUFFQSxTQUFTa0I7SUFDUCxJQUFLLE1BQU1mLE9BQU9WLGlCQUFrQjtRQUNsQ1AsT0FBTyxDQUFDaUIsSUFBSSxHQUFHVixnQkFBZ0IsQ0FBQ1UsSUFBSTtJQUN0QztBQUNGO0FBRUEsU0FBU2dCO0lBQ1A1QixHQUFHTSxpQkFBaUIsR0FBR0Q7QUFDekI7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEd0IsVUFBVUMsT0FBT0QsT0FBTyxHQUFHLFNBQVNFLEtBQUtDLE1BQU0sRUFBRVYsT0FBTztJQUN0RCxNQUFNVyxTQUFTeEMsV0FBV3lDLE1BQU0sQ0FBQ0YsUUFBUVY7SUFDekMsTUFBTTFCLFVBQVUsSUFBSU4sUUFBUTJDO0lBRTVCZCxnQkFBZ0J2QjtJQUVoQixJQUFJdUMsY0FBY3hDLFFBQVFRLEdBQUc7SUFDN0JpQixnQkFDRSxTQUFTakI7UUFDUCxJQUFJVCxZQUFZb0IsY0FBYyxFQUFFO1lBQzlCLE9BQU9xQjtRQUNUO1FBQ0EsT0FBT2pDLGlCQUFpQkMsR0FBRztJQUM3QixHQUNBLFNBQVNDLE1BQU1nQyxTQUFTO1FBQ3RCLElBQUkxQyxZQUFZb0IsY0FBYyxFQUFFO1lBQzlCLElBQUksQ0FBQ2xCLFFBQVF5QyxJQUFJLENBQUNwQyxpQkFBaUJtQyxZQUFZRSxXQUFXLElBQUk7Z0JBQzVELE1BQU0sSUFBSTlDLFFBQVE7WUFDcEI7WUFDQTJDLGNBQWN0QyxLQUFLMEMsT0FBTyxDQUFDSixhQUFhQztRQUMxQyxPQUFPO1lBQ0wsT0FBT2xDLGlCQUFpQkUsS0FBSyxDQUFDZ0M7UUFDaEM7SUFDRjtJQUdGZjtBQUNGO0FBRUE7OztDQUdDLEdBQ0RRLG1CQUFtQixHQUFHO0lBQ3BCLElBQUluQyxZQUFZb0IsY0FBYyxFQUFFO1FBQzlCLE9BQU9wQixZQUFZb0IsY0FBYyxDQUFDMkIsU0FBUyxHQUFHQyxPQUFPO0lBQ3ZELE9BQU87UUFDTCxPQUFPLENBQUM7SUFDVjtBQUNGO0FBRUE7O0NBRUMsR0FDRGIsZUFBZSxHQUFHO0lBQ2hCSDtJQUNBQztJQUNBQztBQUNGO0FBRUE7O0NBRUMsR0FDREMsWUFBWSxHQUFHcEMsV0FBV21ELElBQUk7QUFFOUI7O0NBRUMsR0FDRGYsaUJBQWlCLEdBQUdwQyxXQUFXMkMsU0FBUztBQUV4Qzs7Q0FFQyxHQUNEUCxlQUFlLEdBQUdwQyxXQUFXb0QsT0FBTztBQUVwQzs7Q0FFQyxHQUNEaEIsWUFBWSxHQUFHL0IsT0FBT2dELElBQUk7QUFFMUI7Ozs7OztDQU1DLEdBQ0RqQixjQUFjLEdBQUc5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2luZGV4LmpzP2VkMDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG5jb25zdCBGU0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuY29uc3QgRmlsZVN5c3RlbSA9IHJlcXVpcmUoJy4vZmlsZXN5c3RlbScpO1xuY29uc3QgcmVhbEJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgbG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKTtcbmNvbnN0IGJ5cGFzcyA9IHJlcXVpcmUoJy4vYnlwYXNzJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNvbnN0IHRvTmFtZXNwYWNlZFBhdGggPSBGaWxlU3lzdGVtLnRvTmFtZXNwYWNlZFBhdGg7XG5cbmNvbnN0IHJlYWxQcm9jZXNzUHJvcHMgPSB7XG4gIGN3ZDogcHJvY2Vzcy5jd2QsXG4gIGNoZGlyOiBwcm9jZXNzLmNoZGlyXG59O1xuY29uc3QgcmVhbENyZWF0ZVdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW07XG5jb25zdCByZWFsU3RhdHMgPSByZWFsQmluZGluZy5TdGF0cztcbmNvbnN0IHJlYWxTdGF0V2F0Y2hlciA9IHJlYWxCaW5kaW5nLlN0YXRXYXRjaGVyO1xuXG4vKipcbiAqIFByZS1wYXRjaCBmcyBiaW5kaW5nLlxuICogVGhpcyBhbGxvd3MgbW9jay1mcyB0byB3b3JrIHByb3Blcmx5IHVuZGVyIG5vZGVqcyB2MTArIHJlYWRGaWxlXG4gKiBBcyBSZWFkRmlsZUNvbnRleHQgbm9kZWpzIHYxMCsgaW1wbGVtZW50YXRpb24gdHJhcHMgb3JpZ2luYWwgYmluZGluZyBtZXRob2RzOlxuICogY29uc3QgeyBGU1JlcVdyYXAsIGNsb3NlLCByZWFkIH0gPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG4gKiBOb3RlIHRoaXMgcGF0Y2ggb25seSBzb2x2ZXMgaXNzdWUgZm9yIHJlYWRGaWxlLCBhcyB0aGUgcmVxdWlyZSBvZlxuICogUmVhZEZpbGVDb250ZXh0IGlzIGRlbGF5ZWQgYnkgcmVhZEZpbGUgaW1wbGVtZW50YXRpb24uXG4gKiBpZiAoIVJlYWRGaWxlQ29udGV4dCkgUmVhZEZpbGVDb250ZXh0ID0gcmVxdWlyZSgnaW50ZXJuYWwvZnMvcmVhZF9maWxlX2NvbnRleHQnKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcGF0Y2goa2V5KSB7XG4gIGNvbnN0IGV4aXN0aW5nTWV0aG9kID0gcmVhbEJpbmRpbmdba2V5XTtcbiAgcmVhbEJpbmRpbmdba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9ja2VkQmluZGluZ1trZXldLmFwcGx5KHRoaXMuX21vY2tlZEJpbmRpbmcsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleGlzdGluZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfS5iaW5kKHJlYWxCaW5kaW5nKTtcbn1cblxuZm9yIChjb25zdCBrZXkgaW4gQmluZGluZy5wcm90b3R5cGUpIHtcbiAgaWYgKHR5cGVvZiByZWFsQmluZGluZ1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gU3RhdHMgYW5kIFN0YXRXYXRjaGVyIGFyZSBjb25zdHJ1Y3RvcnNcbiAgICBpZiAoa2V5ICE9PSAnU3RhdHMnICYmIGtleSAhPT0gJ1N0YXRXYXRjaGVyJykge1xuICAgICAgcGF0Y2goa2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVCaW5kaW5nKGJpbmRpbmcpIHtcbiAgcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcgPSBiaW5kaW5nO1xufVxuXG5mdW5jdGlvbiBvdmVycmlkZVByb2Nlc3MoY3dkLCBjaGRpcikge1xuICBwcm9jZXNzLmN3ZCA9IGN3ZDtcbiAgcHJvY2Vzcy5jaGRpciA9IGNoZGlyO1xufVxuXG4vKipcbiAqIEhhdmUgdG8gZGlzYWJsZSB3cml0ZSBzdHJlYW0gX3dyaXRldiBvbiBub2RlanMgdjEwKy5cbiAqXG4gKiBub2RlanMgdjggbGliL2ZzLmpzXG4gKiBub3RlIGJpbmRpbmcud3JpdGVCdWZmZXJzIHdpbGwgdXNlIG1vY2stZnMgcGF0Y2hlZCB3cml0ZUJ1ZmZlcnMuXG4gKlxuICogICBjb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpO1xuICogICBmdW5jdGlvbiB3cml0ZXYoZmQsIGNodW5rcywgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gLi4uXG4gKiAgICAgYmluZGluZy53cml0ZUJ1ZmZlcnMoZmQsIGNodW5rcywgcG9zaXRpb24sIHJlcSk7XG4gKiAgIH1cbiAqXG4gKiBub2RlanMgdjEwKyBsaWIvaW50ZXJuYWwvZnMvc3RyZWFtcy5qc1xuICogbm90ZSBpdCB1c2VzIG9yaWdpbmFsIHdyaXRlQnVmZmVycywgYnlwYXNzZWQgbW9jay1mcyBwYXRjaGVkIHdyaXRlQnVmZmVycy5cbiAqXG4gKiAgY29uc3Qge3dyaXRlQnVmZmVyc30gPSBpbnRlcm5hbEJpbmRpbmcoJ2ZzJyk7XG4gKiAgZnVuY3Rpb24gd3JpdGV2KGZkLCBjaHVua3MsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICogICAgLy8gLi4uXG4gKiAgICB3cml0ZUJ1ZmZlcnMoZmQsIGNodW5rcywgcG9zaXRpb24sIHJlcSk7XG4gKiAgfVxuICpcbiAqIEx1Y2tpbHkgX3dyaXRldiBpcyBhbiBvcHRpb25hbCBtZXRob2Qgb24gV3JpdGVhYmxlIHN0cmVhbSBpbXBsZW1lbnRhdGlvbi5cbiAqIFdoZW4gX3dyaXRldiBpcyBtaXNzaW5nLCBpdCB3aWxsIGZhbGwgYmFjayB0byBtYWtlIG11bHRpcGxlIF93cml0ZSBjYWxscy5cbiAqL1xuZnVuY3Rpb24gb3ZlcnJpZGVDcmVhdGVXcml0ZVN0cmVhbSgpIHtcbiAgZnMuY3JlYXRlV3JpdGVTdHJlYW0gPSBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gcmVhbENyZWF0ZVdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuICAgIC8vIGRpc2FibGUgX3dyaXRldiwgdGhpcyB3aWxsIG92ZXIgc2hhZG93IFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGV2XG4gICAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgICBvdXRwdXQuX3dyaXRldiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZUJpbmRpbmcoKSB7XG4gIGRlbGV0ZSByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZztcbiAgcmVhbEJpbmRpbmcuU3RhdHMgPSByZWFsU3RhdHM7XG4gIHJlYWxCaW5kaW5nLlN0YXRXYXRjaGVyID0gcmVhbFN0YXRXYXRjaGVyO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUHJvY2VzcygpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmVhbFByb2Nlc3NQcm9wcykge1xuICAgIHByb2Nlc3Nba2V5XSA9IHJlYWxQcm9jZXNzUHJvcHNba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ3JlYXRlV3JpdGVTdHJlYW0oKSB7XG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gcmVhbENyZWF0ZVdyaXRlU3RyZWFtO1xufVxuXG4vKipcbiAqIFN3YXAgb3V0IHRoZSBmcyBiaW5kaW5ncyBmb3IgYSBtb2NrIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBNb2NrIGZpbGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbnkgZmlsZXN5c3RlbSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZUN3ZCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBwcm9jZXNzLmN3ZCgpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZVRtcCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBvcy50bXBkaXIoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9jayhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3lzdGVtID0gRmlsZVN5c3RlbS5jcmVhdGUoY29uZmlnLCBvcHRpb25zKTtcbiAgY29uc3QgYmluZGluZyA9IG5ldyBCaW5kaW5nKHN5c3RlbSk7XG5cbiAgb3ZlcnJpZGVCaW5kaW5nKGJpbmRpbmcpO1xuXG4gIGxldCBjdXJyZW50UGF0aCA9IHByb2Nlc3MuY3dkKCk7XG4gIG92ZXJyaWRlUHJvY2VzcyhcbiAgICBmdW5jdGlvbiBjd2QoKSB7XG4gICAgICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlYWxQcm9jZXNzUHJvcHMuY3dkKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjaGRpcihkaXJlY3RvcnkpIHtcbiAgICAgIGlmIChyZWFsQmluZGluZy5fbW9ja2VkQmluZGluZykge1xuICAgICAgICBpZiAoIWJpbmRpbmcuc3RhdCh0b05hbWVzcGFjZWRQYXRoKGRpcmVjdG9yeSkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXRoID0gcGF0aC5yZXNvbHZlKGN1cnJlbnRQYXRoLCBkaXJlY3RvcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlYWxQcm9jZXNzUHJvcHMuY2hkaXIoZGlyZWN0b3J5KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgb3ZlcnJpZGVDcmVhdGVXcml0ZVN0cmVhbSgpO1xufTtcblxuLyoqXG4gKiBHZXQgaG9sZCBvZiB0aGUgbW9ja2VkIGZpbGVzeXN0ZW0ncyAncm9vdCdcbiAqIElmIGZzIGhhc24ndCBjdXJyZW50bHkgYmVlbiByZXBsYWNlZCwgdGhpcyB3aWxsIHJldHVybiBhbiBlbXB0eSBvYmplY3RcbiAqL1xuZXhwb3J0cy5nZXRNb2NrUm9vdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICByZXR1cm4gcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcuZ2V0U3lzdGVtKCkuZ2V0Um9vdCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN0b3JlIHRoZSBmcyBiaW5kaW5ncyBmb3IgdGhlIHJlYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbmV4cG9ydHMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICByZXN0b3JlQmluZGluZygpO1xuICByZXN0b3JlUHJvY2VzcygpO1xuICByZXN0b3JlQ3JlYXRlV3JpdGVTdHJlYW0oKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgZmlsZSBmYWN0b3J5LlxuICovXG5leHBvcnRzLmZpbGUgPSBGaWxlU3lzdGVtLmZpbGU7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGlyZWN0b3J5IGZhY3RvcnkuXG4gKi9cbmV4cG9ydHMuZGlyZWN0b3J5ID0gRmlsZVN5c3RlbS5kaXJlY3Rvcnk7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3ltYm9saWMgbGluayBmYWN0b3J5LlxuICovXG5leHBvcnRzLnN5bWxpbmsgPSBGaWxlU3lzdGVtLnN5bWxpbms7XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBtYXBzIHNwZWNpZmllZCBwYXRocyAoZm9yIHVzZSB3aXRoIGBtb2NrKClgKVxuICovXG5leHBvcnRzLmxvYWQgPSBsb2FkZXIubG9hZDtcblxuLyoqXG4gKiBQZXJmb3JtIGFjdGlvbiwgYnlwYXNzaW5nIG1vY2sgRlNcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGlzIGZpbGUgZXhpc3RzIG9uIHRoZSByZWFsIEZTLCBub3Qgb24gdGhlIG1vY2tlZCBGU1xuICogY29uc3QgZmlsZVBhdGggPSAnL3BhdGgvZmlsZS5qc29uJztcbiAqIGNvbnN0IGRhdGEgPSBtb2NrLmJ5cGFzcygoKSA9PiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGYtOCcpKTtcbiAqL1xuZXhwb3J0cy5ieXBhc3MgPSBieXBhc3M7XG4iXSwibmFtZXMiOlsiQmluZGluZyIsInJlcXVpcmUiLCJGU0Vycm9yIiwiRmlsZVN5c3RlbSIsInJlYWxCaW5kaW5nIiwicHJvY2VzcyIsImJpbmRpbmciLCJwYXRoIiwibG9hZGVyIiwiYnlwYXNzIiwiZnMiLCJ0b05hbWVzcGFjZWRQYXRoIiwicmVhbFByb2Nlc3NQcm9wcyIsImN3ZCIsImNoZGlyIiwicmVhbENyZWF0ZVdyaXRlU3RyZWFtIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJyZWFsU3RhdHMiLCJTdGF0cyIsInJlYWxTdGF0V2F0Y2hlciIsIlN0YXRXYXRjaGVyIiwicGF0Y2giLCJrZXkiLCJleGlzdGluZ01ldGhvZCIsIl9tb2NrZWRCaW5kaW5nIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJiaW5kIiwicHJvdG90eXBlIiwib3ZlcnJpZGVCaW5kaW5nIiwib3ZlcnJpZGVQcm9jZXNzIiwib3ZlcnJpZGVDcmVhdGVXcml0ZVN0cmVhbSIsIm9wdGlvbnMiLCJvdXRwdXQiLCJfd3JpdGV2IiwidW5kZWZpbmVkIiwicmVzdG9yZUJpbmRpbmciLCJyZXN0b3JlUHJvY2VzcyIsInJlc3RvcmVDcmVhdGVXcml0ZVN0cmVhbSIsImV4cG9ydHMiLCJtb2R1bGUiLCJtb2NrIiwiY29uZmlnIiwic3lzdGVtIiwiY3JlYXRlIiwiY3VycmVudFBhdGgiLCJkaXJlY3RvcnkiLCJzdGF0IiwiaXNEaXJlY3RvcnkiLCJyZXNvbHZlIiwiZ2V0TW9ja1Jvb3QiLCJnZXRTeXN0ZW0iLCJnZXRSb290IiwicmVzdG9yZSIsImZpbGUiLCJzeW1saW5rIiwibG9hZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/item.js":
/*!******************************************!*\
  !*** ./node_modules/mock-fs/lib/item.js ***!
  \******************************************/
/***/ ((module, exports) => {

"use strict";
eval("\nlet counter = 0;\n/**\n * Permissions.\n * @enum {number}\n */ const permissions = {\n    USER_READ: 256,\n    USER_WRITE: 128,\n    USER_EXEC: 64,\n    GROUP_READ: 32,\n    GROUP_WRITE: 16,\n    GROUP_EXEC: 8,\n    OTHER_READ: 4,\n    OTHER_WRITE: 2,\n    OTHER_EXEC: 1 // 0001\n};\nfunction getUid() {\n    // force NaN on windows.\n    return process.getuid ? process.getuid() : NaN;\n}\nfunction getGid() {\n    // force NaN on windows.\n    return process.getgid ? process.getgid() : NaN;\n}\n/**\n * A filesystem item.\n * @constructor\n */ function Item() {\n    const now = Date.now();\n    /**\n   * Access time.\n   * @type {Date}\n   */ this._atime = new Date(now);\n    /**\n   * Change time.\n   * @type {Date}\n   */ this._ctime = new Date(now);\n    /**\n   * Birth time.\n   * @type {Date}\n   */ this._birthtime = new Date(now);\n    /**\n   * Modification time.\n   * @type {Date}\n   */ this._mtime = new Date(now);\n    /**\n   * Permissions.\n   */ this._mode = 438; // 0666\n    /**\n   * User id.\n   * @type {number}\n   */ this._uid = getUid();\n    /**\n   * Group id.\n   * @type {number}\n   */ this._gid = getGid();\n    /**\n   * Item number.\n   * @type {number}\n   */ this._id = ++counter;\n    /**\n   * Number of links to this item.\n   */ this.links = 0;\n}\n/**\n * Add execute if read allowed\n * See notes in index.js -> mapping#addDir\n */ Item.fixWin32Permissions = (mode)=>process.platform !== \"win32\" ? mode : mode | (mode & permissions.USER_READ && permissions.USER_EXEC) | (mode & permissions.GROUP_READ && permissions.GROUP_EXEC) | (mode & permissions.OTHER_READ && permissions.OTHER_EXEC);\n/**\n * Determine if the current user has read permission.\n * @return {boolean} The current user can read.\n */ Item.prototype.canRead = function() {\n    const uid = getUid();\n    const gid = getGid();\n    let can = false;\n    if (uid === 0) {\n        can = true;\n    } else if (uid === this._uid || uid !== uid) {\n        // (uid !== uid) means uid is NaN, only for windows\n        can = (permissions.USER_READ & this._mode) === permissions.USER_READ;\n    } else if (gid === this._gid) {\n        can = (permissions.GROUP_READ & this._mode) === permissions.GROUP_READ;\n    } else {\n        can = (permissions.OTHER_READ & this._mode) === permissions.OTHER_READ;\n    }\n    return can;\n};\n/**\n * Determine if the current user has write permission.\n * @return {boolean} The current user can write.\n */ Item.prototype.canWrite = function() {\n    const uid = getUid();\n    const gid = getGid();\n    let can = false;\n    if (uid === 0) {\n        can = true;\n    } else if (uid === this._uid || uid !== uid) {\n        // (uid !== uid) means uid is NaN, only for windows\n        can = (permissions.USER_WRITE & this._mode) === permissions.USER_WRITE;\n    } else if (gid === this._gid) {\n        can = (permissions.GROUP_WRITE & this._mode) === permissions.GROUP_WRITE;\n    } else {\n        can = (permissions.OTHER_WRITE & this._mode) === permissions.OTHER_WRITE;\n    }\n    return can;\n};\n/**\n * Determine if the current user has execute permission.\n * @return {boolean} The current user can execute.\n */ Item.prototype.canExecute = function() {\n    const uid = getUid();\n    const gid = getGid();\n    let can = false;\n    if (uid === 0) {\n        can = true;\n    } else if (uid === this._uid || isNaN(uid)) {\n        // NaN occurs on windows\n        can = (permissions.USER_EXEC & this._mode) === permissions.USER_EXEC;\n    } else if (gid === this._gid) {\n        can = (permissions.GROUP_EXEC & this._mode) === permissions.GROUP_EXEC;\n    } else {\n        can = (permissions.OTHER_EXEC & this._mode) === permissions.OTHER_EXEC;\n    }\n    return can;\n};\n/**\n * Get access time.\n * @return {Date} Access time.\n */ Item.prototype.getATime = function() {\n    return this._atime;\n};\n/**\n * Set access time.\n * @param {Date} atime Access time.\n */ Item.prototype.setATime = function(atime) {\n    this._atime = atime;\n};\n/**\n * Get change time.\n * @return {Date} Change time.\n */ Item.prototype.getCTime = function() {\n    return this._ctime;\n};\n/**\n * Set change time.\n * @param {Date} ctime Change time.\n */ Item.prototype.setCTime = function(ctime) {\n    this._ctime = ctime;\n};\n/**\n * Get birth time.\n * @return {Date} Birth time.\n */ Item.prototype.getBirthtime = function() {\n    return this._birthtime;\n};\n/**\n * Set change time.\n * @param {Date} birthtime Birth time.\n */ Item.prototype.setBirthtime = function(birthtime) {\n    this._birthtime = birthtime;\n};\n/**\n * Get modification time.\n * @return {Date} Modification time.\n */ Item.prototype.getMTime = function() {\n    return this._mtime;\n};\n/**\n * Set modification time.\n * @param {Date} mtime Modification time.\n */ Item.prototype.setMTime = function(mtime) {\n    this._mtime = mtime;\n};\n/**\n * Get mode (permission only, e.g 0666).\n * @return {number} Mode.\n */ Item.prototype.getMode = function() {\n    return this._mode;\n};\n/**\n * Set mode (permission only, e.g 0666).\n * @param {Date} mode Mode.\n */ Item.prototype.setMode = function(mode) {\n    this.setCTime(new Date());\n    this._mode = mode;\n};\n/**\n * Get user id.\n * @return {number} User id.\n */ Item.prototype.getUid = function() {\n    return this._uid;\n};\n/**\n * Set user id.\n * @param {number} uid User id.\n */ Item.prototype.setUid = function(uid) {\n    this.setCTime(new Date());\n    this._uid = uid;\n};\n/**\n * Get group id.\n * @return {number} Group id.\n */ Item.prototype.getGid = function() {\n    return this._gid;\n};\n/**\n * Set group id.\n * @param {number} gid Group id.\n */ Item.prototype.setGid = function(gid) {\n    this.setCTime(new Date());\n    this._gid = gid;\n};\n/**\n * Get item stats.\n * @return {Object} Stats properties.\n */ Item.prototype.getStats = function() {\n    return {\n        dev: 8675309,\n        nlink: this.links,\n        uid: this.getUid(),\n        gid: this.getGid(),\n        rdev: 0,\n        blksize: 4096,\n        ino: this._id,\n        atime: this.getATime(),\n        mtime: this.getMTime(),\n        ctime: this.getCTime(),\n        birthtime: this.getBirthtime(),\n        atimeMs: +this.getATime(),\n        mtimeMs: +this.getMTime(),\n        ctimeMs: +this.getCTime(),\n        birthtimeMs: +this.getBirthtime()\n    };\n};\n/**\n * Get the item's string representation.\n * @return {string} String representation.\n */ Item.prototype.toString = function() {\n    return \"[\" + this.constructor.name + \"]\";\n};\n/**\n * Export the constructor.\n * @type {function()}\n */ exports = module.exports = Item;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaXRlbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFVBQVU7QUFFZDs7O0NBR0MsR0FDRCxNQUFNQyxjQUFjO0lBQ2xCQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsWUFBWSxFQUFFLE9BQU87QUFDdkI7QUFFQSxTQUFTQztJQUNQLHdCQUF3QjtJQUN4QixPQUFPQyxRQUFRQyxNQUFNLEdBQUdELFFBQVFDLE1BQU0sS0FBS0M7QUFDN0M7QUFFQSxTQUFTQztJQUNQLHdCQUF3QjtJQUN4QixPQUFPSCxRQUFRSSxNQUFNLEdBQUdKLFFBQVFJLE1BQU0sS0FBS0Y7QUFDN0M7QUFFQTs7O0NBR0MsR0FDRCxTQUFTRztJQUNQLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7SUFFcEI7OztHQUdDLEdBQ0QsSUFBSSxDQUFDRSxNQUFNLEdBQUcsSUFBSUQsS0FBS0Q7SUFFdkI7OztHQUdDLEdBQ0QsSUFBSSxDQUFDRyxNQUFNLEdBQUcsSUFBSUYsS0FBS0Q7SUFFdkI7OztHQUdDLEdBQ0QsSUFBSSxDQUFDSSxVQUFVLEdBQUcsSUFBSUgsS0FBS0Q7SUFFM0I7OztHQUdDLEdBQ0QsSUFBSSxDQUFDSyxNQUFNLEdBQUcsSUFBSUosS0FBS0Q7SUFFdkI7O0dBRUMsR0FDRCxJQUFJLENBQUNNLEtBQUssR0FBRyxLQUFLLE9BQU87SUFFekI7OztHQUdDLEdBQ0QsSUFBSSxDQUFDQyxJQUFJLEdBQUdkO0lBRVo7OztHQUdDLEdBQ0QsSUFBSSxDQUFDZSxJQUFJLEdBQUdYO0lBRVo7OztHQUdDLEdBQ0QsSUFBSSxDQUFDWSxHQUFHLEdBQUcsRUFBRTNCO0lBRWI7O0dBRUMsR0FDRCxJQUFJLENBQUM0QixLQUFLLEdBQUc7QUFDZjtBQUVBOzs7Q0FHQyxHQUNEWCxLQUFLWSxtQkFBbUIsR0FBR0MsQ0FB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ZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9pdGVtLmpzPzkyY2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5sZXQgY291bnRlciA9IDA7XG5cbi8qKlxuICogUGVybWlzc2lvbnMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBwZXJtaXNzaW9ucyA9IHtcbiAgVVNFUl9SRUFEOiAyNTYsIC8vIDA0MDBcbiAgVVNFUl9XUklURTogMTI4LCAvLyAwMjAwXG4gIFVTRVJfRVhFQzogNjQsIC8vIDAxMDBcbiAgR1JPVVBfUkVBRDogMzIsIC8vIDAwNDBcbiAgR1JPVVBfV1JJVEU6IDE2LCAvLyAwMDIwXG4gIEdST1VQX0VYRUM6IDgsIC8vIDAwMTBcbiAgT1RIRVJfUkVBRDogNCwgLy8gMDAwNFxuICBPVEhFUl9XUklURTogMiwgLy8gMDAwMlxuICBPVEhFUl9FWEVDOiAxIC8vIDAwMDFcbn07XG5cbmZ1bmN0aW9uIGdldFVpZCgpIHtcbiAgLy8gZm9yY2UgTmFOIG9uIHdpbmRvd3MuXG4gIHJldHVybiBwcm9jZXNzLmdldHVpZCA/IHByb2Nlc3MuZ2V0dWlkKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIGdldEdpZCgpIHtcbiAgLy8gZm9yY2UgTmFOIG9uIHdpbmRvd3MuXG4gIHJldHVybiBwcm9jZXNzLmdldGdpZCA/IHByb2Nlc3MuZ2V0Z2lkKCkgOiBOYU47XG59XG5cbi8qKlxuICogQSBmaWxlc3lzdGVtIGl0ZW0uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSXRlbSgpIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAvKipcbiAgICogQWNjZXNzIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fYXRpbWUgPSBuZXcgRGF0ZShub3cpO1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGltZS5cbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuICB0aGlzLl9jdGltZSA9IG5ldyBEYXRlKG5vdyk7XG5cbiAgLyoqXG4gICAqIEJpcnRoIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fYmlydGh0aW1lID0gbmV3IERhdGUobm93KTtcblxuICAvKipcbiAgICogTW9kaWZpY2F0aW9uIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fbXRpbWUgPSBuZXcgRGF0ZShub3cpO1xuXG4gIC8qKlxuICAgKiBQZXJtaXNzaW9ucy5cbiAgICovXG4gIHRoaXMuX21vZGUgPSA0Mzg7IC8vIDA2NjZcblxuICAvKipcbiAgICogVXNlciBpZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX3VpZCA9IGdldFVpZCgpO1xuXG4gIC8qKlxuICAgKiBHcm91cCBpZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2dpZCA9IGdldEdpZCgpO1xuXG4gIC8qKlxuICAgKiBJdGVtIG51bWJlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2lkID0gKytjb3VudGVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgbGlua3MgdG8gdGhpcyBpdGVtLlxuICAgKi9cbiAgdGhpcy5saW5rcyA9IDA7XG59XG5cbi8qKlxuICogQWRkIGV4ZWN1dGUgaWYgcmVhZCBhbGxvd2VkXG4gKiBTZWUgbm90ZXMgaW4gaW5kZXguanMgLT4gbWFwcGluZyNhZGREaXJcbiAqL1xuSXRlbS5maXhXaW4zMlBlcm1pc3Npb25zID0gbW9kZSA9PlxuICBwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInXG4gICAgPyBtb2RlXG4gICAgOiBtb2RlIHxcbiAgICAgIChtb2RlICYgcGVybWlzc2lvbnMuVVNFUl9SRUFEICYmIHBlcm1pc3Npb25zLlVTRVJfRVhFQykgfFxuICAgICAgKG1vZGUgJiBwZXJtaXNzaW9ucy5HUk9VUF9SRUFEICYmIHBlcm1pc3Npb25zLkdST1VQX0VYRUMpIHxcbiAgICAgIChtb2RlICYgcGVybWlzc2lvbnMuT1RIRVJfUkVBRCAmJiBwZXJtaXNzaW9ucy5PVEhFUl9FWEVDKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgcmVhZCBwZXJtaXNzaW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGN1cnJlbnQgdXNlciBjYW4gcmVhZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuY2FuUmVhZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWQoKTtcbiAgY29uc3QgZ2lkID0gZ2V0R2lkKCk7XG4gIGxldCBjYW4gPSBmYWxzZTtcbiAgaWYgKHVpZCA9PT0gMCkge1xuICAgIGNhbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodWlkID09PSB0aGlzLl91aWQgfHwgdWlkICE9PSB1aWQpIHtcbiAgICAvLyAodWlkICE9PSB1aWQpIG1lYW5zIHVpZCBpcyBOYU4sIG9ubHkgZm9yIHdpbmRvd3NcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuVVNFUl9SRUFEICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLlVTRVJfUkVBRDtcbiAgfSBlbHNlIGlmIChnaWQgPT09IHRoaXMuX2dpZCkge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5HUk9VUF9SRUFEICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLkdST1VQX1JFQUQ7XG4gIH0gZWxzZSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLk9USEVSX1JFQUQgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuT1RIRVJfUkVBRDtcbiAgfVxuICByZXR1cm4gY2FuO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgd3JpdGUgcGVybWlzc2lvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBjdXJyZW50IHVzZXIgY2FuIHdyaXRlLlxuICovXG5JdGVtLnByb3RvdHlwZS5jYW5Xcml0ZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWQoKTtcbiAgY29uc3QgZ2lkID0gZ2V0R2lkKCk7XG4gIGxldCBjYW4gPSBmYWxzZTtcbiAgaWYgKHVpZCA9PT0gMCkge1xuICAgIGNhbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodWlkID09PSB0aGlzLl91aWQgfHwgdWlkICE9PSB1aWQpIHtcbiAgICAvLyAodWlkICE9PSB1aWQpIG1lYW5zIHVpZCBpcyBOYU4sIG9ubHkgZm9yIHdpbmRvd3NcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuVVNFUl9XUklURSAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5VU0VSX1dSSVRFO1xuICB9IGVsc2UgaWYgKGdpZCA9PT0gdGhpcy5fZ2lkKSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLkdST1VQX1dSSVRFICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLkdST1VQX1dSSVRFO1xuICB9IGVsc2Uge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5PVEhFUl9XUklURSAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5PVEhFUl9XUklURTtcbiAgfVxuICByZXR1cm4gY2FuO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgdXNlciBoYXMgZXhlY3V0ZSBwZXJtaXNzaW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGN1cnJlbnQgdXNlciBjYW4gZXhlY3V0ZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuY2FuRXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWQoKTtcbiAgY29uc3QgZ2lkID0gZ2V0R2lkKCk7XG4gIGxldCBjYW4gPSBmYWxzZTtcbiAgaWYgKHVpZCA9PT0gMCkge1xuICAgIGNhbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodWlkID09PSB0aGlzLl91aWQgfHwgaXNOYU4odWlkKSkge1xuICAgIC8vIE5hTiBvY2N1cnMgb24gd2luZG93c1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5VU0VSX0VYRUMgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuVVNFUl9FWEVDO1xuICB9IGVsc2UgaWYgKGdpZCA9PT0gdGhpcy5fZ2lkKSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLkdST1VQX0VYRUMgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuR1JPVVBfRVhFQztcbiAgfSBlbHNlIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuT1RIRVJfRVhFQyAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5PVEhFUl9FWEVDO1xuICB9XG4gIHJldHVybiBjYW47XG59O1xuXG4vKipcbiAqIEdldCBhY2Nlc3MgdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IEFjY2VzcyB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRBVGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXRpbWU7XG59O1xuXG4vKipcbiAqIFNldCBhY2Nlc3MgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZX0gYXRpbWUgQWNjZXNzIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldEFUaW1lID0gZnVuY3Rpb24oYXRpbWUpIHtcbiAgdGhpcy5fYXRpbWUgPSBhdGltZTtcbn07XG5cbi8qKlxuICogR2V0IGNoYW5nZSB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gQ2hhbmdlIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldENUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jdGltZTtcbn07XG5cbi8qKlxuICogU2V0IGNoYW5nZSB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBjdGltZSBDaGFuZ2UgdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0Q1RpbWUgPSBmdW5jdGlvbihjdGltZSkge1xuICB0aGlzLl9jdGltZSA9IGN0aW1lO1xufTtcblxuLyoqXG4gKiBHZXQgYmlydGggdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IEJpcnRoIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldEJpcnRodGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYmlydGh0aW1lO1xufTtcblxuLyoqXG4gKiBTZXQgY2hhbmdlIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IGJpcnRodGltZSBCaXJ0aCB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRCaXJ0aHRpbWUgPSBmdW5jdGlvbihiaXJ0aHRpbWUpIHtcbiAgdGhpcy5fYmlydGh0aW1lID0gYmlydGh0aW1lO1xufTtcblxuLyoqXG4gKiBHZXQgbW9kaWZpY2F0aW9uIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBNb2RpZmljYXRpb24gdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0TVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX210aW1lO1xufTtcblxuLyoqXG4gKiBTZXQgbW9kaWZpY2F0aW9uIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IG10aW1lIE1vZGlmaWNhdGlvbiB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRNVGltZSA9IGZ1bmN0aW9uKG10aW1lKSB7XG4gIHRoaXMuX210aW1lID0gbXRpbWU7XG59O1xuXG4vKipcbiAqIEdldCBtb2RlIChwZXJtaXNzaW9uIG9ubHksIGUuZyAwNjY2KS5cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZTtcbn07XG5cbi8qKlxuICogU2V0IG1vZGUgKHBlcm1pc3Npb24gb25seSwgZS5nIDA2NjYpLlxuICogQHBhcmFtIHtEYXRlfSBtb2RlIE1vZGUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbihtb2RlKSB7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUoKSk7XG4gIHRoaXMuX21vZGUgPSBtb2RlO1xufTtcblxuLyoqXG4gKiBHZXQgdXNlciBpZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVXNlciBpZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0VWlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl91aWQ7XG59O1xuXG4vKipcbiAqIFNldCB1c2VyIGlkLlxuICogQHBhcmFtIHtudW1iZXJ9IHVpZCBVc2VyIGlkLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRVaWQgPSBmdW5jdGlvbih1aWQpIHtcbiAgdGhpcy5zZXRDVGltZShuZXcgRGF0ZSgpKTtcbiAgdGhpcy5fdWlkID0gdWlkO1xufTtcblxuLyoqXG4gKiBHZXQgZ3JvdXAgaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEdyb3VwIGlkLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRHaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2dpZDtcbn07XG5cbi8qKlxuICogU2V0IGdyb3VwIGlkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdpZCBHcm91cCBpZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0R2lkID0gZnVuY3Rpb24oZ2lkKSB7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUoKSk7XG4gIHRoaXMuX2dpZCA9IGdpZDtcbn07XG5cbi8qKlxuICogR2V0IGl0ZW0gc3RhdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRzIHByb3BlcnRpZXMuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZGV2OiA4Njc1MzA5LFxuICAgIG5saW5rOiB0aGlzLmxpbmtzLFxuICAgIHVpZDogdGhpcy5nZXRVaWQoKSxcbiAgICBnaWQ6IHRoaXMuZ2V0R2lkKCksXG4gICAgcmRldjogMCxcbiAgICBibGtzaXplOiA0MDk2LFxuICAgIGlubzogdGhpcy5faWQsXG4gICAgYXRpbWU6IHRoaXMuZ2V0QVRpbWUoKSxcbiAgICBtdGltZTogdGhpcy5nZXRNVGltZSgpLFxuICAgIGN0aW1lOiB0aGlzLmdldENUaW1lKCksXG4gICAgYmlydGh0aW1lOiB0aGlzLmdldEJpcnRodGltZSgpLFxuICAgIGF0aW1lTXM6ICt0aGlzLmdldEFUaW1lKCksXG4gICAgbXRpbWVNczogK3RoaXMuZ2V0TVRpbWUoKSxcbiAgICBjdGltZU1zOiArdGhpcy5nZXRDVGltZSgpLFxuICAgIGJpcnRodGltZU1zOiArdGhpcy5nZXRCaXJ0aHRpbWUoKVxuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGl0ZW0ncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqL1xuSXRlbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdbJyArIHRoaXMuY29uc3RydWN0b3IubmFtZSArICddJztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBJdGVtO1xuIl0sIm5hbWVzIjpbImNvdW50ZXIiLCJwZXJtaXNzaW9ucyIsIlVTRVJfUkVBRCIsIlVTRVJfV1JJVEUiLCJVU0VSX0VYRUMiLCJHUk9VUF9SRUFEIiwiR1JPVVBfV1JJVEUiLCJHUk9VUF9FWEVDIiwiT1RIRVJfUkVBRCIsIk9USEVSX1dSSVRFIiwiT1RIRVJfRVhFQyIsImdldFVpZCIsInByb2Nlc3MiLCJnZXR1aWQiLCJOYU4iLCJnZXRHaWQiLCJnZXRnaWQiLCJJdGVtIiwibm93IiwiRGF0ZSIsIl9hdGltZSIsIl9jdGltZSIsIl9iaXJ0aHRpbWUiLCJfbXRpbWUiLCJfbW9kZSIsIl91aWQiLCJfZ2lkIiwiX2lkIiwibGlua3MiLCJmaXhXaW4zMlBlcm1pc3Npb25zIiwibW9kZSIsInBsYXRmb3JtIiwicHJvdG90eXBlIiwiY2FuUmVhZCIsInVpZCIsImdpZCIsImNhbiIsImNhbldyaXRlIiwiY2FuRXhlY3V0ZSIsImlzTmFOIiwiZ2V0QVRpbWUiLCJzZXRBVGltZSIsImF0aW1lIiwiZ2V0Q1RpbWUiLCJzZXRDVGltZSIsImN0aW1lIiwiZ2V0QmlydGh0aW1lIiwic2V0QmlydGh0aW1lIiwiYmlydGh0aW1lIiwiZ2V0TVRpbWUiLCJzZXRNVGltZSIsIm10aW1lIiwiZ2V0TW9kZSIsInNldE1vZGUiLCJzZXRVaWQiLCJzZXRHaWQiLCJnZXRTdGF0cyIsImRldiIsIm5saW5rIiwicmRldiIsImJsa3NpemUiLCJpbm8iLCJhdGltZU1zIiwibXRpbWVNcyIsImN0aW1lTXMiLCJiaXJ0aHRpbWVNcyIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZXhwb3J0cyIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/loader.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/loader.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const { fixWin32Permissions } = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(ssr)/./node_modules/mock-fs/lib/bypass.js\");\nconst createContext = ({ output, options = {}, target }, newContext)=>Object.assign({\n        // Assign options and set defaults if needed\n        options: {\n            recursive: options.recursive !== false,\n            lazy: options.lazy !== false\n        },\n        output,\n        target\n    }, newContext);\nfunction addFile(context, stats, isRoot) {\n    const { output, target } = context;\n    const { lazy } = context.options;\n    if (!stats.isFile()) {\n        throw new Error(`${target} is not a valid file!`);\n    }\n    const outputPropKey = isRoot ? target : path.basename(target);\n    output[outputPropKey] = ()=>{\n        const content = !lazy ? fs.readFileSync(target) : \"\";\n        const file = FileSystem.file(Object.assign({}, stats, {\n            content\n        }))();\n        if (lazy) {\n            Object.defineProperty(file, \"_content\", {\n                get () {\n                    const res = bypass(()=>fs.readFileSync(target));\n                    Object.defineProperty(file, \"_content\", {\n                        value: res,\n                        writable: true\n                    });\n                    return res;\n                },\n                set (data) {\n                    Object.defineProperty(file, \"_content\", {\n                        value: data,\n                        writable: true\n                    });\n                },\n                configurable: true\n            });\n        }\n        return file;\n    };\n    return output[outputPropKey];\n}\nfunction addDir(context, stats, isRoot) {\n    const { target, output } = context;\n    const { recursive } = context.options;\n    if (!stats.isDirectory()) {\n        throw new Error(`${target} is not a valid directory!`);\n    }\n    stats = Object.assign({}, stats);\n    const outputPropKey = isRoot ? target : path.basename(target);\n    // On windows platforms, directories do not have the executable flag, which causes FileSystem.prototype.getItem\n    // to think that the directory cannot be traversed. This is a workaround, however, a better solution may be to\n    // re-think the logic in FileSystem.prototype.getItem\n    // This workaround adds executable privileges if read privileges are found\n    stats.mode = fixWin32Permissions(stats.mode);\n    // Create directory factory\n    const directoryItems = {};\n    output[outputPropKey] = FileSystem.directory(Object.assign(stats, {\n        items: directoryItems\n    }));\n    fs.readdirSync(target).forEach((p)=>{\n        const absPath = path.join(target, p);\n        const stats = fs.statSync(absPath);\n        const newContext = createContext(context, {\n            target: absPath,\n            output: directoryItems\n        });\n        if (recursive && stats.isDirectory()) {\n            addDir(newContext, stats);\n        } else if (stats.isFile()) {\n            addFile(newContext, stats);\n        }\n    });\n    return output[outputPropKey];\n}\n/**\n * Load directory or file from real FS\n */ exports.load = function(p, options) {\n    return bypass(()=>{\n        p = path.resolve(p);\n        const stats = fs.statSync(p);\n        const context = createContext({\n            output: {},\n            options,\n            target: p\n        });\n        if (stats.isDirectory()) {\n            return addDir(context, stats, true);\n        } else if (stats.isFile()) {\n            return addFile(context, stats, true);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvbG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sRUFBQ0EsbUJBQW1CLEVBQUMsR0FBR0MsbUJBQU9BLENBQUM7QUFDdEMsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDckIsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUcsS0FBS0gsbUJBQU9BLENBQUM7QUFDbkIsTUFBTUksU0FBU0osbUJBQU9BLENBQUM7QUFFdkIsTUFBTUssZ0JBQWdCLENBQUMsRUFBQ0MsTUFBTSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxNQUFNLEVBQUMsRUFBRUMsYUFDckRDLE9BQU9DLE1BQU0sQ0FDWDtRQUNFLDRDQUE0QztRQUM1Q0osU0FBUztZQUNQSyxXQUFXTCxRQUFRSyxTQUFTLEtBQUs7WUFDakNDLE1BQU1OLFFBQVFNLElBQUksS0FBSztRQUN6QjtRQUNBUDtRQUNBRTtJQUNGLEdBQ0FDO0FBR0osU0FBU0ssUUFBUUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDckMsTUFBTSxFQUFDWCxNQUFNLEVBQUVFLE1BQU0sRUFBQyxHQUFHTztJQUN6QixNQUFNLEVBQUNGLElBQUksRUFBQyxHQUFHRSxRQUFRUixPQUFPO0lBRTlCLElBQUksQ0FBQ1MsTUFBTUUsTUFBTSxJQUFJO1FBQ25CLE1BQU0sSUFBSUMsTUFBTSxDQUFDLEVBQUVYLE9BQU8scUJBQXFCLENBQUM7SUFDbEQ7SUFFQSxNQUFNWSxnQkFBZ0JILFNBQVNULFNBQVNQLEtBQUtvQixRQUFRLENBQUNiO0lBRXRERixNQUFNLENBQUNjLGNBQWMsR0FBRztRQUN0QixNQUFNRSxVQUFVLENBQUNULE9BQU9WLEdBQUdvQixZQUFZLENBQUNmLFVBQVU7UUFDbEQsTUFBTWdCLE9BQU90QixXQUFXc0IsSUFBSSxDQUFDZCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSyxPQUFPO1lBQUNNO1FBQU87UUFFOUQsSUFBSVQsTUFBTTtZQUNSSCxPQUFPZSxjQUFjLENBQUNELE1BQU0sWUFBWTtnQkFDdENFO29CQUNFLE1BQU1DLE1BQU12QixPQUFPLElBQU1ELEdBQUdvQixZQUFZLENBQUNmO29CQUN6Q0UsT0FBT2UsY0FBYyxDQUFDRCxNQUFNLFlBQVk7d0JBQ3RDSSxPQUFPRDt3QkFDUEUsVUFBVTtvQkFDWjtvQkFDQSxPQUFPRjtnQkFDVDtnQkFDQUcsS0FBSUMsSUFBSTtvQkFDTnJCLE9BQU9lLGNBQWMsQ0FBQ0QsTUFBTSxZQUFZO3dCQUN0Q0ksT0FBT0c7d0JBQ1BGLFVBQVU7b0JBQ1o7Z0JBQ0Y7Z0JBQ0FHLGNBQWM7WUFDaEI7UUFDRjtRQUVBLE9BQU9SO0lBQ1Q7SUFFQSxPQUFPbEIsTUFBTSxDQUFDYyxjQUFjO0FBQzlCO0FBRUEsU0FBU2EsT0FBT2xCLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3BDLE1BQU0sRUFBQ1QsTUFBTSxFQUFFRixNQUFNLEVBQUMsR0FBR1M7SUFDekIsTUFBTSxFQUFDSCxTQUFTLEVBQUMsR0FBR0csUUFBUVIsT0FBTztJQUVuQyxJQUFJLENBQUNTLE1BQU1rQixXQUFXLElBQUk7UUFDeEIsTUFBTSxJQUFJZixNQUFNLENBQUMsRUFBRVgsT0FBTywwQkFBMEIsQ0FBQztJQUN2RDtJQUVBUSxRQUFRTixPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSztJQUMxQixNQUFNSSxnQkFBZ0JILFNBQVNULFNBQVNQLEtBQUtvQixRQUFRLENBQUNiO0lBRXRELCtHQUErRztJQUMvRyw4R0FBOEc7SUFDOUcscURBQXFEO0lBQ3JELDBFQUEwRTtJQUMxRVEsTUFBTW1CLElBQUksR0FBR3BDLG9CQUFvQmlCLE1BQU1tQixJQUFJO0lBRTNDLDJCQUEyQjtJQUMzQixNQUFNQyxpQkFBaUIsQ0FBQztJQUN4QjlCLE1BQU0sQ0FBQ2MsY0FBYyxHQUFHbEIsV0FBV21DLFNBQVMsQ0FDMUMzQixPQUFPQyxNQUFNLENBQUNLLE9BQU87UUFBQ3NCLE9BQU9GO0lBQWM7SUFHN0NqQyxHQUFHb0MsV0FBVyxDQUFDL0IsUUFBUWdDLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDN0IsTUFBTUMsVUFBVXpDLEtBQUswQyxJQUFJLENBQUNuQyxRQUFRaUM7UUFDbEMsTUFBTXpCLFFBQVFiLEdBQUd5QyxRQUFRLENBQUNGO1FBQzFCLE1BQU1qQyxhQUFhSixjQUFjVSxTQUFTO1lBQ3hDUCxRQUFRa0M7WUFDUnBDLFFBQVE4QjtRQUNWO1FBRUEsSUFBSXhCLGFBQWFJLE1BQU1rQixXQUFXLElBQUk7WUFDcENELE9BQU94QixZQUFZTztRQUNyQixPQUFPLElBQUlBLE1BQU1FLE1BQU0sSUFBSTtZQUN6QkosUUFBUUwsWUFBWU87UUFDdEI7SUFDRjtJQUVBLE9BQU9WLE1BQU0sQ0FBQ2MsY0FBYztBQUM5QjtBQUVBOztDQUVDLEdBQ0R5QixZQUFZLEdBQUcsU0FBU0osQ0FBQyxFQUFFbEMsT0FBTztJQUNoQyxPQUFPSCxPQUFPO1FBQ1pxQyxJQUFJeEMsS0FBSzhDLE9BQU8sQ0FBQ047UUFFakIsTUFBTXpCLFFBQVFiLEdBQUd5QyxRQUFRLENBQUNIO1FBQzFCLE1BQU0xQixVQUFVVixjQUFjO1lBQUNDLFFBQVEsQ0FBQztZQUFHQztZQUFTQyxRQUFRaUM7UUFBQztRQUU3RCxJQUFJekIsTUFBTWtCLFdBQVcsSUFBSTtZQUN2QixPQUFPRCxPQUFPbEIsU0FBU0MsT0FBTztRQUNoQyxPQUFPLElBQUlBLE1BQU1FLE1BQU0sSUFBSTtZQUN6QixPQUFPSixRQUFRQyxTQUFTQyxPQUFPO1FBQ2pDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2xvYWRlci5qcz8zMGM2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtmaXhXaW4zMlBlcm1pc3Npb25zfSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IEZpbGVTeXN0ZW0gPSByZXF1aXJlKCcuL2ZpbGVzeXN0ZW0nKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IGJ5cGFzcyA9IHJlcXVpcmUoJy4vYnlwYXNzJyk7XG5cbmNvbnN0IGNyZWF0ZUNvbnRleHQgPSAoe291dHB1dCwgb3B0aW9ucyA9IHt9LCB0YXJnZXR9LCBuZXdDb250ZXh0KSA9PlxuICBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIC8vIEFzc2lnbiBvcHRpb25zIGFuZCBzZXQgZGVmYXVsdHMgaWYgbmVlZGVkXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlY3Vyc2l2ZTogb3B0aW9ucy5yZWN1cnNpdmUgIT09IGZhbHNlLFxuICAgICAgICBsYXp5OiBvcHRpb25zLmxhenkgIT09IGZhbHNlXG4gICAgICB9LFxuICAgICAgb3V0cHV0LFxuICAgICAgdGFyZ2V0XG4gICAgfSxcbiAgICBuZXdDb250ZXh0XG4gICk7XG5cbmZ1bmN0aW9uIGFkZEZpbGUoY29udGV4dCwgc3RhdHMsIGlzUm9vdCkge1xuICBjb25zdCB7b3V0cHV0LCB0YXJnZXR9ID0gY29udGV4dDtcbiAgY29uc3Qge2xhenl9ID0gY29udGV4dC5vcHRpb25zO1xuXG4gIGlmICghc3RhdHMuaXNGaWxlKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGFyZ2V0fSBpcyBub3QgYSB2YWxpZCBmaWxlIWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0UHJvcEtleSA9IGlzUm9vdCA/IHRhcmdldCA6IHBhdGguYmFzZW5hbWUodGFyZ2V0KTtcblxuICBvdXRwdXRbb3V0cHV0UHJvcEtleV0gPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGVudCA9ICFsYXp5ID8gZnMucmVhZEZpbGVTeW5jKHRhcmdldCkgOiAnJztcbiAgICBjb25zdCBmaWxlID0gRmlsZVN5c3RlbS5maWxlKE9iamVjdC5hc3NpZ24oe30sIHN0YXRzLCB7Y29udGVudH0pKSgpO1xuXG4gICAgaWYgKGxhenkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCAnX2NvbnRlbnQnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCByZXMgPSBieXBhc3MoKCkgPT4gZnMucmVhZEZpbGVTeW5jKHRhcmdldCkpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCAnX2NvbnRlbnQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogcmVzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoZGF0YSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCAnX2NvbnRlbnQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG5cbiAgcmV0dXJuIG91dHB1dFtvdXRwdXRQcm9wS2V5XTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyKGNvbnRleHQsIHN0YXRzLCBpc1Jvb3QpIHtcbiAgY29uc3Qge3RhcmdldCwgb3V0cHV0fSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtyZWN1cnNpdmV9ID0gY29udGV4dC5vcHRpb25zO1xuXG4gIGlmICghc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0YXJnZXR9IGlzIG5vdCBhIHZhbGlkIGRpcmVjdG9yeSFgKTtcbiAgfVxuXG4gIHN0YXRzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdHMpO1xuICBjb25zdCBvdXRwdXRQcm9wS2V5ID0gaXNSb290ID8gdGFyZ2V0IDogcGF0aC5iYXNlbmFtZSh0YXJnZXQpO1xuXG4gIC8vIE9uIHdpbmRvd3MgcGxhdGZvcm1zLCBkaXJlY3RvcmllcyBkbyBub3QgaGF2ZSB0aGUgZXhlY3V0YWJsZSBmbGFnLCB3aGljaCBjYXVzZXMgRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbVxuICAvLyB0byB0aGluayB0aGF0IHRoZSBkaXJlY3RvcnkgY2Fubm90IGJlIHRyYXZlcnNlZC4gVGhpcyBpcyBhIHdvcmthcm91bmQsIGhvd2V2ZXIsIGEgYmV0dGVyIHNvbHV0aW9uIG1heSBiZSB0b1xuICAvLyByZS10aGluayB0aGUgbG9naWMgaW4gRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbVxuICAvLyBUaGlzIHdvcmthcm91bmQgYWRkcyBleGVjdXRhYmxlIHByaXZpbGVnZXMgaWYgcmVhZCBwcml2aWxlZ2VzIGFyZSBmb3VuZFxuICBzdGF0cy5tb2RlID0gZml4V2luMzJQZXJtaXNzaW9ucyhzdGF0cy5tb2RlKTtcblxuICAvLyBDcmVhdGUgZGlyZWN0b3J5IGZhY3RvcnlcbiAgY29uc3QgZGlyZWN0b3J5SXRlbXMgPSB7fTtcbiAgb3V0cHV0W291dHB1dFByb3BLZXldID0gRmlsZVN5c3RlbS5kaXJlY3RvcnkoXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0cywge2l0ZW1zOiBkaXJlY3RvcnlJdGVtc30pXG4gICk7XG5cbiAgZnMucmVhZGRpclN5bmModGFyZ2V0KS5mb3JFYWNoKHAgPT4ge1xuICAgIGNvbnN0IGFic1BhdGggPSBwYXRoLmpvaW4odGFyZ2V0LCBwKTtcbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGFic1BhdGgpO1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KGNvbnRleHQsIHtcbiAgICAgIHRhcmdldDogYWJzUGF0aCxcbiAgICAgIG91dHB1dDogZGlyZWN0b3J5SXRlbXNcbiAgICB9KTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgYWRkRGlyKG5ld0NvbnRleHQsIHN0YXRzKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICBhZGRGaWxlKG5ld0NvbnRleHQsIHN0YXRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXRbb3V0cHV0UHJvcEtleV07XG59XG5cbi8qKlxuICogTG9hZCBkaXJlY3Rvcnkgb3IgZmlsZSBmcm9tIHJlYWwgRlNcbiAqL1xuZXhwb3J0cy5sb2FkID0gZnVuY3Rpb24ocCwgb3B0aW9ucykge1xuICByZXR1cm4gYnlwYXNzKCgpID0+IHtcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuXG4gICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhwKTtcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7b3V0cHV0OiB7fSwgb3B0aW9ucywgdGFyZ2V0OiBwfSk7XG5cbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIGFkZERpcihjb250ZXh0LCBzdGF0cywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgcmV0dXJuIGFkZEZpbGUoY29udGV4dCwgc3RhdHMsIHRydWUpO1xuICAgIH1cbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbImZpeFdpbjMyUGVybWlzc2lvbnMiLCJyZXF1aXJlIiwicGF0aCIsIkZpbGVTeXN0ZW0iLCJmcyIsImJ5cGFzcyIsImNyZWF0ZUNvbnRleHQiLCJvdXRwdXQiLCJvcHRpb25zIiwidGFyZ2V0IiwibmV3Q29udGV4dCIsIk9iamVjdCIsImFzc2lnbiIsInJlY3Vyc2l2ZSIsImxhenkiLCJhZGRGaWxlIiwiY29udGV4dCIsInN0YXRzIiwiaXNSb290IiwiaXNGaWxlIiwiRXJyb3IiLCJvdXRwdXRQcm9wS2V5IiwiYmFzZW5hbWUiLCJjb250ZW50IiwicmVhZEZpbGVTeW5jIiwiZmlsZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwicmVzIiwidmFsdWUiLCJ3cml0YWJsZSIsInNldCIsImRhdGEiLCJjb25maWd1cmFibGUiLCJhZGREaXIiLCJpc0RpcmVjdG9yeSIsIm1vZGUiLCJkaXJlY3RvcnlJdGVtcyIsImRpcmVjdG9yeSIsIml0ZW1zIiwicmVhZGRpclN5bmMiLCJmb3JFYWNoIiwicCIsImFic1BhdGgiLCJqb2luIiwic3RhdFN5bmMiLCJleHBvcnRzIiwibG9hZCIsInJlc29sdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/loader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/symlink.js":
/*!*********************************************!*\
  !*** ./node_modules/mock-fs/lib/symlink.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n/**\n * A directory.\n * @constructor\n */ function SymbolicLink() {\n    Item.call(this);\n    /**\n   * Relative path to source.\n   * @type {string}\n   */ this._path = undefined;\n}\nutil.inherits(SymbolicLink, Item);\n/**\n * Set the path to the source.\n * @param {string} pathname Path to source.\n */ SymbolicLink.prototype.setPath = function(pathname) {\n    this._path = pathname;\n};\n/**\n * Get the path to the source.\n * @return {string} Path to source.\n */ SymbolicLink.prototype.getPath = function() {\n    return this._path;\n};\n/**\n * Get symbolic link stats.\n * @return {Object} Stats properties.\n */ SymbolicLink.prototype.getStats = function() {\n    const size = this._path.length;\n    const stats = Item.prototype.getStats.call(this);\n    stats.mode = this.getMode() | constants.S_IFLNK;\n    stats.size = size;\n    stats.blocks = Math.ceil(size / 512);\n    return stats;\n};\n/**\n * Export the constructor.\n * @type {function()}\n */ exports = module.exports = SymbolicLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvc3ltbGluay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDO0FBRTFCOzs7Q0FHQyxHQUNELFNBQVNHO0lBQ1BGLEtBQUtHLElBQUksQ0FBQyxJQUFJO0lBRWQ7OztHQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUdDO0FBQ2Y7QUFDQVAsS0FBS1EsUUFBUSxDQUFDSixjQUFjRjtBQUU1Qjs7O0NBR0MsR0FDREUsYUFBYUssU0FBUyxDQUFDQyxPQUFPLEdBQUcsU0FBU0MsUUFBUTtJQUNoRCxJQUFJLENBQUNMLEtBQUssR0FBR0s7QUFDZjtBQUVBOzs7Q0FHQyxHQUNEUCxhQUFhSyxTQUFTLENBQUNHLE9BQU8sR0FBRztJQUMvQixPQUFPLElBQUksQ0FBQ04sS0FBSztBQUNuQjtBQUVBOzs7Q0FHQyxHQUNERixhQUFhSyxTQUFTLENBQUNJLFFBQVEsR0FBRztJQUNoQyxNQUFNQyxPQUFPLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxNQUFNO0lBQzlCLE1BQU1DLFFBQVFkLEtBQUtPLFNBQVMsQ0FBQ0ksUUFBUSxDQUFDUixJQUFJLENBQUMsSUFBSTtJQUMvQ1csTUFBTUMsSUFBSSxHQUFHLElBQUksQ0FBQ0MsT0FBTyxLQUFLZixVQUFVZ0IsT0FBTztJQUMvQ0gsTUFBTUYsSUFBSSxHQUFHQTtJQUNiRSxNQUFNSSxNQUFNLEdBQUdDLEtBQUtDLElBQUksQ0FBQ1IsT0FBTztJQUNoQyxPQUFPRTtBQUNUO0FBRUE7OztDQUdDLEdBQ0RPLFVBQVVDLE9BQU9ELE9BQU8sR0FBR25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvc3ltbGluay5qcz9mYTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcblxuLyoqXG4gKiBBIGRpcmVjdG9yeS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTeW1ib2xpY0xpbmsoKSB7XG4gIEl0ZW0uY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogUmVsYXRpdmUgcGF0aCB0byBzb3VyY2UuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xufVxudXRpbC5pbmhlcml0cyhTeW1ib2xpY0xpbmssIEl0ZW0pO1xuXG4vKipcbiAqIFNldCB0aGUgcGF0aCB0byB0aGUgc291cmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gc291cmNlLlxuICovXG5TeW1ib2xpY0xpbmsucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbihwYXRobmFtZSkge1xuICB0aGlzLl9wYXRoID0gcGF0aG5hbWU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcGF0aCB0byB0aGUgc291cmNlLlxuICogQHJldHVybiB7c3RyaW5nfSBQYXRoIHRvIHNvdXJjZS5cbiAqL1xuU3ltYm9saWNMaW5rLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wYXRoO1xufTtcblxuLyoqXG4gKiBHZXQgc3ltYm9saWMgbGluayBzdGF0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RhdHMgcHJvcGVydGllcy5cbiAqL1xuU3ltYm9saWNMaW5rLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzaXplID0gdGhpcy5fcGF0aC5sZW5ndGg7XG4gIGNvbnN0IHN0YXRzID0gSXRlbS5wcm90b3R5cGUuZ2V0U3RhdHMuY2FsbCh0aGlzKTtcbiAgc3RhdHMubW9kZSA9IHRoaXMuZ2V0TW9kZSgpIHwgY29uc3RhbnRzLlNfSUZMTks7XG4gIHN0YXRzLnNpemUgPSBzaXplO1xuICBzdGF0cy5ibG9ja3MgPSBNYXRoLmNlaWwoc2l6ZSAvIDUxMik7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xpY0xpbms7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJJdGVtIiwiY29uc3RhbnRzIiwiU3ltYm9saWNMaW5rIiwiY2FsbCIsIl9wYXRoIiwidW5kZWZpbmVkIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJzZXRQYXRoIiwicGF0aG5hbWUiLCJnZXRQYXRoIiwiZ2V0U3RhdHMiLCJzaXplIiwibGVuZ3RoIiwic3RhdHMiLCJtb2RlIiwiZ2V0TW9kZSIsIlNfSUZMTksiLCJibG9ja3MiLCJNYXRoIiwiY2VpbCIsImV4cG9ydHMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/symlink.js\n");

/***/ })

};
;