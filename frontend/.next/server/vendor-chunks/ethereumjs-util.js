"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-util";
exports.ids = ["vendor-chunks/ethereumjs-util"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/account.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/account.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-util/dist/constants.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\");\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */ constructor(nonce = new externals_1.BN(0), balance = new externals_1.BN(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL){\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, stateRoot, codeHash } = accountData;\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = externals_1.rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error(\"Invalid serialized account input. Must be array\");\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, stateRoot, codeHash] = values;\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce.lt(new externals_1.BN(0))) {\n            throw new Error(\"nonce must be greater than zero\");\n        }\n        if (this.balance.lt(new externals_1.BN(0))) {\n            throw new Error(\"balance must be greater than zero\");\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error(\"stateRoot must have a length of 32\");\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error(\"codeHash must have a length of 32\");\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */ raw() {\n        return [\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\n            this.stateRoot,\n            this.codeHash\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */ serialize() {\n        return externals_1.rlp.encode(this.raw());\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */ isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */ isEmpty() {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ const isValidAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */ const toChecksumAddress = function(hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = \"\";\n    if (eip1191ChainId) {\n        const chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + \"0x\";\n    }\n    const hash = (0, hash_1.keccakFromString)(prefix + address).toString(\"hex\");\n    let ret = \"0x\";\n    for(let i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ const generateAddress = function(from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    const nonceBN = new externals_1.BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return (0, hash_1.rlphash)([\n            from,\n            null\n        ]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.rlphash)([\n        from,\n        Buffer.from(nonceBN.toArray())\n    ]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ const generateAddress2 = function(from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    (0, assert_1.default)(from.length === 20);\n    (0, assert_1.default)(salt.length === 32);\n    const address = (0, hash_1.keccak256)(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        from,\n        salt,\n        (0, hash_1.keccak256)(initCode)\n    ]));\n    return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ const isValidPrivate = function(privateKey) {\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const isValidPublic = function(publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([\n            Buffer.from([\n                4\n            ]),\n            publicKey\n        ]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const pubToAddress = function(pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n    }\n    (0, assert_1.default)(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToPublic = function(privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToAddress = function(privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */ const importPublic = function(publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */ const zeroAddress = function() {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */ const isZeroAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EsOEJBQThCLEdBQUdBLHlCQUF5QixHQUFHQSxzQkFBc0IsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDOVgsTUFBTWlCLFdBQVd0QixnQkFBZ0J1QixtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxnR0FBaUM7QUFDN0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMseUVBQVk7QUFDdkMsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsTUFBTU0sU0FBU04sbUJBQU9BLENBQUMsaUVBQVE7QUFDL0IsTUFBTU8sWUFBWVAsbUJBQU9BLENBQUMsdUVBQVc7QUFDckMsTUFBTVEsVUFBVVIsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsTUFBTUY7SUFDRjs7O0tBR0MsR0FDRFcsWUFBWUMsUUFBUSxJQUFJVCxZQUFZVSxFQUFFLENBQUMsRUFBRSxFQUFFQyxVQUFVLElBQUlYLFlBQVlVLEVBQUUsQ0FBQyxFQUFFLEVB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QU9xRyxhQUFhN0M7QUFDeEI7QUFDQTNELHFCQUFxQixHQUFHRSxlQUN4QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9hY2NvdW50LmpzP2JiMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzID0gZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxXCIpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNsYXNzIEFjY291bnQge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29uc3RydWN0b3IgYXNzaWducyBhbmQgdmFsaWRhdGVzIHRoZSB2YWx1ZXMuXG4gICAgICogVXNlIHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBhbiBBY2NvdW50IGZyb20gdmFyeWluZyBkYXRhIHR5cGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vbmNlID0gbmV3IGV4dGVybmFsc18xLkJOKDApLCBiYWxhbmNlID0gbmV3IGV4dGVybmFsc18xLkJOKDApLCBzdGF0ZVJvb3QgPSBjb25zdGFudHNfMS5LRUNDQUsyNTZfUkxQLCBjb2RlSGFzaCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKSB7XG4gICAgICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgdGhpcy5iYWxhbmNlID0gYmFsYW5jZTtcbiAgICAgICAgdGhpcy5zdGF0ZVJvb3QgPSBzdGF0ZVJvb3Q7XG4gICAgICAgIHRoaXMuY29kZUhhc2ggPSBjb2RlSGFzaDtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BY2NvdW50RGF0YShhY2NvdW50RGF0YSkge1xuICAgICAgICBjb25zdCB7IG5vbmNlLCBiYWxhbmNlLCBzdGF0ZVJvb3QsIGNvZGVIYXNoIH0gPSBhY2NvdW50RGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5vbmNlID8gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBieXRlc18xLnRvQnVmZmVyKShub25jZSkpIDogdW5kZWZpbmVkLCBiYWxhbmNlID8gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBieXRlc18xLnRvQnVmZmVyKShiYWxhbmNlKSkgOiB1bmRlZmluZWQsIHN0YXRlUm9vdCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShzdGF0ZVJvb3QpIDogdW5kZWZpbmVkLCBjb2RlSGFzaCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShjb2RlSGFzaCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50KHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZXh0ZXJuYWxzXzEucmxwLmRlY29kZShzZXJpYWxpemVkKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJpYWxpemVkIGFjY291bnQgaW5wdXQuIE11c3QgYmUgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVmFsdWVzQXJyYXkodmFsdWVzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgW25vbmNlLCBiYWxhbmNlLCBzdGF0ZVJvb3QsIGNvZGVIYXNoXSA9IHZhbHVlcztcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5ldyBleHRlcm5hbHNfMS5CTihub25jZSksIG5ldyBleHRlcm5hbHNfMS5CTihiYWxhbmNlKSwgc3RhdGVSb290LCBjb2RlSGFzaCk7XG4gICAgfVxuICAgIF92YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uY2UubHQobmV3IGV4dGVybmFsc18xLkJOKDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZS5sdChuZXcgZXh0ZXJuYWxzXzEuQk4oMCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhbGFuY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlUm9vdC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXRlUm9vdCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMzInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2RlSGFzaC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvZGVIYXNoIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAzMicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCdWZmZXIgQXJyYXkgb2YgdGhlIHJhdyBCdWZmZXJzIGZvciB0aGUgYWNjb3VudCwgaW4gb3JkZXIuXG4gICAgICovXG4gICAgcmF3KCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKDAsIHR5cGVzXzEuYm5Ub1VucGFkZGVkQnVmZmVyKSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgICgwLCB0eXBlc18xLmJuVG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5iYWxhbmNlKSxcbiAgICAgICAgICAgIHRoaXMuc3RhdGVSb290LFxuICAgICAgICAgICAgdGhpcy5jb2RlSGFzaCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUkxQIHNlcmlhbGl6YXRpb24gb2YgdGhlIGFjY291bnQgYXMgYSBgQnVmZmVyYC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbHNfMS5ybHAuZW5jb2RlKHRoaXMucmF3KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGEgY29udHJhY3QuXG4gICAgICovXG4gICAgaXNDb250cmFjdCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvZGVIYXNoLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQm9vbGVhbmAgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjY291bnQgaXMgZW1wdHkgY29tcGx5aW5nIHRvIHRoZSBkZWZpbml0aW9uIG9mXG4gICAgICogYWNjb3VudCBlbXB0aW5lc3MgaW4gW0VJUC0xNjFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTYxKTpcbiAgICAgKiBcIkFuIGFjY291bnQgaXMgY29uc2lkZXJlZCBlbXB0eSB3aGVuIGl0IGhhcyBubyBjb2RlIGFuZCB6ZXJvIG5vbmNlIGFuZCB6ZXJvIGJhbGFuY2UuXCJcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlLmlzWmVybygpICYmIHRoaXMubm9uY2UuaXNaZXJvKCkgJiYgdGhpcy5jb2RlSGFzaC5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b28uXG4gKi9cbmNvbnN0IGlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShoZXhBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoaGV4QWRkcmVzcyk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGlzVmFsaWRBZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBJZiBhbiBlaXAxMTkxQ2hhaW5JZCBpcyBwcm92aWRlZCwgdGhlIGNoYWluSWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY2hlY2tzdW0gY2FsY3VsYXRpb24uIFRoaXNcbiAqIGhhcyB0aGUgZWZmZWN0IG9mIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyBmb3Igb25lIGNoYWluIGhhdmluZyBpbnZhbGlkIGNoZWNrc3VtcyBmb3Igb3RoZXJzLlxuICogRm9yIG1vcmUgZGV0YWlscyBzZWUgW0VJUC0xMTkxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTEpLlxuICpcbiAqIFdBUk5JTkc6IENoZWNrc3VtcyB3aXRoIGFuZCB3aXRob3V0IHRoZSBjaGFpbklkIHdpbGwgZGlmZmVyIGFuZCB0aGUgRUlQLTExOTEgY2hlY2tzdW0gaXMgbm90XG4gKiBiYWNrd2FyZHMgY29tcGF0aWJsZSB0byB0aGUgb3JpZ2luYWwgd2lkZWx5IGFkb3B0ZWQgY2hlY2tzdW0gZm9ybWF0IHN0YW5kYXJkIGludHJvZHVjZWQgaW5cbiAqIFtFSVAtNTVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTUpLCBzbyB0aGlzIHdpbGwgYnJlYWsgaW4gZXhpc3RpbmcgYXBwbGljYXRpb25zLlxuICogVXNhZ2Ugb2YgdGhpcyBFSVAgaXMgdGhlcmVmb3JlIGRpc2NvdXJhZ2VkIHVubGVzcyB5b3UgaGF2ZSBhIHZlcnkgdGFyZ2V0ZWQgdXNlIGNhc2UuXG4gKi9cbmNvbnN0IHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShoZXhBZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBwcmVmaXggPSAnJztcbiAgICBpZiAoZWlwMTE5MUNoYWluSWQpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9ICgwLCB0eXBlc18xLnRvVHlwZSkoZWlwMTE5MUNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgICAgIHByZWZpeCA9IGNoYWluSWQudG9TdHJpbmcoKSArICcweCc7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSAoMCwgaGFzaF8xLmtlY2Nha0Zyb21TdHJpbmcpKHByZWZpeCArIGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBsZXQgcmV0ID0gJzB4JztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gdG9DaGVja3N1bUFkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogU2VlIHRvQ2hlY2tzdW1BZGRyZXNzJyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzIGFib3V0IHRoZSBlaXAxMTkxQ2hhaW5JZCBwYXJhbWV0ZXIuXG4gKi9cbmNvbnN0IGlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MpKGhleEFkZHJlc3MpICYmICgwLCBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKShoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gaXNWYWxpZENoZWNrc3VtQWRkcmVzcztcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKi9cbmNvbnN0IGdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG5vbmNlKTtcbiAgICBjb25zdCBub25jZUJOID0gbmV3IGV4dGVybmFsc18xLkJOKG5vbmNlKTtcbiAgICBpZiAobm9uY2VCTi5pc1plcm8oKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuICgwLCBoYXNoXzEucmxwaGFzaCkoW2Zyb20sIG51bGxdKS5zbGljZSgtMjApO1xuICAgIH1cbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gKDAsIGhhc2hfMS5ybHBoYXNoKShbZnJvbSwgQnVmZmVyLmZyb20obm9uY2VCTi50b0FycmF5KCkpXSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzcztcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICovXG5jb25zdCBnZW5lcmF0ZUFkZHJlc3MyID0gZnVuY3Rpb24gKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoZnJvbSk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoc2FsdCk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoaW5pdENvZGUpO1xuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShmcm9tLmxlbmd0aCA9PT0gMjApO1xuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShzYWx0Lmxlbmd0aCA9PT0gMzIpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaGFzaF8xLmtlY2NhazI1NikoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJ2ZmJywgJ2hleCcpLCBmcm9tLCBzYWx0LCAoMCwgaGFzaF8xLmtlY2NhazI1NikoaW5pdENvZGUpXSkpO1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZ2VuZXJhdGVBZGRyZXNzMjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmNvbnN0IGlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gKDAsIHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkpKHByaXZhdGVLZXkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBpc1ZhbGlkUHJpdmF0ZTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICByZXR1cm4gKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleVZlcmlmeSkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICAgIH1cbiAgICBpZiAoIXNhbml0aXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlWZXJpZnkpKHB1YmxpY0tleSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gaXNWYWxpZFB1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgcHViVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUgPSBmYWxzZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YktleSk7XG4gICAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YktleSA9IEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShwdWJLZXksIGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuICgwLCBoYXNoXzEua2VjY2FrKShwdWJLZXkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBwdWJUb0FkZHJlc3M7XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHByaXZhdGVLZXkpO1xuICAgIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q3JlYXRlKShwcml2YXRlS2V5LCBmYWxzZSkpLnNsaWNlKDEpO1xufTtcbmV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gcHJpdmF0ZVRvUHVibGljO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKSgoMCwgZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMpKHByaXZhdGVLZXkpKTtcbn07XG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBwcml2YXRlVG9BZGRyZXNzO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqL1xuY29uc3QgaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YmxpY0tleSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBpbXBvcnRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICAgIGNvbnN0IGFkZHIgPSAoMCwgYnl0ZXNfMS56ZXJvcykoYWRkcmVzc0xlbmd0aCk7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShhZGRyKTtcbn07XG5leHBvcnRzLnplcm9BZGRyZXNzID0gemVyb0FkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgemVyb0FkZHIgPSAoMCwgZXhwb3J0cy56ZXJvQWRkcmVzcykoKTtcbiAgICByZXR1cm4gemVyb0FkZHIgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gaXNaZXJvQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnQuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzWmVyb0FkZHJlc3MiLCJ6ZXJvQWRkcmVzcyIsImltcG9ydFB1YmxpYyIsInByaXZhdGVUb0FkZHJlc3MiLCJwcml2YXRlVG9QdWJsaWMiLCJwdWJsaWNUb0FkZHJlc3MiLCJwdWJUb0FkZHJlc3MiLCJpc1ZhbGlkUHVibGljIiwiaXNWYWxpZFByaXZhdGUiLCJnZW5lcmF0ZUFkZHJlc3MyIiwiZ2VuZXJhdGVBZGRyZXNzIiwiaXNWYWxpZENoZWNrc3VtQWRkcmVzcyIsInRvQ2hlY2tzdW1BZGRyZXNzIiwiaXNWYWxpZEFkZHJlc3MiLCJBY2NvdW50IiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJzZWNwMjU2azFfMSIsImludGVybmFsXzEiLCJjb25zdGFudHNfMSIsImJ5dGVzXzEiLCJoYXNoXzEiLCJoZWxwZXJzXzEiLCJ0eXBlc18xIiwiY29uc3RydWN0b3IiLCJub25jZSIsIkJOIiwiYmFsYW5jZSIsInN0YXRlUm9vdCIsIktFQ0NBSzI1Nl9STFAiLCJjb2RlSGFzaCIsIktFQ0NBSzI1Nl9OVUxMIiwiX3ZhbGlkYXRlIiwiZnJvbUFjY291bnREYXRhIiwiYWNjb3VudERhdGEiLCJ0b0J1ZmZlciIsInVuZGVmaW5lZCIsImZyb21SbHBTZXJpYWxpemVkQWNjb3VudCIsInNlcmlhbGl6ZWQiLCJ2YWx1ZXMiLCJybHAiLCJkZWNvZGUiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImZyb21WYWx1ZXNBcnJheSIsImx0IiwibGVuZ3RoIiwicmF3IiwiYm5Ub1VucGFkZGVkQnVmZmVyIiwic2VyaWFsaXplIiwiZW5jb2RlIiwiaXNDb250cmFjdCIsImVxdWFscyIsImlzRW1wdHkiLCJpc1plcm8iLCJoZXhBZGRyZXNzIiwiYXNzZXJ0SXNTdHJpbmciLCJlIiwidGVzdCIsImVpcDExOTFDaGFpbklkIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJhZGRyZXNzIiwic3RyaXBIZXhQcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsInByZWZpeCIsImNoYWluSWQiLCJ0b1R5cGUiLCJUeXBlT3V0cHV0IiwidG9TdHJpbmciLCJoYXNoIiwia2VjY2FrRnJvbVN0cmluZyIsInJldCIsImkiLCJwYXJzZUludCIsInRvVXBwZXJDYXNlIiwiZnJvbSIsImFzc2VydElzQnVmZmVyIiwibm9uY2VCTiIsInJscGhhc2giLCJzbGljZSIsIkJ1ZmZlciIsInRvQXJyYXkiLCJzYWx0IiwiaW5pdENvZGUiLCJkZWZhdWx0Iiwia2VjY2FrMjU2IiwiY29uY2F0IiwicHJpdmF0ZUtleSIsInByaXZhdGVLZXlWZXJpZnkiLCJwdWJsaWNLZXkiLCJzYW5pdGl6ZSIsInB1YmxpY0tleVZlcmlmeSIsInB1YktleSIsInB1YmxpY0tleUNvbnZlcnQiLCJrZWNjYWsiLCJwdWJsaWNLZXlDcmVhdGUiLCJhZGRyZXNzTGVuZ3RoIiwiYWRkciIsInplcm9zIiwiYnVmZmVyVG9IZXgiLCJ6ZXJvQWRkciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/address.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/address.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Address = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-util/dist/account.js\");\nclass Address {\n    constructor(buf){\n        (0, assert_1.default)(buf.length === 20, \"Invalid address length\");\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */ static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */ static fromString(str) {\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), \"Invalid address\");\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */ static fromPublicKey(pubKey) {\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), \"Public key should be Buffer\");\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */ static fromPrivateKey(privateKey) {\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), \"Private key should be Buffer\");\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */ static generate(from, nonce) {\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */ static generate2(from, salt, initCode) {\n        (0, assert_1.default)(Buffer.isBuffer(salt));\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */ equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */ isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */ isPrecompileOrSystemAddress() {\n        const addressBN = new externals_1.BN(this.buf);\n        const rangeMin = new externals_1.BN(0);\n        const rangeMax = new externals_1.BN(\"ffff\", \"hex\");\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    }\n    /**\n     * Returns hex encoding of address.\n     */ toString() {\n        return \"0x\" + this.buf.toString(\"hex\");\n    }\n    /**\n     * Returns Buffer representation of address.\n     */ toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLFdBQVdSLGdCQUFnQlMsbUJBQU9BLENBQUMsc0JBQVE7QUFDakQsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUMsdUVBQVc7QUFDckMsTUFBTUY7SUFDRk0sWUFBWUMsR0FBRyxDQUFFO1FBQ1osSUFBR04sU0FBU08sT0FBTyxFQUFFRCxJQUFJRSxNQUFNLEtBQUssSUFBSTtRQUN6QyxJQUFJLENBQUNGLEdBQUcsR0FBR0E7SUFDZjtJQUNBOztLQUVDLEdBQ0QsT0FBT0csT0FBTztRQUNWLE9BQU8sSUFBSVYsUUFBUSxDQUFDLEdBQUdJLFFBQVFPLEtBQUssRUFBRTtJQUMxQztJQUNBOzs7S0FHQyxHQUNELE9BQU9DLFdBQVdDLEdBQUcsRUFBRTtRQUNsQixJQUFHWixTQUFTTyxPQUFPLEVBQUUsQ0FBQyxHQUFHSCxVQUFVUyxjQUFjLEVBQUVELE1BQU07UUFDMUQsT0FBTyxJQUFJYixRQUFRLENBQUMsR0FBR0ksUUFBUVcsUUFBUSxFQUFFRjtJQUM3QztJQUNBOzs7S0FHQyxHQUNELE9BQU9HLGNBQWNDLE1BQU0sRUFBRTtRQUN4QixJQUFHaEIsU0FBU08sT0FBTyxFQUFFVSxPQUFPQyxRQUFRLENBQUNGLFNBQVM7UUFDL0MsTUFBTVYsTUFBTSxDQUFDLEdBQUdGLFVBQVVlLFlBQVksRUFBRUg7UUFDeEMsT0FBTyxJQUFJakIsUUFBUU87SUFDdkI7SUFDQTs7O0tBR0MsR0FDRCxPQUFPYyxlQUFlQyxVQUFVLEVBQUU7UUFDN0IsSUFBR3JCLFNBQVNPLE9BQU8sRUFBRVUsT0FBT0MsUUFBUSxDQUFDRyxhQUFhO1FBQ25ELE1BQU1mLE1BQU0sQ0FBQyxHQUFHRixVQUFVa0IsZ0JBQWdCLEVBQUVEO1FBQzVDLE9BQU8sSUFBSXRCLFFBQVFPO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU9pQixTQUFTQyxJQUFJLEVBQUVDLEtBQUssRUFBRTtRQUN4QixJQUFHekIsU0FBU08sT0FBTyxFQUFFTCxZQUFZd0IsRUFBRSxDQUFDQyxJQUFJLENBQUNGO1FBQzFDLE9BQU8sSUFBSTFCLFFBQVEsQ0FBQyxHQUFHSyxVQUFVd0IsZUFBZSxFQUFFSixLQUFLbEIsR0FBRyxFQUFFbUIsTUFBTUksV0FBVyxDQUFDWjtJQUNsRjtJQUNBOzs7OztLQUtDLEdBQ0QsT0FBT2EsVUFBVU4sSUFBSSxFQUFFTyxJQUFJLEVBQUVDLFFBQVEsRUFBRTtRQUNsQyxJQUFHaEMsU0FBU08sT0FBTyxFQUFFVSxPQUFPQyxRQUFRLENBQUNhO1FBQ3JDLElBQUcvQixTQUFTTyxPQUFPLEVBQUVVLE9BQU9DLFFBQVEsQ0FBQ2M7UUFDdEMsT0FBTyxJQUFJakMsUUFBUSxDQUFDLEdBQUdLLFVBQVU2QixnQkFBZ0IsRUFBRVQsS0FBS2xCLEdBQUcsRUFBRXlCLE1BQU1DO0lBQ3ZFO0lBQ0E7O0tBRUMsR0FDREUsT0FBT0MsT0FBTyxFQUFFO1FBQ1osT0FBTyxJQUFJLENBQUM3QixHQUFHLENBQUM0QixNQUFNLENBQUNDLFFBQVE3QixHQUFHO0lBQ3RDO0lBQ0E7O0tBRUMsR0FDRDhCLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0YsTUFBTSxDQUFDbkMsUUFBUVUsSUFBSTtJQUNuQztJQUNBOzs7S0FHQyxHQUNENEIsOEJBQThCO1FBQzFCLE1BQU1DLFlBQVksSUFBSXBDLFlBQVl3QixFQUFFLENBQUMsSUFBSSxDQUFDcEIsR0FBRztRQUM3QyxNQUFNaUMsV0FBVyxJQUFJckMsWUFBWXdCLEVBQUUsQ0FBQztRQUNwQyxNQUFNYyxXQUFXLElBQUl0QyxZQUFZd0IsRUFBRSxDQUFDLFFBQVE7UUFDNUMsT0FBT1ksVUFBVUcsR0FBRyxDQUFDRixhQUFhRCxVQUFVSSxHQUFHLENBQUNGO0lBQ3BEO0lBQ0E7O0tBRUMsR0FDREcsV0FBVztRQUNQLE9BQU8sT0FBTyxJQUFJLENBQUNyQyxHQUFHLENBQUNxQyxRQUFRLENBQUM7SUFDcEM7SUFDQTs7S0FFQyxHQUNEN0IsV0FBVztRQUNQLE9BQU9HLE9BQU9PLElBQUksQ0FBQyxJQUFJLENBQUNsQixHQUFHO0lBQy9CO0FBQ0o7QUFDQVQsZUFBZSxHQUFHRSxTQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9hZGRyZXNzLmpzPzM0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcbmNsYXNzIEFkZHJlc3Mge1xuICAgIGNvbnN0cnVjdG9yKGJ1Zikge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoYnVmLmxlbmd0aCA9PT0gMjAsICdJbnZhbGlkIGFkZHJlc3MgbGVuZ3RoJyk7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICovXG4gICAgc3RhdGljIHplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS56ZXJvcykoMjApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBZGRyZXNzIG9iamVjdCBmcm9tIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzdHIgLSBIZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSgoMCwgYWNjb3VudF8xLmlzVmFsaWRBZGRyZXNzKShzdHIpLCAnSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc3RyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwdWJsaWMga2V5LlxuICAgICAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHVibGljS2V5KHB1YktleSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHB1YktleSksICdQdWJsaWMga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcbiAgICAgICAgY29uc3QgYnVmID0gKDAsIGFjY291bnRfMS5wdWJUb0FkZHJlc3MpKHB1YktleSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhidWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXkpLCAnUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICBjb25zdCBidWYgPSAoMCwgYWNjb3VudF8xLnByaXZhdGVUb0FkZHJlc3MpKHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlKGZyb20sIG5vbmNlKSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShleHRlcm5hbHNfMS5CTi5pc0JOKG5vbmNlKSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYWNjb3VudF8xLmdlbmVyYXRlQWRkcmVzcykoZnJvbS5idWYsIG5vbmNlLnRvQXJyYXlMaWtlKEJ1ZmZlcikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gc2FsdCBBIHNhbHRcbiAgICAgKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZTIoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihzYWx0KSk7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShCdWZmZXIuaXNCdWZmZXIoaW5pdENvZGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBhY2NvdW50XzEuZ2VuZXJhdGVBZGRyZXNzMikoZnJvbS5idWYsIHNhbHQsIGluaXRDb2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIGFkZHJlc3MgZXF1YWwgdG8gYW5vdGhlci5cbiAgICAgKi9cbiAgICBlcXVhbHMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuZXF1YWxzKGFkZHJlc3MuYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyB6ZXJvLlxuICAgICAqL1xuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEFkZHJlc3MuemVybygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBhZGRyZXNzIGlzIGluIHRoZSBhZGRyZXNzIHJhbmdlIGRlZmluZWRcbiAgICAgKiBieSBFSVAtMTM1MlxuICAgICAqL1xuICAgIGlzUHJlY29tcGlsZU9yU3lzdGVtQWRkcmVzcygpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzc0JOID0gbmV3IGV4dGVybmFsc18xLkJOKHRoaXMuYnVmKTtcbiAgICAgICAgY29uc3QgcmFuZ2VNaW4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4oMCk7XG4gICAgICAgIGNvbnN0IHJhbmdlTWF4ID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmJywgJ2hleCcpO1xuICAgICAgICByZXR1cm4gYWRkcmVzc0JOLmd0ZShyYW5nZU1pbikgJiYgYWRkcmVzc0JOLmx0ZShyYW5nZU1heCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGV4IGVuY29kaW5nIG9mIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgdGhpcy5idWYudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzcyA9IEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBZGRyZXNzIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJieXRlc18xIiwiYWNjb3VudF8xIiwiY29uc3RydWN0b3IiLCJidWYiLCJkZWZhdWx0IiwibGVuZ3RoIiwiemVybyIsInplcm9zIiwiZnJvbVN0cmluZyIsInN0ciIsImlzVmFsaWRBZGRyZXNzIiwidG9CdWZmZXIiLCJmcm9tUHVibGljS2V5IiwicHViS2V5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJwdWJUb0FkZHJlc3MiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJwcml2YXRlVG9BZGRyZXNzIiwiZ2VuZXJhdGUiLCJmcm9tIiwibm9uY2UiLCJCTiIsImlzQk4iLCJnZW5lcmF0ZUFkZHJlc3MiLCJ0b0FycmF5TGlrZSIsImdlbmVyYXRlMiIsInNhbHQiLCJpbml0Q29kZSIsImdlbmVyYXRlQWRkcmVzczIiLCJlcXVhbHMiLCJhZGRyZXNzIiwiaXNaZXJvIiwiaXNQcmVjb21waWxlT3JTeXN0ZW1BZGRyZXNzIiwiYWRkcmVzc0JOIiwicmFuZ2VNaW4iLCJyYW5nZU1heCIsImd0ZSIsImx0ZSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/bytes.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/bytes.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */ const intToHex = function(i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */ const intToBuffer = function(i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), \"hex\");\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ const zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */ const setLength = function(msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthLeft = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthRight = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ const stripZeros = function(a) {\n    let first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */ const unpadBuffer = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */ const unpadArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */ const unpadHexString = function(a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */ const toBuffer = function(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === \"string\") {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), \"hex\");\n    }\n    if (typeof v === \"number\") {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (externals_1.BN.isBN(v)) {\n        if (v.isNeg()) {\n            throw new Error(`Cannot convert negative BN to buffer. Given: ${v}`);\n        }\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error(\"invalid type\");\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ const bufferToInt = function(buf) {\n    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ const bufferToHex = function(buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ const fromSigned = function(num) {\n    return new externals_1.BN(num).fromTwos(256);\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ const toUnsigned = function(num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ const addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : \"0x\" + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */ const toUtf8 = function(hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid non-even hex string input for toUtf8() provided\");\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, \"\"), \"hex\");\n    return bufferVal.toString(\"utf8\");\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ const baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString(\"hex\")}`;\n    } else if (ba instanceof Array) {\n        const array = [];\n        for(let i = 0; i < ba.length; i++){\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */ const validateNoLeadingZeroes = function(values) {\n    for (const [k, v] of Object.entries(values)){\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString(\"hex\")}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a)=>arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);\n    }\n    return arr.map((a)=>bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsK0JBQStCLEdBQUdBLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHNCQUFzQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyYSxNQUFNcUIsY0FBY0MsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMseUVBQVk7QUFDdkMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsdUVBQVc7QUFDckM7Ozs7Q0FJQyxHQUNELE1BQU1GLFdBQVcsU0FBVUssQ0FBQztJQUN4QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUFHO1FBQ25DLE1BQU0sSUFBSUcsTUFBTSxDQUFDLGtDQUFrQyxFQUFFSCxFQUFFLENBQUM7SUFDNUQ7SUFDQSxPQUFPLENBQUMsRUFBRSxFQUFFQSxFQUFFSSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ2hDO0FBQ0E3QixnQkFBZ0IsR0FBR29CO0FBQ25COzs7O0NBSUMsR0FDRCxNQUFNRCxjQUFjLFNBQVVNLENBQUM7SUFDM0IsTUFBTUssTUFBTSxDQUFDLEdBQUc5QixRQUFRb0IsUUFBUSxFQUFFSztJQUNsQyxPQUFPTSxPQUFPQyxJQUFJLENBQUMsQ0FBQyxHQUFHVCxXQUFXVSxTQUFTLEVBQUVILElBQUlJLEtBQUssQ0FBQyxLQUFLO0FBQ2hFO0FBQ0FsQyxtQkFB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Z0QsTUFBTUMsSUFBSSxDQUFDLENBQUMsR0FBRzFFLFFBQVFLLFFBQVEsRUFBRW1FLEVBQUUsQ0FBQy9DLEVBQUU7UUFDMUM7UUFDQSxPQUFPZ0Q7SUFDWDtBQUNKO0FBQ0F6RSxnQkFBZ0IsR0FBR0s7QUFDbkI7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsTUFBTUQsMEJBQTBCLFNBQVV1RSxNQUFNO0lBQzVDLEtBQUssTUFBTSxDQUFDQyxHQUFHekIsRUFBRSxJQUFJckQsT0FBTytFLE9BQU8sQ0FBQ0YsUUFBUztRQUN6QyxJQUFJeEIsTUFBTUMsYUFBYUQsRUFBRVgsTUFBTSxHQUFHLEtBQUtXLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRztZQUMvQyxNQUFNLElBQUl2QixNQUFNLENBQUMsRUFBRWdELEVBQUUsdUNBQXVDLEVBQUV6QixFQUFFdEIsUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUNyRjtJQUNKO0FBQ0o7QUFDQTdCLCtCQUErQixHQUFHSTtBQUNsQyxTQUFTRCxZQUFZMkUsR0FBRztJQUNwQixJQUFJLENBQUN4QixNQUFNQyxPQUFPLENBQUN1QixNQUFNO1FBQ3JCLE9BQU8vQyxPQUFPQyxJQUFJLENBQUM4QztJQUN2QjtJQUNBLE9BQU9BLElBQUlDLEdBQUcsQ0FBQyxDQUFDakMsSUFBTTNDLFlBQVkyQztBQUN0QztBQUNBOUMsbUJBQW1CLEdBQUdHO0FBQ3RCLFNBQVNELFlBQVk0RSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3hCLE1BQU1DLE9BQU8sQ0FBQ3VCLE1BQU07UUFDckIsT0FBT3RCLFdBQVd4QixJQUFJLENBQUM4QyxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJQSxNQUFNLEVBQUU7SUFDcEU7SUFDQSxPQUFPQSxJQUFJQyxHQUFHLENBQUMsQ0FBQ2pDLElBQU01QyxZQUFZNEM7QUFDdEM7QUFDQTlDLG1CQUFtQixHQUFHRSxhQUN0QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9ieXRlcy5qcz8xYjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWZBcnJUb0FyciA9IGV4cG9ydHMuYXJyVG9CdWZBcnIgPSBleHBvcnRzLnZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gZXhwb3J0cy5iYVRvSlNPTiA9IGV4cG9ydHMudG9VdGY4ID0gZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBleHBvcnRzLnRvVW5zaWduZWQgPSBleHBvcnRzLmZyb21TaWduZWQgPSBleHBvcnRzLmJ1ZmZlclRvSGV4ID0gZXhwb3J0cy5idWZmZXJUb0ludCA9IGV4cG9ydHMudG9CdWZmZXIgPSBleHBvcnRzLnVucGFkSGV4U3RyaW5nID0gZXhwb3J0cy51bnBhZEFycmF5ID0gZXhwb3J0cy51bnBhZEJ1ZmZlciA9IGV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBleHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnplcm9zID0gZXhwb3J0cy5pbnRUb0J1ZmZlciA9IGV4cG9ydHMuaW50VG9IZXggPSB2b2lkIDA7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgaW50VG9IZXggPSBmdW5jdGlvbiAoaSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaSkgfHwgaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBhbiBpbnZhbGlkIGludGVnZXIgdHlwZTogJHtpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtpLnRvU3RyaW5nKDE2KX1gO1xufTtcbmV4cG9ydHMuaW50VG9IZXggPSBpbnRUb0hleDtcbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuY29uc3QgaW50VG9CdWZmZXIgPSBmdW5jdGlvbiAoaSkge1xuICAgIGNvbnN0IGhleCA9ICgwLCBleHBvcnRzLmludFRvSGV4KShpKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGludGVybmFsXzEucGFkVG9FdmVuKShoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59O1xuZXhwb3J0cy5pbnRUb0J1ZmZlciA9IGludFRvQnVmZmVyO1xuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAqL1xuY29uc3QgemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbmV4cG9ydHMuemVyb3MgPSB6ZXJvcztcbi8qKlxuICogUGFkcyBhIGBCdWZmZXJgIHdpdGggemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBUcnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgaW5wdXQgaWYgaXRzIGxlbmd0aCBleGNlZWRzIGBsZW5ndGhgLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSByaWdodCB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGggPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgsIHJpZ2h0KSB7XG4gICAgY29uc3QgYnVmID0gKDAsIGV4cG9ydHMuemVyb3MpKGxlbmd0aCk7XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgICB9XG59O1xuLyoqXG4gKiBMZWZ0IFBhZHMgYSBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoTGVmdCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1zZyk7XG4gICAgcmV0dXJuIHNldExlbmd0aChtc2csIGxlbmd0aCwgZmFsc2UpO1xufTtcbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IHNldExlbmd0aExlZnQ7XG4vKipcbiAqIFJpZ2h0IFBhZHMgYSBgQnVmZmVyYCB3aXRoIHRyYWlsaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogaXQgdHJ1bmNhdGVzIHRoZSBlbmQgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobXNnKTtcbiAgICByZXR1cm4gc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gc2V0TGVuZ3RoUmlnaHQ7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgLCBgU3RyaW5nYCBvciBgTnVtYmVyW11gLlxuICogQHBhcmFtIGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICovXG5jb25zdCBzdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgICBsZXQgZmlyc3QgPSBhWzBdO1xuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgICAgICBmaXJzdCA9IGFbMF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyKVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCB1bnBhZEJ1ZmZlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuZXhwb3J0cy51bnBhZEJ1ZmZlciA9IHVucGFkQnVmZmVyO1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYW4gYEFycmF5YCAob2YgbnVtYmVycykuXG4gKiBAcGFyYW0gYSAobnVtYmVyW10pXG4gKiBAcmV0dXJuIChudW1iZXJbXSlcbiAqL1xuY29uc3QgdW5wYWRBcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkQXJyYXkgPSB1bnBhZEFycmF5O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBoZXgtcHJlZml4ZWQgYFN0cmluZ2AuXG4gKiBAcGFyYW0gYSAoU3RyaW5nKVxuICogQHJldHVybiAoU3RyaW5nKVxuICovXG5jb25zdCB1bnBhZEhleFN0cmluZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoYSk7XG4gICAgYSA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG5leHBvcnRzLnVucGFkSGV4U3RyaW5nID0gdW5wYWRIZXhTdHJpbmc7XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuXG4gKiBJbnB1dHMgc3VwcG9ydGVkOiBgQnVmZmVyYCwgYFN0cmluZ2AgKGhleC1wcmVmaXhlZCksIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0c1xuICogd2l0aCBhIGB0b0FycmF5KClgIG9yIGB0b0J1ZmZlcigpYCBtZXRob2QuXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWVcbiAqL1xuY29uc3QgdG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgdiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKHYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogJHt2fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgaW50ZXJuYWxfMS5wYWRUb0V2ZW4pKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KSh2KSksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuaW50VG9CdWZmZXIpKHYpO1xuICAgIH1cbiAgICBpZiAoZXh0ZXJuYWxzXzEuQk4uaXNCTih2KSkge1xuICAgICAgICBpZiAodi5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IG5lZ2F0aXZlIEJOIHRvIGJ1ZmZlci4gR2l2ZW46ICR7dn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH1cbiAgICBpZiAodi50b0FycmF5KSB7XG4gICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9XG4gICAgaWYgKHYudG9CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYudG9CdWZmZXIoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG59O1xuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmAuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5jb25zdCBidWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBleHBvcnRzLnRvQnVmZmVyKShidWYpKS50b051bWJlcigpO1xufTtcbmV4cG9ydHMuYnVmZmVyVG9JbnQgPSBidWZmZXJUb0ludDtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgYDB4YC1wcmVmaXhlZCBoZXggYFN0cmluZ2AuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKi9cbmNvbnN0IGJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGJ1ZiA9ICgwLCBleHBvcnRzLnRvQnVmZmVyKShidWYpO1xuICAgIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gYnVmZmVyVG9IZXg7XG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtIFNpZ25lZCBpbnRlZ2VyIHZhbHVlXG4gKi9cbmNvbnN0IGZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbHNfMS5CTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnJvbVNpZ25lZDtcbi8qKlxuICogQ29udmVydHMgYSBgQk5gIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgaXQgYXMgYSBgQnVmZmVyYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtXG4gKi9cbmNvbnN0IHRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcbmV4cG9ydHMudG9VbnNpZ25lZCA9IHRvVW5zaWduZWQ7XG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIi5cbiAqL1xuY29uc3QgYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGludGVybmFsXzEuaXNIZXhQcmVmaXhlZCkoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBhZGRIZXhQcmVmaXg7XG4vKipcbiAqIFJldHVybnMgdGhlIHV0Zjggc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZyb20gYSBoZXggc3RyaW5nLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIElucHV0IDE6ICc2NTc0Njg2NTcyNjU3NTZkMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICogSW5wdXQgMjogJzY1NzQ2ODY1NzI2NTc1NmQnXG4gKiBJbnB1dCAzOiAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjU3NDY4NjU3MjY1NzU2ZCdcbiAqXG4gKiBPdXRwdXQgKGFsbCAzIGlucHV0IHZhcmlhbnRzKTogJ2V0aGVyZXVtJ1xuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIGhleCBzdHJpbmdzXG4gKiByZXByZXNlbnRpbmcgcXVhbnRpdGllcyBpbiBib3RoIGJpZyBlbmRpYW4gb3IgbGl0dGxlIGVuZGlhbiBub3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIEhleCBzdHJpbmcsIHNob3VsZCBiZSBgMHhgIHByZWZpeGVkXG4gKiBAcmV0dXJuIFV0Zjggc3RyaW5nXG4gKi9cbmNvbnN0IHRvVXRmOCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBjb25zdCB6ZXJvc1JlZ2V4cCA9IC9eKDAwKSt8KDAwKSskL2c7XG4gICAgaGV4ID0gKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKGhleCk7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub24tZXZlbiBoZXggc3RyaW5nIGlucHV0IGZvciB0b1V0ZjgoKSBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJWYWwgPSBCdWZmZXIuZnJvbShoZXgucmVwbGFjZSh6ZXJvc1JlZ2V4cCwgJycpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIGJ1ZmZlclZhbC50b1N0cmluZygndXRmOCcpO1xufTtcbmV4cG9ydHMudG9VdGY4ID0gdG9VdGY4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTi5cbiAqIEBwYXJhbSBiYSAoQnVmZmVyfEFycmF5KVxuICogQHJldHVybiAoQXJyYXl8U3RyaW5nfG51bGwpXG4gKi9cbmNvbnN0IGJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7YmEudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaCgoMCwgZXhwb3J0cy5iYVRvSlNPTikoYmFbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbmV4cG9ydHMuYmFUb0pTT04gPSBiYVRvSlNPTjtcbi8qKlxuICogQ2hlY2tzIHByb3ZpZGVkIEJ1ZmZlcnMgZm9yIGxlYWRpbmcgemVyb2VzIGFuZCB0aHJvd3MgaWYgZm91bmQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogVmFsaWQgdmFsdWVzOiAweDEsIDB4LCAweDAxLCAweDEyMzRcbiAqIEludmFsaWQgdmFsdWVzOiAweDAsIDB4MDAsIDB4MDAxLCAweDAwMDFcbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHZhbGlkYXRpbmcgdGhhdCBSTFAgZW5jb2RlZCBpbnRlZ2VycyBjb21wbHkgd2l0aCB0aGUgcnVsZSB0aGF0IGFsbFxuICogaW50ZWdlciB2YWx1ZXMgZW5jb2RlZCB0byBSTFAgbXVzdCBiZSBpbiB0aGUgbW9zdCBjb21wYWN0IGZvcm0gYW5kIGNvbnRhaW4gbm8gbGVhZGluZyB6ZXJvIGJ5dGVzXG4gKiBAcGFyYW0gdmFsdWVzIEFuIG9iamVjdCBjb250YWluaW5nIHN0cmluZyBrZXlzIGFuZCBCdWZmZXIgdmFsdWVzXG4gKiBAdGhyb3dzIGlmIGFueSBwcm92aWRlZCB2YWx1ZSBpcyBmb3VuZCB0byBoYXZlIGxlYWRpbmcgemVybyBieXRlc1xuICovXG5jb25zdCB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdi5sZW5ndGggPiAwICYmIHZbMF0gPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrfSBjYW5ub3QgaGF2ZSBsZWFkaW5nIHplcm9lcywgcmVjZWl2ZWQ6ICR7di50b1N0cmluZygnaGV4Jyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzO1xuZnVuY3Rpb24gYXJyVG9CdWZBcnIoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBhcnJUb0J1ZkFycihhKSk7XG59XG5leHBvcnRzLmFyclRvQnVmQXJyID0gYXJyVG9CdWZBcnI7XG5mdW5jdGlvbiBidWZBcnJUb0FycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFyciAhPT0gbnVsbCAmJiBhcnIgIT09IHZvaWQgMCA/IGFyciA6IFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5tYXAoKGEpID0+IGJ1ZkFyclRvQXJyKGEpKTtcbn1cbmV4cG9ydHMuYnVmQXJyVG9BcnIgPSBidWZBcnJUb0Fycjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ1ZkFyclRvQXJyIiwiYXJyVG9CdWZBcnIiLCJ2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyIsImJhVG9KU09OIiwidG9VdGY4IiwiYWRkSGV4UHJlZml4IiwidG9VbnNpZ25lZCIsImZyb21TaWduZWQiLCJidWZmZXJUb0hleCIsImJ1ZmZlclRvSW50IiwidG9CdWZmZXIiLCJ1bnBhZEhleFN0cmluZyIsInVucGFkQXJyYXkiLCJ1bnBhZEJ1ZmZlciIsInNldExlbmd0aFJpZ2h0Iiwic2V0TGVuZ3RoTGVmdCIsInplcm9zIiwiaW50VG9CdWZmZXIiLCJpbnRUb0hleCIsImV4dGVybmFsc18xIiwicmVxdWlyZSIsImludGVybmFsXzEiLCJoZWxwZXJzXzEiLCJpIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwidG9TdHJpbmciLCJoZXgiLCJCdWZmZXIiLCJmcm9tIiwicGFkVG9FdmVuIiwic2xpY2UiLCJieXRlcyIsImFsbG9jVW5zYWZlIiwiZmlsbCIsInNldExlbmd0aCIsIm1zZyIsImxlbmd0aCIsInJpZ2h0IiwiYnVmIiwiY29weSIsImFzc2VydElzQnVmZmVyIiwic3RyaXBaZXJvcyIsImEiLCJmaXJzdCIsImFzc2VydElzQXJyYXkiLCJhc3NlcnRJc0hleFN0cmluZyIsInN0cmlwSGV4UHJlZml4IiwidiIsInVuZGVmaW5lZCIsImlzQnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5IiwiVWludDhBcnJheSIsImlzSGV4U3RyaW5nIiwiQk4iLCJpc0JOIiwiaXNOZWciLCJ0b0FycmF5TGlrZSIsInRvQXJyYXkiLCJ0b051bWJlciIsIm51bSIsImZyb21Ud29zIiwidG9Ud29zIiwic3RyIiwiaXNIZXhQcmVmaXhlZCIsInplcm9zUmVnZXhwIiwiYnVmZmVyVmFsIiwicmVwbGFjZSIsImJhIiwiYXJyYXkiLCJwdXNoIiwidmFsdWVzIiwiayIsImVudHJpZXMiLCJhcnIiLCJtYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/constants.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\n/**\n * 2^64-1\n */ exports.MAX_UINT64 = new externals_1.BN(\"ffffffffffffffff\", 16);\n/**\n * The max integer that the evm can handle (2^256-1)\n */ exports.MAX_INTEGER = new externals_1.BN(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n/**\n * 2^256\n */ exports.TWO_POW256 = new externals_1.BN(\"10000000000000000000000000000000000000000000000000000000000000000\", 16);\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, \"hex\"); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDek8sTUFBTVcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekM7O0NBRUMsR0FDRFosa0JBQWtCLEdBQUcsSUFBSWEsWUFBWUMsRUFBRSxDQUFDLG9CQUFvQjtBQUM1RDs7Q0FFQyxHQUNEZCxtQkFBbUIsR0FBRyxJQUFJYSxZQUFZQyxFQUFFLENBQUMsb0VBQW9FO0FBQzdHOztDQUVDLEdBQ0RkLGtCQUFrQixHQUFHLElBQUlhLFlBQVlDLEVBQUUsQ0FBQyxxRUFBcUU7QUFDN0c7O0NBRUMsR0FDRGQsd0JBQXdCLEdBQUc7QUFDM0I7O0NBRUMsR0FDREEsc0JBQXNCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUU8sZ0JBQWdCLEVBQUU7QUFDeEU7O0NBRUMsR0FDRFAsNkJBQTZCLEdBQUc7QUFDaEM7O0NBRUMsR0FDREEsMkJBQTJCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUUsscUJBQXFCLEVBQUU7QUFDbEY7O0NBRUMsR0FDREwsdUJBQXVCLEdBQUc7QUFDMUI7O0NBRUMsR0FDREEscUJBQXFCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUUcsZUFBZSxFQUFFLFFBQ3RFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2NvbnN0YW50cy5qcz9jMTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gZXhwb3J0cy5NQVhfVUlOVDY0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG4vKipcbiAqIDJeNjQtMVxuICovXG5leHBvcnRzLk1BWF9VSU5UNjQgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJ2ZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoZSBldm0gY2FuIGhhbmRsZSAoMl4yNTYtMSlcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IGV4dGVybmFsc18xLkJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5XG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiS0VDQ0FLMjU2X1JMUCIsIktFQ0NBSzI1Nl9STFBfUyIsIktFQ0NBSzI1Nl9STFBfQVJSQVkiLCJLRUNDQUsyNTZfUkxQX0FSUkFZX1MiLCJLRUNDQUsyNTZfTlVMTCIsIktFQ0NBSzI1Nl9OVUxMX1MiLCJUV09fUE9XMjU2IiwiTUFYX0lOVEVHRVIiLCJNQVhfVUlOVDY0IiwiYnVmZmVyXzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJCTiIsIkJ1ZmZlciIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/externals.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/externals.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlp = exports.BN = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nexports.BN = bn_js_1.default;\nconst rlp = __importStar(__webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\"));\nexports.rlp = rlp; //# sourceMappingURL=externals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvZXh0ZXJuYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Q0FJQyxHQUNELElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsSUFBSyxJQUFJLElBQUksQ0FBQ0Esa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLElBQUssSUFBSSxJQUFJLENBQUNBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0EsSUFBSUksa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVTCxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSVYsVUFBVSxHQUFJVSxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBbkIsOENBQTZDO0lBQUVpQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdEUSxXQUFXLEdBQUdBLFVBQVUsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFVBQVVKLGdCQUFnQkssbUJBQU9BLENBQUMsbURBQU87QUFDL0NKLFVBQVUsR0FBR0csUUFBUUUsT0FBTztBQUM1QixNQUFNSixNQUFNUixhQUFhVyxtQkFBT0EsQ0FBQyxtREFBSztBQUN0Q0osV0FBVyxHQUFHQyxLQUNkLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2V4dGVybmFscy5qcz9jODQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZS1leHBvcnRzIGNvbW1vbmx5IHVzZWQgbW9kdWxlczpcbiAqICogRXhwb3J0cyBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpLCBbYHJscGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscCkuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5leHBvcnRzLkJOID0gYm5fanNfMS5kZWZhdWx0O1xuY29uc3QgcmxwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJybHBcIikpO1xuZXhwb3J0cy5ybHAgPSBybHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlcm5hbHMuanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJybHAiLCJCTiIsImJuX2pzXzEiLCJyZXF1aXJlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/externals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/hash.js":
/*!***************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/hash.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */ const keccak = function(a, bits = 256) {\n    (0, helpers_1.assertIsBuffer)(a);\n    switch(bits){\n        case 224:\n            {\n                return (0, keccak_1.keccak224)(a);\n            }\n        case 256:\n            {\n                return (0, keccak_1.keccak256)(a);\n            }\n        case 384:\n            {\n                return (0, keccak_1.keccak384)(a);\n            }\n        case 512:\n            {\n                return (0, keccak_1.keccak512)(a);\n            }\n        default:\n            {\n                throw new Error(`Invald algorithm: keccak${bits}`);\n            }\n    }\n};\nexports.keccak = keccak;\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */ const keccak256 = function(a) {\n    return (0, exports.keccak)(a);\n};\nexports.keccak256 = keccak256;\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromString = function(a, bits = 256) {\n    (0, helpers_1.assertIsString)(a);\n    const buf = Buffer.from(a, \"utf8\");\n    return (0, exports.keccak)(buf, bits);\n};\nexports.keccakFromString = keccakFromString;\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromHexString = function(a, bits = 256) {\n    (0, helpers_1.assertIsHexString)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromHexString = keccakFromHexString;\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */ const keccakFromArray = function(a, bits = 256) {\n    (0, helpers_1.assertIsArray)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromArray = keccakFromArray;\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */ const _sha256 = function(a) {\n    a = (0, bytes_1.toBuffer)(a);\n    return createHash(\"sha256\").update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */ const sha256 = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _sha256(a);\n};\nexports.sha256 = sha256;\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */ const sha256FromString = function(a) {\n    (0, helpers_1.assertIsString)(a);\n    return _sha256(a);\n};\nexports.sha256FromString = sha256FromString;\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */ const sha256FromArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return _sha256(a);\n};\nexports.sha256FromArray = sha256FromArray;\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */ const _ripemd160 = function(a, padded) {\n    a = (0, bytes_1.toBuffer)(a);\n    const hash = createHash(\"rmd160\").update(a).digest();\n    if (padded === true) {\n        return (0, bytes_1.setLengthLeft)(hash, 32);\n    } else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160 = function(a, padded) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160 = ripemd160;\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromString = function(a, padded) {\n    (0, helpers_1.assertIsString)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromString = ripemd160FromString;\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromArray = function(a, padded) {\n    (0, helpers_1.assertIsArray)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromArray = ripemd160FromArray;\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */ const rlphash = function(a) {\n    return (0, exports.keccak)(externals_1.rlp.encode(a));\n};\nexports.rlphash = rlphash; //# sourceMappingURL=hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EsMkJBQTJCLEdBQUdBLGlCQUFpQixHQUFHQSx1QkFBdUIsR0FBR0Esd0JBQXdCLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3BTLE1BQU1jLFdBQVdDLG1CQUFPQSxDQUFDLDBGQUE4QjtBQUN2RCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQzs7OztDQUlDLEdBQ0QsTUFBTUYsU0FBUyxTQUFVTyxDQUFDLEVBQUVDLE9BQU8sR0FBRztJQUNqQyxJQUFHRixVQUFVRyxjQUFjLEVBQUVGO0lBQzlCLE9BQVFDO1FBQ0osS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHUCxTQUFTUyxTQUFTLEVBQUVIO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTRixTQUFTLEVBQUVRO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTVSxTQUFTLEVBQUVKO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTVyxTQUFTLEVBQUVMO1lBQ25DO1FBQ0E7WUFBUztnQkFDTCxNQUFNLElBQUlNLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUwsS0FBSyxDQUFDO1lBQ3JEO0lBQ0o7QUFDSjtBQUNBckIsY0FBYyxHQUFHYTtBQUNqQjs7O0NBR0MsR0FDRCxNQUFNRCxZQUFZLFNBQVVRLENBQUM7SUFDekIsT0FBTyxDQUFDLEdBQUdwQixRQUFRYSxNQUFNLEVBQUVPO0FBQy9CO0FBQ0FwQixpQkFBaUIsR0FBR1k7QUFDcEI7Ozs7Q0FJQyxHQUNELE1BQU1ELG1CQUFtQixTQUFVUyxDQUFDLEVBQUVDLE9BQU8sR0FBRztJQUMzQyxJQUFHRixVQUFVUSxjQUFjLEVBQUVQO0lBQzlCLE1BQU1RLE1BQU1DLE9BQU9DLElBQUksQ0FBQ1YsR0FBRztJQUMzQixPQUFPLENBQUMsR0FBR3BCLFFBQVFhLE1BQU0sRUFBRWUsS0FBS1A7QUFDcEM7QUFDQXJCLHdCQUF3QixHQUFHVztBQUMzQjs7OztDQUlDLEdBQ0QsTUFBTUQsc0JBQXNCLFNBQVVVLENBQUMsRUFBRUMsT0FBTyxHQUFHO0lBQzlDLElBQUdGLFVBQVVZLGlCQUFpQixFQUFFWDtJQUNqQyxPQUFPLENBQUMsR0FBR3BCLFFBQVFhLE1BQU0sRUFBRSxDQUFDLEdBQUdLLFFBQVFjLFFBQVEsRUFBRVosSUFBSUM7QUFDekQ7QUFDQXJCLDJCQUEyQixHQUFHVTtBQUM5Qjs7OztDQUlDLEdBQ0QsTUFBTUQsa0JBQWtCLFNBQVVXLENBQUMsRUFBRUMsT0FBTyxHQUFHO0lBQzFDLElBQUdGLFVBQVVjLGFBQWEsRUFBRWI7SUFDN0IsT0FBTyxDQUFDLEdBQUdwQixRQUFRYSxNQUFNLEVBQUUsQ0FBQyxHQUFHSyxRQUFRYyxRQUFRLEVBQUVaLElBQUlDO0FBQ3pEO0FBQ0FyQix1QkFBdUIsR0FBR1M7QUFDMUI7OztDQUdDLEdBQ0QsTUFBTXlCLFVBQVUsU0FBVWQsQ0FBQztJQUN2QkEsSUFBSSxDQUFDLEdBQUdGLFFBQVFjLFFBQVEsRUFBRVo7SUFDMUIsT0FBT0osV0FBVyxVQUFVbUIsTUFBTSxDQUFDZixHQUFHZ0IsTUFBTTtBQUNoRDtBQUNBOzs7Q0FHQyxHQUNELE1BQU01QixTQUFTLFNBQVVZLENBQUM7SUFDckIsSUFBR0QsVUFBVUcsY0FBYyxFQUFFRjtJQUM5QixPQUFPYyxRQUFRZDtBQUNuQjtBQUNBcEIsY0FBYyxHQUFHUTtBQUNqQjs7O0NBR0MsR0FDRCxNQUFNRCxtQkFBbUIsU0FBVWEsQ0FBQztJQUMvQixJQUFHRCxVQUFVUSxjQUFjLEVBQUVQO0lBQzlCLE9BQU9jLFFBQVFkO0FBQ25CO0FBQ0FwQix3QkFBd0IsR0FBR087QUFDM0I7OztDQUdDLEdBQ0QsTUFBTUQsa0JBQWtCLFNBQVVjLENBQUM7SUFDOUIsSUFBR0QsVUFBVWMsYUFBYSxFQUFFYjtJQUM3QixPQUFPYyxRQUFRZDtBQUNuQjtBQUNBcEIsdUJBQXVCLEdBQUdNO0FBQzFCOzs7O0NBSUMsR0FDRCxNQUFNK0IsYUFBYSxTQUFVakIsQ0FBQyxFQUFFa0IsTUFBTTtJQUNsQ2xCLElBQUksQ0FBQyxHQUFHRixRQUFRYyxRQUFRLEVBQUVaO0lBQzFCLE1BQU1tQixPQUFPdkIsV0FBVyxVQUFVbUIsTUFBTSxDQUFDZixHQUFHZ0IsTUFBTTtJQUNsRCxJQUFJRSxXQUFXLE1BQU07UUFDakIsT0FBTyxDQUFDLEdBQUdwQixRQUFRc0IsYUFBYSxFQUFFRCxNQUFNO0lBQzVDLE9BQ0s7UUFDRCxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTWxDLFlBQVksU0FBVWUsQ0FBQyxFQUFFa0IsTUFBTTtJQUNoQyxJQUFHbkIsVUFBVUcsY0FBYyxFQUFFRjtJQUM5QixPQUFPaUIsV0FBV2pCLEdBQUdrQjtBQUN6QjtBQUNBdEMsaUJBQWlCLEdBQUdLO0FBQ3BCOzs7O0NBSUMsR0FDRCxNQUFNRCxzQkFBc0IsU0FBVWdCLENBQUMsRUFBRWtCLE1BQU07SUFDMUMsSUFBR25CLFVBQVVRLGNBQWMsRUFBRVA7SUFDOUIsT0FBT2lCLFdBQVdqQixHQUFHa0I7QUFDekI7QUFDQXRDLDJCQUEyQixHQUFHSTtBQUM5Qjs7OztDQUlDLEdBQ0QsTUFBTUQscUJBQXFCLFNBQVVpQixDQUFDLEVBQUVrQixNQUFNO0lBQ3pDLElBQUduQixVQUFVYyxhQUFhLEVBQUViO0lBQzdCLE9BQU9pQixXQUFXakIsR0FBR2tCO0FBQ3pCO0FBQ0F0QywwQkFBMEIsR0FBR0c7QUFDN0I7OztDQUdDLEdBQ0QsTUFBTUQsVUFBVSxTQUFVa0IsQ0FBQztJQUN2QixPQUFPLENBQUMsR0FBR3BCLFFBQVFhLE1BQU0sRUFBRUksWUFBWXdCLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDdEI7QUFDdEQ7QUFDQXBCLGVBQWUsR0FBR0UsU0FDbEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcz9jOWEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ybHBoYXNoID0gZXhwb3J0cy5yaXBlbWQxNjBGcm9tQXJyYXkgPSBleHBvcnRzLnJpcGVtZDE2MEZyb21TdHJpbmcgPSBleHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMuc2hhMjU2RnJvbUFycmF5ID0gZXhwb3J0cy5zaGEyNTZGcm9tU3RyaW5nID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLmtlY2Nha0Zyb21BcnJheSA9IGV4cG9ydHMua2VjY2FrRnJvbUhleFN0cmluZyA9IGV4cG9ydHMua2VjY2FrRnJvbVN0cmluZyA9IGV4cG9ydHMua2VjY2FrMjU2ID0gZXhwb3J0cy5rZWNjYWsgPSB2b2lkIDA7XG5jb25zdCBrZWNjYWtfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrXCIpO1xuY29uc3QgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSBCdWZmZXIgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmNvbnN0IGtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgIGNhc2UgMjI0OiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazIyNCkoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNTY6IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDM4NDoge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWtfMS5rZWNjYWszODQpKGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTEyOiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazUxMikoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWske2JpdHN9YCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5rZWNjYWsgPSBrZWNjYWs7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpLlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqL1xuY29uc3Qga2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShhKTtcbn07XG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1Njtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIHV0Zi04IHN0cmluZyBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKFN0cmluZylcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuY29uc3Qga2VjY2FrRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoYSk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oYSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShidWYsIGJpdHMpO1xufTtcbmV4cG9ydHMua2VjY2FrRnJvbVN0cmluZyA9IGtlY2Nha0Zyb21TdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYW4gMHgtcHJlZml4ZWQgc3RyaW5nIGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoU3RyaW5nKVxuICogQHBhcmFtIGJpdHMgKG51bWJlciA9IDI1NikgVGhlIEtlY2NhayB3aWR0aFxuICovXG5jb25zdCBrZWNjYWtGcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gKGEsIGJpdHMgPSAyNTYpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKShhKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSksIGJpdHMpO1xufTtcbmV4cG9ydHMua2VjY2FrRnJvbUhleFN0cmluZyA9IGtlY2Nha0Zyb21IZXhTdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSBudW1iZXIgYXJyYXkgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuY29uc3Qga2VjY2FrRnJvbUFycmF5ID0gZnVuY3Rpb24gKGEsIGJpdHMgPSAyNTYpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5rZWNjYWspKCgwLCBieXRlc18xLnRvQnVmZmVyKShhKSwgYml0cyk7XG59O1xuZXhwb3J0cy5rZWNjYWtGcm9tQXJyYXkgPSBrZWNjYWtGcm9tQXJyYXk7XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYW4gaW5wdXQuXG4gKiBAcGFyYW0gIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSk7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYSBCdWZmZXIgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxuICovXG5jb25zdCBzaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHJldHVybiBfc2hhMjU2KGEpO1xufTtcbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgc3RyaW5nIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKHN0cmluZylcbiAqL1xuY29uc3Qgc2hhMjU2RnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuZXhwb3J0cy5zaGEyNTZGcm9tU3RyaW5nID0gc2hhMjU2RnJvbVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhIG51bWJlcltdIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKG51bWJlcltdKVxuICovXG5jb25zdCBzaGEyNTZGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuZXhwb3J0cy5zaGEyNTZGcm9tQXJyYXkgPSBzaGEyNTZGcm9tQXJyYXk7XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IF9yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgYSA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShhKTtcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICAgIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKGhhc2gsIDMyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBCdWZmZXIgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IHJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICByZXR1cm4gX3JpcGVtZDE2MChhLCBwYWRkZWQpO1xufTtcbmV4cG9ydHMucmlwZW1kMTYwID0gcmlwZW1kMTYwO1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIGEgc3RyaW5nIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKFN0cmluZylcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5jb25zdCByaXBlbWQxNjBGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGEpO1xuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XG59O1xuZXhwb3J0cy5yaXBlbWQxNjBGcm9tU3RyaW5nID0gcmlwZW1kMTYwRnJvbVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiBhIG51bWJlcltdIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKG51bWJlcltdKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmNvbnN0IHJpcGVtZDE2MEZyb21BcnJheSA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiBfcmlwZW1kMTYwKGEsIHBhZGRlZCk7XG59O1xuZXhwb3J0cy5yaXBlbWQxNjBGcm9tQXJyYXkgPSByaXBlbWQxNjBGcm9tQXJyYXk7XG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgaGFzaCBvZiB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YVxuICovXG5jb25zdCBybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKShleHRlcm5hbHNfMS5ybHAuZW5jb2RlKGEpKTtcbn07XG5leHBvcnRzLnJscGhhc2ggPSBybHBoYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJybHBoYXNoIiwicmlwZW1kMTYwRnJvbUFycmF5IiwicmlwZW1kMTYwRnJvbVN0cmluZyIsInJpcGVtZDE2MCIsInNoYTI1NkZyb21BcnJheSIsInNoYTI1NkZyb21TdHJpbmciLCJzaGEyNTYiLCJrZWNjYWtGcm9tQXJyYXkiLCJrZWNjYWtGcm9tSGV4U3RyaW5nIiwia2VjY2FrRnJvbVN0cmluZyIsImtlY2NhazI1NiIsImtlY2NhayIsImtlY2Nha18xIiwicmVxdWlyZSIsImNyZWF0ZUhhc2giLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJoZWxwZXJzXzEiLCJhIiwiYml0cyIsImFzc2VydElzQnVmZmVyIiwia2VjY2FrMjI0Iiwia2VjY2FrMzg0Iiwia2VjY2FrNTEyIiwiRXJyb3IiLCJhc3NlcnRJc1N0cmluZyIsImJ1ZiIsIkJ1ZmZlciIsImZyb20iLCJhc3NlcnRJc0hleFN0cmluZyIsInRvQnVmZmVyIiwiYXNzZXJ0SXNBcnJheSIsIl9zaGEyNTYiLCJ1cGRhdGUiLCJkaWdlc3QiLCJfcmlwZW1kMTYwIiwicGFkZGVkIiwiaGFzaCIsInNldExlbmd0aExlZnQiLCJybHAiLCJlbmNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/helpers.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/helpers.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */ const assertIsHexString = function(input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */ const assertIsBuffer = function(input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */ const assertIsArray = function(input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */ const assertIsString = function(input) {\n    if (typeof input !== \"string\") {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMzRyxNQUFNTSxhQUFhQyxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN2Qzs7O0NBR0MsR0FDRCxNQUFNRixvQkFBb0IsU0FBVUcsS0FBSztJQUNyQyxJQUFJLENBQUMsQ0FBQyxHQUFHRixXQUFXRyxXQUFXLEVBQUVELFFBQVE7UUFDckMsTUFBTUUsTUFBTSxDQUFDLGlFQUFpRSxFQUFFRixNQUFNLENBQUM7UUFDdkYsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHlCQUF5QixHQUFHSztBQUM1Qjs7O0NBR0MsR0FDRCxNQUFNRCxpQkFBaUIsU0FBVUksS0FBSztJQUNsQyxJQUFJLENBQUNJLE9BQU9DLFFBQVEsQ0FBQ0wsUUFBUTtRQUN6QixNQUFNRSxNQUFNLENBQUMsZ0RBQWdELEVBQUVGLE1BQU0sQ0FBQztRQUN0RSxNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYsc0JBQXNCLEdBQUdJO0FBQ3pCOzs7Q0FHQyxHQUNELE1BQU1ELGdCQUFnQixTQUFVSyxLQUFLO0lBQ2pDLElBQUksQ0FBQ00sTUFBTUMsT0FBTyxDQUFDUCxRQUFRO1FBQ3ZCLE1BQU1FLE1BQU0sQ0FBQyx1REFBdUQsRUFBRUYsTUFBTSxDQUFDO1FBQzdFLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVixxQkFBcUIsR0FBR0c7QUFDeEI7OztDQUdDLEdBQ0QsTUFBTUQsaUJBQWlCLFNBQVVNLEtBQUs7SUFDbEMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsTUFBTUUsTUFBTSxDQUFDLGlEQUFpRCxFQUFFRixNQUFNLENBQUM7UUFDdkUsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHNCQUFzQixHQUFHRSxnQkFDekIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGVscGVycy5qcz80YmVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRJc1N0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNBcnJheSA9IGV4cG9ydHMuYXNzZXJ0SXNCdWZmZXIgPSBleHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gdm9pZCAwO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuLyoqXG4gKiBUaHJvd3MgaWYgYSBzdHJpbmcgaXMgbm90IGhleCBwcmVmaXhlZFxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHN0cmluZyB0byBjaGVjayBoZXggcHJlZml4IG9mXG4gKi9cbmNvbnN0IGFzc2VydElzSGV4U3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCEoMCwgaW50ZXJuYWxfMS5pc0hleFN0cmluZykoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBhc3NlcnRJc0hleFN0cmluZztcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhIGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0IHZhbHVlIHRvIGNoZWNrXG4gKi9cbmNvbnN0IGFzc2VydElzQnVmZmVyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIEJ1ZmZlciBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzQnVmZmVyID0gYXNzZXJ0SXNCdWZmZXI7XG4vKipcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyW119IGlucHV0IHZhbHVlIHRvIGNoZWNrXG4gKi9cbmNvbnN0IGFzc2VydElzQXJyYXkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIG51bWJlciBhcnJheXMgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0FycmF5ID0gYXNzZXJ0SXNBcnJheTtcbi8qKlxuICogVGhyb3dzIGlmIGlucHV0IGlzIG5vdCBhIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHZhbHVlIHRvIGNoZWNrXG4gKi9cbmNvbnN0IGFzc2VydElzU3RyaW5nID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoaXMgbWV0aG9kIG9ubHkgc3VwcG9ydHMgc3RyaW5ncyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzU3RyaW5nID0gYXNzZXJ0SXNTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFzc2VydElzU3RyaW5nIiwiYXNzZXJ0SXNBcnJheSIsImFzc2VydElzQnVmZmVyIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJpbnRlcm5hbF8xIiwicmVxdWlyZSIsImlucHV0IiwiaXNIZXhTdHJpbmciLCJtc2ciLCJFcnJvciIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiQXJyYXkiLCJpc0FycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-util/dist/constants.js\"), exports);\n/**\n * Account class and helper functions\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-util/dist/account.js\"), exports);\n/**\n * Address type\n */ __exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/ethereumjs-util/dist/address.js\"), exports);\n/**\n * Hash functions\n */ __exportStar(__webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/ethereumjs-util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\"), exports);\n/**\n * Function for definining properties on an object\n */ __exportStar(__webpack_require__(/*! ./object */ \"(ssr)/./node_modules/ethereumjs-util/dist/object.js\"), exports);\n/**\n * External exports (BN, rlp)\n */ __exportStar(__webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\"), exports);\n/**\n * Helpful TypeScript types\n */ __exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\"), exports);\n/**\n * Export ethjs-util methods\n */ var internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nObject.defineProperty(exports, \"isHexPrefixed\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexPrefixed;\n    }\n}));\nObject.defineProperty(exports, \"stripHexPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.stripHexPrefix;\n    }\n}));\nObject.defineProperty(exports, \"padToEven\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.padToEven;\n    }\n}));\nObject.defineProperty(exports, \"getBinarySize\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getBinarySize;\n    }\n}));\nObject.defineProperty(exports, \"arrayContainsArray\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.arrayContainsArray;\n    }\n}));\nObject.defineProperty(exports, \"toAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.toAscii;\n    }\n}));\nObject.defineProperty(exports, \"fromUtf8\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromUtf8;\n    }\n}));\nObject.defineProperty(exports, \"fromAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromAscii;\n    }\n}));\nObject.defineProperty(exports, \"getKeys\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getKeys;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexString;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxJQUFLLElBQUksSUFBSSxDQUFDQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REwsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxlQUFlLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ2hPOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywyRUFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLHVFQUFXLEdBQUdoQjtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsdUVBQVcsR0FBR2hCO0FBQ25DOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyxpRUFBUSxHQUFHaEI7QUFDaEM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLDJFQUFhLEdBQUdoQjtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsbUVBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyxxRUFBVSxHQUFHaEI7QUFDbEM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLDJFQUFhLEdBQUdoQjtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsbUVBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0QsSUFBSWlCLGFBQWFELG1CQUFPQSxDQUFDLHlFQUFZO0FBQ3JDaEMsaURBQWdEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXRixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDNUgvQixrREFBaUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdILGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SDlCLDZDQUE0QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0osU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIN0IsaURBQWdEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXTCxhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDNUg1QixzREFBcUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdOLGtCQUFrQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RJM0IsMkNBQTBDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXUCxPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDaEgxQiw0Q0FBMkM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdSLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSHpCLDZDQUE0QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1QsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIeEIsMkNBQTBDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXVixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDaEh2QiwrQ0FBOEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdYLFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUN4SCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcz8wOGJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRLZXlzID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy50b0FzY2lpID0gZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSB2b2lkIDA7XG4vKipcbiAqIENvbnN0YW50c1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogQWNjb3VudCBjbGFzcyBhbmQgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWNjb3VudFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEFkZHJlc3MgdHlwZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhhc2ggZnVuY3Rpb25zXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oYXNoXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRUNEU0Egc2lnbmF0dXJlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduYXR1cmVcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBCdWZmZXJzLCBieXRlIGFycmF5cywgZXRjLlxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBGdW5jdGlvbiBmb3IgZGVmaW5pbmluZyBwcm9wZXJ0aWVzIG9uIGFuIG9iamVjdFxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JqZWN0XCIpLCBleHBvcnRzKTtcbi8qKlxuICogRXh0ZXJuYWwgZXhwb3J0cyAoQk4sIHJscClcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhlbHBmdWwgVHlwZVNjcmlwdCB0eXBlc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFeHBvcnQgZXRoanMtdXRpbCBtZXRob2RzXG4gKi9cbnZhciBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleFByZWZpeGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmlzSGV4UHJlZml4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpcEhleFByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhZFRvRXZlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5wYWRUb0V2ZW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaW5hcnlTaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmdldEJpbmFyeVNpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheUNvbnRhaW5zQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuYXJyYXlDb250YWluc0FycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Bc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS50b0FzY2lpOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbVV0ZjhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZnJvbVV0Zjg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tQXNjaWlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZnJvbUFzY2lpOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0S2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRLZXlzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhTdHJpbmc7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsImlzSGV4U3RyaW5nIiwiZ2V0S2V5cyIsImZyb21Bc2NpaSIsImZyb21VdGY4IiwidG9Bc2NpaSIsImFycmF5Q29udGFpbnNBcnJheSIsImdldEJpbmFyeVNpemUiLCJwYWRUb0V2ZW4iLCJzdHJpcEhleFByZWZpeCIsImlzSGV4UHJlZml4ZWQiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/internal.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/internal.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */ function isHexPrefixed(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === \"0\" && str[1] === \"x\";\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */ const stripHexPrefix = (str)=>{\n    if (typeof str !== \"string\") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */ function padToEven(value) {\n    let a = value;\n    if (typeof a !== \"string\") {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2) a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */ function getBinarySize(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[getBinarySize] method requires input type 'string', recieved ${typeof str}`);\n    }\n    return Buffer.byteLength(str, \"utf8\");\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */ function arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some ? \"some\" : \"every\"]((value)=>superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */ function toAscii(hex) {\n    let str = \"\";\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") i = 2;\n    for(; i < l; i += 2){\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */ function fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, \"utf8\");\n    return `0x${padToEven(str.toString(\"hex\")).replace(/^0+|0+$/g, \"\")}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */ function fromAscii(stringValue) {\n    let hex = \"\";\n    for(let i = 0; i < stringValue.length; i++){\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */ function getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for(let i = 0; i < params.length; i++){\n        let value = params[i][key];\n        if (allowEmpty && !value) {\n            value = \"\";\n        } else if (typeof value !== \"string\") {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n    if (length && value.length !== 2 + 2 * length) return false;\n    return true;\n}\nexports.isHexString = isHexString; //# sourceMappingURL=internal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxlQUFlLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ2hPOzs7OztDQUtDLEdBQ0QsU0FBU1csY0FBY0MsR0FBRztJQUN0QixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QixNQUFNLElBQUlDLE1BQU0sQ0FBQywyREFBMkQsRUFBRSxPQUFPRCxJQUFJLENBQUM7SUFDOUY7SUFDQSxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUs7QUFDeEM7QUFDQVoscUJBQXFCLEdBQUdXO0FBQ3hCOzs7O0NBSUMsR0FDRCxNQUFNRCxpQkFBaUIsQ0FBQ0U7SUFDcEIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJQyxNQUFNLENBQUMsdURBQXVELEVBQUUsT0FBT0QsSUFBSSxDQUFDO0lBQzFGLE9BQU9ELGNBQWNDLE9BQU9BLElBQUlFLEtBQUssQ0FBQyxLQUFLRjtBQUMvQztBQUNBWixzQkFBc0IsR0FBR1U7QUFDekI7Ozs7Q0FJQyxHQUNELFNBQVNELFVBQVVSLEtBQUs7SUFDcEIsSUFBSWMsSUFBSWQ7SUFDUixJQUFJLE9BQU9jLE1BQU0sVUFBVTtRQUN2QixNQUFNLElBQUlGLE1BQU0sQ0FBQyxrREFBa0QsRUFBRSxPQUFPRSxFQUFFLENBQUM7SUFDbkY7SUFDQSxJQUFJQSxFQUFFQyxNQUFNLEdBQUcsR0FDWEQsSUFBSSxDQUFDLENBQUMsRUFBRUEsRUFBRSxDQUFDO0lB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YyxDQUFDekMsT0FBTztZQUN0QkEsUUFBUTtRQUNaLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDaEMsTUFBTSxJQUFJWSxNQUFNLENBQUMsK0NBQStDLEVBQUUsT0FBT1osTUFBTSxDQUFDO1FBQ3BGO1FBQ0EwQyxPQUFPQyxJQUFJLENBQUMzQztJQUNoQjtJQUNBLE9BQU8wQztBQUNYO0FBQ0EzQyxlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFlBQVlELEtBQUssRUFBRWUsTUFBTTtJQUM5QixJQUFJLE9BQU9mLFVBQVUsWUFBWSxDQUFDQSxNQUFNNEMsS0FBSyxDQUFDLHFCQUMxQyxPQUFPO0lBQ1gsSUFBSTdCLFVBQVVmLE1BQU1lLE1BQU0sS0FBSyxJQUFJLElBQUlBLFFBQ25DLE9BQU87SUFDWCxPQUFPO0FBQ1g7QUFDQWhCLG1CQUFtQixHQUFHRSxhQUN0QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbnRlcm5hbC5qcz8wZmY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcblRoZSBNSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTYgTmljayBEb2Rzb24uIG5pY2tkb2Rzb24uY29tXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5nZXRLZXlzID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy50b0FzY2lpID0gZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSB2b2lkIDA7XG4vKipcbiAqIFJldHVybnMgYSBgQm9vbGVhbmAgb24gd2hldGhlciBvciBub3QgdGhlIGEgYFN0cmluZ2Agc3RhcnRzIHdpdGggJzB4J1xuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJuIGEgYm9vbGVhbiBpZiBpdCBpcyBvciBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAdGhyb3dzIGlmIHRoZSBzdHIgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2lzSGV4UHJlZml4ZWRdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJbMF0gPT09ICcwJyAmJiBzdHJbMV0gPT09ICd4Jztcbn1cbmV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IGlzSGV4UHJlZml4ZWQ7XG4vKipcbiAqIFJlbW92ZXMgJzB4JyBmcm9tIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgcHJlc2VudFxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHZhbHVlXG4gKiBAcmV0dXJucyB0aGUgc3RyaW5nIHdpdGhvdXQgMHggcHJlZml4XG4gKi9cbmNvbnN0IHN0cmlwSGV4UHJlZml4ID0gKHN0cikgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbc3RyaXBIZXhQcmVmaXhdIGlucHV0IG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59O1xuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgICBsZXQgYSA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbcGFkVG9FdmVuXSB2YWx1ZSBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIGF9YCk7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAlIDIpXG4gICAgICAgIGEgPSBgMCR7YX1gO1xuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5wYWRUb0V2ZW4gPSBwYWRUb0V2ZW47XG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEJpbmFyeVNpemVdIG1ldGhvZCByZXF1aXJlcyBpbnB1dCB0eXBlICdzdHJpbmcnLCByZWNpZXZlZCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5leHBvcnRzLmdldEJpbmFyeVNpemUgPSBnZXRCaW5hcnlTaXplO1xuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0gc3VwZXJzZXRcbiAqIEBwYXJhbSBzdWJzZXRcbiAqXG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdXBlcnNldCcgdG8gYmUgYW4gYXJyYXksIGdvdCB0eXBlICcke3R5cGVvZiBzdXBlcnNldH0nYCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYXJyYXlDb250YWluc0FycmF5XSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgJ3N1YnNldCcgdG8gYmUgYW4gYXJyYXksIGdvdCB0eXBlICcke3R5cGVvZiBzdWJzZXR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2V0W3NvbWUgPyAnc29tZScgOiAnZXZlcnknXSgodmFsdWUpID0+IHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDApO1xufVxuZXhwb3J0cy5hcnJheUNvbnRhaW5zQXJyYXkgPSBhcnJheUNvbnRhaW5zQXJyYXk7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXRzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4JylcbiAgICAgICAgaSA9IDI7XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnRvQXNjaWkgPSB0b0FzY2lpO1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHJpbmdcbiAqIEBwYXJhbSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gICAgY29uc3Qgc3RyID0gQnVmZmVyLmZyb20oc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG4gICAgcmV0dXJuIGAweCR7cGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpfWA7XG59XG5leHBvcnRzLmZyb21VdGY4ID0gZnJvbVV0Zjg7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBwYXJhbSAgc3RyaW5nXG4gKiBAcGFyYW0gIG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zICBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjb25zdCBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyBgMCR7bn1gIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aGV4fWA7XG59XG5leHBvcnRzLmZyb21Bc2NpaSA9IGZyb21Bc2NpaTtcbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGdldEtleXMoW3thOiAnMScsIGI6ICcyJ30sIHthOiAnMycsIGI6ICc0J31dLCAnYScpID0+IFsnMScsICczJ11cbiAqYGBgYFxuICogQHBhcmFtICBwYXJhbXNcbiAqIEBwYXJhbSAga2V5XG4gKiBAcGFyYW0gIGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRLZXlzXSBtZXRob2QgZXhwZWN0cyBpbnB1dCAncGFyYW1zJyB0byBiZSBhbiBhcnJheSwgZ290ICR7dHlwZW9mIHBhcmFtc31gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdrZXknIHRvIGJlIHR5cGUgJ3N0cmluZycsIGdvdCAke3R5cGVvZiBwYXJhbXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldO1xuICAgICAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFiaSAtIGV4cGVjdGVkIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0S2V5cyA9IGdldEtleXM7XG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAgdmFsdWVcbiAqIEBwYXJhbSAgbGVuZ3RoXG4gKiBAcmV0dXJucyAgb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNIZXhTdHJpbmciLCJnZXRLZXlzIiwiZnJvbUFzY2lpIiwiZnJvbVV0ZjgiLCJ0b0FzY2lpIiwiYXJyYXlDb250YWluc0FycmF5IiwiZ2V0QmluYXJ5U2l6ZSIsInBhZFRvRXZlbiIsInN0cmlwSGV4UHJlZml4IiwiaXNIZXhQcmVmaXhlZCIsInN0ciIsIkVycm9yIiwic2xpY2UiLCJhIiwibGVuZ3RoIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsInN1cGVyc2V0Iiwic3Vic2V0Iiwic29tZSIsIkFycmF5IiwiaXNBcnJheSIsImluZGV4T2YiLCJoZXgiLCJpIiwibCIsInN1YnN0cmluZyIsImNvZGUiLCJwYXJzZUludCIsInN1YnN0ciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN0cmluZ1ZhbHVlIiwiZnJvbSIsInRvU3RyaW5nIiwicmVwbGFjZSIsImNoYXJDb2RlQXQiLCJuIiwicGFyYW1zIiwia2V5IiwiYWxsb3dFbXB0eSIsInJlc3VsdCIsInB1c2giLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/object.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/object.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defineProperties = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */ const defineProperties = function(self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function(label = false) {\n        if (label) {\n            const obj = {};\n            self._fields.forEach((field)=>{\n                obj[field] = `0x${self[field].toString(\"hex\")}`;\n            });\n            return obj;\n        }\n        return (0, bytes_1.baToJSON)(self.raw);\n    };\n    self.serialize = function serialize() {\n        return externals_1.rlp.encode(self.raw);\n    };\n    fields.forEach((field, i)=>{\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = (0, bytes_1.toBuffer)(v);\n            if (v.toString(\"hex\") === \"00\" && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = (0, bytes_1.unpadBuffer)(v);\n                (0, assert_1.default)(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);\n            } else if (!(field.allowZero && v.length === 0) && field.length) {\n                (0, assert_1.default)(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === \"string\") {\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), \"hex\");\n        }\n        if (Buffer.isBuffer(data)) {\n            data = externals_1.rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error(\"wrong number of fields in data\");\n            }\n            // make sure all the items are buffers\n            data.forEach((d, i)=>{\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n            });\n        } else if (typeof data === \"object\") {\n            const keys = Object.keys(data);\n            fields.forEach((field)=>{\n                if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n            });\n        } else {\n            throw new Error(\"invalid data\");\n        }\n    }\n};\nexports.defineProperties = defineProperties; //# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyxXQUFXUixnQkFBZ0JTLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHlFQUFZO0FBQ3ZDLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pDLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLG1FQUFTO0FBQ2pDOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNRixtQkFBbUIsU0FBVU0sSUFBSSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7SUFDakRGLEtBQUtHLEdBQUcsR0FBRyxFQUFFO0lBQ2JILEtBQUtJLE9BQU8sR0FBRyxFQUFFO0lBQ2pCLHNCQUFzQjtJQUN0QkosS0FBS0ssTUFBTSxHQUFHLFNBQVVDLFFBQVEsS0FBSztRQUNqQyxJQUFJQSxPQUFPO1lBQ1AsTUFBTUMsTUFBTSxDQUFDO1lBQ2JQLEtBQUtJLE9BQU8sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDO2dCQUNsQkYsR0FBRyxDQUFDRSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUVULElBQUksQ0FBQ1MsTUFBTSxDQUFDQyxRQUFRLENBQUMsT0FBTyxDQUFDO1lBQ25EO1lBQ0EsT0FBT0g7UUFDWDtRQUNBLE9BQU8sQ0FBQyxHQUFHUixRQUFRWSxRQUFRLEVBQUVYLEtBQUtHLEdBQUc7SUFDekM7SUFDQUgsS0FBS1ksU0FBUyxHQUFHLFNBQVNBO1FBQ3RCLE9BQU9kLFlBQVllLEdBQUcsQ0FB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QUFNUSxJQUFJLENBQUMsR0FBR2YsSUFBSSxDQUFDTyxNQUFNUSxJQUFJLENBQUM7Z0JBQ3ZDLElBQUl5QixLQUFLQyxPQUFPLENBQUNsQyxNQUFNd0IsS0FBSyxNQUFNLENBQUMsR0FDL0JqQyxJQUFJLENBQUNTLE1BQU13QixLQUFLLENBQUMsR0FBRy9CLElBQUksQ0FBQ08sTUFBTXdCLEtBQUssQ0FBQztZQUM3QztRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUlPLE1BQU07UUFDcEI7SUFDSjtBQUNKO0FBQ0FoRCx3QkFBd0IsR0FBR0Usa0JBQzNCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L29iamVjdC5qcz80ZDU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3QgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgICBzZWxmLnJhdyA9IFtdO1xuICAgIHNlbGYuX2ZpZWxkcyA9IFtdO1xuICAgIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBvYmpbZmllbGRdID0gYDB4JHtzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYmFUb0pTT04pKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxzXzEucmxwLmVuY29kZShzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQsIGkpID0+IHtcbiAgICAgICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgICAgICAgdiA9ICgwLCBieXRlc18xLnRvQnVmZmVyKSh2KTtcbiAgICAgICAgICAgIGlmICh2LnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwJyAmJiAhZmllbGQuYWxsb3daZXJvKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZC5hbGxvd0xlc3MgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdiA9ICgwLCBieXRlc18xLnVucGFkQnVmZmVyKSh2KTtcbiAgICAgICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCBgVGhlIGZpZWxkICR7ZmllbGQubmFtZX0gbXVzdCBub3QgaGF2ZSBtb3JlICR7ZmllbGQubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCBgVGhlIGZpZWxkICR7ZmllbGQubmFtZX0gbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICR7ZmllbGQubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICAgICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShkYXRhKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBleHRlcm5hbHNfMS5ybHAuZGVjb2RlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRhJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydF8xIiwicmVxdWlyZSIsImludGVybmFsXzEiLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJzZWxmIiwiZmllbGRzIiwiZGF0YSIsInJhdyIsIl9maWVsZHMiLCJ0b0pTT04iLCJsYWJlbCIsIm9iaiIsImZvckVhY2giLCJmaWVsZCIsInRvU3RyaW5nIiwiYmFUb0pTT04iLCJzZXJpYWxpemUiLCJybHAiLCJlbmNvZGUiLCJpIiwicHVzaCIsIm5hbWUiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJ2IiwidG9CdWZmZXIiLCJhbGxvd1plcm8iLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImFsbG93TGVzcyIsImxlbmd0aCIsInVucGFkQnVmZmVyIiwiZGVmYXVsdCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJzZXQiLCJhbGlhcyIsImZyb20iLCJzdHJpcEhleFByZWZpeCIsImlzQnVmZmVyIiwiZGVjb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJkIiwia2V5cyIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/signature.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/signature.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    const { signature, recid: recovery } = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey);\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === \"number\") {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n        }\n        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return {\n            r,\n            s,\n            v\n        };\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return {\n        r,\n        s,\n        v\n    };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    const vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (vBN.eqn(0) || vBN.eqn(1)) return (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    const rec = new externals_1.BN(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Recovered public key\n */ const ecrecover = function(msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32)\n    ], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);\n    return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toRpcSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32),\n        (0, bytes_1.toBuffer)(v)\n    ]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toCompactSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);\n    let ss = s;\n    if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(ss, 32)\n    ]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */ const fromRpcSig = function(sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(64));\n    } else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;\n        s[0] &= 0x7f;\n    } else {\n        throw new Error(\"Invalid signature length\");\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v,\n        r,\n        s\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {\n    const SECP256K1_N_DIV_2 = new externals_1.BN(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16);\n    const SECP256K1_N = new externals_1.BN(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBN = new externals_1.BN(r);\n    const sBN = new externals_1.BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ const hashPersonalMessage = function(message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, \"utf-8\");\n    return (0, hash_1.keccak)(Buffer.concat([\n        prefix,\n        message\n    ]));\n};\nexports.hashPersonalMessage = hashPersonalMessage; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUNsSyxNQUFNUyxjQUFjQyxtQkFBT0EsQ0FBQyxnR0FBaUM7QUFDN0QsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsaUVBQVE7QUFDL0IsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsdUVBQVc7QUFDckMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsU0FBU0YsT0FBT1EsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE9BQU87SUFDeEMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLE9BQU9DLFFBQVEsRUFBRSxHQUFHLENBQUMsR0FBR1osWUFBWWEsU0FBUyxFQUFFTixTQUFTQztJQUMzRSxNQUFNTSxJQUFJQyxPQUFPQyxJQUFJLENBQUNOLFVBQVVPLEtBQUssQ0FBQyxHQUFHO0lBQ3pDLE1BQU1DLElBQUlILE9BQU9DLElBQUksQ0FBQ04sVUFBVU8sS0FBSyxDQUFDLElBQUk7SUFDMUMsSUFBSSxDQUFDUixXQUFXLE9BQU9BLFlBQVksVUFBVTtRQUN6QywyR0FBMkc7UUFDM0csSUFBSUEsV0FBVyxDQUFDVSxPQUFPQyxhQUFhLENBQUNYLFVBQVU7WUFDM0MsTUFBTSxJQUFJWSxNQUFNO1FBQ3BCO1FBQ0EsTUFBTUMsSUFBSWIsVUFBVUcsV0FBWUgsQ0FBQUEsVUFBVSxJQUFJLEVBQUMsSUFBS0csV0FBVztRQUMvRCxPQUFPO1lBQUVFO1lBQUdJO1lB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UVYsTUFBTSxDQUFDLENBQUMsRUFBRTtJQUNoRixPQUFPLENBQUMsR0FBRzdDLE9BQU8wRCxNQUFNLEVBQUUvQyxPQUFPc0IsTUFBTSxDQUFDO1FBQUN3QjtRQUFRRjtLQUFRO0FBQzdEO0FBQ0FwRSwyQkFBMkIsR0FBR0UscUJBQzlCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NpZ25hdHVyZS5qcz9mYjI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZXhwb3J0cy5mcm9tUnBjU2lnID0gZXhwb3J0cy50b0NvbXBhY3RTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZnVuY3Rpb24gZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSwgcmVjaWQ6IHJlY292ZXJ5IH0gPSAoMCwgc2VjcDI1NmsxXzEuZWNkc2FTaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCByID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKTtcbiAgICBpZiAoIWNoYWluSWQgfHwgdHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIHJldHVybiBsZWdhY3kgdHlwZSBFQ0RTQVNpZ25hdHVyZSAoZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBFQ0RTQVNpZ25hdHVyZUJ1ZmZlciB0byBoYW5kbGUgbGFyZ2UgY2hhaW5JZHMpXG4gICAgICAgIGlmIChjaGFpbklkICYmICFOdW1iZXIuaXNTYWZlSW50ZWdlcihjaGFpbklkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIGlucHV0IHR5cGUpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IGNoYWluSWQgPyByZWNvdmVyeSArIChjaGFpbklkICogMiArIDM1KSA6IHJlY292ZXJ5ICsgMjc7XG4gICAgICAgIHJldHVybiB7IHIsIHMsIHYgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZEJOID0gKDAsIHR5cGVzXzEudG9UeXBlKShjaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIGNvbnN0IHYgPSBjaGFpbklkQk4ubXVsbigyKS5hZGRuKDM1KS5hZGRuKHJlY292ZXJ5KS50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIHJldHVybiB7IHIsIHMsIHYgfTtcbn1cbmV4cG9ydHMuZWNzaWduID0gZWNzaWduO1xuZnVuY3Rpb24gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkge1xuICAgIGNvbnN0IHZCTiA9ICgwLCB0eXBlc18xLnRvVHlwZSkodiwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICBpZiAodkJOLmVxbigwKSB8fCB2Qk4uZXFuKDEpKVxuICAgICAgICByZXR1cm4gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gdkJOLnN1Ym4oMjcpO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbklkQk4gPSAoMCwgdHlwZXNfMS50b1R5cGUpKGNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgcmV0dXJuIHZCTi5zdWIoY2hhaW5JZEJOLm11bG4oMikuYWRkbigzNSkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgY29uc3QgcmVjID0gbmV3IGV4dGVybmFsc18xLkJOKHJlY292ZXJ5KTtcbiAgICByZXR1cm4gcmVjLmVxbigwKSB8fCByZWMuZXFuKDEpO1xufVxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlLlxuICogTk9URTogQWNjZXB0cyBgdiA9PSAwIHwgdiA9PSAxYCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnNcbiAqIEByZXR1cm5zIFJlY292ZXJlZCBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IGVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMildLCA2NCk7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbmRlclB1YktleSA9ICgwLCBzZWNwMjU2azFfMS5lY2RzYVJlY292ZXIpKHNpZ25hdHVyZSwgcmVjb3ZlcnkudG9OdW1iZXIoKSwgbXNnSGFzaCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKSk7XG59O1xuZXhwb3J0cy5lY3JlY292ZXIgPSBlY3JlY292ZXI7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZC5cbiAqIE5PVEU6IEFjY2VwdHMgYHYgPT0gMCB8IHYgPT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMiksICgwLCBieXRlc18xLnRvQnVmZmVyKSh2KV0pKTtcbn07XG5leHBvcnRzLnRvUnBjU2lnID0gdG9ScGNTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChFSVAtMjA5OCkuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09IDAgfCB2ID09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmNvbnN0IHRvQ29tcGFjdFNpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIGNvbnN0IHZuID0gKDAsIHR5cGVzXzEudG9UeXBlKSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuTnVtYmVyKTtcbiAgICBsZXQgc3MgPSBzO1xuICAgIGlmICgodm4gPiAyOCAmJiB2biAlIDIgPT09IDEpIHx8IHZuID09PSAxIHx8IHZuID09PSAyOCkge1xuICAgICAgICBzcyA9IEJ1ZmZlci5mcm9tKHMpO1xuICAgICAgICBzc1swXSB8PSAweDgwO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkoc3MsIDMyKV0pKTtcbn07XG5leHBvcnRzLnRvQ29tcGFjdFNpZyA9IHRvQ29tcGFjdFNpZztcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogTk9URTogQWZ0ZXIgRUlQMTU1OSwgYHZgIGNvdWxkIGJlIGAwYCBvciBgMWAgYnV0IHRoaXMgZnVuY3Rpb24gYXNzdW1lc1xuICogaXQncyBhIHNpZ25lZCBtZXNzYWdlIChFSVAtMTkxIG9yIEVJUC03MTIpIGFkZGluZyBgMjdgIGF0IHRoZSBlbmQuIFJlbW92ZSBpZiBuZWVkZWQuXG4gKi9cbmNvbnN0IGZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgY29uc3QgYnVmID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKHNpZyk7XG4gICAgbGV0IHI7XG4gICAgbGV0IHM7XG4gICAgbGV0IHY7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPj0gNjUpIHtcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoNjQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgLy8gQ29tcGFjdCBTaWduYXR1cmUgUmVwcmVzZW50YXRpb24gKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjA5OClcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9ICgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoMzIsIDMzKSkgPj4gNztcbiAgICAgICAgc1swXSAmPSAweDdmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgICB9XG4gICAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXG4gICAgaWYgKHYgPCAyNykge1xuICAgICAgICB2ICs9IDI3O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2LFxuICAgICAgICByLFxuICAgICAgICBzLFxuICAgIH07XG59O1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnJvbVJwY1NpZztcbi8qKlxuICogVmFsaWRhdGUgYSBFQ0RTQSBzaWduYXR1cmUuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09IDAgfCB2ID09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkT3JMYXRlciA9IHRydWUsIGNoYWluSWQpIHtcbiAgICBjb25zdCBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBleHRlcm5hbHNfMS5CTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgICBjb25zdCBTRUNQMjU2SzFfTiA9IG5ldyBleHRlcm5hbHNfMS5CTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcbiAgICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJCTiA9IG5ldyBleHRlcm5hbHNfMS5CTihyKTtcbiAgICBjb25zdCBzQk4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4ocyk7XG4gICAgaWYgKHJCTi5pc1plcm8oKSB8fCByQk4uZ3QoU0VDUDI1NksxX04pIHx8IHNCTi5pc1plcm8oKSB8fCBzQk4uZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JOLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBpc1ZhbGlkU2lnbmF0dXJlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqL1xuY29uc3QgaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobWVzc2FnZSk7XG4gICAgY29uc3QgcHJlZml4ID0gQnVmZmVyLmZyb20oYFxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4ke21lc3NhZ2UubGVuZ3RofWAsICd1dGYtOCcpO1xuICAgIHJldHVybiAoMCwgaGFzaF8xLmtlY2NhaykoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGhhc2hQZXJzb25hbE1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzaFBlcnNvbmFsTWVzc2FnZSIsImlzVmFsaWRTaWduYXR1cmUiLCJmcm9tUnBjU2lnIiwidG9Db21wYWN0U2lnIiwidG9ScGNTaWciLCJlY3JlY292ZXIiLCJlY3NpZ24iLCJzZWNwMjU2azFfMSIsInJlcXVpcmUiLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJoYXNoXzEiLCJoZWxwZXJzXzEiLCJ0eXBlc18xIiwibXNnSGFzaCIsInByaXZhdGVLZXkiLCJjaGFpbklkIiwic2lnbmF0dXJlIiwicmVjaWQiLCJyZWNvdmVyeSIsImVjZHNhU2lnbiIsInIiLCJCdWZmZXIiLCJmcm9tIiwic2xpY2UiLCJzIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwidiIsImNoYWluSWRCTiIsInRvVHlwZSIsIlR5cGVPdXRwdXQiLCJCTiIsIm11bG4iLCJhZGRuIiwidG9BcnJheUxpa2UiLCJjYWxjdWxhdGVTaWdSZWNvdmVyeSIsInZCTiIsImVxbiIsInN1Ym4iLCJzdWIiLCJpc1ZhbGlkU2lnUmVjb3ZlcnkiLCJyZWMiLCJjb25jYXQiLCJzZXRMZW5ndGhMZWZ0Iiwic2VuZGVyUHViS2V5IiwiZWNkc2FSZWNvdmVyIiwidG9OdW1iZXIiLCJwdWJsaWNLZXlDb252ZXJ0IiwiYnVmZmVyVG9IZXgiLCJ0b0J1ZmZlciIsInZuIiwic3MiLCJzaWciLCJidWYiLCJsZW5ndGgiLCJidWZmZXJUb0ludCIsImhvbWVzdGVhZE9yTGF0ZXIiLCJTRUNQMjU2SzFfTl9ESVZfMiIsIlNFQ1AyNTZLMV9OIiwickJOIiwic0JOIiwiaXNaZXJvIiwiZ3QiLCJjbXAiLCJtZXNzYWdlIiwiYXNzZXJ0SXNCdWZmZXIiLCJwcmVmaXgiLCJrZWNjYWsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/types.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */ function bnToHex(value) {\n    return `0x${value.toString(16)}`;\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */ function bnToUnpaddedBuffer(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */ function bnToRlp(value) {\n    return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */ var TypeOutput;\n(function(TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === \"string\" && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    } else if (typeof input === \"number\" && !Number.isSafeInteger(input)) {\n        throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    if (outputType === TypeOutput.Buffer) {\n        return output;\n    } else if (outputType === TypeOutput.BN) {\n        return new externals_1.BN(output);\n    } else if (outputType === TypeOutput.Number) {\n        const bn = new externals_1.BN(output);\n        const max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n        }\n        return bn.toNumber();\n    } else {\n        // outputType === TypeOutput.PrefixedHexString\n        return `0x${output.toString(\"hex\")}`;\n    }\n}\nexports.toType = toType; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0Esa0JBQWtCLEdBQUdBLGVBQWUsR0FBR0EsMEJBQTBCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzVHLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHlFQUFZO0FBQ3ZDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLG1FQUFTO0FBQ2pDOztDQUVDLEdBQ0QsU0FBU0YsUUFBUUwsS0FBSztJQUNsQixPQUFPLENBQUMsRUFBRSxFQUFFQSxNQUFNVSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ3BDO0FBQ0FYLGVBQWUsR0FBR007QUFDbEI7Ozs7Q0FJQyxHQUNELFNBQVNELG1CQUFtQkosS0FBSztJQUM3Qiw0REFBNEQ7SUFDNUQsc0RBQXNEO0lBQ3RELE9BQU8sQ0FBQyxHQUFHUyxRQUFRRSxXQUFXLEVBQUVYLE1BQU1ZLFdBQVcsQ0FBQ0M7QUFDdEQ7QUFDQWQsMEJBQTBCLEdBQUdLO0FBQzdCOzs7Q0FHQyxHQUNELFNBQVNELFFBQVFILEtBQUs7SUFDbEIsT0FBT0ksbUJBQW1CSjtBQUM5QjtBQUNBRCxlQUFlLEdBQUdJO0FBQ2xCOztDQUVDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHO0lBQ25DQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDdEQsR0FBR0EsYUFBYUgsUUFBUUcsVUFBVSxJQUFLSCxDQUFBQSxrQkFBa0IsR0FBRyxDQUFDO0FBQzdELFNBQVNFLE9BQU9hLEtBQUssRUFBRUMsVUFBVTtJQUM3QixJQUFJRCxVQUFVLE1BQU07UUFDaEIsT0FBTztJQUNYO0lBQ0EsSUFBSUEsVUFBVUUsV0FBVztRQUNyQixPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFPRixVQUFVLFlBQVksQ0FBQyxDQUFDLEdBQUdOLFdBQVdTLFdBQVcsRUFBRUgsUUFBUTtRQUNsRSxNQUFNLElBQUlJLE1BQU0sQ0FBQyxtREFBbUQsRUFBRUosTUFBTSxDQUFDO0lBQ2pGLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0ssT0FBT0MsYUFBYSxDQUFDTixRQUFRO1FBQ2hFLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUNBLE1BQU1HLFNBQVMsQ0FBQyxHQUFHWixRQUFRYSxRQUFRLEVBQUVSO0lBQ3JDLElBQUlDLGVBQWViLFdBQVdXLE1BQU0sRUFBRTtRQUNsQyxPQUFPUTtJQUNYLE9BQ0ssSUFBSU4sZUFBZWIsV0FBV3FCLEVBQUUsRUFBRTtRQUNuQyxPQUFPLElBQUlqQixZQUFZaUIsRUFBRSxDQUFDRjtJQUM5QixPQUNLLElBQUlOLGVBQWViLFdBQVdpQixNQUFNLEVBQUU7UUFDdkMsTUFBTUssS0FBSyxJQUFJbEIsWUFBWWlCLEVBQUUsQ0FBQ0Y7UUFDOUIsTUFBTUksTUFBTSxJQUFJbkIsWUFBWWlCLEVBQUUsQ0FBQ0osT0FBT08sZ0JBQWdCLENBQUNoQixRQUFRO1FBQy9ELElBQUljLEdBQUdHLEVBQUUsQ0FBQ0YsTUFBTTtZQUNaLE1BQU0sSUFBSVAsTUFBTTtRQUNwQjtRQUNBLE9BQU9NLEdBQUdJLFFBQVE7SUFDdEIsT0FDSztRQUNELDhDQUE4QztRQUM5QyxPQUFPLENBQUMsRUFBRSxFQUFFUCxPQUFPWCxRQUFRLENBQUMsT0FBTyxDQUFDO0lBQ3hDO0FBQ0o7QUFDQVgsY0FBYyxHQUFHRSxRQUNqQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC90eXBlcy5qcz8zYWYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1R5cGUgPSBleHBvcnRzLlR5cGVPdXRwdXQgPSBleHBvcnRzLmJuVG9SbHAgPSBleHBvcnRzLmJuVG9VbnBhZGRlZEJ1ZmZlciA9IGV4cG9ydHMuYm5Ub0hleCA9IHZvaWQgMDtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IEJOIHRvIDB4LXByZWZpeGVkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJuVG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZS50b1N0cmluZygxNil9YDtcbn1cbmV4cG9ydHMuYm5Ub0hleCA9IGJuVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgdmFsdWUgZnJvbSBCTiB0byBhbiB1bnBhZGRlZCBCdWZmZXJcbiAqICh1c2VmdWwgZm9yIFJMUCB0cmFuc3BvcnQpXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY29udmVydFxuICovXG5mdW5jdGlvbiBiblRvVW5wYWRkZWRCdWZmZXIodmFsdWUpIHtcbiAgICAvLyBVc2luZyBgYm4udG9BcnJheUxpa2UoQnVmZmVyKWAgaW5zdGVhZCBvZiBgYm4udG9CdWZmZXIoKWBcbiAgICAvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGJyb3dzZXJpZnkgYW5kIHNpbWlsYXIgdG9vbHNcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEudW5wYWRCdWZmZXIpKHZhbHVlLnRvQXJyYXlMaWtlKEJ1ZmZlcikpO1xufVxuZXhwb3J0cy5iblRvVW5wYWRkZWRCdWZmZXIgPSBiblRvVW5wYWRkZWRCdWZmZXI7XG4vKipcbiAqIERlcHJlY2F0ZWQgYWxpYXMgZm9yIHtAbGluayBiblRvVW5wYWRkZWRCdWZmZXJ9XG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBiblRvUmxwKHZhbHVlKSB7XG4gICAgcmV0dXJuIGJuVG9VbnBhZGRlZEJ1ZmZlcih2YWx1ZSk7XG59XG5leHBvcnRzLmJuVG9SbHAgPSBiblRvUmxwO1xuLyoqXG4gKiBUeXBlIG91dHB1dCBvcHRpb25zXG4gKi9cbnZhciBUeXBlT3V0cHV0O1xuKGZ1bmN0aW9uIChUeXBlT3V0cHV0KSB7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiTnVtYmVyXCJdID0gMF0gPSBcIk51bWJlclwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIkJOXCJdID0gMV0gPSBcIkJOXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQnVmZmVyXCJdID0gMl0gPSBcIkJ1ZmZlclwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIlByZWZpeGVkSGV4U3RyaW5nXCJdID0gM10gPSBcIlByZWZpeGVkSGV4U3RyaW5nXCI7XG59KShUeXBlT3V0cHV0ID0gZXhwb3J0cy5UeXBlT3V0cHV0IHx8IChleHBvcnRzLlR5cGVPdXRwdXQgPSB7fSkpO1xuZnVuY3Rpb24gdG9UeXBlKGlucHV0LCBvdXRwdXRUeXBlKSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiAhKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIDB4LXByZWZpeCwgZ2l2ZW46ICR7aW5wdXR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGlucHV0KTtcbiAgICBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5CTikge1xuICAgICAgICByZXR1cm4gbmV3IGV4dGVybmFsc18xLkJOKG91dHB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGJuID0gbmV3IGV4dGVybmFsc18xLkJOKG91dHB1dCk7XG4gICAgICAgIGNvbnN0IG1heCA9IG5ldyBleHRlcm5hbHNfMS5CTihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGJuLmd0KG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gTUFYX1NBRkVfSU5URUdFUiAocGxlYXNlIHVzZSBhbiBhbHRlcm5hdGl2ZSBvdXRwdXQgdHlwZSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm4udG9OdW1iZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuUHJlZml4ZWRIZXhTdHJpbmdcbiAgICAgICAgcmV0dXJuIGAweCR7b3V0cHV0LnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgIH1cbn1cbmV4cG9ydHMudG9UeXBlID0gdG9UeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidG9UeXBlIiwiVHlwZU91dHB1dCIsImJuVG9SbHAiLCJiblRvVW5wYWRkZWRCdWZmZXIiLCJiblRvSGV4IiwiZXh0ZXJuYWxzXzEiLCJyZXF1aXJlIiwiaW50ZXJuYWxfMSIsImJ5dGVzXzEiLCJ0b1N0cmluZyIsInVucGFkQnVmZmVyIiwidG9BcnJheUxpa2UiLCJCdWZmZXIiLCJpbnB1dCIsIm91dHB1dFR5cGUiLCJ1bmRlZmluZWQiLCJpc0hleFN0cmluZyIsIkVycm9yIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm91dHB1dCIsInRvQnVmZmVyIiwiQk4iLCJibiIsIm1heCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJndCIsInRvTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/types.js\n");

/***/ })

};
;