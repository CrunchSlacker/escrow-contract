/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/urijs";
exports.ids = ["vendor-chunks/urijs"];
exports.modules = {

/***/ "(ssr)/./node_modules/urijs/src/IPv6.js":
/*!****************************************!*\
  !*** ./node_modules/urijs/src/IPv6.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * IPv6 Support\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */ (function(root, factory) {\n    \"use strict\";\n    // https://github.com/umdjs/umd/blob/master/returnExports.js\n    if ( true && module.exports) {\n        // Node\n        module.exports = factory();\n    } else if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function(root) {\n    \"use strict\";\n    /*\n  var _in = \"fe80:0000:0000:0000:0204:61ff:fe9d:f156\";\n  var _out = IPv6.best(_in);\n  var _expected = \"fe80::204:61ff:fe9d:f156\";\n\n  console.log(_in, _out, _expected, _out === _expected);\n  */ // save current IPv6 variable, if any\n    var _IPv6 = root && root.IPv6;\n    function bestPresentation(address) {\n        // based on:\n        // Javascript to test an IPv6 address for proper format, and to\n        // present the \"best text representation\" according to IETF Draft RFC at\n        // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04\n        // 8 Feb 2010 Rich Brown, Dartware, LLC\n        // Please feel free to use this code as long as you provide a link to\n        // http://www.intermapper.com\n        // http://intermapper.com/support/tools/IPV6-Validator.aspx\n        // http://download.dartware.com/thirdparty/ipv6validator.js\n        var _address = address.toLowerCase();\n        var segments = _address.split(\":\");\n        var length = segments.length;\n        var total = 8;\n        // trim colons (:: or ::a:b:c… or …a:b:c::)\n        if (segments[0] === \"\" && segments[1] === \"\" && segments[2] === \"\") {\n            // must have been ::\n            // remove first two items\n            segments.shift();\n            segments.shift();\n        } else if (segments[0] === \"\" && segments[1] === \"\") {\n            // must have been ::xxxx\n            // remove the first item\n            segments.shift();\n        } else if (segments[length - 1] === \"\" && segments[length - 2] === \"\") {\n            // must have been xxxx::\n            segments.pop();\n        }\n        length = segments.length;\n        // adjust total segments for IPv4 trailer\n        if (segments[length - 1].indexOf(\".\") !== -1) {\n            // found a \".\" which means IPv4\n            total = 7;\n        }\n        // fill empty segments them with \"0000\"\n        var pos;\n        for(pos = 0; pos < length; pos++){\n            if (segments[pos] === \"\") {\n                break;\n            }\n        }\n        if (pos < total) {\n            segments.splice(pos, 1, \"0000\");\n            while(segments.length < total){\n                segments.splice(pos, 0, \"0000\");\n            }\n        }\n        // strip leading zeros\n        var _segments;\n        for(var i = 0; i < total; i++){\n            _segments = segments[i].split(\"\");\n            for(var j = 0; j < 3; j++){\n                if (_segments[0] === \"0\" && _segments.length > 1) {\n                    _segments.splice(0, 1);\n                } else {\n                    break;\n                }\n            }\n            segments[i] = _segments.join(\"\");\n        }\n        // find longest sequence of zeroes and coalesce them into one segment\n        var best = -1;\n        var _best = 0;\n        var _current = 0;\n        var current = -1;\n        var inzeroes = false;\n        // i; already declared\n        for(i = 0; i < total; i++){\n            if (inzeroes) {\n                if (segments[i] === \"0\") {\n                    _current += 1;\n                } else {\n                    inzeroes = false;\n                    if (_current > _best) {\n                        best = current;\n                        _best = _current;\n                    }\n                }\n            } else {\n                if (segments[i] === \"0\") {\n                    inzeroes = true;\n                    current = i;\n                    _current = 1;\n                }\n            }\n        }\n        if (_current > _best) {\n            best = current;\n            _best = _current;\n        }\n        if (_best > 1) {\n            segments.splice(best, _best, \"\");\n        }\n        length = segments.length;\n        // assemble remaining segments\n        var result = \"\";\n        if (segments[0] === \"\") {\n            result = \":\";\n        }\n        for(i = 0; i < length; i++){\n            result += segments[i];\n            if (i === length - 1) {\n                break;\n            }\n            result += \":\";\n        }\n        if (segments[length - 1] === \"\") {\n            result += \":\";\n        }\n        return result;\n    }\n    function noConflict() {\n        /*jshint validthis: true */ if (root.IPv6 === this) {\n            root.IPv6 = _IPv6;\n        }\n        return this;\n    }\n    return {\n        best: bestPresentation,\n        noConflict: noConflict\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL0lQdjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBRUEsVUFBVUEsSUFBSSxFQUFFQyxPQUFPO0lBQ3RCO0lBQ0EsNERBQTREO0lBQzVELElBQUksS0FBa0IsSUFBWUMsT0FBT0MsT0FBTyxFQUFFO1FBQ2hELE9BQU87UUFDUEQsT0FBT0MsT0FBTyxHQUFHRjtJQUNuQixPQUFPLElBQUksSUFBMEMsRUFBRTtRQUNyRCx3Q0FBd0M7UUFDeENHLG9DQUFPSCxPQUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtJQUNqQixPQUFPLEVBR047QUFDSCxHQUFFLElBQUksRUFBRSxTQUFVRCxJQUFJO0lBQ3BCO0lBRUE7Ozs7OztFQU1BLEdBRUEscUNBQXFDO0lBQ3JDLElBQUlPLFFBQVFQLFFBQVFBLEtBQUtNLElBQUk7SUFFN0IsU0FBU0UsaUJBQWlCQyxPQUFPO1FBQy9CLFlBQVk7UUFDWiwrREFBK0Q7UUFDL0Qsd0VBQXdFO1FBQ3hFLHlFQUF5RTtRQUN6RSx1Q0FBdUM7UUFDdkMscUVBQXFFO1FBQ3JFLDZCQUE2QjtRQUM3QiwyREFBMkQ7UUFDM0QsMkRBQTJEO1FBRTNELElBQUlDLFdBQVdELFFBQVFFLFdBQVc7UUFDbEMsSUFBSUMsV0FBV0YsU0FBU0csS0FBSyxDQUFDO1FBQzlCLElBQUlDLFNBQVNGLFNBQVNFLE1BQU07UUFDNUIsSUFBSUMsUUFBUTtRQUVaLDJDQUEyQztRQUMzQyxJQUFJSCxRQUFRLENBQUMsRUFBRSxLQUFLLE1BQU1BLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFBTUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxJQUFJO1lBQ2xFLG9CQUFvQjtZQUNwQix5QkFBeUI7WUFDekJBLFNBQVNJLEtBQUs7WUFDZEosU0FBU0ksS0FBSztRQUNoQixPQUFPLElBQUlKLFFBQVEsQ0FBQyxFQUFFLEtBQUssTUFBTUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxJQUFJO1lBQ25ELHdC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STtJQUNiO0lBRUEsT0FBTztRQUNMa0IsTUFBTWpCO1FBQ051QixZQUFZQTtJQUNkO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy91cmlqcy9zcmMvSVB2Ni5qcz9jZGZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVVJJLmpzIC0gTXV0YXRpbmcgVVJMc1xuICogSVB2NiBTdXBwb3J0XG4gKlxuICogVmVyc2lvbjogMS4xOS4xMVxuICpcbiAqIEF1dGhvcjogUm9kbmV5IFJlaG1cbiAqIFdlYjogaHR0cDovL21lZGlhbGl6ZS5naXRodWIuaW8vVVJJLmpzL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyXG4gKiAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgcm9vdC5JUHY2ID0gZmFjdG9yeShyb290KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAocm9vdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLypcbiAgdmFyIF9pbiA9IFwiZmU4MDowMDAwOjAwMDA6MDAwMDowMjA0OjYxZmY6ZmU5ZDpmMTU2XCI7XG4gIHZhciBfb3V0ID0gSVB2Ni5iZXN0KF9pbik7XG4gIHZhciBfZXhwZWN0ZWQgPSBcImZlODA6OjIwNDo2MWZmOmZlOWQ6ZjE1NlwiO1xuXG4gIGNvbnNvbGUubG9nKF9pbiwgX291dCwgX2V4cGVjdGVkLCBfb3V0ID09PSBfZXhwZWN0ZWQpO1xuICAqL1xuXG4gIC8vIHNhdmUgY3VycmVudCBJUHY2IHZhcmlhYmxlLCBpZiBhbnlcbiAgdmFyIF9JUHY2ID0gcm9vdCAmJiByb290LklQdjY7XG5cbiAgZnVuY3Rpb24gYmVzdFByZXNlbnRhdGlvbihhZGRyZXNzKSB7XG4gICAgLy8gYmFzZWQgb246XG4gICAgLy8gSmF2YXNjcmlwdCB0byB0ZXN0IGFuIElQdjYgYWRkcmVzcyBmb3IgcHJvcGVyIGZvcm1hdCwgYW5kIHRvXG4gICAgLy8gcHJlc2VudCB0aGUgXCJiZXN0IHRleHQgcmVwcmVzZW50YXRpb25cIiBhY2NvcmRpbmcgdG8gSUVURiBEcmFmdCBSRkMgYXRcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLTZtYW4tdGV4dC1hZGRyLXJlcHJlc2VudGF0aW9uLTA0XG4gICAgLy8gOCBGZWIgMjAxMCBSaWNoIEJyb3duLCBEYXJ0d2FyZSwgTExDXG4gICAgLy8gUGxlYXNlIGZlZWwgZnJlZSB0byB1c2UgdGhpcyBjb2RlIGFzIGxvbmcgYXMgeW91IHByb3ZpZGUgYSBsaW5rIHRvXG4gICAgLy8gaHR0cDovL3d3dy5pbnRlcm1hcHBlci5jb21cbiAgICAvLyBodHRwOi8vaW50ZXJtYXBwZXIuY29tL3N1cHBvcnQvdG9vbHMvSVBWNi1WYWxpZGF0b3IuYXNweFxuICAgIC8vIGh0dHA6Ly9kb3dubG9hZC5kYXJ0d2FyZS5jb20vdGhpcmRwYXJ0eS9pcHY2dmFsaWRhdG9yLmpzXG5cbiAgICB2YXIgX2FkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHNlZ21lbnRzID0gX2FkZHJlc3Muc3BsaXQoJzonKTtcbiAgICB2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciB0b3RhbCA9IDg7XG5cbiAgICAvLyB0cmltIGNvbG9ucyAoOjogb3IgOjphOmI6Y+KApiBvciDigKZhOmI6Yzo6KVxuICAgIGlmIChzZWdtZW50c1swXSA9PT0gJycgJiYgc2VnbWVudHNbMV0gPT09ICcnICYmIHNlZ21lbnRzWzJdID09PSAnJykge1xuICAgICAgLy8gbXVzdCBoYXZlIGJlZW4gOjpcbiAgICAgIC8vIHJlbW92ZSBmaXJzdCB0d28gaXRlbXNcbiAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICBzZWdtZW50cy5zaGlmdCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudHNbMF0gPT09ICcnICYmIHNlZ21lbnRzWzFdID09PSAnJykge1xuICAgICAgLy8gbXVzdCBoYXZlIGJlZW4gOjp4eHh4XG4gICAgICAvLyByZW1vdmUgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50c1tsZW5ndGggLSAxXSA9PT0gJycgJiYgc2VnbWVudHNbbGVuZ3RoIC0gMl0gPT09ICcnKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYmVlbiB4eHh4OjpcbiAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGFkanVzdCB0b3RhbCBzZWdtZW50cyBmb3IgSVB2NCB0cmFpbGVyXG4gICAgaWYgKHNlZ21lbnRzW2xlbmd0aCAtIDFdLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIC8vIGZvdW5kIGEgXCIuXCIgd2hpY2ggbWVhbnMgSVB2NFxuICAgICAgdG90YWwgPSA3O1xuICAgIH1cblxuICAgIC8vIGZpbGwgZW1wdHkgc2VnbWVudHMgdGhlbSB3aXRoIFwiMDAwMFwiXG4gICAgdmFyIHBvcztcbiAgICBmb3IgKHBvcyA9IDA7IHBvcyA8IGxlbmd0aDsgcG9zKyspIHtcbiAgICAgIGlmIChzZWdtZW50c1twb3NdID09PSAnJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zIDwgdG90YWwpIHtcbiAgICAgIHNlZ21lbnRzLnNwbGljZShwb3MsIDEsICcwMDAwJyk7XG4gICAgICB3aGlsZSAoc2VnbWVudHMubGVuZ3RoIDwgdG90YWwpIHtcbiAgICAgICAgc2VnbWVudHMuc3BsaWNlKHBvcywgMCwgJzAwMDAnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm9zXG4gICAgdmFyIF9zZWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIF9zZWdtZW50cyA9IHNlZ21lbnRzW2ldLnNwbGl0KCcnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMyA7IGorKykge1xuICAgICAgICBpZiAoX3NlZ21lbnRzWzBdID09PSAnMCcgJiYgX3NlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBfc2VnbWVudHMuc3BsaWNlKDAsMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VnbWVudHNbaV0gPSBfc2VnbWVudHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLy8gZmluZCBsb25nZXN0IHNlcXVlbmNlIG9mIHplcm9lcyBhbmQgY29hbGVzY2UgdGhlbSBpbnRvIG9uZSBzZWdtZW50XG4gICAgdmFyIGJlc3QgPSAtMTtcbiAgICB2YXIgX2Jlc3QgPSAwO1xuICAgIHZhciBfY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnQgPSAtMTtcbiAgICB2YXIgaW56ZXJvZXMgPSBmYWxzZTtcbiAgICAvLyBpOyBhbHJlYWR5IGRlY2xhcmVkXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgaWYgKGluemVyb2VzKSB7XG4gICAgICAgIGlmIChzZWdtZW50c1tpXSA9PT0gJzAnKSB7XG4gICAgICAgICAgX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnplcm9lcyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChfY3VycmVudCA+IF9iZXN0KSB7XG4gICAgICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgICAgIF9iZXN0ID0gX2N1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VnbWVudHNbaV0gPT09ICcwJykge1xuICAgICAgICAgIGluemVyb2VzID0gdHJ1ZTtcbiAgICAgICAgICBjdXJyZW50ID0gaTtcbiAgICAgICAgICBfY3VycmVudCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2N1cnJlbnQgPiBfYmVzdCkge1xuICAgICAgYmVzdCA9IGN1cnJlbnQ7XG4gICAgICBfYmVzdCA9IF9jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChfYmVzdCA+IDEpIHtcbiAgICAgIHNlZ21lbnRzLnNwbGljZShiZXN0LCBfYmVzdCwgJycpO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGFzc2VtYmxlIHJlbWFpbmluZyBzZWdtZW50c1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAoc2VnbWVudHNbMF0gPT09ICcnKSAge1xuICAgICAgcmVzdWx0ID0gJzonO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNlZ21lbnRzW2ldO1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnOic7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRzW2xlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgcmVzdWx0ICs9ICc6JztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICBpZiAocm9vdC5JUHY2ID09PSB0aGlzKSB7XG4gICAgICByb290LklQdjYgPSBfSVB2NjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVzdDogYmVzdFByZXNlbnRhdGlvbixcbiAgICBub0NvbmZsaWN0OiBub0NvbmZsaWN0XG4gIH07XG59KSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiYW1kIiwiSVB2NiIsIl9JUHY2IiwiYmVzdFByZXNlbnRhdGlvbiIsImFkZHJlc3MiLCJfYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwic2VnbWVudHMiLCJzcGxpdCIsImxlbmd0aCIsInRvdGFsIiwic2hpZnQiLCJwb3AiLCJpbmRleE9mIiwicG9zIiwic3BsaWNlIiwiX3NlZ21lbnRzIiwiaSIsImoiLCJqb2luIiwiYmVzdCIsIl9iZXN0IiwiX2N1cnJlbnQiLCJjdXJyZW50IiwiaW56ZXJvZXMiLCJyZXN1bHQiLCJub0NvbmZsaWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/IPv6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/SecondLevelDomains.js":
/*!******************************************************!*\
  !*** ./node_modules/urijs/src/SecondLevelDomains.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n * Second Level Domain (SLD) Support\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */ (function(root, factory) {\n    \"use strict\";\n    // https://github.com/umdjs/umd/blob/master/returnExports.js\n    if ( true && module.exports) {\n        // Node\n        module.exports = factory();\n    } else if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function(root) {\n    \"use strict\";\n    // save current SecondLevelDomains variable, if any\n    var _SecondLevelDomains = root && root.SecondLevelDomains;\n    var SLD = {\n        // list of known Second Level Domains\n        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains\n        // ----\n        // publicsuffix.org is more current and actually used by a couple of browsers internally.\n        // downside is it also contains domains like \"dyndns.org\" - which is fine for the security\n        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js\n        // ----\n        list: {\n            \"ac\": \" com gov mil net org \",\n            \"ae\": \" ac co gov mil name net org pro sch \",\n            \"af\": \" com edu gov net org \",\n            \"al\": \" com edu gov mil net org \",\n            \"ao\": \" co ed gv it og pb \",\n            \"ar\": \" com edu gob gov int mil net org tur \",\n            \"at\": \" ac co gv or \",\n            \"au\": \" asn com csiro edu gov id net org \",\n            \"ba\": \" co com edu gov mil net org rs unbi unmo unsa untz unze \",\n            \"bb\": \" biz co com edu gov info net org store tv \",\n            \"bh\": \" biz cc com edu gov info net org \",\n            \"bn\": \" com edu gov net org \",\n            \"bo\": \" com edu gob gov int mil net org tv \",\n            \"br\": \" adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg \",\n            \"bs\": \" com edu gov net org \",\n            \"bz\": \" du et om ov rg \",\n            \"ca\": \" ab bc mb nb nf nl ns nt nu on pe qc sk yk \",\n            \"ck\": \" biz co edu gen gov info net org \",\n            \"cn\": \" ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj \",\n            \"co\": \" com edu gov mil net nom org \",\n            \"cr\": \" ac c co ed fi go or sa \",\n            \"cy\": \" ac biz com ekloges gov ltd name net org parliament press pro tm \",\n            \"do\": \" art com edu gob gov mil net org sld web \",\n            \"dz\": \" art asso com edu gov net org pol \",\n            \"ec\": \" com edu fin gov info med mil net org pro \",\n            \"eg\": \" com edu eun gov mil name net org sci \",\n            \"er\": \" com edu gov ind mil net org rochest w \",\n            \"es\": \" com edu gob nom org \",\n            \"et\": \" biz com edu gov info name net org \",\n            \"fj\": \" ac biz com info mil name net org pro \",\n            \"fk\": \" ac co gov net nom org \",\n            \"fr\": \" asso com f gouv nom prd presse tm \",\n            \"gg\": \" co net org \",\n            \"gh\": \" com edu gov mil org \",\n            \"gn\": \" ac com gov net org \",\n            \"gr\": \" com edu gov mil net org \",\n            \"gt\": \" com edu gob ind mil net org \",\n            \"gu\": \" com edu gov net org \",\n            \"hk\": \" com edu gov idv net org \",\n            \"hu\": \" 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video \",\n            \"id\": \" ac co go mil net or sch web \",\n            \"il\": \" ac co gov idf k12 muni net org \",\n            \"in\": \" ac co edu ernet firm gen gov i ind mil net nic org res \",\n            \"iq\": \" com edu gov i mil net org \",\n            \"ir\": \" ac co dnssec gov i id net org sch \",\n            \"it\": \" edu gov \",\n            \"je\": \" co net org \",\n            \"jo\": \" com edu gov mil name net org sch \",\n            \"jp\": \" ac ad co ed go gr lg ne or \",\n            \"ke\": \" ac co go info me mobi ne or sc \",\n            \"kh\": \" com edu gov mil net org per \",\n            \"ki\": \" biz com de edu gov info mob net org tel \",\n            \"km\": \" asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire \",\n            \"kn\": \" edu gov net org \",\n            \"kr\": \" ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan \",\n            \"kw\": \" com edu gov net org \",\n            \"ky\": \" com edu gov net org \",\n            \"kz\": \" com edu gov mil net org \",\n            \"lb\": \" com edu gov net org \",\n            \"lk\": \" assn com edu gov grp hotel int ltd net ngo org sch soc web \",\n            \"lr\": \" com edu gov net org \",\n            \"lv\": \" asn com conf edu gov id mil net org \",\n            \"ly\": \" com edu gov id med net org plc sch \",\n            \"ma\": \" ac co gov m net org press \",\n            \"mc\": \" asso tm \",\n            \"me\": \" ac co edu gov its net org priv \",\n            \"mg\": \" com edu gov mil nom org prd tm \",\n            \"mk\": \" com edu gov inf name net org pro \",\n            \"ml\": \" com edu gov net org presse \",\n            \"mn\": \" edu gov org \",\n            \"mo\": \" com edu gov net org \",\n            \"mt\": \" com edu gov net org \",\n            \"mv\": \" aero biz com coop edu gov info int mil museum name net org pro \",\n            \"mw\": \" ac co com coop edu gov int museum net org \",\n            \"mx\": \" com edu gob net org \",\n            \"my\": \" com edu gov mil name net org sch \",\n            \"nf\": \" arts com firm info net other per rec store web \",\n            \"ng\": \" biz com edu gov mil mobi name net org sch \",\n            \"ni\": \" ac co com edu gob mil net nom org \",\n            \"np\": \" com edu gov mil net org \",\n            \"nr\": \" biz com edu gov info net org \",\n            \"om\": \" ac biz co com edu gov med mil museum net org pro sch \",\n            \"pe\": \" com edu gob mil net nom org sld \",\n            \"ph\": \" com edu gov i mil net ngo org \",\n            \"pk\": \" biz com edu fam gob gok gon gop gos gov net org web \",\n            \"pl\": \" art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora \",\n            \"pr\": \" ac biz com edu est gov info isla name net org pro prof \",\n            \"ps\": \" com edu gov net org plo sec \",\n            \"pw\": \" belau co ed go ne or \",\n            \"ro\": \" arts com firm info nom nt org rec store tm www \",\n            \"rs\": \" ac co edu gov in org \",\n            \"sb\": \" com edu gov net org \",\n            \"sc\": \" com edu gov net org \",\n            \"sh\": \" co com edu gov net nom org \",\n            \"sl\": \" com edu gov net org \",\n            \"st\": \" co com consulado edu embaixada gov mil net org principe saotome store \",\n            \"sv\": \" com edu gob org red \",\n            \"sz\": \" ac co org \",\n            \"tr\": \" av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web \",\n            \"tt\": \" aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel \",\n            \"tw\": \" club com ebiz edu game gov idv mil net org \",\n            \"mu\": \" ac co com gov net or org \",\n            \"mz\": \" ac co edu gov org \",\n            \"na\": \" co com \",\n            \"nz\": \" ac co cri geek gen govt health iwi maori mil net org parliament school \",\n            \"pa\": \" abo ac com edu gob ing med net nom org sld \",\n            \"pt\": \" com edu gov int net nome org publ \",\n            \"py\": \" com edu gov mil net org \",\n            \"qa\": \" com edu gov mil net org \",\n            \"re\": \" asso com nom \",\n            \"ru\": \" ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk \",\n            \"rw\": \" ac co com edu gouv gov int mil net \",\n            \"sa\": \" com edu gov med net org pub sch \",\n            \"sd\": \" com edu gov info med net org tv \",\n            \"se\": \" a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z \",\n            \"sg\": \" com edu gov idn net org per \",\n            \"sn\": \" art com edu gouv org perso univ \",\n            \"sy\": \" com edu gov mil net news org \",\n            \"th\": \" ac co go in mi net or \",\n            \"tj\": \" ac biz co com edu go gov info int mil name net nic org test web \",\n            \"tn\": \" agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism \",\n            \"tz\": \" ac co go ne or \",\n            \"ua\": \" biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt \",\n            \"ug\": \" ac co go ne or org sc \",\n            \"uk\": \" ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc \",\n            \"us\": \" dni fed isa kids nsn \",\n            \"uy\": \" com edu gub mil net org \",\n            \"ve\": \" co com edu gob info mil net org web \",\n            \"vi\": \" co com k12 net org \",\n            \"vn\": \" ac biz com edu gov health info int name net org pro \",\n            \"ye\": \" co com gov ltd me net org plc \",\n            \"yu\": \" ac co edu gov org \",\n            \"za\": \" ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web \",\n            \"zm\": \" ac co com edu gov net org sch \",\n            // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains\n            \"com\": \"ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za \",\n            \"net\": \"gb jp se uk \",\n            \"org\": \"ae\",\n            \"de\": \"com \"\n        },\n        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost\n        // in both performance and memory footprint. No initialization required.\n        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4\n        // Following methods use lastIndexOf() rather than array.split() in order\n        // to avoid any memory allocations.\n        has: function(domain) {\n            var tldOffset = domain.lastIndexOf(\".\");\n            if (tldOffset <= 0 || tldOffset >= domain.length - 1) {\n                return false;\n            }\n            var sldOffset = domain.lastIndexOf(\".\", tldOffset - 1);\n            if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {\n                return false;\n            }\n            var sldList = SLD.list[domain.slice(tldOffset + 1)];\n            if (!sldList) {\n                return false;\n            }\n            return sldList.indexOf(\" \" + domain.slice(sldOffset + 1, tldOffset) + \" \") >= 0;\n        },\n        is: function(domain) {\n            var tldOffset = domain.lastIndexOf(\".\");\n            if (tldOffset <= 0 || tldOffset >= domain.length - 1) {\n                return false;\n            }\n            var sldOffset = domain.lastIndexOf(\".\", tldOffset - 1);\n            if (sldOffset >= 0) {\n                return false;\n            }\n            var sldList = SLD.list[domain.slice(tldOffset + 1)];\n            if (!sldList) {\n                return false;\n            }\n            return sldList.indexOf(\" \" + domain.slice(0, tldOffset) + \" \") >= 0;\n        },\n        get: function(domain) {\n            var tldOffset = domain.lastIndexOf(\".\");\n            if (tldOffset <= 0 || tldOffset >= domain.length - 1) {\n                return null;\n            }\n            var sldOffset = domain.lastIndexOf(\".\", tldOffset - 1);\n            if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {\n                return null;\n            }\n            var sldList = SLD.list[domain.slice(tldOffset + 1)];\n            if (!sldList) {\n                return null;\n            }\n            if (sldList.indexOf(\" \" + domain.slice(sldOffset + 1, tldOffset) + \" \") < 0) {\n                return null;\n            }\n            return domain.slice(sldOffset + 1);\n        },\n        noConflict: function() {\n            if (root.SecondLevelDomains === this) {\n                root.SecondLevelDomains = _SecondLevelDomains;\n            }\n            return this;\n        }\n    };\n    return SLD;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1NlY29uZExldmVsRG9tYWlucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FFQSxVQUFVQSxJQUFJLEVBQUVDLE9BQU87SUFDdEI7SUFDQSw0REFBNEQ7SUFDNUQsSUFBSSxLQUFrQixJQUFZQyxPQUFPQyxPQUFPLEVBQUU7UUFDaEQsT0FBTztRQUNQRCxPQUFPQyxPQUFPLEdBQUdGO0lBQ25CLE9BQU8sSUFBSSxJQUEwQyxFQUFFO1FBQ3JELHdDQUF3QztRQUN4Q0csb0NBQU9ILE9BQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ2pCLE9BQU8sRUFHTjtBQUNILEdBQUUsSUFBSSxFQUFFLFNBQVVELElBQUk7SUFDcEI7SUFFQSxtREFBbUQ7SUFDbkQsSUFBSU8sc0JBQXNCUCxRQUFRQSxLQUFLTSxrQkFBa0I7SUFFekQsSUFBSUUsTUFBTTtRQUNSLHFDQUFxQztRQUNyQyxtRkFBbUY7UUFDbkYsT0FBTztRQUNQLHlGQUF5RjtRQUN6RiwwRkFBMEY7UUFDMUYsNEZBQTRGO1FBQzVGLE9BQU87UUFDUEMsTUFBTTtZQUNKLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsTUFBSztZQUNMLE1BQUs7WUFDTCxNQUFLO1lBQ0wsZ0VBQWdFO1lBQ2hFLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE1BQU07UUFDUjtRQUNBLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsd0RBQXdEO1FBQ3hELHlFQUF5RTtRQUN6RSxtQ0FBbUM7UUFDbkNDLEtBQUssU0FBU0MsTUFBTTtZQUNsQixJQUFJQyxZQUFZRCxPQUFPRSxXQUFXLENBQUM7WUFDbkMsSUFBSUQsYUFBYSxLQUFLQSxhQUFjRCxPQUFPRyxNQUFNLEdBQUMsR0FBSTtnQkFDcEQsT0FBTztZQUNUO1lBQ0EsSUFBSUMsWUFBWUosT0FBT0UsV0FBVyxDQUFDLEtBQUtELFlBQVU7WUFDbEQsSUFBSUcsYUFBYSxLQUFLQSxhQUFjSCxZQUFVLEdBQUk7Z0JBQ2hELE9BQU87WUFDVDtZQUNBLElBQUlJLFVBQVVSLElBQUlDLElBQUksQ0FBQ0UsT0FBT00sS0FBSyxDQUFDTCxZQUFVLEdBQUc7WUFDakQsSUFBSSxDQUFDSSxTQUFTO2dCQUNaLE9BQU87WUFDVDtZQUNBLE9BQU9BLFFBQVFFLE9BQU8sQ0FBQyxNQUFNUCxPQUFPTSxLQUFLLENBQUNGLFlBQVUsR0FBR0gsYUFBYSxRQUFRO1FBQzlFO1FBQ0FPLElBQUksU0FBU1IsTUFBTTtZQUNqQixJQUFJQyxZQUFZRCxPQUFPRSxXQUFXLENBQUM7WUFDbkMsSUFBSUQsYUFBYSxLQUFLQSxhQUFjRCxPQUFPRyxNQUFNLEdBQUMsR0FBSTtnQkFDcEQsT0FBTztZQUNUO1lBQ0EsSUFBSUMsWUFBWUosT0FBT0UsV0FBVyxDQUFDLEtBQUtELFlBQVU7WUFDbEQsSUFBSUcsYUFBYSxHQUFHO2dCQUNsQixPQUFPO1lBQ1Q7WUFDQSxJQUFJQyxVQUFVUixJQUFJQyxJQUFJLENBQUNFLE9BQU9NLEtBQUssQ0FBQ0wsWUFBVSxHQUFHO1lBQ2pELElBQUksQ0FBQ0ksU0FBUztnQkFDWixPQUFPO1lBQ1Q7WUFDQSxPQUFPQSxRQUFRRSxPQUFPLENBQUMsTUFBTVAsT0FBT00sS0FBSyxDQUFDLEdBQUdMLGFBQWEsUUFBUTtRQUNwRTtRQUNBUSxLQUFLLFNBQVNULE1BQU07WUFDbEIsSUFBSUMsWUFBWUQsT0FBT0UsV0FBVyxDQUFDO1lBQ25DLElBQUlELGFBQWEsS0FBS0EsYUFBY0QsT0FBT0csTUFBTSxHQUFDLEdBQUk7Z0JBQ3BELE9BQU87WUFDVDtZQUNBLElBQUlDLFlBQVlKLE9BQU9FLFdBQVcsQ0FBQyxLQUFLRCxZQUFVO1lBQ2xELElBQUlHLGFBQWEsS0FBS0EsYUFBY0gsWUFBVSxHQUFJO2dCQUNoRCxPQUFPO1lBQ1Q7WUFDQSxJQUFJSSxVQUFVUixJQUFJQyxJQUFJLENBQUNFLE9BQU9NLEtBQUssQ0FBQ0wsWUFBVSxHQUFHO1lBQ2pELElBQUksQ0FBQ0ksU0FBUztnQkFDWixPQUFPO1lBQ1Q7WUFDQSxJQUFJQSxRQUFRRSxPQUFPLENBQUMsTUFBTVAsT0FBT00sS0FBSyxDQUFDRixZQUFVLEdBQUdILGFBQWEsT0FBTyxHQUFHO2dCQUN6RSxPQUFPO1lBQ1Q7WUFDQSxPQUFPRCxPQUFPTSxLQUFLLENBQUNGLFlBQVU7UUFDaEM7UUFDQU0sWUFBWTtZQUNWLElBQUlyQixLQUFLTSxrQkFBa0IsS0FBSyxJQUFJLEVBQUU7Z0JBQ3BDTixLQUFLTSxrQkFBa0IsR0FBR0M7WUFDNUI7WUFDQSxPQUFPLElBQUk7UUFDYjtJQUNGO0lBRUEsT0FBT0M7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3VyaWpzL3NyYy9TZWNvbmRMZXZlbERvbWFpbnMuanM/ZjcxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFVSSS5qcyAtIE11dGF0aW5nIFVSTHNcbiAqIFNlY29uZCBMZXZlbCBEb21haW4gKFNMRCkgU3VwcG9ydFxuICpcbiAqIFZlcnNpb246IDEuMTkuMTFcbiAqXG4gKiBBdXRob3I6IFJvZG5leSBSZWhtXG4gKiBXZWI6IGh0dHA6Ly9tZWRpYWxpemUuZ2l0aHViLmlvL1VSSS5qcy9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlclxuICogICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKlxuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zID0gZmFjdG9yeShyb290KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAocm9vdCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gc2F2ZSBjdXJyZW50IFNlY29uZExldmVsRG9tYWlucyB2YXJpYWJsZSwgaWYgYW55XG4gIHZhciBfU2Vjb25kTGV2ZWxEb21haW5zID0gcm9vdCAmJiByb290LlNlY29uZExldmVsRG9tYWlucztcblxuICB2YXIgU0xEID0ge1xuICAgIC8vIGxpc3Qgb2Yga25vd24gU2Vjb25kIExldmVsIERvbWFpbnNcbiAgICAvLyBjb252ZXJ0ZWQgbGlzdCBvZiBTTERzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dhdmluZ21pbGxlci9zZWNvbmQtbGV2ZWwtZG9tYWluc1xuICAgIC8vIC0tLS1cbiAgICAvLyBwdWJsaWNzdWZmaXgub3JnIGlzIG1vcmUgY3VycmVudCBhbmQgYWN0dWFsbHkgdXNlZCBieSBhIGNvdXBsZSBvZiBicm93c2VycyBpbnRlcm5hbGx5LlxuICAgIC8vIGRvd25zaWRlIGlzIGl0IGFsc28gY29udGFpbnMgZG9tYWlucyBsaWtlIFwiZHluZG5zLm9yZ1wiIC0gd2hpY2ggaXMgZmluZSBmb3IgdGhlIHNlY3VyaXR5XG4gICAgLy8gaXNzdWVzIGJyb3dzZXIgaGF2ZSB0byBkZWFsIHdpdGggKFNPUCBmb3IgY29va2llcywgZXRjKSAtIGJ1dCBpcyB3YXkgb3ZlcmJvYXJkIGZvciBVUkkuanNcbiAgICAvLyAtLS0tXG4gICAgbGlzdDoge1xuICAgICAgJ2FjJzonIGNvbSBnb3YgbWlsIG5ldCBvcmcgJyxcbiAgICAgICdhZSc6JyBhYyBjbyBnb3YgbWlsIG5hbWUgbmV0IG9yZyBwcm8gc2NoICcsXG4gICAgICAnYWYnOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2FsJzonIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICcsXG4gICAgICAnYW8nOicgY28gZWQgZ3YgaXQgb2cgcGIgJyxcbiAgICAgICdhcic6JyBjb20gZWR1IGdvYiBnb3YgaW50IG1pbCBuZXQgb3JnIHR1ciAnLFxuICAgICAgJ2F0JzonIGFjIGNvIGd2IG9yICcsXG4gICAgICAnYXUnOicgYXNuIGNvbSBjc2lybyBlZHUgZ292IGlkIG5ldCBvcmcgJyxcbiAgICAgICdiYSc6JyBjbyBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyBycyB1bmJpIHVubW8gdW5zYSB1bnR6IHVuemUgJyxcbiAgICAgICdiYic6JyBiaXogY28gY29tIGVkdSBnb3YgaW5mbyBuZXQgb3JnIHN0b3JlIHR2ICcsXG4gICAgICAnYmgnOicgYml6IGNjIGNvbSBlZHUgZ292IGluZm8gbmV0IG9yZyAnLFxuICAgICAgJ2JuJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdibyc6JyBjb20gZWR1IGdvYiBnb3YgaW50IG1pbCBuZXQgb3JnIHR2ICcsXG4gICAgICAnYnInOicgYWRtIGFkdiBhZ3IgYW0gYXJxIGFydCBhdG8gYiBiaW8gYmxvZyBibWQgY2ltIGNuZyBjbnQgY29tIGNvb3AgZWNuIGVkdSBlbmcgZXNwIGV0YyBldGkgZmFyIGZsb2cgZm0gZm5kIGZvdCBmc3QgZzEyIGdnZiBnb3YgaW1iIGluZCBpbmYgam9yIGp1cyBsZWwgbWF0IG1lZCBtaWwgbXVzIG5ldCBub20gbm90IG50ciBvZG8gb3JnIHBwZyBwcm8gcHNjIHBzaSBxc2wgcmVjIHNsZyBzcnYgdG1wIHRyZCB0dXIgdHYgdmV0IHZsb2cgd2lraSB6bGcgJyxcbiAgICAgICdicyc6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnYnonOicgZHUgZXQgb20gb3YgcmcgJyxcbiAgICAgICdjYSc6JyBhYiBiYyBtYiBuYiBuZiBubCBucyBudCBudSBvbiBwZSBxYyBzayB5ayAnLFxuICAgICAgJ2NrJzonIGJpeiBjbyBlZHUgZ2VuIGdvdiBpbmZvIG5ldCBvcmcgJyxcbiAgICAgICdjbic6JyBhYyBhaCBiaiBjb20gY3EgZWR1IGZqIGdkIGdvdiBncyBneCBneiBoYSBoYiBoZSBoaSBobCBobiBqbCBqcyBqeCBsbiBtaWwgbmV0IG5tIG54IG9yZyBxaCBzYyBzZCBzaCBzbiBzeCB0aiB0dyB4aiB4eiB5biB6aiAnLFxuICAgICAgJ2NvJzonIGNvbSBlZHUgZ292IG1pbCBuZXQgbm9tIG9yZyAnLFxuICAgICAgJ2NyJzonIGFjIGMgY28gZWQgZmkgZ28gb3Igc2EgJyxcbiAgICAgICdjeSc6JyBhYyBiaXogY29tIGVrbG9nZXMgZ292IGx0ZCBuYW1lIG5ldCBvcmcgcGFybGlhbWVudCBwcmVzcyBwcm8gdG0gJyxcbiAgICAgICdkbyc6JyBhcnQgY29tIGVkdSBnb2IgZ292IG1pbCBuZXQgb3JnIHNsZCB3ZWIgJyxcbiAgICAgICdkeic6JyBhcnQgYXNzbyBjb20gZWR1IGdvdiBuZXQgb3JnIHBvbCAnLFxuICAgICAgJ2VjJzonIGNvbSBlZHUgZmluIGdvdiBpbmZvIG1lZCBtaWwgbmV0IG9yZyBwcm8gJyxcbiAgICAgICdlZyc6JyBjb20gZWR1IGV1biBnb3YgbWlsIG5hbWUgbmV0IG9yZyBzY2kgJyxcbiAgICAgICdlcic6JyBjb20gZWR1IGdvdiBpbmQgbWlsIG5ldCBvcmcgcm9jaGVzdCB3ICcsXG4gICAgICAnZXMnOicgY29tIGVkdSBnb2Igbm9tIG9yZyAnLFxuICAgICAgJ2V0JzonIGJpeiBjb20gZWR1IGdvdiBpbmZvIG5hbWUgbmV0IG9yZyAnLFxuICAgICAgJ2ZqJzonIGFjIGJpeiBjb20gaW5mbyBtaWwgbmFtZSBuZXQgb3JnIHBybyAnLFxuICAgICAgJ2ZrJzonIGFjIGNvIGdvdiBuZXQgbm9tIG9yZyAnLFxuICAgICAgJ2ZyJzonIGFzc28gY29tIGYgZ291diBub20gcHJkIHByZXNzZSB0bSAnLFxuICAgICAgJ2dnJzonIGNvIG5ldCBvcmcgJyxcbiAgICAgICdnaCc6JyBjb20gZWR1IGdvdiBtaWwgb3JnICcsXG4gICAgICAnZ24nOicgYWMgY29tIGdvdiBuZXQgb3JnICcsXG4gICAgICAnZ3InOicgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgJyxcbiAgICAgICdndCc6JyBjb20gZWR1IGdvYiBpbmQgbWlsIG5ldCBvcmcgJyxcbiAgICAgICdndSc6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnaGsnOicgY29tIGVkdSBnb3YgaWR2IG5ldCBvcmcgJyxcbiAgICAgICdodSc6JyAyMDAwIGFncmFyIGJvbHQgY2FzaW5vIGNpdHkgY28gZXJvdGljYSBlcm90aWthIGZpbG0gZm9ydW0gZ2FtZXMgaG90ZWwgaW5mbyBpbmdhdGxhbiBqb2dhc3oga29ueXZlbG8gbGFrYXMgbWVkaWEgbmV3cyBvcmcgcHJpdiByZWtsYW0gc2V4IHNob3Agc3BvcnQgc3VsaSBzemV4IHRtIHRvenNkZSB1dGF6YXMgdmlkZW8gJyxcbiAgICAgICdpZCc6JyBhYyBjbyBnbyBtaWwgbmV0IG9yIHNjaCB3ZWIgJyxcbiAgICAgICdpbCc6JyBhYyBjbyBnb3YgaWRmIGsxMiBtdW5pIG5ldCBvcmcgJyxcbiAgICAgICdpbic6JyBhYyBjbyBlZHUgZXJuZXQgZmlybSBnZW4gZ292IGkgaW5kIG1pbCBuZXQgbmljIG9yZyByZXMgJyxcbiAgICAgICdpcSc6JyBjb20gZWR1IGdvdiBpIG1pbCBuZXQgb3JnICcsXG4gICAgICAnaXInOicgYWMgY28gZG5zc2VjIGdvdiBpIGlkIG5ldCBvcmcgc2NoICcsXG4gICAgICAnaXQnOicgZWR1IGdvdiAnLFxuICAgICAgJ2plJzonIGNvIG5ldCBvcmcgJyxcbiAgICAgICdqbyc6JyBjb20gZWR1IGdvdiBtaWwgbmFtZSBuZXQgb3JnIHNjaCAnLFxuICAgICAgJ2pwJzonIGFjIGFkIGNvIGVkIGdvIGdyIGxnIG5lIG9yICcsXG4gICAgICAna2UnOicgYWMgY28gZ28gaW5mbyBtZSBtb2JpIG5lIG9yIHNjICcsXG4gICAgICAna2gnOicgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgcGVyICcsXG4gICAgICAna2knOicgYml6IGNvbSBkZSBlZHUgZ292IGluZm8gbW9iIG5ldCBvcmcgdGVsICcsXG4gICAgICAna20nOicgYXNzbyBjb20gY29vcCBlZHUgZ291diBrIG1lZGVjaW4gbWlsIG5vbSBub3RhaXJlcyBwaGFybWFjaWVucyBwcmVzc2UgdG0gdmV0ZXJpbmFpcmUgJyxcbiAgICAgICdrbic6JyBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdrcic6JyBhYyBidXNhbiBjaHVuZ2J1ayBjaHVuZ25hbSBjbyBkYWVndSBkYWVqZW9uIGVzIGdhbmd3b24gZ28gZ3dhbmdqdSBneWVvbmdidWsgZ3llb25nZ2kgZ3llb25nbmFtIGhzIGluY2hlb24gamVqdSBqZW9uYnVrIGplb25uYW0gayBrZyBtaWwgbXMgbmUgb3IgcGUgcmUgc2Mgc2VvdWwgdWxzYW4gJyxcbiAgICAgICdrdyc6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAna3knOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2t6JzonIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICcsXG4gICAgICAnbGInOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ2xrJzonIGFzc24gY29tIGVkdSBnb3YgZ3JwIGhvdGVsIGludCBsdGQgbmV0IG5nbyBvcmcgc2NoIHNvYyB3ZWIgJyxcbiAgICAgICdscic6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnbHYnOicgYXNuIGNvbSBjb25mIGVkdSBnb3YgaWQgbWlsIG5ldCBvcmcgJyxcbiAgICAgICdseSc6JyBjb20gZWR1IGdvdiBpZCBtZWQgbmV0IG9yZyBwbGMgc2NoICcsXG4gICAgICAnbWEnOicgYWMgY28gZ292IG0gbmV0IG9yZyBwcmVzcyAnLFxuICAgICAgJ21jJzonIGFzc28gdG0gJyxcbiAgICAgICdtZSc6JyBhYyBjbyBlZHUgZ292IGl0cyBuZXQgb3JnIHByaXYgJyxcbiAgICAgICdtZyc6JyBjb20gZWR1IGdvdiBtaWwgbm9tIG9yZyBwcmQgdG0gJyxcbiAgICAgICdtayc6JyBjb20gZWR1IGdvdiBpbmYgbmFtZSBuZXQgb3JnIHBybyAnLFxuICAgICAgJ21sJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgcHJlc3NlICcsXG4gICAgICAnbW4nOicgZWR1IGdvdiBvcmcgJyxcbiAgICAgICdtbyc6JyBjb20gZWR1IGdvdiBuZXQgb3JnICcsXG4gICAgICAnbXQnOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ212JzonIGFlcm8gYml6IGNvbSBjb29wIGVkdSBnb3YgaW5mbyBpbnQgbWlsIG11c2V1bSBuYW1lIG5ldCBvcmcgcHJvICcsXG4gICAgICAnbXcnOicgYWMgY28gY29tIGNvb3AgZWR1IGdvdiBpbnQgbXVzZXVtIG5ldCBvcmcgJyxcbiAgICAgICdteCc6JyBjb20gZWR1IGdvYiBuZXQgb3JnICcsXG4gICAgICAnbXknOicgY29tIGVkdSBnb3YgbWlsIG5hbWUgbmV0IG9yZyBzY2ggJyxcbiAgICAgICduZic6JyBhcnRzIGNvbSBmaXJtIGluZm8gbmV0IG90aGVyIHBlciByZWMgc3RvcmUgd2ViICcsXG4gICAgICAnbmcnOicgYml6IGNvbSBlZHUgZ292IG1pbCBtb2JpIG5hbWUgbmV0IG9yZyBzY2ggJyxcbiAgICAgICduaSc6JyBhYyBjbyBjb20gZWR1IGdvYiBtaWwgbmV0IG5vbSBvcmcgJyxcbiAgICAgICducCc6JyBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAnLFxuICAgICAgJ25yJzonIGJpeiBjb20gZWR1IGdvdiBpbmZvIG5ldCBvcmcgJyxcbiAgICAgICdvbSc6JyBhYyBiaXogY28gY29tIGVkdSBnb3YgbWVkIG1pbCBtdXNldW0gbmV0IG9yZyBwcm8gc2NoICcsXG4gICAgICAncGUnOicgY29tIGVkdSBnb2IgbWlsIG5ldCBub20gb3JnIHNsZCAnLFxuICAgICAgJ3BoJzonIGNvbSBlZHUgZ292IGkgbWlsIG5ldCBuZ28gb3JnICcsXG4gICAgICAncGsnOicgYml6IGNvbSBlZHUgZmFtIGdvYiBnb2sgZ29uIGdvcCBnb3MgZ292IG5ldCBvcmcgd2ViICcsXG4gICAgICAncGwnOicgYXJ0IGJpYWx5c3RvayBiaXogY29tIGVkdSBnZGEgZ2RhbnNrIGdvcnpvdyBnb3YgaW5mbyBrYXRvd2ljZSBrcmFrb3cgbG9keiBsdWJsaW4gbWlsIG5ldCBuZ28gb2xzenR5biBvcmcgcG96bmFuIHB3ciByYWRvbSBzbHVwc2sgc3pjemVjaW4gdG9ydW4gd2Fyc3phd2Egd2F3IHdyb2Mgd3JvY2xhdyB6Z29yYSAnLFxuICAgICAgJ3ByJzonIGFjIGJpeiBjb20gZWR1IGVzdCBnb3YgaW5mbyBpc2xhIG5hbWUgbmV0IG9yZyBwcm8gcHJvZiAnLFxuICAgICAgJ3BzJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgcGxvIHNlYyAnLFxuICAgICAgJ3B3JzonIGJlbGF1IGNvIGVkIGdvIG5lIG9yICcsXG4gICAgICAncm8nOicgYXJ0cyBjb20gZmlybSBpbmZvIG5vbSBudCBvcmcgcmVjIHN0b3JlIHRtIHd3dyAnLFxuICAgICAgJ3JzJzonIGFjIGNvIGVkdSBnb3YgaW4gb3JnICcsXG4gICAgICAnc2InOicgY29tIGVkdSBnb3YgbmV0IG9yZyAnLFxuICAgICAgJ3NjJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdzaCc6JyBjbyBjb20gZWR1IGdvdiBuZXQgbm9tIG9yZyAnLFxuICAgICAgJ3NsJzonIGNvbSBlZHUgZ292IG5ldCBvcmcgJyxcbiAgICAgICdzdCc6JyBjbyBjb20gY29uc3VsYWRvIGVkdSBlbWJhaXhhZGEgZ292IG1pbCBuZXQgb3JnIHByaW5jaXBlIHNhb3RvbWUgc3RvcmUgJyxcbiAgICAgICdzdic6JyBjb20gZWR1IGdvYiBvcmcgcmVkICcsXG4gICAgICAnc3onOicgYWMgY28gb3JnICcsXG4gICAgICAndHInOicgYXYgYmJzIGJlbCBiaXogY29tIGRyIGVkdSBnZW4gZ292IGluZm8gazEyIG5hbWUgbmV0IG9yZyBwb2wgdGVsIHRzayB0diB3ZWIgJyxcbiAgICAgICd0dCc6JyBhZXJvIGJpeiBjYXQgY28gY29tIGNvb3AgZWR1IGdvdiBpbmZvIGludCBqb2JzIG1pbCBtb2JpIG11c2V1bSBuYW1lIG5ldCBvcmcgcHJvIHRlbCB0cmF2ZWwgJyxcbiAgICAgICd0dyc6JyBjbHViIGNvbSBlYml6IGVkdSBnYW1lIGdvdiBpZHYgbWlsIG5ldCBvcmcgJyxcbiAgICAgICdtdSc6JyBhYyBjbyBjb20gZ292IG5ldCBvciBvcmcgJyxcbiAgICAgICdteic6JyBhYyBjbyBlZHUgZ292IG9yZyAnLFxuICAgICAgJ25hJzonIGNvIGNvbSAnLFxuICAgICAgJ256JzonIGFjIGNvIGNyaSBnZWVrIGdlbiBnb3Z0IGhlYWx0aCBpd2kgbWFvcmkgbWlsIG5ldCBvcmcgcGFybGlhbWVudCBzY2hvb2wgJyxcbiAgICAgICdwYSc6JyBhYm8gYWMgY29tIGVkdSBnb2IgaW5nIG1lZCBuZXQgbm9tIG9yZyBzbGQgJyxcbiAgICAgICdwdCc6JyBjb20gZWR1IGdvdiBpbnQgbmV0IG5vbWUgb3JnIHB1YmwgJyxcbiAgICAgICdweSc6JyBjb20gZWR1IGdvdiBtaWwgbmV0IG9yZyAnLFxuICAgICAgJ3FhJzonIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICcsXG4gICAgICAncmUnOicgYXNzbyBjb20gbm9tICcsXG4gICAgICAncnUnOicgYWMgYWR5Z2V5YSBhbHRhaSBhbXVyIGFya2hhbmdlbHNrIGFzdHJha2hhbiBiYXNoa2lyaWEgYmVsZ29yb2QgYmlyIGJyeWFuc2sgYnVyeWF0aWEgY2JnIGNoZWwgY2hlbHlhYmluc2sgY2hpdGEgY2h1a290a2EgY2h1dmFzaGlhIGNvbSBkYWdlc3RhbiBlLWJ1cmcgZWR1IGdvdiBncm96bnkgaW50IGlya3V0c2sgaXZhbm92byBpemhldnNrIGphciBqb3Noa2FyLW9sYSBrYWxteWtpYSBrYWx1Z2Ega2FtY2hhdGthIGthcmVsaWEga2F6YW4ga2NociBrZW1lcm92byBraGFiYXJvdnNrIGtoYWthc3NpYSBraHYga2lyb3Yga29lbmlnIGtvbWkga29zdHJvbWEga3Jhbm95YXJzayBrdWJhbiBrdXJnYW4ga3Vyc2sgbGlwZXRzayBtYWdhZGFuIG1hcmkgbWFyaS1lbCBtYXJpbmUgbWlsIG1vcmRvdmlhIG1vc3JlZyBtc2sgbXVybWFuc2sgbmFsY2hpayBuZXQgbm5vdiBub3Ygbm92b3NpYmlyc2sgbnNrIG9tc2sgb3JlbmJ1cmcgb3JnIG9yeW9sIHBlbnphIHBlcm0gcHAgcHNrb3YgcHR6IHJuZCByeWF6YW4gc2FraGFsaW4gc2FtYXJhIHNhcmF0b3Ygc2ltYmlyc2sgc21vbGVuc2sgc3BiIHN0YXZyb3BvbCBzdHYgc3VyZ3V0IHRhbWJvdiB0YXRhcnN0YW4gdG9tIHRvbXNrIHRzYXJpdHN5biB0c2sgdHVsYSB0dXZhIHR2ZXIgdHl1bWVuIHVkbSB1ZG11cnRpYSB1bGFuLXVkZSB2bGFkaWthdmtheiB2bGFkaW1pciB2bGFkaXZvc3RvayB2b2xnb2dyYWQgdm9sb2dkYSB2b3JvbmV6aCB2cm4gdnlhdGthIHlha3V0aWEgeWFtYWwgeWVrYXRlcmluYnVyZyB5dXpobm8tc2FraGFsaW5zayAnLFxuICAgICAgJ3J3JzonIGFjIGNvIGNvbSBlZHUgZ291diBnb3YgaW50IG1pbCBuZXQgJyxcbiAgICAgICdzYSc6JyBjb20gZWR1IGdvdiBtZWQgbmV0IG9yZyBwdWIgc2NoICcsXG4gICAgICAnc2QnOicgY29tIGVkdSBnb3YgaW5mbyBtZWQgbmV0IG9yZyB0diAnLFxuICAgICAgJ3NlJzonIGEgYWMgYiBiZCBjIGQgZSBmIGcgaCBpIGsgbCBtIG4gbyBvcmcgcCBwYXJ0aSBwcCBwcmVzcyByIHMgdCB0bSB1IHcgeCB5IHogJyxcbiAgICAgICdzZyc6JyBjb20gZWR1IGdvdiBpZG4gbmV0IG9yZyBwZXIgJyxcbiAgICAgICdzbic6JyBhcnQgY29tIGVkdSBnb3V2IG9yZyBwZXJzbyB1bml2ICcsXG4gICAgICAnc3knOicgY29tIGVkdSBnb3YgbWlsIG5ldCBuZXdzIG9yZyAnLFxuICAgICAgJ3RoJzonIGFjIGNvIGdvIGluIG1pIG5ldCBvciAnLFxuICAgICAgJ3RqJzonIGFjIGJpeiBjbyBjb20gZWR1IGdvIGdvdiBpbmZvIGludCBtaWwgbmFtZSBuZXQgbmljIG9yZyB0ZXN0IHdlYiAnLFxuICAgICAgJ3RuJzonIGFncmluZXQgY29tIGRlZmVuc2UgZWR1bmV0IGVucyBmaW4gZ292IGluZCBpbmZvIGludGwgbWluY29tIG5hdCBuZXQgb3JnIHBlcnNvIHJucnQgcm5zIHJudSB0b3VyaXNtICcsXG4gICAgICAndHonOicgYWMgY28gZ28gbmUgb3IgJyxcbiAgICAgICd1YSc6JyBiaXogY2hlcmthc3N5IGNoZXJuaWdvdiBjaGVybm92dHN5IGNrIGNuIGNvIGNvbSBjcmltZWEgY3YgZG4gZG5lcHJvcGV0cm92c2sgZG9uZXRzayBkcCBlZHUgZ292IGlmIGluIGl2YW5vLWZyYW5raXZzayBraCBraGFya292IGtoZXJzb24ga2htZWxuaXRza2l5IGtpZXYga2lyb3ZvZ3JhZCBrbSBrciBrcyBrdiBsZyBsdWdhbnNrIGx1dHNrIGx2aXYgbWUgbWsgbmV0IG5pa29sYWV2IG9kIG9kZXNzYSBvcmcgcGwgcG9sdGF2YSBwcCByb3ZubyBydiBzZWJhc3RvcG9sIHN1bXkgdGUgdGVybm9waWwgdXpoZ29yb2QgdmlubmljYSB2biB6YXBvcml6aHpoZSB6aGl0b21pciB6cCB6dCAnLFxuICAgICAgJ3VnJzonIGFjIGNvIGdvIG5lIG9yIG9yZyBzYyAnLFxuICAgICAgJ3VrJzonIGFjIGJsIGJyaXRpc2gtbGlicmFyeSBjbyBjeW0gZ292IGdvdnQgaWNuZXQgamV0IGxlYSBsdGQgbWUgbWlsIG1vZCBuYXRpb25hbC1saWJyYXJ5LXNjb3RsYW5kIG5lbCBuZXQgbmhzIG5pYyBubHMgb3JnIG9yZ24gcGFybGlhbWVudCBwbGMgcG9saWNlIHNjaCBzY290IHNvYyAnLFxuICAgICAgJ3VzJzonIGRuaSBmZWQgaXNhIGtpZHMgbnNuICcsXG4gICAgICAndXknOicgY29tIGVkdSBndWIgbWlsIG5ldCBvcmcgJyxcbiAgICAgICd2ZSc6JyBjbyBjb20gZWR1IGdvYiBpbmZvIG1pbCBuZXQgb3JnIHdlYiAnLFxuICAgICAgJ3ZpJzonIGNvIGNvbSBrMTIgbmV0IG9yZyAnLFxuICAgICAgJ3ZuJzonIGFjIGJpeiBjb20gZWR1IGdvdiBoZWFsdGggaW5mbyBpbnQgbmFtZSBuZXQgb3JnIHBybyAnLFxuICAgICAgJ3llJzonIGNvIGNvbSBnb3YgbHRkIG1lIG5ldCBvcmcgcGxjICcsXG4gICAgICAneXUnOicgYWMgY28gZWR1IGdvdiBvcmcgJyxcbiAgICAgICd6YSc6JyBhYyBhZ3JpYyBhbHQgYm91cnNlIGNpdHkgY28gY3liZXJuZXQgZGIgZWR1IGdvdiBncm9uZGFyIGlhY2Nlc3MgaW10IGluY2EgbGFuZGVzaWduIGxhdyBtaWwgbmV0IG5nbyBuaXMgbm9tIG9saXZldHRpIG9yZyBwaXggc2Nob29sIHRtIHdlYiAnLFxuICAgICAgJ3ptJzonIGFjIGNvIGNvbSBlZHUgZ292IG5ldCBvcmcgc2NoICcsXG4gICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cmFsTmljI1NlY29uZC1sZXZlbF9kb21haW5zXG4gICAgICAnY29tJzogJ2FyIGJyIGNuIGRlIGV1IGdiIGdyIGh1IGpwbiBrciBubyBxYyBydSBzYSBzZSB1ayB1cyB1eSB6YSAnLFxuICAgICAgJ25ldCc6ICdnYiBqcCBzZSB1ayAnLFxuICAgICAgJ29yZyc6ICdhZScsXG4gICAgICAnZGUnOiAnY29tICdcbiAgICB9LFxuICAgIC8vIGdvcmhpbGwgMjAxMy0xMC0yNTogVXNpbmcgaW5kZXhPZigpIGluc3RlYWQgUmVnZXhwKCkuIFNpZ25pZmljYW50IGJvb3N0XG4gICAgLy8gaW4gYm90aCBwZXJmb3JtYW5jZSBhbmQgbWVtb3J5IGZvb3RwcmludC4gTm8gaW5pdGlhbGl6YXRpb24gcmVxdWlyZWQuXG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdXJpLWpzLXNsZC1yZWdleC12cy1iaW5hcnktc2VhcmNoLzRcbiAgICAvLyBGb2xsb3dpbmcgbWV0aG9kcyB1c2UgbGFzdEluZGV4T2YoKSByYXRoZXIgdGhhbiBhcnJheS5zcGxpdCgpIGluIG9yZGVyXG4gICAgLy8gdG8gYXZvaWQgYW55IG1lbW9yeSBhbGxvY2F0aW9ucy5cbiAgICBoYXM6IGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgdmFyIHRsZE9mZnNldCA9IGRvbWFpbi5sYXN0SW5kZXhPZignLicpO1xuICAgICAgaWYgKHRsZE9mZnNldCA8PSAwIHx8IHRsZE9mZnNldCA+PSAoZG9tYWluLmxlbmd0aC0xKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgc2xkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCcuJywgdGxkT2Zmc2V0LTEpO1xuICAgICAgaWYgKHNsZE9mZnNldCA8PSAwIHx8IHNsZE9mZnNldCA+PSAodGxkT2Zmc2V0LTEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzbGRMaXN0ID0gU0xELmxpc3RbZG9tYWluLnNsaWNlKHRsZE9mZnNldCsxKV07XG4gICAgICBpZiAoIXNsZExpc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsZExpc3QuaW5kZXhPZignICcgKyBkb21haW4uc2xpY2Uoc2xkT2Zmc2V0KzEsIHRsZE9mZnNldCkgKyAnICcpID49IDA7XG4gICAgfSxcbiAgICBpczogZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICB2YXIgdGxkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICBpZiAodGxkT2Zmc2V0IDw9IDAgfHwgdGxkT2Zmc2V0ID49IChkb21haW4ubGVuZ3RoLTEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzbGRPZmZzZXQgPSBkb21haW4ubGFzdEluZGV4T2YoJy4nLCB0bGRPZmZzZXQtMSk7XG4gICAgICBpZiAoc2xkT2Zmc2V0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHNsZExpc3QgPSBTTEQubGlzdFtkb21haW4uc2xpY2UodGxkT2Zmc2V0KzEpXTtcbiAgICAgIGlmICghc2xkTGlzdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xkTGlzdC5pbmRleE9mKCcgJyArIGRvbWFpbi5zbGljZSgwLCB0bGRPZmZzZXQpICsgJyAnKSA+PSAwO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbihkb21haW4pIHtcbiAgICAgIHZhciB0bGRPZmZzZXQgPSBkb21haW4ubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmICh0bGRPZmZzZXQgPD0gMCB8fCB0bGRPZmZzZXQgPj0gKGRvbWFpbi5sZW5ndGgtMSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc2xkT2Zmc2V0ID0gZG9tYWluLmxhc3RJbmRleE9mKCcuJywgdGxkT2Zmc2V0LTEpO1xuICAgICAgaWYgKHNsZE9mZnNldCA8PSAwIHx8IHNsZE9mZnNldCA+PSAodGxkT2Zmc2V0LTEpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHNsZExpc3QgPSBTTEQubGlzdFtkb21haW4uc2xpY2UodGxkT2Zmc2V0KzEpXTtcbiAgICAgIGlmICghc2xkTGlzdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzbGRMaXN0LmluZGV4T2YoJyAnICsgZG9tYWluLnNsaWNlKHNsZE9mZnNldCsxLCB0bGRPZmZzZXQpICsgJyAnKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tYWluLnNsaWNlKHNsZE9mZnNldCsxKTtcbiAgICB9LFxuICAgIG5vQ29uZmxpY3Q6IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAocm9vdC5TZWNvbmRMZXZlbERvbWFpbnMgPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5TZWNvbmRMZXZlbERvbWFpbnMgPSBfU2Vjb25kTGV2ZWxEb21haW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTTEQ7XG59KSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiYW1kIiwiU2Vjb25kTGV2ZWxEb21haW5zIiwiX1NlY29uZExldmVsRG9tYWlucyIsIlNMRCIsImxpc3QiLCJoYXMiLCJkb21haW4iLCJ0bGRPZmZzZXQiLCJsYXN0SW5kZXhPZiIsImxlbmd0aCIsInNsZE9mZnNldCIsInNsZExpc3QiLCJzbGljZSIsImluZGV4T2YiLCJpcyIsImdldCIsIm5vQ29uZmxpY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/SecondLevelDomains.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/URI.js":
/*!***************************************!*\
  !*** ./node_modules/urijs/src/URI.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * URI.js - Mutating URLs\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */ (function(root, factory) {\n    \"use strict\";\n    // https://github.com/umdjs/umd/blob/master/returnExports.js\n    if ( true && module.exports) {\n        // Node\n        module.exports = factory(__webpack_require__(/*! ./punycode */ \"(ssr)/./node_modules/urijs/src/punycode.js\"), __webpack_require__(/*! ./IPv6 */ \"(ssr)/./node_modules/urijs/src/IPv6.js\"), __webpack_require__(/*! ./SecondLevelDomains */ \"(ssr)/./node_modules/urijs/src/SecondLevelDomains.js\"));\n    } else if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ./punycode */ \"(ssr)/./node_modules/urijs/src/punycode.js\"),\n            __webpack_require__(/*! ./IPv6 */ \"(ssr)/./node_modules/urijs/src/IPv6.js\"),\n            __webpack_require__(/*! ./SecondLevelDomains */ \"(ssr)/./node_modules/urijs/src/SecondLevelDomains.js\")\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function(punycode, IPv6, SLD, root) {\n    \"use strict\";\n    /*global location, escape, unescape */ // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n    /*jshint camelcase: false */ // save current URI variable, if any\n    var _URI = root && root.URI;\n    function URI(url, base) {\n        var _urlSupplied = arguments.length >= 1;\n        var _baseSupplied = arguments.length >= 2;\n        // Allow instantiation without the 'new' keyword\n        if (!(this instanceof URI)) {\n            if (_urlSupplied) {\n                if (_baseSupplied) {\n                    return new URI(url, base);\n                }\n                return new URI(url);\n            }\n            return new URI();\n        }\n        if (url === undefined) {\n            if (_urlSupplied) {\n                throw new TypeError(\"undefined is not a valid argument for URI\");\n            }\n            if (typeof location !== \"undefined\") {\n                url = location.href + \"\";\n            } else {\n                url = \"\";\n            }\n        }\n        if (url === null) {\n            if (_urlSupplied) {\n                throw new TypeError(\"null is not a valid argument for URI\");\n            }\n        }\n        this.href(url);\n        // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor\n        if (base !== undefined) {\n            return this.absoluteTo(base);\n        }\n        return this;\n    }\n    function isInteger(value) {\n        return /^[0-9]+$/.test(value);\n    }\n    URI.version = \"1.19.11\";\n    var p = URI.prototype;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    function escapeRegEx(string) {\n        // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963\n        return string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n    }\n    function getType(value) {\n        // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value\n        if (value === undefined) {\n            return \"Undefined\";\n        }\n        return String(Object.prototype.toString.call(value)).slice(8, -1);\n    }\n    function isArray(obj) {\n        return getType(obj) === \"Array\";\n    }\n    function filterArrayValues(data, value) {\n        var lookup = {};\n        var i, length;\n        if (getType(value) === \"RegExp\") {\n            lookup = null;\n        } else if (isArray(value)) {\n            for(i = 0, length = value.length; i < length; i++){\n                lookup[value[i]] = true;\n            }\n        } else {\n            lookup[value] = true;\n        }\n        for(i = 0, length = data.length; i < length; i++){\n            /*jshint laxbreak: true */ var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);\n            /*jshint laxbreak: false */ if (_match) {\n                data.splice(i, 1);\n                length--;\n                i--;\n            }\n        }\n        return data;\n    }\n    function arrayContains(list, value) {\n        var i, length;\n        // value may be string, number, array, regexp\n        if (isArray(value)) {\n            // Note: this can be optimized to O(n) (instead of current O(m * n))\n            for(i = 0, length = value.length; i < length; i++){\n                if (!arrayContains(list, value[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        var _type = getType(value);\n        for(i = 0, length = list.length; i < length; i++){\n            if (_type === \"RegExp\") {\n                if (typeof list[i] === \"string\" && list[i].match(value)) {\n                    return true;\n                }\n            } else if (list[i] === value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function arraysEqual(one, two) {\n        if (!isArray(one) || !isArray(two)) {\n            return false;\n        }\n        // arrays can't be equal if they have different amount of content\n        if (one.length !== two.length) {\n            return false;\n        }\n        one.sort();\n        two.sort();\n        for(var i = 0, l = one.length; i < l; i++){\n            if (one[i] !== two[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function trimSlashes(text) {\n        var trim_expression = /^\\/+|\\/+$/g;\n        return text.replace(trim_expression, \"\");\n    }\n    URI._parts = function() {\n        return {\n            protocol: null,\n            username: null,\n            password: null,\n            hostname: null,\n            urn: null,\n            port: null,\n            path: null,\n            query: null,\n            fragment: null,\n            // state\n            preventInvalidHostname: URI.preventInvalidHostname,\n            duplicateQueryParameters: URI.duplicateQueryParameters,\n            escapeQuerySpace: URI.escapeQuerySpace\n        };\n    };\n    // state: throw on invalid hostname\n    // see https://github.com/medialize/URI.js/pull/345\n    // and https://github.com/medialize/URI.js/issues/354\n    URI.preventInvalidHostname = false;\n    // state: allow duplicate query parameters (a=1&a=1)\n    URI.duplicateQueryParameters = false;\n    // state: replaces + with %20 (space in query strings)\n    URI.escapeQuerySpace = true;\n    // static properties\n    URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;\n    URI.idn_expression = /[^a-z0-9\\._-]/i;\n    URI.punycode_expression = /(xn--)/i;\n    // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?\n    URI.ip4_expression = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n    // credits to Rich Brown\n    // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096\n    // specification: http://www.ietf.org/rfc/rfc4291.txt\n    URI.ip6_expression = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/;\n    // expression used is \"gruber revised\" (@gruber v2) determined to be the\n    // best solution in a regex-golf we did a couple of ages ago at\n    // * http://mathiasbynens.be/demo/url-regex\n    // * http://rodneyrehm.de/t/url-regex.html\n    URI.find_uri_expression = /\\b((?:[a-z][\\w-]+:(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’]))/ig;\n    URI.findUri = {\n        // valid \"scheme://\" or \"www.\"\n        start: /\\b(?:([a-z][a-z0-9.+-]*:\\/\\/)|www\\.)/gi,\n        // everything up to the next whitespace\n        end: /[\\s\\r\\n]|$/,\n        // trim trailing punctuation captured by end RegExp\n        trim: /[`!()\\[\\]{};:'\".,<>?«»“”„‘’]+$/,\n        // balanced parens inclusion (), [], {}, <>\n        parens: /(\\([^\\)]*\\)|\\[[^\\]]*\\]|\\{[^}]*\\}|<[^>]*>)/g\n    };\n    URI.leading_whitespace_expression = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n    // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n    URI.ascii_tab_whitespace = /[\\u0009\\u000A\\u000D]+/g;\n    // http://www.iana.org/assignments/uri-schemes.html\n    // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports\n    URI.defaultPorts = {\n        http: \"80\",\n        https: \"443\",\n        ftp: \"21\",\n        gopher: \"70\",\n        ws: \"80\",\n        wss: \"443\"\n    };\n    // list of protocols which always require a hostname\n    URI.hostProtocols = [\n        \"http\",\n        \"https\"\n    ];\n    // allowed hostname characters according to RFC 3986\n    // ALPHA DIGIT \"-\" \".\" \"_\" \"~\" \"!\" \"$\" \"&\" \"'\" \"(\" \")\" \"*\" \"+\" \",\" \";\" \"=\" %encoded\n    // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _\n    URI.invalid_hostname_characters = /[^a-zA-Z0-9\\.\\-:_]/;\n    // map DOM Elements to their URI attribute\n    URI.domAttributes = {\n        \"a\": \"href\",\n        \"blockquote\": \"cite\",\n        \"link\": \"href\",\n        \"base\": \"href\",\n        \"script\": \"src\",\n        \"form\": \"action\",\n        \"img\": \"src\",\n        \"area\": \"href\",\n        \"iframe\": \"src\",\n        \"embed\": \"src\",\n        \"source\": \"src\",\n        \"track\": \"src\",\n        \"input\": \"src\",\n        \"audio\": \"src\",\n        \"video\": \"src\"\n    };\n    URI.getDomAttribute = function(node) {\n        if (!node || !node.nodeName) {\n            return undefined;\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        // <input> should only expose src for type=\"image\"\n        if (nodeName === \"input\" && node.type !== \"image\") {\n            return undefined;\n        }\n        return URI.domAttributes[nodeName];\n    };\n    function escapeForDumbFirefox36(value) {\n        // https://github.com/medialize/URI.js/issues/91\n        return escape(value);\n    }\n    // encoding / decoding according to RFC3986\n    function strictEncodeURIComponent(string) {\n        // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent\n        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\\*/g, \"%2A\");\n    }\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = decodeURIComponent;\n    URI.iso8859 = function() {\n        URI.encode = escape;\n        URI.decode = unescape;\n    };\n    URI.unicode = function() {\n        URI.encode = strictEncodeURIComponent;\n        URI.decode = decodeURIComponent;\n    };\n    URI.characters = {\n        pathname: {\n            encode: {\n                // RFC3986 2.1: For consistency, URI producers and normalizers should\n                // use uppercase hexadecimal digits for all percent-encodings.\n                expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,\n                map: {\n                    // -._~!'()*\n                    \"%24\": \"$\",\n                    \"%26\": \"&\",\n                    \"%2B\": \"+\",\n                    \"%2C\": \",\",\n                    \"%3B\": \";\",\n                    \"%3D\": \"=\",\n                    \"%3A\": \":\",\n                    \"%40\": \"@\"\n                }\n            },\n            decode: {\n                expression: /[\\/\\?#]/g,\n                map: {\n                    \"/\": \"%2F\",\n                    \"?\": \"%3F\",\n                    \"#\": \"%23\"\n                }\n            }\n        },\n        reserved: {\n            encode: {\n                // RFC3986 2.1: For consistency, URI producers and normalizers should\n                // use uppercase hexadecimal digits for all percent-encodings.\n                expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,\n                map: {\n                    // gen-delims\n                    \"%3A\": \":\",\n                    \"%2F\": \"/\",\n                    \"%3F\": \"?\",\n                    \"%23\": \"#\",\n                    \"%5B\": \"[\",\n                    \"%5D\": \"]\",\n                    \"%40\": \"@\",\n                    // sub-delims\n                    \"%21\": \"!\",\n                    \"%24\": \"$\",\n                    \"%26\": \"&\",\n                    \"%27\": \"'\",\n                    \"%28\": \"(\",\n                    \"%29\": \")\",\n                    \"%2A\": \"*\",\n                    \"%2B\": \"+\",\n                    \"%2C\": \",\",\n                    \"%3B\": \";\",\n                    \"%3D\": \"=\"\n                }\n            }\n        },\n        urnpath: {\n            // The characters under `encode` are the characters called out by RFC 2141 as being acceptable\n            // for usage in a URN. RFC2141 also calls out \"-\", \".\", and \"_\" as acceptable characters, but\n            // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also\n            // note that the colon character is not featured in the encoding map; this is because URI.js\n            // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it\n            // should not appear unencoded in a segment itself.\n            // See also the note above about RFC3986 and capitalalized hex digits.\n            encode: {\n                expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,\n                map: {\n                    \"%21\": \"!\",\n                    \"%24\": \"$\",\n                    \"%27\": \"'\",\n                    \"%28\": \"(\",\n                    \"%29\": \")\",\n                    \"%2A\": \"*\",\n                    \"%2B\": \"+\",\n                    \"%2C\": \",\",\n                    \"%3B\": \";\",\n                    \"%3D\": \"=\",\n                    \"%40\": \"@\"\n                }\n            },\n            // These characters are the characters called out by RFC2141 as \"reserved\" characters that\n            // should never appear in a URN, plus the colon character (see note above).\n            decode: {\n                expression: /[\\/\\?#:]/g,\n                map: {\n                    \"/\": \"%2F\",\n                    \"?\": \"%3F\",\n                    \"#\": \"%23\",\n                    \":\": \"%3A\"\n                }\n            }\n        }\n    };\n    URI.encodeQuery = function(string, escapeQuerySpace) {\n        var escaped = URI.encode(string + \"\");\n        if (escapeQuerySpace === undefined) {\n            escapeQuerySpace = URI.escapeQuerySpace;\n        }\n        return escapeQuerySpace ? escaped.replace(/%20/g, \"+\") : escaped;\n    };\n    URI.decodeQuery = function(string, escapeQuerySpace) {\n        string += \"\";\n        if (escapeQuerySpace === undefined) {\n            escapeQuerySpace = URI.escapeQuerySpace;\n        }\n        try {\n            return URI.decode(escapeQuerySpace ? string.replace(/\\+/g, \"%20\") : string);\n        } catch (e) {\n            // we're not going to mess with weird encodings,\n            // give up and return the undecoded original string\n            // see https://github.com/medialize/URI.js/issues/87\n            // see https://github.com/medialize/URI.js/issues/92\n            return string;\n        }\n    };\n    // generate encode/decode path functions\n    var _parts = {\n        \"encode\": \"encode\",\n        \"decode\": \"decode\"\n    };\n    var _part;\n    var generateAccessor = function(_group, _part) {\n        return function(string) {\n            try {\n                return URI[_part](string + \"\").replace(URI.characters[_group][_part].expression, function(c) {\n                    return URI.characters[_group][_part].map[c];\n                });\n            } catch (e) {\n                // we're not going to mess with weird encodings,\n                // give up and return the undecoded original string\n                // see https://github.com/medialize/URI.js/issues/87\n                // see https://github.com/medialize/URI.js/issues/92\n                return string;\n            }\n        };\n    };\n    for(_part in _parts){\n        URI[_part + \"PathSegment\"] = generateAccessor(\"pathname\", _parts[_part]);\n        URI[_part + \"UrnPathSegment\"] = generateAccessor(\"urnpath\", _parts[_part]);\n    }\n    var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {\n        return function(string) {\n            // Why pass in names of functions, rather than the function objects themselves? The\n            // definitions of some functions (but in particular, URI.decode) will occasionally change due\n            // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure\n            // that the functions we use here are \"fresh\".\n            var actualCodingFunc;\n            if (!_innerCodingFuncName) {\n                actualCodingFunc = URI[_codingFuncName];\n            } else {\n                actualCodingFunc = function(string) {\n                    return URI[_codingFuncName](URI[_innerCodingFuncName](string));\n                };\n            }\n            var segments = (string + \"\").split(_sep);\n            for(var i = 0, length = segments.length; i < length; i++){\n                segments[i] = actualCodingFunc(segments[i]);\n            }\n            return segments.join(_sep);\n        };\n    };\n    // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.\n    URI.decodePath = generateSegmentedPathFunction(\"/\", \"decodePathSegment\");\n    URI.decodeUrnPath = generateSegmentedPathFunction(\":\", \"decodeUrnPathSegment\");\n    URI.recodePath = generateSegmentedPathFunction(\"/\", \"encodePathSegment\", \"decode\");\n    URI.recodeUrnPath = generateSegmentedPathFunction(\":\", \"encodeUrnPathSegment\", \"decode\");\n    URI.encodeReserved = generateAccessor(\"reserved\", \"encode\");\n    URI.parse = function(string, parts) {\n        var pos;\n        if (!parts) {\n            parts = {\n                preventInvalidHostname: URI.preventInvalidHostname\n            };\n        }\n        string = string.replace(URI.leading_whitespace_expression, \"\");\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        string = string.replace(URI.ascii_tab_whitespace, \"\");\n        // [protocol\"://\"[username[\":\"password]\"@\"]hostname[\":\"port]\"/\"?][path][\"?\"querystring][\"#\"fragment]\n        // extract fragment\n        pos = string.indexOf(\"#\");\n        if (pos > -1) {\n            // escaping?\n            parts.fragment = string.substring(pos + 1) || null;\n            string = string.substring(0, pos);\n        }\n        // extract query\n        pos = string.indexOf(\"?\");\n        if (pos > -1) {\n            // escaping?\n            parts.query = string.substring(pos + 1) || null;\n            string = string.substring(0, pos);\n        }\n        // slashes and backslashes have lost all meaning for the web protocols (https, http, wss, ws)\n        string = string.replace(/^(https?|ftp|wss?)?:+[/\\\\]*/i, \"$1://\");\n        // slashes and backslashes have lost all meaning for scheme relative URLs\n        string = string.replace(/^[/\\\\]{2,}/i, \"//\");\n        // extract protocol\n        if (string.substring(0, 2) === \"//\") {\n            // relative-scheme\n            parts.protocol = null;\n            string = string.substring(2);\n            // extract \"user:pass@host:port\"\n            string = URI.parseAuthority(string, parts);\n        } else {\n            pos = string.indexOf(\":\");\n            if (pos > -1) {\n                parts.protocol = string.substring(0, pos) || null;\n                if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {\n                    // : may be within the path\n                    parts.protocol = undefined;\n                } else if (string.substring(pos + 1, pos + 3).replace(/\\\\/g, \"/\") === \"//\") {\n                    string = string.substring(pos + 3);\n                    // extract \"user:pass@host:port\"\n                    string = URI.parseAuthority(string, parts);\n                } else {\n                    string = string.substring(pos + 1);\n                    parts.urn = true;\n                }\n            }\n        }\n        // what's left must be the path\n        parts.path = string;\n        // and we're done\n        return parts;\n    };\n    URI.parseHost = function(string, parts) {\n        if (!string) {\n            string = \"\";\n        }\n        // Copy chrome, IE, opera backslash-handling behavior.\n        // Back slashes before the query string get converted to forward slashes\n        // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124\n        // See: https://code.google.com/p/chromium/issues/detail?id=25916\n        // https://github.com/medialize/URI.js/pull/233\n        string = string.replace(/\\\\/g, \"/\");\n        // extract host:port\n        var pos = string.indexOf(\"/\");\n        var bracketPos;\n        var t;\n        if (pos === -1) {\n            pos = string.length;\n        }\n        if (string.charAt(0) === \"[\") {\n            // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6\n            // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts\n            // IPv6+port in the format [2001:db8::1]:80 (for the time being)\n            bracketPos = string.indexOf(\"]\");\n            parts.hostname = string.substring(1, bracketPos) || null;\n            parts.port = string.substring(bracketPos + 2, pos) || null;\n            if (parts.port === \"/\") {\n                parts.port = null;\n            }\n        } else {\n            var firstColon = string.indexOf(\":\");\n            var firstSlash = string.indexOf(\"/\");\n            var nextColon = string.indexOf(\":\", firstColon + 1);\n            if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {\n                // IPv6 host contains multiple colons - but no port\n                // this notation is actually not allowed by RFC 3986, but we're a liberal parser\n                parts.hostname = string.substring(0, pos) || null;\n                parts.port = null;\n            } else {\n                t = string.substring(0, pos).split(\":\");\n                parts.hostname = t[0] || null;\n                parts.port = t[1] || null;\n            }\n        }\n        if (parts.hostname && string.substring(pos).charAt(0) !== \"/\") {\n            pos++;\n            string = \"/\" + string;\n        }\n        if (parts.preventInvalidHostname) {\n            URI.ensureValidHostname(parts.hostname, parts.protocol);\n        }\n        if (parts.port) {\n            URI.ensureValidPort(parts.port);\n        }\n        return string.substring(pos) || \"/\";\n    };\n    URI.parseAuthority = function(string, parts) {\n        string = URI.parseUserinfo(string, parts);\n        return URI.parseHost(string, parts);\n    };\n    URI.parseUserinfo = function(string, parts) {\n        // extract username:password\n        var _string = string;\n        var firstBackSlash = string.indexOf(\"\\\\\");\n        if (firstBackSlash !== -1) {\n            string = string.replace(/\\\\/g, \"/\");\n        }\n        var firstSlash = string.indexOf(\"/\");\n        var pos = string.lastIndexOf(\"@\", firstSlash > -1 ? firstSlash : string.length - 1);\n        var t;\n        // authority@ must come before /path or \\path\n        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {\n            t = string.substring(0, pos).split(\":\");\n            parts.username = t[0] ? URI.decode(t[0]) : null;\n            t.shift();\n            parts.password = t[0] ? URI.decode(t.join(\":\")) : null;\n            string = _string.substring(pos + 1);\n        } else {\n            parts.username = null;\n            parts.password = null;\n        }\n        return string;\n    };\n    URI.parseQuery = function(string, escapeQuerySpace) {\n        if (!string) {\n            return {};\n        }\n        // throw out the funky business - \"?\"[name\"=\"value\"&\"]+\n        string = string.replace(/&+/g, \"&\").replace(/^\\?*&*|&+$/g, \"\");\n        if (!string) {\n            return {};\n        }\n        var items = {};\n        var splits = string.split(\"&\");\n        var length = splits.length;\n        var v, name, value;\n        for(var i = 0; i < length; i++){\n            v = splits[i].split(\"=\");\n            name = URI.decodeQuery(v.shift(), escapeQuerySpace);\n            // no \"=\" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters\n            value = v.length ? URI.decodeQuery(v.join(\"=\"), escapeQuerySpace) : null;\n            if (name === \"__proto__\") {\n                continue;\n            } else if (hasOwn.call(items, name)) {\n                if (typeof items[name] === \"string\" || items[name] === null) {\n                    items[name] = [\n                        items[name]\n                    ];\n                }\n                items[name].push(value);\n            } else {\n                items[name] = value;\n            }\n        }\n        return items;\n    };\n    URI.build = function(parts) {\n        var t = \"\";\n        var requireAbsolutePath = false;\n        if (parts.protocol) {\n            t += parts.protocol + \":\";\n        }\n        if (!parts.urn && (t || parts.hostname)) {\n            t += \"//\";\n            requireAbsolutePath = true;\n        }\n        t += URI.buildAuthority(parts) || \"\";\n        if (typeof parts.path === \"string\") {\n            if (parts.path.charAt(0) !== \"/\" && requireAbsolutePath) {\n                t += \"/\";\n            }\n            t += parts.path;\n        }\n        if (typeof parts.query === \"string\" && parts.query) {\n            t += \"?\" + parts.query;\n        }\n        if (typeof parts.fragment === \"string\" && parts.fragment) {\n            t += \"#\" + parts.fragment;\n        }\n        return t;\n    };\n    URI.buildHost = function(parts) {\n        var t = \"\";\n        if (!parts.hostname) {\n            return \"\";\n        } else if (URI.ip6_expression.test(parts.hostname)) {\n            t += \"[\" + parts.hostname + \"]\";\n        } else {\n            t += parts.hostname;\n        }\n        if (parts.port) {\n            t += \":\" + parts.port;\n        }\n        return t;\n    };\n    URI.buildAuthority = function(parts) {\n        return URI.buildUserinfo(parts) + URI.buildHost(parts);\n    };\n    URI.buildUserinfo = function(parts) {\n        var t = \"\";\n        if (parts.username) {\n            t += URI.encode(parts.username);\n        }\n        if (parts.password) {\n            t += \":\" + URI.encode(parts.password);\n        }\n        if (t) {\n            t += \"@\";\n        }\n        return t;\n    };\n    URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {\n        // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html\n        // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed\n        // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!\n        // URI.js treats the query string as being application/x-www-form-urlencoded\n        // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type\n        var t = \"\";\n        var unique, key, i, length;\n        for(key in data){\n            if (key === \"__proto__\") {\n                continue;\n            } else if (hasOwn.call(data, key)) {\n                if (isArray(data[key])) {\n                    unique = {};\n                    for(i = 0, length = data[key].length; i < length; i++){\n                        if (data[key][i] !== undefined && unique[data[key][i] + \"\"] === undefined) {\n                            t += \"&\" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);\n                            if (duplicateQueryParameters !== true) {\n                                unique[data[key][i] + \"\"] = true;\n                            }\n                        }\n                    }\n                } else if (data[key] !== undefined) {\n                    t += \"&\" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);\n                }\n            }\n        }\n        return t.substring(1);\n    };\n    URI.buildQueryParameter = function(name, value, escapeQuerySpace) {\n        // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded\n        // don't append \"=\" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization\n        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? \"=\" + URI.encodeQuery(value, escapeQuerySpace) : \"\");\n    };\n    URI.addQuery = function(data, name, value) {\n        if (typeof name === \"object\") {\n            for(var key in name){\n                if (hasOwn.call(name, key)) {\n                    URI.addQuery(data, key, name[key]);\n                }\n            }\n        } else if (typeof name === \"string\") {\n            if (data[name] === undefined) {\n                data[name] = value;\n                return;\n            } else if (typeof data[name] === \"string\") {\n                data[name] = [\n                    data[name]\n                ];\n            }\n            if (!isArray(value)) {\n                value = [\n                    value\n                ];\n            }\n            data[name] = (data[name] || []).concat(value);\n        } else {\n            throw new TypeError(\"URI.addQuery() accepts an object, string as the name parameter\");\n        }\n    };\n    URI.setQuery = function(data, name, value) {\n        if (typeof name === \"object\") {\n            for(var key in name){\n                if (hasOwn.call(name, key)) {\n                    URI.setQuery(data, key, name[key]);\n                }\n            }\n        } else if (typeof name === \"string\") {\n            data[name] = value === undefined ? null : value;\n        } else {\n            throw new TypeError(\"URI.setQuery() accepts an object, string as the name parameter\");\n        }\n    };\n    URI.removeQuery = function(data, name, value) {\n        var i, length, key;\n        if (isArray(name)) {\n            for(i = 0, length = name.length; i < length; i++){\n                data[name[i]] = undefined;\n            }\n        } else if (getType(name) === \"RegExp\") {\n            for(key in data){\n                if (name.test(key)) {\n                    data[key] = undefined;\n                }\n            }\n        } else if (typeof name === \"object\") {\n            for(key in name){\n                if (hasOwn.call(name, key)) {\n                    URI.removeQuery(data, key, name[key]);\n                }\n            }\n        } else if (typeof name === \"string\") {\n            if (value !== undefined) {\n                if (getType(value) === \"RegExp\") {\n                    if (!isArray(data[name]) && value.test(data[name])) {\n                        data[name] = undefined;\n                    } else {\n                        data[name] = filterArrayValues(data[name], value);\n                    }\n                } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {\n                    data[name] = undefined;\n                } else if (isArray(data[name])) {\n                    data[name] = filterArrayValues(data[name], value);\n                }\n            } else {\n                data[name] = undefined;\n            }\n        } else {\n            throw new TypeError(\"URI.removeQuery() accepts an object, string, RegExp as the first parameter\");\n        }\n    };\n    URI.hasQuery = function(data, name, value, withinArray) {\n        switch(getType(name)){\n            case \"String\":\n                break;\n            case \"RegExp\":\n                for(var key in data){\n                    if (hasOwn.call(data, key)) {\n                        if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            case \"Object\":\n                for(var _key in name){\n                    if (hasOwn.call(name, _key)) {\n                        if (!URI.hasQuery(data, _key, name[_key])) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            default:\n                throw new TypeError(\"URI.hasQuery() accepts a string, regular expression or object as the name parameter\");\n        }\n        switch(getType(value)){\n            case \"Undefined\":\n                // true if exists (but may be empty)\n                return name in data; // data[name] !== undefined;\n            case \"Boolean\":\n                // true if exists and non-empty\n                var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);\n                return value === _booly;\n            case \"Function\":\n                // allow complex comparison\n                return !!value(data[name], name, data);\n            case \"Array\":\n                if (!isArray(data[name])) {\n                    return false;\n                }\n                var op = withinArray ? arrayContains : arraysEqual;\n                return op(data[name], value);\n            case \"RegExp\":\n                if (!isArray(data[name])) {\n                    return Boolean(data[name] && data[name].match(value));\n                }\n                if (!withinArray) {\n                    return false;\n                }\n                return arrayContains(data[name], value);\n            case \"Number\":\n                value = String(value);\n            /* falls through */ case \"String\":\n                if (!isArray(data[name])) {\n                    return data[name] === value;\n                }\n                if (!withinArray) {\n                    return false;\n                }\n                return arrayContains(data[name], value);\n            default:\n                throw new TypeError(\"URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter\");\n        }\n    };\n    URI.joinPaths = function() {\n        var input = [];\n        var segments = [];\n        var nonEmptySegments = 0;\n        for(var i = 0; i < arguments.length; i++){\n            var url = new URI(arguments[i]);\n            input.push(url);\n            var _segments = url.segment();\n            for(var s = 0; s < _segments.length; s++){\n                if (typeof _segments[s] === \"string\") {\n                    segments.push(_segments[s]);\n                }\n                if (_segments[s]) {\n                    nonEmptySegments++;\n                }\n            }\n        }\n        if (!segments.length || !nonEmptySegments) {\n            return new URI(\"\");\n        }\n        var uri = new URI(\"\").segment(segments);\n        if (input[0].path() === \"\" || input[0].path().slice(0, 1) === \"/\") {\n            uri.path(\"/\" + uri.path());\n        }\n        return uri.normalize();\n    };\n    URI.commonPath = function(one, two) {\n        var length = Math.min(one.length, two.length);\n        var pos;\n        // find first non-matching character\n        for(pos = 0; pos < length; pos++){\n            if (one.charAt(pos) !== two.charAt(pos)) {\n                pos--;\n                break;\n            }\n        }\n        if (pos < 1) {\n            return one.charAt(0) === two.charAt(0) && one.charAt(0) === \"/\" ? \"/\" : \"\";\n        }\n        // revert to last /\n        if (one.charAt(pos) !== \"/\" || two.charAt(pos) !== \"/\") {\n            pos = one.substring(0, pos).lastIndexOf(\"/\");\n        }\n        return one.substring(0, pos + 1);\n    };\n    URI.withinString = function(string, callback, options) {\n        options || (options = {});\n        var _start = options.start || URI.findUri.start;\n        var _end = options.end || URI.findUri.end;\n        var _trim = options.trim || URI.findUri.trim;\n        var _parens = options.parens || URI.findUri.parens;\n        var _attributeOpen = /[a-z0-9-]=[\"']?$/i;\n        _start.lastIndex = 0;\n        while(true){\n            var match = _start.exec(string);\n            if (!match) {\n                break;\n            }\n            var start = match.index;\n            if (options.ignoreHtml) {\n                // attribut(e=[\"']?$)\n                var attributeOpen = string.slice(Math.max(start - 3, 0), start);\n                if (attributeOpen && _attributeOpen.test(attributeOpen)) {\n                    continue;\n                }\n            }\n            var end = start + string.slice(start).search(_end);\n            var slice = string.slice(start, end);\n            // make sure we include well balanced parens\n            var parensEnd = -1;\n            while(true){\n                var parensMatch = _parens.exec(slice);\n                if (!parensMatch) {\n                    break;\n                }\n                var parensMatchEnd = parensMatch.index + parensMatch[0].length;\n                parensEnd = Math.max(parensEnd, parensMatchEnd);\n            }\n            if (parensEnd > -1) {\n                slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, \"\");\n            } else {\n                slice = slice.replace(_trim, \"\");\n            }\n            if (slice.length <= match[0].length) {\n                continue;\n            }\n            if (options.ignore && options.ignore.test(slice)) {\n                continue;\n            }\n            end = start + slice.length;\n            var result = callback(slice, start, end, string);\n            if (result === undefined) {\n                _start.lastIndex = end;\n                continue;\n            }\n            result = String(result);\n            string = string.slice(0, start) + result + string.slice(end);\n            _start.lastIndex = start + result.length;\n        }\n        _start.lastIndex = 0;\n        return string;\n    };\n    URI.ensureValidHostname = function(v, protocol) {\n        // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)\n        // they are not part of DNS and therefore ignored by URI.js\n        var hasHostname = !!v; // not null and not an empty string\n        var hasProtocol = !!protocol;\n        var rejectEmptyHostname = false;\n        if (hasProtocol) {\n            rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);\n        }\n        if (rejectEmptyHostname && !hasHostname) {\n            throw new TypeError(\"Hostname cannot be empty, if protocol is \" + protocol);\n        } else if (v && v.match(URI.invalid_hostname_characters)) {\n            // test punycode\n            if (!punycode) {\n                throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');\n            }\n            if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {\n                throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-:_]');\n            }\n        }\n    };\n    URI.ensureValidPort = function(v) {\n        if (!v) {\n            return;\n        }\n        var port = Number(v);\n        if (isInteger(port) && port > 0 && port < 65536) {\n            return;\n        }\n        throw new TypeError('Port \"' + v + '\" is not a valid port');\n    };\n    // noConflict\n    URI.noConflict = function(removeAll) {\n        if (removeAll) {\n            var unconflicted = {\n                URI: this.noConflict()\n            };\n            if (root.URITemplate && typeof root.URITemplate.noConflict === \"function\") {\n                unconflicted.URITemplate = root.URITemplate.noConflict();\n            }\n            if (root.IPv6 && typeof root.IPv6.noConflict === \"function\") {\n                unconflicted.IPv6 = root.IPv6.noConflict();\n            }\n            if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === \"function\") {\n                unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();\n            }\n            return unconflicted;\n        } else if (root.URI === this) {\n            root.URI = _URI;\n        }\n        return this;\n    };\n    p.build = function(deferBuild) {\n        if (deferBuild === true) {\n            this._deferred_build = true;\n        } else if (deferBuild === undefined || this._deferred_build) {\n            this._string = URI.build(this._parts);\n            this._deferred_build = false;\n        }\n        return this;\n    };\n    p.clone = function() {\n        return new URI(this);\n    };\n    p.valueOf = p.toString = function() {\n        return this.build(false)._string;\n    };\n    function generateSimpleAccessor(_part) {\n        return function(v, build) {\n            if (v === undefined) {\n                return this._parts[_part] || \"\";\n            } else {\n                this._parts[_part] = v || null;\n                this.build(!build);\n                return this;\n            }\n        };\n    }\n    function generatePrefixAccessor(_part, _key) {\n        return function(v, build) {\n            if (v === undefined) {\n                return this._parts[_part] || \"\";\n            } else {\n                if (v !== null) {\n                    v = v + \"\";\n                    if (v.charAt(0) === _key) {\n                        v = v.substring(1);\n                    }\n                }\n                this._parts[_part] = v;\n                this.build(!build);\n                return this;\n            }\n        };\n    }\n    p.protocol = generateSimpleAccessor(\"protocol\");\n    p.username = generateSimpleAccessor(\"username\");\n    p.password = generateSimpleAccessor(\"password\");\n    p.hostname = generateSimpleAccessor(\"hostname\");\n    p.port = generateSimpleAccessor(\"port\");\n    p.query = generatePrefixAccessor(\"query\", \"?\");\n    p.fragment = generatePrefixAccessor(\"fragment\", \"#\");\n    p.search = function(v, build) {\n        var t = this.query(v, build);\n        return typeof t === \"string\" && t.length ? \"?\" + t : t;\n    };\n    p.hash = function(v, build) {\n        var t = this.fragment(v, build);\n        return typeof t === \"string\" && t.length ? \"#\" + t : t;\n    };\n    p.pathname = function(v, build) {\n        if (v === undefined || v === true) {\n            var res = this._parts.path || (this._parts.hostname ? \"/\" : \"\");\n            return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;\n        } else {\n            if (this._parts.urn) {\n                this._parts.path = v ? URI.recodeUrnPath(v) : \"\";\n            } else {\n                this._parts.path = v ? URI.recodePath(v) : \"/\";\n            }\n            this.build(!build);\n            return this;\n        }\n    };\n    p.path = p.pathname;\n    p.href = function(href, build) {\n        var key;\n        if (href === undefined) {\n            return this.toString();\n        }\n        this._string = \"\";\n        this._parts = URI._parts();\n        var _URI = href instanceof URI;\n        var _object = typeof href === \"object\" && (href.hostname || href.path || href.pathname);\n        if (href.nodeName) {\n            var attribute = URI.getDomAttribute(href);\n            href = href[attribute] || \"\";\n            _object = false;\n        }\n        // window.location is reported to be an object, but it's not the sort\n        // of object we're looking for:\n        // * location.protocol ends with a colon\n        // * location.query != object.search\n        // * location.hash != object.fragment\n        // simply serializing the unknown object should do the trick\n        // (for location, not for everything...)\n        if (!_URI && _object && href.pathname !== undefined) {\n            href = href.toString();\n        }\n        if (typeof href === \"string\" || href instanceof String) {\n            this._parts = URI.parse(String(href), this._parts);\n        } else if (_URI || _object) {\n            var src = _URI ? href._parts : href;\n            for(key in src){\n                if (key === \"query\") {\n                    continue;\n                }\n                if (hasOwn.call(this._parts, key)) {\n                    this._parts[key] = src[key];\n                }\n            }\n            if (src.query) {\n                this.query(src.query, false);\n            }\n        } else {\n            throw new TypeError(\"invalid input\");\n        }\n        this.build(!build);\n        return this;\n    };\n    // identification accessors\n    p.is = function(what) {\n        var ip = false;\n        var ip4 = false;\n        var ip6 = false;\n        var name = false;\n        var sld = false;\n        var idn = false;\n        var punycode = false;\n        var relative = !this._parts.urn;\n        if (this._parts.hostname) {\n            relative = false;\n            ip4 = URI.ip4_expression.test(this._parts.hostname);\n            ip6 = URI.ip6_expression.test(this._parts.hostname);\n            ip = ip4 || ip6;\n            name = !ip;\n            sld = name && SLD && SLD.has(this._parts.hostname);\n            idn = name && URI.idn_expression.test(this._parts.hostname);\n            punycode = name && URI.punycode_expression.test(this._parts.hostname);\n        }\n        switch(what.toLowerCase()){\n            case \"relative\":\n                return relative;\n            case \"absolute\":\n                return !relative;\n            // hostname identification\n            case \"domain\":\n            case \"name\":\n                return name;\n            case \"sld\":\n                return sld;\n            case \"ip\":\n                return ip;\n            case \"ip4\":\n            case \"ipv4\":\n            case \"inet4\":\n                return ip4;\n            case \"ip6\":\n            case \"ipv6\":\n            case \"inet6\":\n                return ip6;\n            case \"idn\":\n                return idn;\n            case \"url\":\n                return !this._parts.urn;\n            case \"urn\":\n                return !!this._parts.urn;\n            case \"punycode\":\n                return punycode;\n        }\n        return null;\n    };\n    // component specific input validation\n    var _protocol = p.protocol;\n    var _port = p.port;\n    var _hostname = p.hostname;\n    p.protocol = function(v, build) {\n        if (v) {\n            // accept trailing ://\n            v = v.replace(/:(\\/\\/)?$/, \"\");\n            if (!v.match(URI.protocol_expression)) {\n                throw new TypeError('Protocol \"' + v + \"\\\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]\");\n            }\n        }\n        return _protocol.call(this, v, build);\n    };\n    p.scheme = p.protocol;\n    p.port = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v !== undefined) {\n            if (v === 0) {\n                v = null;\n            }\n            if (v) {\n                v += \"\";\n                if (v.charAt(0) === \":\") {\n                    v = v.substring(1);\n                }\n                URI.ensureValidPort(v);\n            }\n        }\n        return _port.call(this, v, build);\n    };\n    p.hostname = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v !== undefined) {\n            var x = {\n                preventInvalidHostname: this._parts.preventInvalidHostname\n            };\n            var res = URI.parseHost(v, x);\n            if (res !== \"/\") {\n                throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n            }\n            v = x.hostname;\n            if (this._parts.preventInvalidHostname) {\n                URI.ensureValidHostname(v, this._parts.protocol);\n            }\n        }\n        return _hostname.call(this, v, build);\n    };\n    // compound accessors\n    p.origin = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v === undefined) {\n            var protocol = this.protocol();\n            var authority = this.authority();\n            if (!authority) {\n                return \"\";\n            }\n            return (protocol ? protocol + \"://\" : \"\") + this.authority();\n        } else {\n            var origin = URI(v);\n            this.protocol(origin.protocol()).authority(origin.authority()).build(!build);\n            return this;\n        }\n    };\n    p.host = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v === undefined) {\n            return this._parts.hostname ? URI.buildHost(this._parts) : \"\";\n        } else {\n            var res = URI.parseHost(v, this._parts);\n            if (res !== \"/\") {\n                throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n            }\n            this.build(!build);\n            return this;\n        }\n    };\n    p.authority = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v === undefined) {\n            return this._parts.hostname ? URI.buildAuthority(this._parts) : \"\";\n        } else {\n            var res = URI.parseAuthority(v, this._parts);\n            if (res !== \"/\") {\n                throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n            }\n            this.build(!build);\n            return this;\n        }\n    };\n    p.userinfo = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v === undefined) {\n            var t = URI.buildUserinfo(this._parts);\n            return t ? t.substring(0, t.length - 1) : t;\n        } else {\n            if (v[v.length - 1] !== \"@\") {\n                v += \"@\";\n            }\n            URI.parseUserinfo(v, this._parts);\n            this.build(!build);\n            return this;\n        }\n    };\n    p.resource = function(v, build) {\n        var parts;\n        if (v === undefined) {\n            return this.path() + this.search() + this.hash();\n        }\n        parts = URI.parse(v);\n        this._parts.path = parts.path;\n        this._parts.query = parts.query;\n        this._parts.fragment = parts.fragment;\n        this.build(!build);\n        return this;\n    };\n    // fraction accessors\n    p.subdomain = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        // convenience, return \"www\" from \"www.example.org\"\n        if (v === undefined) {\n            if (!this._parts.hostname || this.is(\"IP\")) {\n                return \"\";\n            }\n            // grab domain and add another segment\n            var end = this._parts.hostname.length - this.domain().length - 1;\n            return this._parts.hostname.substring(0, end) || \"\";\n        } else {\n            var e = this._parts.hostname.length - this.domain().length;\n            var sub = this._parts.hostname.substring(0, e);\n            var replace = new RegExp(\"^\" + escapeRegEx(sub));\n            if (v && v.charAt(v.length - 1) !== \".\") {\n                v += \".\";\n            }\n            if (v.indexOf(\":\") !== -1) {\n                throw new TypeError(\"Domains cannot contain colons\");\n            }\n            if (v) {\n                URI.ensureValidHostname(v, this._parts.protocol);\n            }\n            this._parts.hostname = this._parts.hostname.replace(replace, v);\n            this.build(!build);\n            return this;\n        }\n    };\n    p.domain = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (typeof v === \"boolean\") {\n            build = v;\n            v = undefined;\n        }\n        // convenience, return \"example.org\" from \"www.example.org\"\n        if (v === undefined) {\n            if (!this._parts.hostname || this.is(\"IP\")) {\n                return \"\";\n            }\n            // if hostname consists of 1 or 2 segments, it must be the domain\n            var t = this._parts.hostname.match(/\\./g);\n            if (t && t.length < 2) {\n                return this._parts.hostname;\n            }\n            // grab tld and add another segment\n            var end = this._parts.hostname.length - this.tld(build).length - 1;\n            end = this._parts.hostname.lastIndexOf(\".\", end - 1) + 1;\n            return this._parts.hostname.substring(end) || \"\";\n        } else {\n            if (!v) {\n                throw new TypeError(\"cannot set domain empty\");\n            }\n            if (v.indexOf(\":\") !== -1) {\n                throw new TypeError(\"Domains cannot contain colons\");\n            }\n            URI.ensureValidHostname(v, this._parts.protocol);\n            if (!this._parts.hostname || this.is(\"IP\")) {\n                this._parts.hostname = v;\n            } else {\n                var replace = new RegExp(escapeRegEx(this.domain()) + \"$\");\n                this._parts.hostname = this._parts.hostname.replace(replace, v);\n            }\n            this.build(!build);\n            return this;\n        }\n    };\n    p.tld = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (typeof v === \"boolean\") {\n            build = v;\n            v = undefined;\n        }\n        // return \"org\" from \"www.example.org\"\n        if (v === undefined) {\n            if (!this._parts.hostname || this.is(\"IP\")) {\n                return \"\";\n            }\n            var pos = this._parts.hostname.lastIndexOf(\".\");\n            var tld = this._parts.hostname.substring(pos + 1);\n            if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {\n                return SLD.get(this._parts.hostname) || tld;\n            }\n            return tld;\n        } else {\n            var replace;\n            if (!v) {\n                throw new TypeError(\"cannot set TLD empty\");\n            } else if (v.match(/[^a-zA-Z0-9-]/)) {\n                if (SLD && SLD.is(v)) {\n                    replace = new RegExp(escapeRegEx(this.tld()) + \"$\");\n                    this._parts.hostname = this._parts.hostname.replace(replace, v);\n                } else {\n                    throw new TypeError('TLD \"' + v + '\" contains characters other than [A-Z0-9]');\n                }\n            } else if (!this._parts.hostname || this.is(\"IP\")) {\n                throw new ReferenceError(\"cannot set TLD on non-domain host\");\n            } else {\n                replace = new RegExp(escapeRegEx(this.tld()) + \"$\");\n                this._parts.hostname = this._parts.hostname.replace(replace, v);\n            }\n            this.build(!build);\n            return this;\n        }\n    };\n    p.directory = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v === undefined || v === true) {\n            if (!this._parts.path && !this._parts.hostname) {\n                return \"\";\n            }\n            if (this._parts.path === \"/\") {\n                return \"/\";\n            }\n            var end = this._parts.path.length - this.filename().length - 1;\n            var res = this._parts.path.substring(0, end) || (this._parts.hostname ? \"/\" : \"\");\n            return v ? URI.decodePath(res) : res;\n        } else {\n            var e = this._parts.path.length - this.filename().length;\n            var directory = this._parts.path.substring(0, e);\n            var replace = new RegExp(\"^\" + escapeRegEx(directory));\n            // fully qualifier directories begin with a slash\n            if (!this.is(\"relative\")) {\n                if (!v) {\n                    v = \"/\";\n                }\n                if (v.charAt(0) !== \"/\") {\n                    v = \"/\" + v;\n                }\n            }\n            // directories always end with a slash\n            if (v && v.charAt(v.length - 1) !== \"/\") {\n                v += \"/\";\n            }\n            v = URI.recodePath(v);\n            this._parts.path = this._parts.path.replace(replace, v);\n            this.build(!build);\n            return this;\n        }\n    };\n    p.filename = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (typeof v !== \"string\") {\n            if (!this._parts.path || this._parts.path === \"/\") {\n                return \"\";\n            }\n            var pos = this._parts.path.lastIndexOf(\"/\");\n            var res = this._parts.path.substring(pos + 1);\n            return v ? URI.decodePathSegment(res) : res;\n        } else {\n            var mutatedDirectory = false;\n            if (v.charAt(0) === \"/\") {\n                v = v.substring(1);\n            }\n            if (v.match(/\\.?\\//)) {\n                mutatedDirectory = true;\n            }\n            var replace = new RegExp(escapeRegEx(this.filename()) + \"$\");\n            v = URI.recodePath(v);\n            this._parts.path = this._parts.path.replace(replace, v);\n            if (mutatedDirectory) {\n                this.normalizePath(build);\n            } else {\n                this.build(!build);\n            }\n            return this;\n        }\n    };\n    p.suffix = function(v, build) {\n        if (this._parts.urn) {\n            return v === undefined ? \"\" : this;\n        }\n        if (v === undefined || v === true) {\n            if (!this._parts.path || this._parts.path === \"/\") {\n                return \"\";\n            }\n            var filename = this.filename();\n            var pos = filename.lastIndexOf(\".\");\n            var s, res;\n            if (pos === -1) {\n                return \"\";\n            }\n            // suffix may only contain alnum characters (yup, I made this up.)\n            s = filename.substring(pos + 1);\n            res = /^[a-z0-9%]+$/i.test(s) ? s : \"\";\n            return v ? URI.decodePathSegment(res) : res;\n        } else {\n            if (v.charAt(0) === \".\") {\n                v = v.substring(1);\n            }\n            var suffix = this.suffix();\n            var replace;\n            if (!suffix) {\n                if (!v) {\n                    return this;\n                }\n                this._parts.path += \".\" + URI.recodePath(v);\n            } else if (!v) {\n                replace = new RegExp(escapeRegEx(\".\" + suffix) + \"$\");\n            } else {\n                replace = new RegExp(escapeRegEx(suffix) + \"$\");\n            }\n            if (replace) {\n                v = URI.recodePath(v);\n                this._parts.path = this._parts.path.replace(replace, v);\n            }\n            this.build(!build);\n            return this;\n        }\n    };\n    p.segment = function(segment, v, build) {\n        var separator = this._parts.urn ? \":\" : \"/\";\n        var path = this.path();\n        var absolute = path.substring(0, 1) === \"/\";\n        var segments = path.split(separator);\n        if (segment !== undefined && typeof segment !== \"number\") {\n            build = v;\n            v = segment;\n            segment = undefined;\n        }\n        if (segment !== undefined && typeof segment !== \"number\") {\n            throw new Error('Bad segment \"' + segment + '\", must be 0-based integer');\n        }\n        if (absolute) {\n            segments.shift();\n        }\n        if (segment < 0) {\n            // allow negative indexes to address from the end\n            segment = Math.max(segments.length + segment, 0);\n        }\n        if (v === undefined) {\n            /*jshint laxbreak: true */ return segment === undefined ? segments : segments[segment];\n        /*jshint laxbreak: false */ } else if (segment === null || segments[segment] === undefined) {\n            if (isArray(v)) {\n                segments = [];\n                // collapse empty elements within array\n                for(var i = 0, l = v.length; i < l; i++){\n                    if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {\n                        continue;\n                    }\n                    if (segments.length && !segments[segments.length - 1].length) {\n                        segments.pop();\n                    }\n                    segments.push(trimSlashes(v[i]));\n                }\n            } else if (v || typeof v === \"string\") {\n                v = trimSlashes(v);\n                if (segments[segments.length - 1] === \"\") {\n                    // empty trailing elements have to be overwritten\n                    // to prevent results such as /foo//bar\n                    segments[segments.length - 1] = v;\n                } else {\n                    segments.push(v);\n                }\n            }\n        } else {\n            if (v) {\n                segments[segment] = trimSlashes(v);\n            } else {\n                segments.splice(segment, 1);\n            }\n        }\n        if (absolute) {\n            segments.unshift(\"\");\n        }\n        return this.path(segments.join(separator), build);\n    };\n    p.segmentCoded = function(segment, v, build) {\n        var segments, i, l;\n        if (typeof segment !== \"number\") {\n            build = v;\n            v = segment;\n            segment = undefined;\n        }\n        if (v === undefined) {\n            segments = this.segment(segment, v, build);\n            if (!isArray(segments)) {\n                segments = segments !== undefined ? URI.decode(segments) : undefined;\n            } else {\n                for(i = 0, l = segments.length; i < l; i++){\n                    segments[i] = URI.decode(segments[i]);\n                }\n            }\n            return segments;\n        }\n        if (!isArray(v)) {\n            v = typeof v === \"string\" || v instanceof String ? URI.encode(v) : v;\n        } else {\n            for(i = 0, l = v.length; i < l; i++){\n                v[i] = URI.encode(v[i]);\n            }\n        }\n        return this.segment(segment, v, build);\n    };\n    // mutating query string\n    var q = p.query;\n    p.query = function(v, build) {\n        if (v === true) {\n            return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n        } else if (typeof v === \"function\") {\n            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n            var result = v.call(this, data);\n            this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n            this.build(!build);\n            return this;\n        } else if (v !== undefined && typeof v !== \"string\") {\n            this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n            this.build(!build);\n            return this;\n        } else {\n            return q.call(this, v, build);\n        }\n    };\n    p.setQuery = function(name, value, build) {\n        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n        if (typeof name === \"string\" || name instanceof String) {\n            data[name] = value !== undefined ? value : null;\n        } else if (typeof name === \"object\") {\n            for(var key in name){\n                if (hasOwn.call(name, key)) {\n                    data[key] = name[key];\n                }\n            }\n        } else {\n            throw new TypeError(\"URI.addQuery() accepts an object, string as the name parameter\");\n        }\n        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n        if (typeof name !== \"string\") {\n            build = value;\n        }\n        this.build(!build);\n        return this;\n    };\n    p.addQuery = function(name, value, build) {\n        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n        URI.addQuery(data, name, value === undefined ? null : value);\n        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n        if (typeof name !== \"string\") {\n            build = value;\n        }\n        this.build(!build);\n        return this;\n    };\n    p.removeQuery = function(name, value, build) {\n        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n        URI.removeQuery(data, name, value);\n        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n        if (typeof name !== \"string\") {\n            build = value;\n        }\n        this.build(!build);\n        return this;\n    };\n    p.hasQuery = function(name, value, withinArray) {\n        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n        return URI.hasQuery(data, name, value, withinArray);\n    };\n    p.setSearch = p.setQuery;\n    p.addSearch = p.addQuery;\n    p.removeSearch = p.removeQuery;\n    p.hasSearch = p.hasQuery;\n    // sanitizing URLs\n    p.normalize = function() {\n        if (this._parts.urn) {\n            return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();\n        }\n        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();\n    };\n    p.normalizeProtocol = function(build) {\n        if (typeof this._parts.protocol === \"string\") {\n            this._parts.protocol = this._parts.protocol.toLowerCase();\n            this.build(!build);\n        }\n        return this;\n    };\n    p.normalizeHostname = function(build) {\n        if (this._parts.hostname) {\n            if (this.is(\"IDN\") && punycode) {\n                this._parts.hostname = punycode.toASCII(this._parts.hostname);\n            } else if (this.is(\"IPv6\") && IPv6) {\n                this._parts.hostname = IPv6.best(this._parts.hostname);\n            }\n            this._parts.hostname = this._parts.hostname.toLowerCase();\n            this.build(!build);\n        }\n        return this;\n    };\n    p.normalizePort = function(build) {\n        // remove port of it's the protocol's default\n        if (typeof this._parts.protocol === \"string\" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {\n            this._parts.port = null;\n            this.build(!build);\n        }\n        return this;\n    };\n    p.normalizePath = function(build) {\n        var _path = this._parts.path;\n        if (!_path) {\n            return this;\n        }\n        if (this._parts.urn) {\n            this._parts.path = URI.recodeUrnPath(this._parts.path);\n            this.build(!build);\n            return this;\n        }\n        if (this._parts.path === \"/\") {\n            return this;\n        }\n        _path = URI.recodePath(_path);\n        var _was_relative;\n        var _leadingParents = \"\";\n        var _parent, _pos;\n        // handle relative paths\n        if (_path.charAt(0) !== \"/\") {\n            _was_relative = true;\n            _path = \"/\" + _path;\n        }\n        // handle relative files (as opposed to directories)\n        if (_path.slice(-3) === \"/..\" || _path.slice(-2) === \"/.\") {\n            _path += \"/\";\n        }\n        // resolve simples\n        _path = _path.replace(/(\\/(\\.\\/)+)|(\\/\\.$)/g, \"/\").replace(/\\/{2,}/g, \"/\");\n        // remember leading parents\n        if (_was_relative) {\n            _leadingParents = _path.substring(1).match(/^(\\.\\.\\/)+/) || \"\";\n            if (_leadingParents) {\n                _leadingParents = _leadingParents[0];\n            }\n        }\n        // resolve parents\n        while(true){\n            _parent = _path.search(/\\/\\.\\.(\\/|$)/);\n            if (_parent === -1) {\n                break;\n            } else if (_parent === 0) {\n                // top level cannot be relative, skip it\n                _path = _path.substring(3);\n                continue;\n            }\n            _pos = _path.substring(0, _parent).lastIndexOf(\"/\");\n            if (_pos === -1) {\n                _pos = _parent;\n            }\n            _path = _path.substring(0, _pos) + _path.substring(_parent + 3);\n        }\n        // revert to relative\n        if (_was_relative && this.is(\"relative\")) {\n            _path = _leadingParents + _path.substring(1);\n        }\n        this._parts.path = _path;\n        this.build(!build);\n        return this;\n    };\n    p.normalizePathname = p.normalizePath;\n    p.normalizeQuery = function(build) {\n        if (typeof this._parts.query === \"string\") {\n            if (!this._parts.query.length) {\n                this._parts.query = null;\n            } else {\n                this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));\n            }\n            this.build(!build);\n        }\n        return this;\n    };\n    p.normalizeFragment = function(build) {\n        if (!this._parts.fragment) {\n            this._parts.fragment = null;\n            this.build(!build);\n        }\n        return this;\n    };\n    p.normalizeSearch = p.normalizeQuery;\n    p.normalizeHash = p.normalizeFragment;\n    p.iso8859 = function() {\n        // expect unicode input, iso8859 output\n        var e = URI.encode;\n        var d = URI.decode;\n        URI.encode = escape;\n        URI.decode = decodeURIComponent;\n        try {\n            this.normalize();\n        } finally{\n            URI.encode = e;\n            URI.decode = d;\n        }\n        return this;\n    };\n    p.unicode = function() {\n        // expect iso8859 input, unicode output\n        var e = URI.encode;\n        var d = URI.decode;\n        URI.encode = strictEncodeURIComponent;\n        URI.decode = unescape;\n        try {\n            this.normalize();\n        } finally{\n            URI.encode = e;\n            URI.decode = d;\n        }\n        return this;\n    };\n    p.readable = function() {\n        var uri = this.clone();\n        // removing username, password, because they shouldn't be displayed according to RFC 3986\n        uri.username(\"\").password(\"\").normalize();\n        var t = \"\";\n        if (uri._parts.protocol) {\n            t += uri._parts.protocol + \"://\";\n        }\n        if (uri._parts.hostname) {\n            if (uri.is(\"punycode\") && punycode) {\n                t += punycode.toUnicode(uri._parts.hostname);\n                if (uri._parts.port) {\n                    t += \":\" + uri._parts.port;\n                }\n            } else {\n                t += uri.host();\n            }\n        }\n        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== \"/\") {\n            t += \"/\";\n        }\n        t += uri.path(true);\n        if (uri._parts.query) {\n            var q = \"\";\n            for(var i = 0, qp = uri._parts.query.split(\"&\"), l = qp.length; i < l; i++){\n                var kv = (qp[i] || \"\").split(\"=\");\n                q += \"&\" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, \"%26\");\n                if (kv[1] !== undefined) {\n                    q += \"=\" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, \"%26\");\n                }\n            }\n            t += \"?\" + q.substring(1);\n        }\n        t += URI.decodeQuery(uri.hash(), true);\n        return t;\n    };\n    // resolving relative and absolute URLs\n    p.absoluteTo = function(base) {\n        var resolved = this.clone();\n        var properties = [\n            \"protocol\",\n            \"username\",\n            \"password\",\n            \"hostname\",\n            \"port\"\n        ];\n        var basedir, i, p;\n        if (this._parts.urn) {\n            throw new Error(\"URNs do not have any generally defined hierarchical components\");\n        }\n        if (!(base instanceof URI)) {\n            base = new URI(base);\n        }\n        if (resolved._parts.protocol) {\n            // Directly returns even if this._parts.hostname is empty.\n            return resolved;\n        } else {\n            resolved._parts.protocol = base._parts.protocol;\n        }\n        if (this._parts.hostname) {\n            return resolved;\n        }\n        for(i = 0; p = properties[i]; i++){\n            resolved._parts[p] = base._parts[p];\n        }\n        if (!resolved._parts.path) {\n            resolved._parts.path = base._parts.path;\n            if (!resolved._parts.query) {\n                resolved._parts.query = base._parts.query;\n            }\n        } else {\n            if (resolved._parts.path.substring(-2) === \"..\") {\n                resolved._parts.path += \"/\";\n            }\n            if (resolved.path().charAt(0) !== \"/\") {\n                basedir = base.directory();\n                basedir = basedir ? basedir : base.path().indexOf(\"/\") === 0 ? \"/\" : \"\";\n                resolved._parts.path = (basedir ? basedir + \"/\" : \"\") + resolved._parts.path;\n                resolved.normalizePath();\n            }\n        }\n        resolved.build();\n        return resolved;\n    };\n    p.relativeTo = function(base) {\n        var relative = this.clone().normalize();\n        var relativeParts, baseParts, common, relativePath, basePath;\n        if (relative._parts.urn) {\n            throw new Error(\"URNs do not have any generally defined hierarchical components\");\n        }\n        base = new URI(base).normalize();\n        relativeParts = relative._parts;\n        baseParts = base._parts;\n        relativePath = relative.path();\n        basePath = base.path();\n        if (relativePath.charAt(0) !== \"/\") {\n            throw new Error(\"URI is already relative\");\n        }\n        if (basePath.charAt(0) !== \"/\") {\n            throw new Error(\"Cannot calculate a URI relative to another relative URI\");\n        }\n        if (relativeParts.protocol === baseParts.protocol) {\n            relativeParts.protocol = null;\n        }\n        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {\n            return relative.build();\n        }\n        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {\n            return relative.build();\n        }\n        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {\n            relativeParts.hostname = null;\n            relativeParts.port = null;\n        } else {\n            return relative.build();\n        }\n        if (relativePath === basePath) {\n            relativeParts.path = \"\";\n            return relative.build();\n        }\n        // determine common sub path\n        common = URI.commonPath(relativePath, basePath);\n        // If the paths have nothing in common, return a relative URL with the absolute path.\n        if (!common) {\n            return relative.build();\n        }\n        var parents = baseParts.path.substring(common.length).replace(/[^\\/]*$/, \"\").replace(/.*?\\//g, \"../\");\n        relativeParts.path = parents + relativeParts.path.substring(common.length) || \"./\";\n        return relative.build();\n    };\n    // comparing URIs\n    p.equals = function(uri) {\n        var one = this.clone();\n        var two = new URI(uri);\n        var one_map = {};\n        var two_map = {};\n        var checked = {};\n        var one_query, two_query, key;\n        one.normalize();\n        two.normalize();\n        // exact match\n        if (one.toString() === two.toString()) {\n            return true;\n        }\n        // extract query string\n        one_query = one.query();\n        two_query = two.query();\n        one.query(\"\");\n        two.query(\"\");\n        // definitely not equal if not even non-query parts match\n        if (one.toString() !== two.toString()) {\n            return false;\n        }\n        // query parameters have the same length, even if they're permuted\n        if (one_query.length !== two_query.length) {\n            return false;\n        }\n        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);\n        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);\n        for(key in one_map){\n            if (hasOwn.call(one_map, key)) {\n                if (!isArray(one_map[key])) {\n                    if (one_map[key] !== two_map[key]) {\n                        return false;\n                    }\n                } else if (!arraysEqual(one_map[key], two_map[key])) {\n                    return false;\n                }\n                checked[key] = true;\n            }\n        }\n        for(key in two_map){\n            if (hasOwn.call(two_map, key)) {\n                if (!checked[key]) {\n                    // two contains a parameter not present in one\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    // state\n    p.preventInvalidHostname = function(v) {\n        this._parts.preventInvalidHostname = !!v;\n        return this;\n    };\n    p.duplicateQueryParameters = function(v) {\n        this._parts.duplicateQueryParameters = !!v;\n        return this;\n    };\n    p.escapeQuerySpace = function(v) {\n        this._parts.escapeQuerySpace = !!v;\n        return this;\n    };\n    return URI;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL1VSSS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNBLFVBQVVBLElBQUksRUFBRUMsT0FBTztJQUN0QjtJQUNBLDREQUE0RDtJQUM1RCxJQUFJLEtBQWtCLElBQVlDLE9BQU9DLE9BQU8sRUFBRTtRQUNoRCxPQUFPO1FBQ1BELE9BQU9DLE9BQU8sR0FBR0YsUUFBUUcsbUJBQU9BLENBQUMsaUVBQWVBLG1CQUFPQSxDQUFDLHlEQUFXQSxtQkFBT0EsQ0FBQztJQUM3RSxPQUFPLElBQUksSUFBMEMsRUFBRTtRQUNyRCx3Q0FBd0M7UUFDeENDLGlDQUFPO1lBQUM7WUFBYztZQUFVO1NBQXVCLG9DQUFFSixPQUFPQTtBQUFBO0FBQUE7QUFBQSxrR0FBQ0E7SUFDbkUsT0FBTyxFQUdOO0FBQ0gsR0FBRSxJQUFJLEVBQUUsU0FBVU8sUUFBUSxFQUFFQyxJQUFJLEVBQUVFLEdBQUcsRUFBRVgsSUFBSTtJQUN6QztJQUNBLG9DQUFvQyxHQUNwQyw4REFBOEQ7SUFDOUQsMEJBQTBCLEdBRTFCLG9DQUFvQztJQUNwQyxJQUFJWSxPQUFPWixRQUFRQSxLQUFLTyxHQUFHO0lBRTNCLFNBQVNBLElBQUlNLEdBQUcsRUFBRUMsSUFBSTtRQUNwQixJQUFJQyxlQUFlQyxVQUFVQyxNQUFNLElBQUk7UUFDdkMsSUFBSUMsZ0JBQWdCRixVQUFVQyxNQUFNLElBQUk7UUFFeEMsZ0RBQWdEO1FBQ2hELElBQUksQ0FBRSxLQUFJLFlBQVlWLEdBQUUsR0FBSTtZQUMxQixJQUFJUSxjQUFjO2dCQUNoQixJQUFJRyxlQUFlO29CQUNqQixPQUFPLElBQUlYLElBQUlNLEtBQUtDO2dCQUN0QjtnQkFFQSxPQUFPLElBQUlQLElBQUlNO1lBQ2pCO1lBRUEsT0FBTyxJQUFJTjtRQUNiO1FBRUEsSUFBSU0sUUFBUU0sV0FBVztZQUNyQixJQUFJSixjQUFjO2dCQUNoQixNQUFNLElBQUlLLFVBQVU7WUFDdEI7WUFFQSxJQUFJLE9BQU9DLGFBQWEsYUFBYTtnQkFDbkNSLE1BQU1RLFNBQVNDLElBQUksR0FBRztZQUN4QixPQUFPO2dCQUNMVCxNQUFNO1lBQ1I7UUFDRjtRQUVBLElBQUlBLFFBQVEsTUFBTTtZQUNoQixJQUFJRSxjQUFjO2dCQUNoQixNQUFNLElBQUlLLFVBQVU7WUFDdEI7UUFDRjtRQUVBLElBQUksQ0FBQ0UsSUFBSSxDQUFDVDtRQUVWLGdHQUFnRztRQUNoRyxJQUFJQyxTQUFTSyxXQUFXO1lBQ3RCLE9BQU8sSUFBSSxDQUFDSSxVQUFVLENBQUNUO1FBQ3pCO1FBRUEsT0FBTyxJQUFJO0lBQ2I7SUFFQSxTQUFTVSxVQUFVQyxLQUFLO1FBQ3RCLE9BQU8sV0FBV0MsSUFBSSxDQUFDRDtJQUN6QjtJQUVBbEIsSUFBSW9CLE9BQU8sR0FBRztJQUVkLElBQUlDLElBQUlyQixJQUFJc0IsU0FBUztJQUNyQixJQUFJQyxTQUFTQyxPQUFPRixTQUFTLENBQUNHLGNBQWM7SUFFNUMsU0FBU0MsWUFBWUMsTUFBTTtRQUN6QiwyR0FBMkc7UUFDM0csT0FBT0EsT0FBT0MsT0FBTyxDQUFDLDhCQUE4QjtJQUN0RDtJQUVBLFNBQVNDLFFBQVFYLEtBQUs7UUFDcEIsZ0ZBQWdGO1FBQ2hGLElBQUlBLFVBQVVOLFdBQVc7WUFDdkIsT0FBTztRQUNUO1FBRUEsT0FBT2tCLE9BQU9OLE9BQU9GLFNBQVMsQ0FBQ1MsUUFBUSxDQUFDQyxJQUFJLENBQUNkLFFBQVFlLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDakU7SUFFQSxTQUFTQyxRQUFRQyxHQUFHO1FBQ2xCLE9BQU9OLFFBQVFNLFNBQVM7SUFDMUI7SUFFQSxTQUFTQyxrQkFBa0JDLElBQUksRUFBRW5CLEtBQUs7UUFDcEMsSUFBSW9CLFNBQVMsQ0FBQztRQUNkLElBQUlDLEdBQUc3QjtRQUVQLElBQUltQixRQUFRWCxXQUFXLFVBQVU7WUFDL0JvQixTQUFTO1FBQ1gsT0FBTyxJQUFJSixRQUFRaEIsUUFBUTtZQUN6QixJQUFLcUIsSUFBSSxHQUFHN0IsU0FBU1EsTUFBTVIsTUFBTSxFQUFFNkIsSUFBSTdCLFFBQVE2QixJQUFLO2dCQUNsREQsTUFBTSxDQUFDcEIsS0FBSyxDQUFDcUIsRUFBRSxDQUFDLEdBQUc7WUFDckI7UUFDRixPQUFPO1lBQ0xELE1BQU0sQ0FBQ3BCLE1BQU0sR0FBRztRQUNsQjtRQUVBLElBQUtxQixJQUFJLEdBQUc3QixTQUFTMkIsS0FBSzNCLE1BQU0sRUFBRTZCLElBQUk3QixRQUFRNkIsSUFBSztZQUNqRCx3QkFBd0IsR0FDeEIsSUFBSUMsU0FBU0YsVUFBVUEsTUFBTSxDQUFDRCxJQUFJLENBQUNFLEVBQUUsQ0FBQyxLQUFLM0IsYUFDdEMsQ0FBQzBCLFVBQVVwQixNQUFNQyxJQUFJLENBQUNrQixJQUFJLENBQUNFLEVBQUU7WUFDbEMseUJBQXlCLEdBQ3pCLElBQUlDLFFBQVE7Z0JBQ1ZILEtBQUtJLE1BQU0sQ0FBQ0YsR0FBRztnQkFDZjdCO2dCQUNBNkI7WUFDRjtRQUNGO1FBRUEsT0FBT0Y7SUFDVDtJQUVBLFNBQVNLLGNBQWNDLElBQUksRUFBRXpCLEtBQUs7UUFDaEMsSUFBSXFCLEdBQUc3QjtRQUVQLDZDQUE2QztRQUM3QyxJQUFJd0IsUUFBUWhCLFFBQVE7WUFDbEIsb0VBQW9FO1lBQ3BFLElBQUtxQixJQUFJLEdBQUc3QixTQUFTUSxNQUFNUixNQUFNLEVBQUU2QixJQUFJN0IsUUFBUTZCLElBQUs7Z0JBQ2xELElBQUksQ0FBQ0csY0FBY0MsTUFBTXpCLEtBQUssQ0FBQ3FCLEVBQUUsR0FBRztvQkFDbEMsT0FBTztnQkFDVDtZQUNGO1lBRUEsT0FBTztRQUNUO1FBRUEsSUFBSUssUUFBUWYsUUFBUVg7UUFDcEIsSUFBS3FCLElBQUksR0FBRzdCLFNBQVNpQyxLQUFLakMsTUFBTSxFQUFFNkIsSUFBSTdCLFFBQVE2QixJQUFLO1lBQ2pELElBQUlLLFVBQVUsVUFBVTtnQkFDdEIsSUFBSSxPQUFPRCxJQUFJLENBQUNKLEVBQUUsS0FBSyxZQUFZSSxJQUFJLENBQUNKLEVBQUUsQ0FBQ00sS0FBSyxDQUFDM0IsUUFBUTtvQkFDdkQsT0FBTztnQkFDVDtZQUNGLE9BQU8sSUFBSXlCLElBQUksQ0FBQ0osRUFBRSxLQUFLckIsT0FBTztnQkFDNUIsT0FBTztZQUNUO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxTQUFTNEIsWUFBWUMsR0FBRyxFQUFFQyxHQUFHO1FBQzNCLElBQUksQ0FBQ2QsUUFBUWEsUUFBUSxDQUFDYixRQUFRYyxNQUFNO1lBQ2xDLE9BQU87UUFDVDtRQUVBLGlFQUFpRTtRQUNqRSxJQUFJRCxJQUFJckMsTUFBTSxLQUFLc0MsSUFBSXRDLE1BQU0sRUFBRTtZQUM3QixPQUFPO1FBQ1Q7UUFFQXFDLElBQUlFLElBQUk7UUFDUkQsSUFBSUMsSUFBSTtRQUVSLElBQUssSUFBSVYsSUFBSSxHQUFHVyxJQUFJSCxJQUFJckMsTUFBTSxFQUFFNkIsSUFBSVcsR0FBR1gsSUFBSztZQUMxQyxJQUFJUSxHQUFHLENBQUNSLEVBQUUsS0FBS1MsR0FBRyxDQUFDVCxFQUFFLEVBQUU7Z0JBQ3JCLE9BQU87WUFDVDtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRUEsU0FBU1ksWUFBWUMsSUFBSTtRQUN2QixJQUFJQyxrQkFBa0I7UUFDdEIsT0FBT0QsS0FBS3hCLE9BQU8sQ0FBQ3lCLGlCQUFpQjtJQUN2QztJQUVBckQsSUFBSXNELE1BQU0sR0FBRztRQUNYLE9BQU87WUFDTEMsVUFBVTtZQUNWQyxVQUFVO1lBQ1ZDLFVBQVU7WUFDVkMsVUFBVTtZQUNWQyxLQUFLO1lBQ0xDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVixRQUFRO1lBQ1JDLHdCQUF3QmhFLElBQUlnRSxzQkFBc0I7WUFDbERDLDBCQUEwQmpFLElBQUlpRSx3QkFBd0I7WUFDdERDLGtCQUFrQmxFLElBQUlrRSxnQkFBZ0I7UUFDeEM7SUFDRjtJQUNBLG1DQUFtQztJQUNuQyxtREFBbUQ7SUFDbkQscURBQXFEO0lBQ3JEbEUsSUFBSWdFLHNCQUFzQixHQUFHO0lBQzdCLG9EQUFvRDtJQUNwRGhFLElBQUlpRSx3QkFBd0IsR0FBRztJQUMvQixzREFBc0Q7SUFDdERqRSxJQUFJa0UsZ0JBQWdCLEdBQUc7SUFDdkIsb0JBQW9CO0lBQ3BCbEUsSUFBSW1FLG1CQUFtQixHQUFHO0lBQzFCbkUsSUFBSW9FLGNBQWMsR0FBRztJQUNyQnBFLElBQUlxRSxtQkFBbUIsR0FBRztJQUMxQix5RUFBeUU7SUFDekVyRSxJQUFJc0UsY0FBYyxHQUFHO0lBQ3JCLHdCQUF3QjtJQUN4QixrRUFBa0U7SUFDbEUscURBQXFEO0lBQ3JEdEUsSUFBSXVFLGNBQWMsR0FBRztJQUNyQix3RUFBd0U7SUFDeEUsK0RBQStEO0lBQy9ELDJDQUEyQztJQUMzQywwQ0FBMEM7SUFDMUN2RSxJQUFJd0UsbUJBQW1CLEdBQUc7SUFDMUJ4RSxJQUFJeUUsT0FBTyxHQUFHO1FBQ1osOEJBQThCO1FBQzlCQyxPQUFPO1FBQ1AsdUNBQXVDO1FBQ3ZDQyxLQUFLO1FBQ0wsbURBQW1EO1FBQ25EQyxNQUFNO1FBQ04sMkNBQTJDO1FBQzNDQyxRQUFRO0lBQ1Y7SUFDQTdFLElBQUk4RSw2QkFBNkIsR0FBRztJQUNwQyxzREFBc0Q7SUFDdEQ5RSxJQUFJK0Usb0JBQW9CLEdBQUc7SUFDM0IsbURBQW1EO0lBQ25ELGlGQUFpRjtJQUNqRi9FLElBQUlnRixZQUFZLEdBQUc7UUFDakJDLE1BQU07UUFDTkMsT0FBTztRQUNQQyxLQUFLO1FBQ0xDLFFBQVE7UUFDUkMsSUFBSTtRQUNKQyxLQUFLO0lBQ1A7SUFDQSxvREFBb0Q7SUFDcER0RixJQUFJdUYsYUFBYSxHQUFHO1FBQ2xCO1FBQ0E7S0FDRDtJQUVELG9EQUFvRDtJQUNwRCxtRkFBbUY7SUFDbkYscUVBQXFFO0lBQ3JFdkYsSUFBSXdGLDJCQUEyQixHQUFHO0lBQ2xDLDBDQUEwQztJQUMxQ3hGLElBQUl5RixhQUFhLEdBQUc7UUFDbEIsS0FBSztRQUNMLGNBQWM7UUFDZCxRQUFRO1FBQ1IsUUFBUTtRQUNSLFVBQVU7UUFDVixRQUFRO1FBQ1IsT0FBTztRQUNQLFFBQVE7UUFDUixVQUFVO1FBQ1YsU0FBUztRQUNULFVBQVU7UUFDVixTQUFTO1FBQ1QsU0FBUztRQUNULFNBQVM7UUFDVCxTQUFTO0lBQ1g7SUFDQXpGLElBQUkwRixlQUFlLEdBQUcsU0FBU0MsSUFBSTtRQUNqQyxJQUFJLENBQUNBLFFBQVEsQ0FBQ0EsS0FBS0MsUUFBUSxFQUFFO1lBQzNCLE9BQU9oRjtRQUNUO1FBRUEsSUFBSWdGLFdBQVdELEtBQUtDLFFBQVEsQ0FBQ0MsV0FBVztRQUN4QyxrREFBa0Q7UUFDbEQsSUFBSUQsYUFBYSxXQUFXRCxLQUFLRyxJQUFJLEtBQUssU0FBUztZQUNqRCxPQUFPbEY7UUFDVDtRQUVBLE9BQU9aLElBQUl5RixhQUFhLENBQUNHLFNBQVM7SUFDcEM7SUFFQSxTQUFTRyx1QkFBdUI3RSxLQUFLO1FBQ25DLGdEQUFnRDtRQUNoRCxPQUFPOEUsT0FBTzlFO0lBQ2hCO0lBRUEsMkNBQTJDO0lBQzNDLFNBQVMrRSx5QkFBeUJ0RSxNQUFNO1FBQ3RDLHNHQUFzRztRQUN0RyxPQUFPdUUsbUJBQW1CdkUsUUFDdkJDLE9BQU8sQ0FBQyxZQUFZbUUsd0JBQ3BCbkUsT0FBTyxDQUFDLE9BQU87SUFDcEI7SUFDQTVCLElBQUltRyxNQUFNLEdBQUdGO0lBQ2JqRyxJQUFJb0csTUFBTSxHQUFHQztJQUNickcsSUFBSXNHLE9BQU8sR0FBRztRQUNadEcsSUFBSW1HLE1BQU0sR0FBR0g7UUFDYmhHLElBQUlvRyxNQUFNLEdBQUdHO0lBQ2Y7SUFDQXZHLElBQUl3RyxPQUFPLEdBQUc7UUFDWnhHLElBQUltRyxNQUFNLEdBQUdGO1FBQ2JqRyxJQUFJb0csTUFBTSxHQUFHQztJQUNmO0lBQ0FyRyxJQUFJeUcsVUFBVSxHQUFHO1FBQ2ZDLFVBQVU7WUFDUlAsUUFBUTtnQkFDTixxRUFBcUU7Z0JBQ3JFLDhEQUE4RDtnQkFDOURRLFlBQVk7Z0JBQ1pDLEtBQUs7b0JBQ0gsWUFBWTtvQkFDWixPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87Z0JBQ1Q7WUFDRjtZQUNBUixRQUFRO2dCQUNOTyxZQUFZO2dCQUNaQyxLQUFLO29CQUNILEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO2dCQUNQO1lBQ0Y7UUFDRjtRQUNBQyxVQUFVO1lBQ1JWLFFBQVE7Z0JBQ04scUVBQXFFO2dCQUNyRSw4REFBOEQ7Z0JBQzlEUSxZQUFZO2dCQUNaQyxLQUFLO29CQUNILGFBQWE7b0JBQ2IsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxhQUFhO29CQUNiLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFDQUUsU0FBUztZQUNQLDhGQUE4RjtZQUM5Riw2RkFBNkY7WUFDN0YsMkZBQTJGO1lBQzNGLDRGQUE0RjtZQUM1RiwyRkFBMkY7WUFDM0YsbURBQW1EO1lBQ25ELHNFQUFzRTtZQUN0RVgsUUFBUTtnQkFDTlEsWUFBWTtnQkFDWkMsS0FBSztvQkFDSCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87b0JBQ1AsT0FBTztvQkFDUCxPQUFPO29CQUNQLE9BQU87Z0JBQ1Q7WUFDRjtZQUNBLDBGQUEwRjtZQUMxRiwyRUFBMkU7WUFDM0VSLFFBQVE7Z0JBQ05PLFlBQVk7Z0JBQ1pDLEtBQUs7b0JBQ0gsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztnQkFDUDtZQUNGO1FBQ0Y7SUFDRjtJQUNBNUcsSUFBSStHLFdBQVcsR0FBRyxTQUFTcEYsTUFBTSxFQUFFdUMsZ0JBQWdCO1FBQ2pELElBQUk4QyxVQUFVaEgsSUFBSW1HLE1BQU0sQ0FBQ3hFLFNBQVM7UUFDbEMsSUFBSXVDLHFCQUFxQnRELFdBQVc7WUFDbENzRCxtQkFBbUJsRSxJQUFJa0UsZ0JBQWdCO1FBQ3pDO1FBRUEsT0FBT0EsbUJBQW1COEMsUUFBUXBGLE9BQU8sQ0FBQyxRQUFRLE9BQU9vRjtJQUMzRDtJQUNBaEgsSUFBSWlILFdBQVcsR0FBRyxTQUFTdEYsTUFBTSxFQUFFdUMsZ0JBQWdCO1FBQ2pEdkMsVUFBVTtRQUNWLElBQUl1QyxxQkFBcUJ0RCxXQUFXO1lBQ2xDc0QsbUJBQW1CbEUsSUFBSWtFLGdCQUFnQjtRQUN6QztRQUVBLElBQUk7WUFDRixPQUFPbEUsSUFBSW9HLE1BQU0sQ0FBQ2xDLG1CQUFtQnZDLE9BQU9DLE9BQU8sQ0FBQyxPQUFPLFNBQVNEO1FBQ3RFLEVBQUUsT0FBTXVGLEdBQUc7WUFDVCxnREFBZ0Q7WUFDaEQsbURBQW1EO1lBQ25ELG9EQUFvRDtZQUNwRCxvREFBb0Q7WUFDcEQsT0FBT3ZGO1FBQ1Q7SUFDRjtJQUNBLHdDQUF3QztJQUN4QyxJQUFJMkIsU0FBUztRQUFDLFVBQVM7UUFBVSxVQUFTO0lBQVE7SUFDbEQsSUFBSTZEO0lBQ0osSUFBSUMsbUJBQW1CLFNBQVNDLE1BQU0sRUFBRUYsS0FBSztRQUMzQyxPQUFPLFNBQVN4RixNQUFNO1lBQ3BCLElBQUk7Z0JBQ0YsT0FBTzNCLEdBQUcsQ0FBQ21ILE1BQU0sQ0FBQ3hGLFNBQVMsSUFBSUMsT0FBTyxDQUFDNUIsSUFBSXlHLFVBQVUsQ0FBQ1ksT0FBTyxDQUFDRixNQUFNLENBQUNSLFVBQVUsRUFBRSxTQUFTVyxDQUFDO29CQUN6RixPQUFPdEgsSUFBSXlHLFVBQVUsQ0FBQ1ksT0FBTyxDQUFDRixNQUFNLENBQUNQLEdBQUcsQ0FBQ1UsRUFBRTtnQkFDN0M7WUFDRixFQUFFLE9BQU9KLEdBQUc7Z0JBQ1YsZ0RBQWdEO2dCQUNoRCxtREFBbUQ7Z0JBQ25ELG9EQUFvRDtnQkFDcEQsb0RBQW9EO2dCQUNwRCxPQUFPdkY7WUFDVDtRQUNGO0lBQ0Y7SUFFQSxJQUFLd0YsU0FBUzdELE9BQVE7UUFDcEJ0RCxHQUFHLENBQUNtSCxRQUFRLGNBQWMsR0FBR0MsaUJBQWlCLFlBQVk5RCxNQUFNLENBQUM2RCxNQUFNO1FBQ3ZFbkgsR0FBRyxDQUFDbUgsUUFBUSxpQkFBaUIsR0FBR0MsaUJBQWlCLFdBQVc5RCxNQUFNLENBQUM2RCxNQUFNO0lBQzNFO0lBRUEsSUFBSUksZ0NBQWdDLFNBQVNDLElBQUksRUFBRUMsZUFBZSxFQUFFQyxvQkFBb0I7UUFDdEYsT0FBTyxTQUFTL0YsTUFBTTtZQUNwQixtRkFBbUY7WUFDbkYsNkZBQTZGO1lBQzdGLDZGQUE2RjtZQUM3Riw4Q0FBOEM7WUFDOUMsSUFBSWdHO1lBQ0osSUFBSSxDQUFDRCxzQkFBc0I7Z0JBQ3pCQyxtQkFBbUIzSCxHQUFHLENBQUN5SCxnQkFBZ0I7WUFDekMsT0FBTztnQkFDTEUsbUJBQW1CLFNBQVNoRyxNQUFNO29CQUNoQyxPQUFPM0IsR0FBRyxDQUFDeUgsZ0JBQWdCLENBQUN6SCxHQUFHLENBQUMwSCxxQkFBcUIsQ0FBQy9GO2dCQUN4RDtZQUNGO1lBRUEsSUFBSWlHLFdBQVcsQ0FBQ2pHLFNBQVMsRUFBQyxFQUFHa0csS0FBSyxDQUFDTDtZQUVuQyxJQUFLLElBQUlqRixJQUFJLEdBQUc3QixTQUFTa0gsU0FBU2xILE1BQU0sRUFBRTZCLElBQUk3QixRQUFRNkIsSUFBSztnQkFDekRxRixRQUFRLENBQUNyRixFQUFFLEdBQUdvRixpQkFBaUJDLFFBQVEsQ0FBQ3JGLEVBQUU7WUFDNUM7WUFFQSxPQUFPcUYsU0FBU0UsSUFBSSxDQUFDTjtRQUN2QjtJQUNGO0lBRUEsZ0dBQWdHO0lBQ2hHeEgsSUFBSStILFVBQVUsR0FBR1IsOEJBQThCLEtBQUs7SUFDcER2SCxJQUFJZ0ksYUFBYSxHQUFHVCw4QkFBOEIsS0FBSztJQUN2RHZILElBQUlpSSxVQUFVLEdBQUdWLDhCQUE4QixLQUFLLHFCQUFxQjtJQUN6RXZILElBQUlrSSxhQUFhLEdBQUdYLDhCQUE4QixLQUFLLHdCQUF3QjtJQUUvRXZILElBQUltSSxjQUFjLEdBQUdmLGlCQUFpQixZQUFZO0lBRWxEcEgsSUFBSW9JLEtBQUssR0FBRyxTQUFTekcsTUFBTSxFQUFFMEcsS0FBSztRQUNoQyxJQUFJQztRQUNKLElBQUksQ0FBQ0QsT0FBTztZQUNWQSxRQUFRO2dCQUNOckUsd0JBQXdCaEUsSUFBSWdFLHNCQUFzQjtZQUNwRDtRQUNGO1FBRUFyQyxTQUFTQSxPQUFPQyxPQUFPLENBQUM1QixJQUFJOEUsNkJBQTZCLEVBQUU7UUFDM0Qsc0RBQXNEO1FBQ3REbkQsU0FBU0EsT0FBT0MsT0FBTyxDQUFDNUIsSUFBSStFLG9CQUFvQixFQUFFO1FBRWxELG9HQUFvRztRQUVwRyxtQkFBbUI7UUFDbkJ1RCxNQUFNM0csT0FBTzRHLE9BQU8sQ0FBQztRQUNyQixJQUFJRCxNQUFNLENBQUMsR0FBRztZQUNaLFlBQVk7WUFDWkQsTUFBTXRFLFFBQVEsR0FBR3BDLE9BQU82RyxTQUFTLENBQUNGLE1BQU0sTUFBTTtZQUM5QzNHLFNBQVNBLE9BQU82RyxTQUFTLENBQUMsR0FBR0Y7UUFDL0I7UUFFQSxnQkFBZ0I7UUFDaEJBLE1BQU0zRyxPQUFPNEcsT0FBTyxDQUFDO1FBQ3JCLElBQUlELE1BQU0sQ0FBQyxHQUFHO1lBQ1osWUFBWTtZQUNaRCxNQUFNdkUsS0FBSyxHQUFHbkMsT0FBTzZHLFNBQVMsQ0FBQ0YsTUFBTSxNQUFNO1lBQzNDM0csU0FBU0EsT0FBTzZHLFNBQVMsQ0FBQyxHQUFHRjtRQUMvQjtRQUVBLDZGQUE2RjtRQUM3RjNHLFNBQVNBLE9BQU9DLE9BQU8sQ0FBQyxnQ0FBZ0M7UUFDeEQseUVBQXlFO1FBQ3pFRCxTQUFTQSxPQUFPQyxPQUFPLENBQUMsZUFBZTtRQUV2QyxtQkFBbUI7UUFDbkIsSUFBSUQsT0FBTzZHLFNBQVMsQ0FBQyxHQUFHLE9BQU8sTUFBTTtZQUNuQyxrQkFBa0I7WUFDbEJILE1BQU05RSxRQUFRLEdBQUc7WUFDakI1QixTQUFTQSxPQUFPNkcsU0FBUyxDQUFDO1lBQzFCLGdDQUFnQztZQUNoQzdHLFNBQVMzQixJQUFJeUksY0FBYyxDQUFDOUcsUUFBUTBHO1FBQ3RDLE9BQU87WUFDTEMsTUFBTTNHLE9BQU80RyxPQUFPLENBQUM7WUFDckIsSUFBSUQsTUFBTSxDQUFDLEdBQUc7Z0JBQ1pELE1BQU05RSxRQUFRLEdBQUc1QixPQUFPNkcsU0FBUyxDQUFDLEdBQUdGLFFBQVE7Z0JBQzdDLElBQUlELE1BQU05RSxRQUFRLElBQUksQ0FBQzhFLE1BQU05RSxRQUFRLENBQUNWLEtBQUssQ0FBQzdDLElBQUltRSxtQkFBbUIsR0FBRztvQkFDcEUsMkJBQTJCO29CQUMzQmtFLE1BQU05RSxRQUFRLEdBQUczQztnQkFDbkIsT0FBTyxJQUFJZSxPQUFPNkcsU0FBUyxDQUFDRixNQUFNLEdBQUdBLE1BQU0sR0FBRzFHLE9BQU8sQ0FBQyxPQUFPLFNBQVMsTUFBTTtvQkFDMUVELFNBQVNBLE9BQU82RyxTQUFTLENBQUNGLE1BQU07b0JBRWhDLGdDQUFnQztvQkFDaEMzRyxTQUFTM0IsSUFBSXlJLGNBQWMsQ0FBQzlHLFFBQVEwRztnQkFDdEMsT0FBTztvQkFDTDFHLFNBQVNBLE9BQU82RyxTQUFTLENBQUNGLE1BQU07b0JBQ2hDRCxNQUFNMUUsR0FBRyxHQUFHO2dCQUNkO1lBQ0Y7UUFDRjtRQUVBLCtCQUErQjtRQUMvQjBFLE1BQU14RSxJQUFJLEdBQUdsQztRQUViLGlCQUFpQjtRQUNqQixPQUFPMEc7SUFDVDtJQUNBckksSUFBSTBJLFNBQVMsR0FBRyxTQUFTL0csTUFBTSxFQUFFMEcsS0FBSztRQUNwQyxJQUFJLENBQUMxRyxRQUFRO1lBQ1hBLFNBQVM7UUFDWDtRQUVBLHNEQUFzRDtRQUN0RCx3RUFBd0U7UUFDeEUseUdBQXlHO1FBQ3pHLGlFQUFpRTtRQUNqRSwrQ0FBK0M7UUFDL0NBLFNBQVNBLE9BQU9DLE9BQU8sQ0FBQyxPQUFPO1FBRS9CLG9CQUFvQjtRQUNwQixJQUFJMEcsTUFBTTNHLE9BQU80RyxPQUFPLENBQUM7UUFDekIsSUFBSUk7UUFDSixJQUFJQztRQUVKLElBQUlOLFFBQVEsQ0FBQyxHQUFHO1lBQ2RBLE1BQU0zRyxPQUFPakIsTUFBTTtRQUNyQjtRQUVBLElBQUlpQixPQUFPa0gsTUFBTSxDQUFDLE9BQU8sS0FBSztZQUM1QiwrRkFBK0Y7WUFDL0YsNEZBQTRGO1lBQzVGLGdFQUFnRTtZQUNoRUYsYUFBYWhILE9BQU80RyxPQUFPLENBQUM7WUFDNUJGLE1BQU0zRSxRQUFRLEdBQUcvQixPQUFPNkcsU0FBUyxDQUFDLEdBQUdHLGVBQWU7WUFDcEROLE1BQU16RSxJQUFJLEdBQUdqQyxPQUFPNkcsU0FBUyxDQUFDRyxhQUFhLEdBQUdMLFFBQVE7WUFDdEQsSUFBSUQsTUFBTXpFLElBQUksS0FBSyxLQUFLO2dCQUN0QnlFLE1BQU16RSxJQUFJLEdBQUc7WUFDZjtRQUNGLE9BQU87WUFDTCxJQUFJa0YsYUFBYW5ILE9BQU80RyxPQUFPLENBQUM7WUFDaEMsSUFBSVEsYUFBYXBILE9BQU80RyxPQUFPLENBQUM7WUFDaEMsSUFBSVMsWUFBWXJILE9BQU80RyxPQUFPLENBQUMsS0FBS08sYUFBYTtZQUNqRCxJQUFJRSxjQUFjLENBQUMsS0FBTUQsQ0FBQUEsZUFBZSxDQUFDLEtBQUtDLFlBQVlELFVBQVMsR0FBSTtnQkFDckUsbURBQW1EO2dCQUNuRCxnRkFBZ0Y7Z0JBQ2hGVixNQUFNM0UsUUFBUSxHQUFHL0IsT0FBTzZHLFNBQVMsQ0FBQyxHQUFHRixRQUFRO2dCQUM3Q0QsTUFBTXpFLElBQUksR0FBRztZQUNmLE9BQU87Z0JBQ0xnRixJQUFJakgsT0FBTzZHLFNBQVMsQ0FBQyxHQUFHRixLQUFLVCxLQUFLLENBQUM7Z0JBQ25DUSxNQUFNM0UsUUFBUSxHQUFHa0YsQ0FBQyxDQUFDLEVBQUUsSUFBSTtnQkFDekJQLE1BQU16RSxJQUFJLEdBQUdnRixDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ3ZCO1FBQ0Y7UUFFQSxJQUFJUCxNQUFNM0UsUUFBUSxJQUFJL0IsT0FBTzZHLFNBQVMsQ0FBQ0YsS0FBS08sTUFBTSxDQUFDLE9BQU8sS0FBSztZQUM3RFA7WUFDQTNHLFNBQVMsTUFBTUE7UUFDakI7UUFFQSxJQUFJMEcsTUFBTXJFLHNCQUFzQixFQUFFO1lBQ2hDaEUsSUFBSWlKLG1CQUFtQixDQUFDWixNQUFNM0UsUUFBUSxFQUFFMkUsTUFBTTlFLFFBQVE7UUFDeEQ7UUFFQSxJQUFJOEUsTUFBTXpFLElBQUksRUFBRTtZQUNkNUQsSUFBSWtKLGVBQWUsQ0FBQ2IsTUFBTXpFLElBQUk7UUFDaEM7UUFFQSxPQUFPakMsT0FBTzZHLFNBQVMsQ0FBQ0YsUUFBUTtJQUNsQztJQUNBdEksSUFBSXlJLGNBQWMsR0FBRyxTQUFTOUcsTUFBTSxFQUFFMEcsS0FBSztRQUN6QzFHLFNBQVMzQixJQUFJbUosYUFBYSxDQUFDeEgsUUFBUTBHO1FBQ25DLE9BQU9ySSxJQUFJMEksU0FBUyxDQUFDL0csUUFBUTBHO0lBQy9CO0lBQ0FySSxJQUFJbUosYUFBYSxHQUFHLFNBQVN4SCxNQUFNLEVBQUUwRyxLQUFLO1FBQ3hDLDRCQUE0QjtRQUM1QixJQUFJZSxVQUFVekg7UUFDZCxJQUFJMEgsaUJBQWlCMUgsT0FBTzRHLE9BQU8sQ0FBQztRQUNwQyxJQUFJYyxtQkFBbUIsQ0FBQyxHQUFHO1lBQ3pCMUgsU0FBU0EsT0FBT0MsT0FBTyxDQUFDLE9BQU87UUFDakM7UUFDQSxJQUFJbUgsYUFBYXBILE9BQU80RyxPQUFPLENBQUM7UUFDaEMsSUFBSUQsTUFBTTNHLE9BQU8ySCxXQUFXLENBQUMsS0FBS1AsYUFBYSxDQUFDLElBQUlBLGFBQWFwSCxPQUFPakIsTUFBTSxHQUFHO1FBQ2pGLElBQUlrSTtRQUVKLDZDQUE2QztRQUM3QyxJQUFJTixNQUFNLENBQUMsS0FBTVMsQ0FBQUEsZUFBZSxDQUFDLEtBQUtULE1BQU1TLFVBQVMsR0FBSTtZQUN2REgsSUFBSWpILE9BQU82RyxTQUFTLENBQUMsR0FBR0YsS0FBS1QsS0FBSyxDQUFDO1lBQ25DUSxNQUFNN0UsUUFBUSxHQUFHb0YsQ0FBQyxDQUFDLEVBQUUsR0FBRzVJLElBQUlvRyxNQUFNLENBQUN3QyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQzNDQSxFQUFFVyxLQUFLO1lBQ1BsQixNQUFNNUUsUUFBUSxHQUFHbUYsQ0FBQyxDQUFDLEVBQUUsR0FBRzVJLElBQUlvRyxNQUFNLENBQUN3QyxFQUFFZCxJQUFJLENBQUMsUUFBUTtZQUNsRG5HLFNBQVN5SCxRQUFRWixTQUFTLENBQUNGLE1BQU07UUFDbkMsT0FBTztZQUNMRCxNQUFNN0UsUUFBUSxHQUFHO1lBQ2pCNkUsTUFBTTVFLFFBQVEsR0FBRztRQUNuQjtRQUVBLE9BQU85QjtJQUNUO0lBQ0EzQixJQUFJd0osVUFBVSxHQUFHLFNBQVM3SCxNQUFNLEVBQUV1QyxnQkFBZ0I7UUFDaEQsSUFBSSxDQUFDdkMsUUFBUTtZQUNYLE9BQU8sQ0FBQztRQUNWO1FBRUEsdURBQXVEO1FBQ3ZEQSxTQUFTQSxPQUFPQyxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsZUFBZTtRQUUzRCxJQUFJLENBQUNELFFBQVE7WUFDWCxPQUFPLENBQUM7UUFDVjtRQUVBLElBQUk4SCxRQUFRLENBQUM7UUFDYixJQUFJQyxTQUFTL0gsT0FBT2tHLEtBQUssQ0FBQztRQUMxQixJQUFJbkgsU0FBU2dKLE9BQU9oSixNQUFNO1FBQzFCLElBQUlpSixHQUFHQyxNQUFNMUk7UUFFYixJQUFLLElBQUlxQixJQUFJLEdBQUdBLElBQUk3QixRQUFRNkIsSUFBSztZQUMvQm9ILElBQUlELE1BQU0sQ0FBQ25ILEVBQUUsQ0FBQ3NGLEtBQUssQ0FBQztZQUNwQitCLE9BQU81SixJQUFJaUgsV0FBVyxDQUFDMEMsRUFBRUosS0FBSyxJQUFJckY7WUFDbEMsMEdBQTBHO1lBQzFHaEQsUUFBUXlJLEVBQUVqSixNQUFNLEdBQUdWLElBQUlpSCxXQUFXLENBQUMwQyxFQUFFN0IsSUFBSSxDQUFDLE1BQU01RCxvQkFBb0I7WUFFcEUsSUFBSTBGLFNBQVMsYUFBYTtnQkFFeEI7WUFDRixPQUFPLElBQUlySSxPQUFPUyxJQUFJLENBQUN5SCxPQUFPRyxPQUFPO2dCQUNuQyxJQUFJLE9BQU9ILEtBQUssQ0FBQ0csS0FBSyxLQUFLLFlBQVlILEtBQUssQ0FBQ0csS0FBSyxLQUFLLE1BQU07b0JBQzNESCxLQUFLLENBQUNHLEtBQUssR0FBRzt3QkFBQ0gsS0FBSyxDQUFDRyxLQUFLO3FCQUFDO2dCQUM3QjtnQkFFQUgsS0FBSyxDQUFDRyxLQUFLLENBQUNDLElBQUksQ0FBQzNJO1lBQ25CLE9BQU87Z0JBQ0x1SSxLQUFLLENBQUNHLEtBQUssR0FBRzFJO1lBQ2hCO1FBQ0Y7UUFFQSxPQUFPdUk7SUFDVDtJQUVBekosSUFBSThKLEtBQUssR0FBRyxTQUFTekIsS0FBSztRQUN4QixJQUFJTyxJQUFJO1FBQ1IsSUFBSW1CLHNCQUFzQjtRQUUxQixJQUFJMUIsTUFBTTlFLFFBQVEsRUFBRTtZQUNsQnFGLEtBQUtQLE1BQU05RSxRQUFRLEdBQUc7UUFDeEI7UUFFQSxJQUFJLENBQUM4RSxNQUFNMUUsR0FBRyxJQUFLaUYsQ0FBQUEsS0FBS1AsTUFBTTNFLFFBQVEsR0FBRztZQUN2Q2tGLEtBQUs7WUFDTG1CLHNCQUFzQjtRQUN4QjtRQUVBbkIsS0FBTTVJLElBQUlnSyxjQUFjLENBQUMzQixVQUFVO1FBRW5DLElBQUksT0FBT0EsTUFBTXhFLElBQUksS0FBSyxVQUFVO1lBQ2xDLElBQUl3RSxNQUFNeEUsSUFBSSxDQUFDZ0YsTUFBTSxDQUFDLE9BQU8sT0FBT2tCLHFCQUFxQjtnQkFDdkRuQixLQUFLO1lBQ1A7WUFFQUEsS0FBS1AsTUFBTXhFLElBQUk7UUFDakI7UUFFQSxJQUFJLE9BQU93RSxNQUFNdkUsS0FBSyxLQUFLLFlBQVl1RSxNQUFNdkUsS0FBSyxFQUFFO1lBQ2xEOEUsS0FBSyxNQUFNUCxNQUFNdkUsS0FBSztRQUN4QjtRQUVBLElBQUksT0FBT3VFLE1BQU10RSxRQUFRLEtBQUssWUFBWXNFLE1BQU10RSxRQUFRLEVBQUU7WUFDeEQ2RSxLQUFLLE1BQU1QLE1BQU10RSxRQUFRO1FBQzNCO1FBQ0EsT0FBTzZFO0lBQ1Q7SUFDQTVJLElBQUlpSyxTQUFTLEdBQUcsU0FBUzVCLEtBQUs7UUFDNUIsSUFBSU8sSUFBSTtRQUVSLElBQUksQ0FBQ1AsTUFBTTNFLFFBQVEsRUFBRTtZQUNuQixPQUFPO1FBQ1QsT0FBTyxJQUFJMUQsSUFBSXVFLGNBQWMsQ0FBQ3BELElBQUksQ0FBQ2tILE1BQU0zRSxRQUFRLEdBQUc7WUFDbERrRixLQUFLLE1BQU1QLE1BQU0zRSxRQUFRLEdBQUc7UUFDOUIsT0FBTztZQUNMa0YsS0FBS1AsTUFBTTNFLFFBQVE7UUFDckI7UUFFQSxJQUFJMkUsTUFBTXpFLElBQUksRUFBRTtZQUNkZ0YsS0FBSyxNQUFNUCxNQUFNekUsSUFBSTtRQUN2QjtRQUVBLE9BQU9nRjtJQUNUO0lBQ0E1SSxJQUFJZ0ssY0FBYyxHQUFHLFNBQVMzQixLQUFLO1FBQ2pDLE9BQU9ySSxJQUFJa0ssYUFBYSxDQUFDN0IsU0FBU3JJLElBQUlpSyxTQUFTLENBQUM1QjtJQUNsRDtJQUNBckksSUFBSWtLLGFBQWEsR0FBRyxTQUFTN0IsS0FBSztRQUNoQyxJQUFJTyxJQUFJO1FBRVIsSUFBSVAsTUFBTTdFLFFBQVEsRUFBRTtZQUNsQm9GLEtBQUs1SSxJQUFJbUcsTUFBTSxDQUFDa0MsTUFBTTdFLFFBQVE7UUFDaEM7UUFFQSxJQUFJNkUsTUFBTTVFLFFBQVEsRUFBRTtZQUNsQm1GLEtBQUssTUFBTTVJLElBQUltRyxNQUFNLENBQUNrQyxNQUFNNUUsUUFBUTtRQUN0QztRQUVBLElBQUltRixHQUFHO1lBQ0xBLEtBQUs7UUFDUDtRQUVBLE9BQU9BO0lBQ1Q7SUFDQTVJLElBQUltSyxVQUFVLEdBQUcsU0FBUzlILElBQUksRUFBRTRCLHdCQUF3QixFQUFFQyxnQkFBZ0I7UUFDeEUseUdBQXlHO1FBQ3pHLHlEQUF5RDtRQUN6RCwwRkFBMEY7UUFDMUYsNEVBQTRFO1FBQzVFLDRFQUE0RTtRQUU1RSxJQUFJMEUsSUFBSTtRQUNSLElBQUl3QixRQUFRQyxLQUFLOUgsR0FBRzdCO1FBQ3BCLElBQUsySixPQUFPaEksS0FBTTtZQUNoQixJQUFJZ0ksUUFBUSxhQUFhO2dCQUV2QjtZQUNGLE9BQU8sSUFBSTlJLE9BQU9TLElBQUksQ0FBQ0ssTUFBTWdJLE1BQU07Z0JBQ2pDLElBQUluSSxRQUFRRyxJQUFJLENBQUNnSSxJQUFJLEdBQUc7b0JBQ3RCRCxTQUFTLENBQUM7b0JBQ1YsSUFBSzdILElBQUksR0FBRzdCLFNBQVMyQixJQUFJLENBQUNnSSxJQUFJLENBQUMzSixNQUFNLEVBQUU2QixJQUFJN0IsUUFBUTZCLElBQUs7d0JBQ3RELElBQUlGLElBQUksQ0FBQ2dJLElBQUksQ0FBQzlILEVBQUUsS0FBSzNCLGFBQWF3SixNQUFNLENBQUMvSCxJQUFJLENBQUNnSSxJQUFJLENBQUM5SCxFQUFFLEdBQUcsR0FBRyxLQUFLM0IsV0FBVzs0QkFDekVnSSxLQUFLLE1BQU01SSxJQUFJc0ssbUJBQW1CLENBQUNELEtBQUtoSSxJQUFJLENBQUNnSSxJQUFJLENBQUM5SCxFQUFFLEVBQUUyQjs0QkFDdEQsSUFBSUQsNkJBQTZCLE1BQU07Z0NBQ3JDbUcsTUFBTSxDQUFDL0gsSUFBSSxDQUFDZ0ksSUFBSSxDQUFDOUgsRUFBRSxHQUFHLEdBQUcsR0FBRzs0QkFDOUI7d0JBQ0Y7b0JBQ0Y7Z0JBQ0YsT0FBTyxJQUFJRixJQUFJLENBQUNnSSxJQUFJLEtBQUt6SixXQUFXO29CQUNsQ2dJLEtBQUssTUFBTTVJLElBQUlzSyxtQkFBbUIsQ0FBQ0QsS0FBS2hJLElBQUksQ0FBQ2dJLElBQUksRUFBRW5HO2dCQUNyRDtZQUNGO1FBQ0Y7UUFFQSxPQUFPMEUsRUFBRUosU0FBUyxDQUFDO0lBQ3JCO0lBQ0F4SSxJQUFJc0ssbUJBQW1CLEdBQUcsU0FBU1YsSUFBSSxFQUFFMUksS0FBSyxFQUFFZ0QsZ0JBQWdCO1FBQzlELDZHQUE2RztRQUM3RyxrSUFBa0k7UUFDbEksT0FBT2xFLElBQUkrRyxXQUFXLENBQUM2QyxNQUFNMUYsb0JBQXFCaEQsQ0FBQUEsVUFBVSxPQUFPLE1BQU1sQixJQUFJK0csV0FBVyxDQUFDN0YsT0FBT2dELG9CQUFvQixFQUFDO0lBQ3ZIO0lBRUFsRSxJQUFJdUssUUFBUSxHQUFHLFNBQVNsSSxJQUFJLEVBQUV1SCxJQUFJLEVBQUUxSSxLQUFLO1FBQ3ZDLElBQUksT0FBTzBJLFNBQVMsVUFBVTtZQUM1QixJQUFLLElBQUlTLE9BQU9ULEtBQU07Z0JBQ3BCLElBQUlySSxPQUFPUyxJQUFJLENBQUM0SCxNQUFNUyxNQUFNO29CQUMxQnJLLElBQUl1SyxRQUFRLENBQUNsSSxNQUFNZ0ksS0FBS1QsSUFBSSxDQUFDUyxJQUFJO2dCQUNuQztZQUNGO1FBQ0YsT0FBTyxJQUFJLE9BQU9ULFNBQVMsVUFBVTtZQUNuQyxJQUFJdkgsSUFBSSxDQUFDdUgsS0FBSyxLQUFLaEosV0FBVztnQkFDNUJ5QixJQUFJLENBQUN1SCxLQUFLLEdBQUcxSTtnQkFDYjtZQUNGLE9BQU8sSUFBSSxPQUFPbUIsSUFBSSxDQUFDdUgsS0FBSyxLQUFLLFVBQVU7Z0JBQ3pDdkgsSUFBSSxDQUFDdUgsS0FBSyxHQUFHO29CQUFDdkgsSUFBSSxDQUFDdUgsS0FBSztpQkFBQztZQUMzQjtZQUVBLElBQUksQ0FBQzFILFFBQVFoQixRQUFRO2dCQUNuQkEsUUFBUTtvQkFBQ0E7aUJBQU07WUFDakI7WUFFQW1CLElBQUksQ0FBQ3VILEtBQUssR0FBRyxDQUFDdkgsSUFBSSxDQUFDdUgsS0FBSyxJQUFJLEVBQUUsRUFBRVksTUFBTSxDQUFDdEo7UUFDekMsT0FBTztZQUNMLE1BQU0sSUFBSUwsVUFBVTtRQUN0QjtJQUNGO0lBRUFiLElBQUl5SyxRQUFRLEdBQUcsU0FBU3BJLElBQUksRUFBRXVILElBQUksRUFBRTFJLEtBQUs7UUFDdkMsSUFBSSxPQUFPMEksU0FBUyxVQUFVO1lBQzVCLElBQUssSUFBSVMsT0FBT1QsS0FBTTtnQkFDcEIsSUFBSXJJLE9BQU9TLElBQUksQ0FBQzRILE1BQU1TLE1BQU07b0JBQzFCckssSUFBSXlLLFFBQVEsQ0FBQ3BJLE1BQU1nSSxLQUFLVCxJQUFJLENBQUNTLElBQUk7Z0JBQ25DO1lBQ0Y7UUFDRixPQUFPLElBQUksT0FBT1QsU0FBUyxVQUFVO1lBQ25DdkgsSUFBSSxDQUFDdUgsS0FBSyxHQUFHMUksVUFBVU4sWUFBWSxPQUFPTTtRQUM1QyxPQUFPO1lBQ0wsTUFBTSxJQUFJTCxVQUFVO1FBQ3RCO0lBQ0Y7SUFFQWIsSUFBSTBLLFdBQVcsR0FBRyxTQUFTckksSUFBSSxFQUFFdUgsSUFBSSxFQUFFMUksS0FBSztRQUMxQyxJQUFJcUIsR0FBRzdCLFFBQVEySjtRQUVmLElBQUluSSxRQUFRMEgsT0FBTztZQUNqQixJQUFLckgsSUFBSSxHQUFHN0IsU0FBU2tKLEtBQUtsSixNQUFNLEVBQUU2QixJQUFJN0IsUUFBUTZCLElBQUs7Z0JBQ2pERixJQUFJLENBQUN1SCxJQUFJLENBQUNySCxFQUFFLENBQUMsR0FBRzNCO1lBQ2xCO1FBQ0YsT0FBTyxJQUFJaUIsUUFBUStILFVBQVUsVUFBVTtZQUNyQyxJQUFLUyxPQUFPaEksS0FBTTtnQkFDaEIsSUFBSXVILEtBQUt6SSxJQUFJLENBQUNrSixNQUFNO29CQUNsQmhJLElBQUksQ0FBQ2dJLElBQUksR0FBR3pKO2dCQUNkO1lBQ0Y7UUFDRixPQUFPLElBQUksT0FBT2dKLFNBQVMsVUFBVTtZQUNuQyxJQUFLUyxPQUFPVCxLQUFNO2dCQUNoQixJQUFJckksT0FBT1MsSUFBSSxDQUFDNEgsTUFBTVMsTUFBTTtvQkFDMUJySyxJQUFJMEssV0FBVyxDQUFDckksTUFBTWdJLEtBQUtULElBQUksQ0FBQ1MsSUFBSTtnQkFDdEM7WUFDRjtRQUNGLE9BQU8sSUFBSSxPQUFPVCxTQUFTLFVBQVU7WUFDbkMsSUFBSTFJLFVBQVVOLFdBQVc7Z0JBQ3ZCLElBQUlpQixRQUFRWCxXQUFXLFVBQVU7b0JBQy9CLElBQUksQ0FBQ2dCLFFBQVFHLElBQUksQ0FBQ3VILEtBQUssS0FBSzFJLE1BQU1DLElBQUksQ0FBQ2tCLElBQUksQ0FBQ3VILEtBQUssR0FBRzt3QkFDbER2SCxJQUFJLENBQUN1SCxLQUFLLEdBQUdoSjtvQkFDZixPQUFPO3dCQUNMeUIsSUFBSSxDQUFDdUgsS0FBSyxHQUFHeEgsa0JBQWtCQyxJQUFJLENBQUN1SCxLQUFLLEVBQUUxSTtvQkFDN0M7Z0JBQ0YsT0FBTyxJQUFJbUIsSUFBSSxDQUFDdUgsS0FBSyxLQUFLOUgsT0FBT1osVUFBVyxFQUFDZ0IsUUFBUWhCLFVBQVVBLE1BQU1SLE1BQU0sS0FBSyxJQUFJO29CQUNsRjJCLElBQUksQ0FBQ3VILEtBQUssR0FBR2hKO2dCQUNmLE9BQU8sSUFBSXNCLFFBQVFHLElBQUksQ0FBQ3VILEtBQUssR0FBRztvQkFDOUJ2SCxJQUFJLENBQUN1SCxLQUFLLEdBQUd4SCxrQkFBa0JDLElBQUksQ0FBQ3VILEtBQUssRUFBRTFJO2dCQUM3QztZQUNGLE9BQU87Z0JBQ0xtQixJQUFJLENBQUN1SCxLQUFLLEdBQUdoSjtZQUNmO1FBQ0YsT0FBTztZQUNMLE1BQU0sSUFBSUMsVUFBVTtRQUN0QjtJQUNGO0lBQ0FiLElBQUkySyxRQUFRLEdBQUcsU0FBU3RJLElBQUksRUFBRXVILElBQUksRUFBRTFJLEtBQUssRUFBRTBKLFdBQVc7UUFDcEQsT0FBUS9JLFFBQVErSDtZQUNkLEtBQUs7Z0JBRUg7WUFFRixLQUFLO2dCQUNILElBQUssSUFBSVMsT0FBT2hJLEtBQU07b0JBQ3BCLElBQUlkLE9BQU9TLElBQUksQ0FBQ0ssTUFBTWdJLE1BQU07d0JBQzFCLElBQUlULEtBQUt6SSxJQUFJLENBQUNrSixRQUFTbkosQ0FBQUEsVUFBVU4sYUFBYVosSUFBSTJLLFFBQVEsQ0FBQ3RJLE1BQU1nSSxLQUFLbkosTUFBSyxHQUFJOzRCQUM3RSxPQUFPO3dCQUNUO29CQUNGO2dCQUNGO2dCQUVBLE9BQU87WUFFVCxLQUFLO2dCQUNILElBQUssSUFBSTJKLFFBQVFqQixLQUFNO29CQUNyQixJQUFJckksT0FBT1MsSUFBSSxDQUFDNEgsTUFBTWlCLE9BQU87d0JBQzNCLElBQUksQ0FBQzdLLElBQUkySyxRQUFRLENBQUN0SSxNQUFNd0ksTUFBTWpCLElBQUksQ0FBQ2lCLEtBQUssR0FBRzs0QkFDekMsT0FBTzt3QkFDVDtvQkFDRjtnQkFDRjtnQkFFQSxPQUFPO1lBRVQ7Z0JBQ0UsTUFBTSxJQUFJaEssVUFBVTtRQUN4QjtRQUVBLE9BQVFnQixRQUFRWDtZQUNkLEtBQUs7Z0JBQ0gsb0NBQW9DO2dCQUNwQyxPQUFPMEksUUFBUXZILE1BQU0sNEJBQTRCO1lBRW5ELEtBQUs7Z0JBQ0gsK0JBQStCO2dCQUMvQixJQUFJeUksU0FBU0MsUUFBUTdJLFFBQVFHLElBQUksQ0FBQ3VILEtBQUssSUFBSXZILElBQUksQ0FBQ3VILEtBQUssQ0FBQ2xKLE1BQU0sR0FBRzJCLElBQUksQ0FBQ3VILEtBQUs7Z0JBQ3pFLE9BQU8xSSxVQUFVNEo7WUFFbkIsS0FBSztnQkFDSCwyQkFBMkI7Z0JBQzNCLE9BQU8sQ0FBQyxDQUFDNUosTUFBTW1CLElBQUksQ0FBQ3VILEtBQUssRUFBRUEsTUFBTXZIO1lBRW5DLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDSCxRQUFRRyxJQUFJLENBQUN1SCxLQUFLLEdBQUc7b0JBQ3hCLE9BQU87Z0JBQ1Q7Z0JBRUEsSUFBSW9CLEtBQUtKLGNBQWNsSSxnQkFBZ0JJO2dCQUN2QyxPQUFPa0ksR0FBRzNJLElBQUksQ0FBQ3VILEtBQUssRUFBRTFJO1lBRXhCLEtBQUs7Z0JBQ0gsSUFBSSxDQUFDZ0IsUUFBUUcsSUFBSSxDQUFDdUgsS0FBSyxHQUFHO29CQUN4QixPQUFPbUIsUUFBUTFJLElBQUksQ0FBQ3VILEtBQUssSUFBSXZILElBQUksQ0FBQ3VILEtBQUssQ0FBQy9HLEtBQUssQ0FBQzNCO2dCQUNoRDtnQkFFQSxJQUFJLENBQUMwSixhQUFhO29CQUNoQixPQUFPO2dCQUNUO2dCQUVBLE9BQU9sSSxjQUFjTCxJQUFJLENBQUN1SCxLQUFLLEVBQUUxSTtZQUVuQyxLQUFLO2dCQUNIQSxRQUFRWSxPQUFPWjtZQUNmLGlCQUFpQixHQUNuQixLQUFLO2dCQUNILElBQUksQ0FBQ2dCLFFBQVFHLElBQUksQ0FBQ3VILEtBQUssR0FBRztvQkFDeEIsT0FBT3ZILElBQUksQ0FBQ3VILEtBQUssS0FBSzFJO2dCQUN4QjtnQkFFQSxJQUFJLENBQUMwSixhQUFhO29CQUNoQixPQUFPO2dCQUNUO2dCQUVBLE9BQU9sSSxjQUFjTCxJQUFJLENBQUN1SCxLQUFLLEVBQUUxSTtZQUVuQztnQkFDRSxNQUFNLElBQUlMLFVBQVU7UUFDeEI7SUFDRjtJQUdBYixJQUFJaUwsU0FBUyxHQUFHO1FBQ2QsSUFBSUMsUUFBUSxFQUFFO1FBQ2QsSUFBSXRELFdBQVcsRUFBRTtRQUNqQixJQUFJdUQsbUJBQW1CO1FBRXZCLElBQUssSUFBSTVJLElBQUksR0FBR0EsSUFBSTlCLFVBQVVDLE1BQU0sRUFBRTZCLElBQUs7WUFDekMsSUFBSWpDLE1BQU0sSUFBSU4sSUFBSVMsU0FBUyxDQUFDOEIsRUFBRTtZQUM5QjJJLE1BQU1yQixJQUFJLENBQUN2SjtZQUNYLElBQUk4SyxZQUFZOUssSUFBSStLLE9BQU87WUFDM0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVUxSyxNQUFNLEVBQUU0SyxJQUFLO2dCQUN6QyxJQUFJLE9BQU9GLFNBQVMsQ0FBQ0UsRUFBRSxLQUFLLFVBQVU7b0JBQ3BDMUQsU0FBU2lDLElBQUksQ0FBQ3VCLFNBQVMsQ0FBQ0UsRUFBRTtnQkFDNUI7Z0JBRUEsSUFBSUYsU0FBUyxDQUFDRSxFQUFFLEVBQUU7b0JBQ2hCSDtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUN2RCxTQUFTbEgsTUFBTSxJQUFJLENBQUN5SyxrQkFBa0I7WUFDekMsT0FBTyxJQUFJbkwsSUFBSTtRQUNqQjtRQUVBLElBQUl1TCxNQUFNLElBQUl2TCxJQUFJLElBQUlxTCxPQUFPLENBQUN6RDtRQUU5QixJQUFJc0QsS0FBSyxDQUFDLEVBQUUsQ0FBQ3JILElBQUksT0FBTyxNQUFNcUgsS0FBSyxDQUFDLEVBQUUsQ0FBQ3JILElBQUksR0FBRzVCLEtBQUssQ0FBQyxHQUFHLE9BQU8sS0FBSztZQUNqRXNKLElBQUkxSCxJQUFJLENBQUMsTUFBTTBILElBQUkxSCxJQUFJO1FBQ3pCO1FBRUEsT0FBTzBILElBQUlDLFNBQVM7SUFDdEI7SUFFQXhMLElBQUl5TCxVQUFVLEdBQUcsU0FBUzFJLEdBQUcsRUFBRUMsR0FBRztRQUNoQyxJQUFJdEMsU0FBU2dMLEtBQUtDLEdBQUcsQ0FBQzVJLElBQUlyQyxNQUFNLEVBQUVzQyxJQUFJdEMsTUFBTTtRQUM1QyxJQUFJNEg7UUFFSixvQ0FBb0M7UUFDcEMsSUFBS0EsTUFBTSxHQUFHQSxNQUFNNUgsUUFBUTRILE1BQU87WUFDakMsSUFBSXZGLElBQUk4RixNQUFNLENBQUNQLFNBQVN0RixJQUFJNkYsTUFBTSxDQUFDUCxNQUFNO2dCQUN2Q0E7Z0JBQ0E7WUFDRjtRQUNGO1FBRUEsSUFBSUEsTUFBTSxHQUFHO1lBQ1gsT0FBT3ZGLElBQUk4RixNQUFNLENBQUMsT0FBTzdGLElBQUk2RixNQUFNLENBQUMsTUFBTTlGLElBQUk4RixNQUFNLENBQUMsT0FBTyxNQUFNLE1BQU07UUFDMUU7UUFFQSxtQkFBbUI7UUFDbkIsSUFBSTlGLElBQUk4RixNQUFNLENBQUNQLFNBQVMsT0FBT3RGLElBQUk2RixNQUFNLENBQUNQLFNBQVMsS0FBSztZQUN0REEsTUFBTXZGLElBQUl5RixTQUFTLENBQUMsR0FBR0YsS0FBS2dCLFdBQVcsQ0FBQztRQUMxQztRQUVBLE9BQU92RyxJQUFJeUYsU0FBUyxDQUFDLEdBQUdGLE1BQU07SUFDaEM7SUFFQXRJLElBQUk0TCxZQUFZLEdBQUcsU0FBU2pLLE1BQU0sRUFBRWtLLFFBQVEsRUFBRUMsT0FBTztRQUNuREEsV0FBWUEsQ0FBQUEsVUFBVSxDQUFDO1FBQ3ZCLElBQUlDLFNBQVNELFFBQVFwSCxLQUFLLElBQUkxRSxJQUFJeUUsT0FBTyxDQUFDQyxLQUFLO1FBQy9DLElBQUlzSCxPQUFPRixRQUFRbkgsR0FBRyxJQUFJM0UsSUFBSXlFLE9BQU8sQ0FBQ0UsR0FBRztRQUN6QyxJQUFJc0gsUUFBUUgsUUFBUWxILElBQUksSUFBSTVFLElBQUl5RSxPQUFPLENBQUNHLElBQUk7UUFDNUMsSUFBSXNILFVBQVVKLFFBQVFqSCxNQUFNLElBQUk3RSxJQUFJeUUsT0FBTyxDQUFDSSxNQUFNO1FBQ2xELElBQUlzSCxpQkFBaUI7UUFFckJKLE9BQU9LLFNBQVMsR0FBRztRQUNuQixNQUFPLEtBQU07WUFDWCxJQUFJdkosUUFBUWtKLE9BQU9NLElBQUksQ0FBQzFLO1lBQ3hCLElBQUksQ0FBQ2tCLE9BQU87Z0JBQ1Y7WUFDRjtZQUVBLElBQUk2QixRQUFRN0IsTUFBTXlKLEtBQUs7WUFDdkIsSUFBSVIsUUFBUVMsVUFBVSxFQUFFO2dCQUN0QixxQkFBcUI7Z0JBQ3JCLElBQUlDLGdCQUFnQjdLLE9BQU9NLEtBQUssQ0FBQ3lKLEtBQUtlLEdBQUcsQ0FBQy9ILFFBQVEsR0FBRyxJQUFJQTtnQkFDekQsSUFBSThILGlCQUFpQkwsZUFBZWhMLElBQUksQ0FBQ3FMLGdCQUFnQjtvQkFDdkQ7Z0JBQ0Y7WUFDRjtZQUVBLElBQUk3SCxNQUFNRCxRQUFRL0MsT0FBT00sS0FBSyxDQUFDeUMsT0FBT2dJLE1BQU0sQ0FBQ1Y7WUFDN0MsSUFBSS9KLFFBQVFOLE9BQU9NLEtBQUssQ0FBQ3lDLE9BQU9DO1lBQ2hDLDRDQUE0QztZQUM1QyxJQUFJZ0ksWUFBWSxDQUFDO1lBQ2pCLE1BQU8sS0FBTTtnQkFDWCxJQUFJQyxjQUFjVixRQUFRRyxJQUFJLENBQUNwSztnQkFDL0IsSUFBSSxDQUFDMkssYUFBYTtvQkFDaEI7Z0JBQ0Y7Z0JBRUEsSUFBSUMsaUJBQWlCRCxZQUFZTixLQUFLLEdBQUdNLFdBQVcsQ0FBQyxFQUFFLENBQUNsTSxNQUFNO2dCQUM5RGlNLFlBQVlqQixLQUFLZSxHQUFHLENBQUNFLFdBQVdFO1lBQ2xDO1lBRUEsSUFBSUYsWUFBWSxDQUFDLEdBQUc7Z0JBQ2xCMUssUUFBUUEsTUFBTUEsS0FBSyxDQUFDLEdBQUcwSyxhQUFhMUssTUFBTUEsS0FBSyxDQUFDMEssV0FBVy9LLE9BQU8sQ0FBQ3FLLE9BQU87WUFDNUUsT0FBTztnQkFDTGhLLFFBQVFBLE1BQU1MLE9BQU8sQ0FBQ3FLLE9BQU87WUFDL0I7WUFFQSxJQUFJaEssTUFBTXZCLE1BQU0sSUFBSW1DLEtBQUssQ0FBQyxFQUFFLENBQUNuQyxNQUFNLEVBQUU7Z0JBR25DO1lBQ0Y7WUFFQSxJQUFJb0wsUUFBUWdCLE1BQU0sSUFBSWhCLFFBQVFnQixNQUFNLENBQUMzTCxJQUFJLENBQUNjLFFBQVE7Z0JBQ2hEO1lBQ0Y7WUFFQTBDLE1BQU1ELFFBQVF6QyxNQUFNdkIsTUFBTTtZQUMxQixJQUFJcU0sU0FBU2xCLFNBQVM1SixPQUFPeUMsT0FBT0MsS0FBS2hEO1lBQ3pDLElBQUlvTCxXQUFXbk0sV0FBVztnQkFDeEJtTCxPQUFPSyxTQUFTLEdBQUd6SDtnQkFDbkI7WUFDRjtZQUVBb0ksU0FBU2pMLE9BQU9pTDtZQUNoQnBMLFNBQVNBLE9BQU9NLEtBQUssQ0FBQyxHQUFHeUMsU0FBU3FJLFNBQVNwTCxPQUFPTSxLQUFLLENBQUMwQztZQUN4RG9ILE9BQU9LLFNBQVMsR0FBRzFILFFBQVFxSSxPQUFPck0sTUFBTTtRQUMxQztRQUVBcUwsT0FBT0ssU0FBUyxHQUFHO1FBQ25CLE9BQU96SztJQUNUO0lBRUEzQixJQUFJaUosbUJBQW1CLEdBQUcsU0FBU1UsQ0FBQyxFQUFFcEcsUUFBUTtRQUM1QyxpRkFBaUY7UUFDakYsMkRBQTJEO1FBRTNELElBQUl5SixjQUFjLENBQUMsQ0FBQ3JELEdBQUcsbUNBQW1DO1FBQzFELElBQUlzRCxjQUFjLENBQUMsQ0FBQzFKO1FBQ3BCLElBQUkySixzQkFBc0I7UUFFMUIsSUFBSUQsYUFBYTtZQUNmQyxzQkFBc0J4SyxjQUFjMUMsSUFBSXVGLGFBQWEsRUFBRWhDO1FBQ3pEO1FBRUEsSUFBSTJKLHVCQUF1QixDQUFDRixhQUFhO1lBQ3ZDLE1BQU0sSUFBSW5NLFVBQVUsOENBQThDMEM7UUFDcEUsT0FBTyxJQUFJb0csS0FBS0EsRUFBRTlHLEtBQUssQ0FBQzdDLElBQUl3RiwyQkFBMkIsR0FBRztZQUN4RCxnQkFBZ0I7WUFDaEIsSUFBSSxDQUFDdkYsVUFBVTtnQkFDYixNQUFNLElBQUlZLFVBQVUsZUFBZThJLElBQUk7WUFDekM7WUFDQSxJQUFJMUosU0FBU2tOLE9BQU8sQ0FBQ3hELEdBQUc5RyxLQUFLLENBQUM3QyxJQUFJd0YsMkJBQTJCLEdBQUc7Z0JBQzlELE1BQU0sSUFBSTNFLFVBQVUsZUFBZThJLElBQUk7WUFDekM7UUFDRjtJQUNGO0lBRUEzSixJQUFJa0osZUFBZSxHQUFHLFNBQVVTLENBQUM7UUFDL0IsSUFBSSxDQUFDQSxHQUFHO1lBQ047UUFDRjtRQUVBLElBQUkvRixPQUFPd0osT0FBT3pEO1FBQ2xCLElBQUkxSSxVQUFVMkMsU0FBVUEsT0FBTyxLQUFPQSxPQUFPLE9BQVE7WUFDbkQ7UUFDRjtRQUVBLE1BQU0sSUFBSS9DLFVBQVUsV0FBVzhJLElBQUk7SUFDckM7SUFFQSxhQUFhO0lBQ2IzSixJQUFJcU4sVUFBVSxHQUFHLFNBQVNDLFNBQVM7UUFDakMsSUFBSUEsV0FBVztZQUNiLElBQUlDLGVBQWU7Z0JBQ2pCdk4sS0FBSyxJQUFJLENBQUNxTixVQUFVO1lBQ3RCO1lBRUEsSUFBSTVOLEtBQUsrTixXQUFXLElBQUksT0FBTy9OLEtBQUsrTixXQUFXLENBQUNILFVBQVUsS0FBSyxZQUFZO2dCQUN6RUUsYUFBYUMsV0FBVyxHQUFHL04sS0FBSytOLFdBQVcsQ0FBQ0gsVUFBVTtZQUN4RDtZQUVBLElBQUk1TixLQUFLUyxJQUFJLElBQUksT0FBT1QsS0FBS1MsSUFBSSxDQUFDbU4sVUFBVSxLQUFLLFlBQVk7Z0JBQzNERSxhQUFhck4sSUFBSSxHQUFHVCxLQUFLUyxJQUFJLENBQUNtTixVQUFVO1lBQzFDO1lBRUEsSUFBSTVOLEtBQUtVLGtCQUFrQixJQUFJLE9BQU9WLEtBQUtVLGtCQUFrQixDQUFDa04sVUFBVSxLQUFLLFlBQVk7Z0JBQ3ZGRSxhQUFhcE4sa0JBQWtCLEdBQUdWLEtBQUtVLGtCQUFrQixDQUFDa04sVUFBVTtZQUN0RTtZQUVBLE9BQU9FO1FBQ1QsT0FBTyxJQUFJOU4sS0FBS08sR0FBRyxLQUFLLElBQUksRUFBRTtZQUM1QlAsS0FBS08sR0FBRyxHQUFHSztRQUNiO1FBRUEsT0FBTyxJQUFJO0lBQ2I7SUFFQWdCLEVBQUV5SSxLQUFLLEdBQUcsU0FBUzJELFVBQVU7UUFDM0IsSUFBSUEsZUFBZSxNQUFNO1lBQ3ZCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3pCLE9BQU8sSUFBSUQsZUFBZTdNLGFBQWEsSUFBSSxDQUFDOE0sZUFBZSxFQUFFO1lBQzNELElBQUksQ0FBQ3RFLE9BQU8sR0FBR3BKLElBQUk4SixLQUFLLENBQUMsSUFBSSxDQUFDeEcsTUFBTTtZQUNwQyxJQUFJLENBQUNvSyxlQUFlLEdBQUc7UUFDekI7UUFFQSxPQUFPLElBQUk7SUFDYjtJQUVBck0sRUFBRXNNLEtBQUssR0FBRztRQUNSLE9BQU8sSUFBSTNOLElBQUksSUFBSTtJQUNyQjtJQUVBcUIsRUFBRXVNLE9BQU8sR0FBR3ZNLEVBQUVVLFFBQVEsR0FBRztRQUN2QixPQUFPLElBQUksQ0FBQytILEtBQUssQ0FBQyxPQUFPVixPQUFPO0lBQ2xDO0lBR0EsU0FBU3lFLHVCQUF1QjFHLEtBQUs7UUFDbkMsT0FBTyxTQUFTd0MsQ0FBQyxFQUFFRyxLQUFLO1lBQ3RCLElBQUlILE1BQU0vSSxXQUFXO2dCQUNuQixPQUFPLElBQUksQ0FBQzBDLE1BQU0sQ0FBQzZELE1BQU0sSUFBSTtZQUMvQixPQUFPO2dCQUNMLElBQUksQ0FBQzdELE1BQU0sQ0FBQzZELE1BQU0sR0FBR3dDLEtBQUs7Z0JBQzFCLElBQUksQ0FBQ0csS0FBSyxDQUFDLENBQUNBO2dCQUNaLE9BQU8sSUFBSTtZQUNiO1FBQ0Y7SUFDRjtJQUVBLFNBQVNnRSx1QkFBdUIzRyxLQUFLLEVBQUUwRCxJQUFJO1FBQ3pDLE9BQU8sU0FBU2xCLENBQUMsRUFBRUcsS0FBSztZQUN0QixJQUFJSCxNQUFNL0ksV0FBVztnQkFDbkIsT0FBTyxJQUFJLENBQUMwQyxNQUFNLENBQUM2RCxNQUFNLElBQUk7WUFDL0IsT0FBTztnQkFDTCxJQUFJd0MsTUFBTSxNQUFNO29CQUNkQSxJQUFJQSxJQUFJO29CQUNSLElBQUlBLEVBQUVkLE1BQU0sQ0FBQyxPQUFPZ0MsTUFBTTt3QkFDeEJsQixJQUFJQSxFQUFFbkIsU0FBUyxDQUFDO29CQUNsQjtnQkFDRjtnQkFFQSxJQUFJLENBQUNsRixNQUFNLENBQUM2RCxNQUFNLEdBQUd3QztnQkFDckIsSUFBSSxDQUFDRyxLQUFLLENBQUMsQ0FBQ0E7Z0JBQ1osT0FBTyxJQUFJO1lBQ2I7UUFDRjtJQUNGO0lBRUF6SSxFQUFFa0MsUUFBUSxHQUFHc0ssdUJBQXVCO0lBQ3BDeE0sRUFBRW1DLFFBQVEsR0FBR3FLLHVCQUF1QjtJQUNwQ3hNLEVBQUVvQyxRQUFRLEdBQUdvSyx1QkFBdUI7SUFDcEN4TSxFQUFFcUMsUUFBUSxHQUFHbUssdUJBQXVCO0lBQ3BDeE0sRUFBRXVDLElBQUksR0FBR2lLLHVCQUF1QjtJQUNoQ3hNLEVBQUV5QyxLQUFLLEdBQUdnSyx1QkFBdUIsU0FBUztJQUMxQ3pNLEVBQUUwQyxRQUFRLEdBQUcrSix1QkFBdUIsWUFBWTtJQUVoRHpNLEVBQUVxTCxNQUFNLEdBQUcsU0FBUy9DLENBQUMsRUFBRUcsS0FBSztRQUMxQixJQUFJbEIsSUFBSSxJQUFJLENBQUM5RSxLQUFLLENBQUM2RixHQUFHRztRQUN0QixPQUFPLE9BQU9sQixNQUFNLFlBQVlBLEVBQUVsSSxNQUFNLEdBQUksTUFBTWtJLElBQUtBO0lBQ3pEO0lBQ0F2SCxFQUFFME0sSUFBSSxHQUFHLFNBQVNwRSxDQUFDLEVBQUVHLEtBQUs7UUFDeEIsSUFBSWxCLElBQUksSUFBSSxDQUFDN0UsUUFBUSxDQUFDNEYsR0FBR0c7UUFDekIsT0FBTyxPQUFPbEIsTUFBTSxZQUFZQSxFQUFFbEksTUFBTSxHQUFJLE1BQU1rSSxJQUFLQTtJQUN6RDtJQUVBdkgsRUFBRXFGLFFBQVEsR0FBRyxTQUFTaUQsQ0FBQyxFQUFFRyxLQUFLO1FBQzVCLElBQUlILE1BQU0vSSxhQUFhK0ksTUFBTSxNQUFNO1lBQ2pDLElBQUlxRSxNQUFNLElBQUksQ0FBQzFLLE1BQU0sQ0FBQ08sSUFBSSxJQUFLLEtBQUksQ0FBQ1AsTUFBTSxDQUFDSSxRQUFRLEdBQUcsTUFBTSxFQUFDO1lBQzdELE9BQU9pRyxJQUFJLENBQUMsSUFBSSxDQUFDckcsTUFBTSxDQUFDSyxHQUFHLEdBQUczRCxJQUFJZ0ksYUFBYSxHQUFHaEksSUFBSStILFVBQVUsRUFBRWlHLE9BQU9BO1FBQzNFLE9BQU87WUFDTCxJQUFJLElBQUksQ0FBQzFLLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO2dCQUNuQixJQUFJLENBQUNMLE1BQU0sQ0FBQ08sSUFBSSxHQUFHOEYsSUFBSTNKLElBQUlrSSxhQUFhLENBQUN5QixLQUFLO1lBQ2hELE9BQU87Z0JBQ0wsSUFBSSxDQUFDckcsTUFBTSxDQUFDTyxJQUFJLEdBQUc4RixJQUFJM0osSUFBSWlJLFVBQVUsQ0FBQzBCLEtBQUs7WUFDN0M7WUFDQSxJQUFJLENBQUNHLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFDQXpJLEVBQUV3QyxJQUFJLEdBQUd4QyxFQUFFcUYsUUFBUTtJQUNuQnJGLEVBQUVOLElBQUksR0FBRyxTQUFTQSxJQUFJLEVBQUUrSSxLQUFLO1FBQzNCLElBQUlPO1FBRUosSUFBSXRKLFNBQVNILFdBQVc7WUFDdEIsT0FBTyxJQUFJLENBQUNtQixRQUFRO1FBQ3RCO1FBRUEsSUFBSSxDQUFDcUgsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDOUYsTUFBTSxHQUFHdEQsSUFBSXNELE1BQU07UUFFeEIsSUFBSWpELE9BQU9VLGdCQUFnQmY7UUFDM0IsSUFBSWlPLFVBQVUsT0FBT2xOLFNBQVMsWUFBYUEsQ0FBQUEsS0FBSzJDLFFBQVEsSUFBSTNDLEtBQUs4QyxJQUFJLElBQUk5QyxLQUFLMkYsUUFBUTtRQUN0RixJQUFJM0YsS0FBSzZFLFFBQVEsRUFBRTtZQUNqQixJQUFJc0ksWUFBWWxPLElBQUkwRixlQUFlLENBQUMzRTtZQUNwQ0EsT0FBT0EsSUFBSSxDQUFDbU4sVUFBVSxJQUFJO1lBQzFCRCxVQUFVO1FBQ1o7UUFFQSxxRUFBcUU7UUFDckUsK0JBQStCO1FBQy9CLHdDQUF3QztRQUN4QyxvQ0FBb0M7UUFDcEMscUNBQXFDO1FBQ3JDLDREQUE0RDtRQUM1RCx3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDNU4sUUFBUTROLFdBQVdsTixLQUFLMkYsUUFBUSxLQUFLOUYsV0FBVztZQUNuREcsT0FBT0EsS0FBS2dCLFFBQVE7UUFDdEI7UUFFQSxJQUFJLE9BQU9oQixTQUFTLFlBQVlBLGdCQUFnQmUsUUFBUTtZQUN0RCxJQUFJLENBQUN3QixNQUFNLEdBQUd0RCxJQUFJb0ksS0FBSyxDQUFDdEcsT0FBT2YsT0FBTyxJQUFJLENBQUN1QyxNQUFNO1FBQ25ELE9BQU8sSUFBSWpELFFBQVE0TixTQUFTO1lBQzFCLElBQUlFLE1BQU05TixPQUFPVSxLQUFLdUMsTUFBTSxHQUFHdkM7WUFDL0IsSUFBS3NKLE9BQU84RCxJQUFLO2dCQUNmLElBQUk5RCxRQUFRLFNBQVM7b0JBQUU7Z0JBQVU7Z0JBQ2pDLElBQUk5SSxPQUFPUyxJQUFJLENBQUMsSUFBSSxDQUFDc0IsTUFBTSxFQUFFK0csTUFBTTtvQkFDakMsSUFBSSxDQUFDL0csTUFBTSxDQUFDK0csSUFBSSxHQUFHOEQsR0FBRyxDQUFDOUQsSUFBSTtnQkFDN0I7WUFDRjtZQUNBLElBQUk4RCxJQUFJckssS0FBSyxFQUFFO2dCQUNiLElBQUksQ0FBQ0EsS0FBSyxDQUFDcUssSUFBSXJLLEtBQUssRUFBRTtZQUN4QjtRQUNGLE9BQU87WUFDTCxNQUFNLElBQUlqRCxVQUFVO1FBQ3RCO1FBRUEsSUFBSSxDQUFDaUosS0FBSyxDQUFDLENBQUNBO1FBQ1osT0FBTyxJQUFJO0lBQ2I7SUFFQSwyQkFBMkI7SUFDM0J6SSxFQUFFK00sRUFBRSxHQUFHLFNBQVNDLElBQUk7UUFDbEIsSUFBSUMsS0FBSztRQUNULElBQUlDLE1BQU07UUFDVixJQUFJQyxNQUFNO1FBQ1YsSUFBSTVFLE9BQU87UUFDWCxJQUFJNkUsTUFBTTtRQUNWLElBQUlDLE1BQU07UUFDVixJQUFJek8sV0FBVztRQUNmLElBQUkwTyxXQUFXLENBQUMsSUFBSSxDQUFDckwsTUFBTSxDQUFDSyxHQUFHO1FBRS9CLElBQUksSUFBSSxDQUFDTCxNQUFNLENBQUNJLFFBQVEsRUFBRTtZQUN4QmlMLFdBQVc7WUFDWEosTUFBTXZPLElBQUlzRSxjQUFjLENBQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDbUMsTUFBTSxDQUFDSSxRQUFRO1lBQ2xEOEssTUFBTXhPLElBQUl1RSxjQUFjLENBQUNwRCxJQUFJLENBQUMsSUFBSSxDQUFDbUMsTUFBTSxDQUFDSSxRQUFRO1lBQ2xENEssS0FBS0MsT0FBT0M7WUFDWjVFLE9BQU8sQ0FBQzBFO1lBQ1JHLE1BQU03RSxRQUFReEosT0FBT0EsSUFBSXdPLEdBQUcsQ0FBQyxJQUFJLENBQUN0TCxNQUFNLENBQUNJLFFBQVE7WUFDakRnTCxNQUFNOUUsUUFBUTVKLElBQUlvRSxjQUFjLENBQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDbUMsTUFBTSxDQUFDSSxRQUFRO1lBQzFEekQsV0FBVzJKLFFBQVE1SixJQUFJcUUsbUJBQW1CLENBQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDbUMsTUFBTSxDQUFDSSxRQUFRO1FBQ3RFO1FBRUEsT0FBUTJLLEtBQUt4SSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQ0gsT0FBTzhJO1lBRVQsS0FBSztnQkFDSCxPQUFPLENBQUNBO1lBRVYsMEJBQTBCO1lBQzFCLEtBQUs7WUFDTCxLQUFLO2dCQUNILE9BQU8vRTtZQUVULEtBQUs7Z0JBQ0gsT0FBTzZFO1lBRVQsS0FBSztnQkFDSCxPQUFPSDtZQUVULEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPQztZQUVULEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDSCxPQUFPQztZQUVULEtBQUs7Z0JBQ0gsT0FBT0U7WUFFVCxLQUFLO2dCQUNILE9BQU8sQ0FBQyxJQUFJLENBQUNwTCxNQUFNLENBQUNLLEdBQUc7WUFFekIsS0FBSztnQkFDSCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUNMLE1BQU0sQ0FBQ0ssR0FBRztZQUUxQixLQUFLO2dCQUNILE9BQU8xRDtRQUNYO1FBRUEsT0FBTztJQUNUO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUk0TyxZQUFZeE4sRUFBRWtDLFFBQVE7SUFDMUIsSUFBSXVMLFFBQVF6TixFQUFFdUMsSUFBSTtJQUNsQixJQUFJbUwsWUFBWTFOLEVBQUVxQyxRQUFRO0lBRTFCckMsRUFBRWtDLFFBQVEsR0FBRyxTQUFTb0csQ0FBQyxFQUFFRyxLQUFLO1FBQzVCLElBQUlILEdBQUc7WUFDTCxzQkFBc0I7WUFDdEJBLElBQUlBLEVBQUUvSCxPQUFPLENBQUMsYUFBYTtZQUUzQixJQUFJLENBQUMrSCxFQUFFOUcsS0FBSyxDQUFDN0MsSUFBSW1FLG1CQUFtQixHQUFHO2dCQUNyQyxNQUFNLElBQUl0RCxVQUFVLGVBQWU4SSxJQUFJO1lBQ3pDO1FBQ0Y7UUFFQSxPQUFPa0YsVUFBVTdNLElBQUksQ0FBQyxJQUFJLEVBQUUySCxHQUFHRztJQUNqQztJQUNBekksRUFBRTJOLE1BQU0sR0FBRzNOLEVBQUVrQyxRQUFRO0lBQ3JCbEMsRUFBRXVDLElBQUksR0FBRyxTQUFTK0YsQ0FBQyxFQUFFRyxLQUFLO1FBQ3hCLElBQUksSUFBSSxDQUFDeEcsTUFBTSxDQUFDSyxHQUFHLEVBQUU7WUFDbkIsT0FBT2dHLE1BQU0vSSxZQUFZLEtBQUssSUFBSTtRQUNwQztRQUVBLElBQUkrSSxNQUFNL0ksV0FBVztZQUNuQixJQUFJK0ksTUFBTSxHQUFHO2dCQUNYQSxJQUFJO1lBQ047WUFFQSxJQUFJQSxHQUFHO2dCQUNMQSxLQUFLO2dCQUNMLElBQUlBLEVBQUVkLE1BQU0sQ0FBQyxPQUFPLEtBQUs7b0JBQ3ZCYyxJQUFJQSxFQUFFbkIsU0FBUyxDQUFDO2dCQUNsQjtnQkFFQXhJLElBQUlrSixlQUFlLENBQUNTO1lBQ3RCO1FBQ0Y7UUFDQSxPQUFPbUYsTUFBTTlNLElBQUksQ0FBQyxJQUFJLEVBQUUySCxHQUFHRztJQUM3QjtJQUNBekksRUFBRXFDLFFBQVEsR0FBRyxTQUFTaUcsQ0FBQyxFQUFFRyxLQUFLO1FBQzVCLElBQUksSUFBSSxDQUFDeEcsTUFBTSxDQUFDSyxHQUFHLEVBQUU7WUFDbkIsT0FBT2dHLE1BQU0vSSxZQUFZLEtBQUssSUFBSTtRQUNwQztRQUVBLElBQUkrSSxNQUFNL0ksV0FBVztZQUNuQixJQUFJcU8sSUFBSTtnQkFBRWpMLHdCQUF3QixJQUFJLENBQUNWLE1BQU0sQ0FBQ1Usc0JBQXNCO1lBQUM7WUFDckUsSUFBSWdLLE1BQU1oTyxJQUFJMEksU0FBUyxDQUFDaUIsR0FBR3NGO1lBQzNCLElBQUlqQixRQUFRLEtBQUs7Z0JBQ2YsTUFBTSxJQUFJbk4sVUFBVSxlQUFlOEksSUFBSTtZQUN6QztZQUVBQSxJQUFJc0YsRUFBRXZMLFFBQVE7WUFDZCxJQUFJLElBQUksQ0FBQ0osTUFBTSxDQUFDVSxzQkFBc0IsRUFBRTtnQkFDdENoRSxJQUFJaUosbUJBQW1CLENBQUNVLEdBQUcsSUFBSSxDQUFDckcsTUFBTSxDQUFDQyxRQUFRO1lBQ2pEO1FBQ0Y7UUFFQSxPQUFPd0wsVUFBVS9NLElBQUksQ0FBQyxJQUFJLEVBQUUySCxHQUFHRztJQUNqQztJQUVBLHFCQUFxQjtJQUNyQnpJLEVBQUU2TixNQUFNLEdBQUcsU0FBU3ZGLENBQUMsRUFBRUcsS0FBSztRQUMxQixJQUFJLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE9BQU9nRyxNQUFNL0ksWUFBWSxLQUFLLElBQUk7UUFDcEM7UUFFQSxJQUFJK0ksTUFBTS9JLFdBQVc7WUFDbkIsSUFBSTJDLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1lBQzVCLElBQUk0TCxZQUFZLElBQUksQ0FBQ0EsU0FBUztZQUM5QixJQUFJLENBQUNBLFdBQVc7Z0JBQ2QsT0FBTztZQUNUO1lBRUEsT0FBTyxDQUFDNUwsV0FBV0EsV0FBVyxRQUFRLEVBQUMsSUFBSyxJQUFJLENBQUM0TCxTQUFTO1FBQzVELE9BQU87WUFDTCxJQUFJRCxTQUFTbFAsSUFBSTJKO1lBQ2pCLElBQUksQ0FDRHBHLFFBQVEsQ0FBQzJMLE9BQU8zTCxRQUFRLElBQ3hCNEwsU0FBUyxDQUFDRCxPQUFPQyxTQUFTLElBQzFCckYsS0FBSyxDQUFDLENBQUNBO1lBQ1YsT0FBTyxJQUFJO1FBQ2I7SUFDRjtJQUNBekksRUFBRStOLElBQUksR0FBRyxTQUFTekYsQ0FBQyxFQUFFRyxLQUFLO1FBQ3hCLElBQUksSUFBSSxDQUFDeEcsTUFBTSxDQUFDSyxHQUFHLEVBQUU7WUFDbkIsT0FBT2dHLE1BQU0vSSxZQUFZLEtBQUssSUFBSTtRQUNwQztRQUVBLElBQUkrSSxNQUFNL0ksV0FBVztZQUNuQixPQUFPLElBQUksQ0FBQzBDLE1BQU0sQ0FBQ0ksUUFBUSxHQUFHMUQsSUFBSWlLLFNBQVMsQ0FBQyxJQUFJLENBQUMzRyxNQUFNLElBQUk7UUFDN0QsT0FBTztZQUNMLElBQUkwSyxNQUFNaE8sSUFBSTBJLFNBQVMsQ0FBQ2lCLEdBQUcsSUFBSSxDQUFDckcsTUFBTTtZQUN0QyxJQUFJMEssUUFBUSxLQUFLO2dCQUNmLE1BQU0sSUFBSW5OLFVBQVUsZUFBZThJLElBQUk7WUFDekM7WUFFQSxJQUFJLENBQUNHLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFDQXpJLEVBQUU4TixTQUFTLEdBQUcsU0FBU3hGLENBQUMsRUFBRUcsS0FBSztRQUM3QixJQUFJLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE9BQU9nRyxNQUFNL0ksWUFBWSxLQUFLLElBQUk7UUFDcEM7UUFFQSxJQUFJK0ksTUFBTS9JLFdBQVc7WUFDbkIsT0FBTyxJQUFJLENBQUMwQyxNQUFNLENBQUNJLFFBQVEsR0FBRzFELElBQUlnSyxjQUFjLENBQUMsSUFBSSxDQUFDMUcsTUFBTSxJQUFJO1FBQ2xFLE9BQU87WUFDTCxJQUFJMEssTUFBTWhPLElBQUl5SSxjQUFjLENBQUNrQixHQUFHLElBQUksQ0FBQ3JHLE1BQU07WUFDM0MsSUFBSTBLLFFBQVEsS0FBSztnQkFDZixNQUFNLElBQUluTixVQUFVLGVBQWU4SSxJQUFJO1lBQ3pDO1lBRUEsSUFBSSxDQUFDRyxLQUFLLENBQUMsQ0FBQ0E7WUFDWixPQUFPLElBQUk7UUFDYjtJQUNGO0lBQ0F6SSxFQUFFZ08sUUFBUSxHQUFHLFNBQVMxRixDQUFDLEVBQUVHLEtBQUs7UUFDNUIsSUFBSSxJQUFJLENBQUN4RyxNQUFNLENBQUNLLEdBQUcsRUFBRTtZQUNuQixPQUFPZ0csTUFBTS9JLFlBQVksS0FBSyxJQUFJO1FBQ3BDO1FBRUEsSUFBSStJLE1BQU0vSSxXQUFXO1lBQ25CLElBQUlnSSxJQUFJNUksSUFBSWtLLGFBQWEsQ0FBQyxJQUFJLENBQUM1RyxNQUFNO1lBQ3JDLE9BQU9zRixJQUFJQSxFQUFFSixTQUFTLENBQUMsR0FBR0ksRUFBRWxJLE1BQU0sR0FBRSxLQUFLa0k7UUFDM0MsT0FBTztZQUNMLElBQUllLENBQUMsQ0FBQ0EsRUFBRWpKLE1BQU0sR0FBQyxFQUFFLEtBQUssS0FBSztnQkFDekJpSixLQUFLO1lBQ1A7WUFFQTNKLElBQUltSixhQUFhLENBQUNRLEdBQUcsSUFBSSxDQUFDckcsTUFBTTtZQUNoQyxJQUFJLENBQUN3RyxLQUFLLENBQUMsQ0FBQ0E7WUFDWixPQUFPLElBQUk7UUFDYjtJQUNGO0lBQ0F6SSxFQUFFaU8sUUFBUSxHQUFHLFNBQVMzRixDQUFDLEVBQUVHLEtBQUs7UUFDNUIsSUFBSXpCO1FBRUosSUFBSXNCLE1BQU0vSSxXQUFXO1lBQ25CLE9BQU8sSUFBSSxDQUFDaUQsSUFBSSxLQUFLLElBQUksQ0FBQzZJLE1BQU0sS0FBSyxJQUFJLENBQUNxQixJQUFJO1FBQ2hEO1FBRUExRixRQUFRckksSUFBSW9JLEtBQUssQ0FBQ3VCO1FBQ2xCLElBQUksQ0FBQ3JHLE1BQU0sQ0FBQ08sSUFBSSxHQUFHd0UsTUFBTXhFLElBQUk7UUFDN0IsSUFBSSxDQUFDUCxNQUFNLENBQUNRLEtBQUssR0FBR3VFLE1BQU12RSxLQUFLO1FBQy9CLElBQUksQ0FBQ1IsTUFBTSxDQUFDUyxRQUFRLEdBQUdzRSxNQUFNdEUsUUFBUTtRQUNyQyxJQUFJLENBQUMrRixLQUFLLENBQUMsQ0FBQ0E7UUFDWixPQUFPLElBQUk7SUFDYjtJQUVBLHFCQUFxQjtJQUNyQnpJLEVBQUVrTyxTQUFTLEdBQUcsU0FBUzVGLENBQUMsRUFBRUcsS0FBSztRQUM3QixJQUFJLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE9BQU9nRyxNQUFNL0ksWUFBWSxLQUFLLElBQUk7UUFDcEM7UUFFQSxtREFBbUQ7UUFDbkQsSUFBSStJLE1BQU0vSSxXQUFXO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMwQyxNQUFNLENBQUNJLFFBQVEsSUFBSSxJQUFJLENBQUMwSyxFQUFFLENBQUMsT0FBTztnQkFDMUMsT0FBTztZQUNUO1lBRUEsc0NBQXNDO1lBQ3RDLElBQUl6SixNQUFNLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDaEQsTUFBTSxHQUFHLElBQUksQ0FBQzhPLE1BQU0sR0FBRzlPLE1BQU0sR0FBRztZQUMvRCxPQUFPLElBQUksQ0FBQzRDLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDOEUsU0FBUyxDQUFDLEdBQUc3RCxRQUFRO1FBQ25ELE9BQU87WUFDTCxJQUFJdUMsSUFBSSxJQUFJLENBQUM1RCxNQUFNLENBQUNJLFFBQVEsQ0FBQ2hELE1BQU0sR0FBRyxJQUFJLENBQUM4TyxNQUFNLEdBQUc5TyxNQUFNO1lBQzFELElBQUkrTyxNQUFNLElBQUksQ0FBQ25NLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDOEUsU0FBUyxDQUFDLEdBQUd0QjtZQUM1QyxJQUFJdEYsVUFBVSxJQUFJOE4sT0FBTyxNQUFNaE8sWUFBWStOO1lBRTNDLElBQUk5RixLQUFLQSxFQUFFZCxNQUFNLENBQUNjLEVBQUVqSixNQUFNLEdBQUcsT0FBTyxLQUFLO2dCQUN2Q2lKLEtBQUs7WUFDUDtZQUVBLElBQUlBLEVBQUVwQixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUc7Z0JBQ3pCLE1BQU0sSUFBSTFILFVBQVU7WUFDdEI7WUFFQSxJQUFJOEksR0FBRztnQkFDTDNKLElBQUlpSixtQkFBbUIsQ0FBQ1UsR0FBRyxJQUFJLENBQUNyRyxNQUFNLENBQUNDLFFBQVE7WUFDakQ7WUFFQSxJQUFJLENBQUNELE1BQU0sQ0FBQ0ksUUFBUSxHQUFHLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxRQUFRLENBQUM5QixPQUFPLENBQUNBLFNBQVMrSDtZQUM3RCxJQUFJLENBQUNHLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFDQXpJLEVBQUVtTyxNQUFNLEdBQUcsU0FBUzdGLENBQUMsRUFBRUcsS0FBSztRQUMxQixJQUFJLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE9BQU9nRyxNQUFNL0ksWUFBWSxLQUFLLElBQUk7UUFDcEM7UUFFQSxJQUFJLE9BQU8rSSxNQUFNLFdBQVc7WUFDMUJHLFFBQVFIO1lBQ1JBLElBQUkvSTtRQUNOO1FBRUEsMkRBQTJEO1FBQzNELElBQUkrSSxNQUFNL0ksV0FBVztZQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDMEMsTUFBTSxDQUFDSSxRQUFRLElBQUksSUFBSSxDQUFDMEssRUFBRSxDQUFDLE9BQU87Z0JBQzFDLE9BQU87WUFDVDtZQUVBLGlFQUFpRTtZQUNqRSxJQUFJeEYsSUFBSSxJQUFJLENBQUN0RixNQUFNLENBQUNJLFFBQVEsQ0FBQ2IsS0FBSyxDQUFDO1lBQ25DLElBQUkrRixLQUFLQSxFQUFFbEksTUFBTSxHQUFHLEdBQUc7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDNEMsTUFBTSxDQUFDSSxRQUFRO1lBQzdCO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlpQixNQUFNLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDaEQsTUFBTSxHQUFHLElBQUksQ0FBQ2lQLEdBQUcsQ0FBQzdGLE9BQU9wSixNQUFNLEdBQUc7WUFDakVpRSxNQUFNLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDNEYsV0FBVyxDQUFDLEtBQUszRSxNQUFLLEtBQUs7WUFDdEQsT0FBTyxJQUFJLENBQUNyQixNQUFNLENBQUNJLFFBQVEsQ0FBQzhFLFNBQVMsQ0FBQzdELFFBQVE7UUFDaEQsT0FBTztZQUNMLElBQUksQ0FBQ2dGLEdBQUc7Z0JBQ04sTUFBTSxJQUFJOUksVUFBVTtZQUN0QjtZQUVBLElBQUk4SSxFQUFFcEIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUN6QixNQUFNLElBQUkxSCxVQUFVO1lBQ3RCO1lBRUFiLElBQUlpSixtQkFBbUIsQ0FBQ1UsR0FBRyxJQUFJLENBQUNyRyxNQUFNLENBQUNDLFFBQVE7WUFFL0MsSUFBSSxDQUFDLElBQUksQ0FBQ0QsTUFBTSxDQUFDSSxRQUFRLElBQUksSUFBSSxDQUFDMEssRUFBRSxDQUFDLE9BQU87Z0JBQzFDLElBQUksQ0FBQzlLLE1BQU0sQ0FBQ0ksUUFBUSxHQUFHaUc7WUFDekIsT0FBTztnQkFDTCxJQUFJL0gsVUFBVSxJQUFJOE4sT0FBT2hPLFlBQVksSUFBSSxDQUFDOE4sTUFBTSxNQUFNO2dCQUN0RCxJQUFJLENBQUNsTSxNQUFNLENBQUNJLFFBQVEsR0FBRyxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDOUIsT0FBTyxDQUFDQSxTQUFTK0g7WUFDL0Q7WUFFQSxJQUFJLENBQUNHLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFDQXpJLEVBQUVzTyxHQUFHLEdBQUcsU0FBU2hHLENBQUMsRUFBRUcsS0FBSztRQUN2QixJQUFJLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE9BQU9nRyxNQUFNL0ksWUFBWSxLQUFLLElBQUk7UUFDcEM7UUFFQSxJQUFJLE9BQU8rSSxNQUFNLFdBQVc7WUFDMUJHLFFBQVFIO1lBQ1JBLElBQUkvSTtRQUNOO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUkrSSxNQUFNL0ksV0FBVztZQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDMEMsTUFBTSxDQUFDSSxRQUFRLElBQUksSUFBSSxDQUFDMEssRUFBRSxDQUFDLE9BQU87Z0JBQzFDLE9BQU87WUFDVDtZQUVBLElBQUk5RixNQUFNLElBQUksQ0FBQ2hGLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDNEYsV0FBVyxDQUFDO1lBQzNDLElBQUlxRyxNQUFNLElBQUksQ0FBQ3JNLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDOEUsU0FBUyxDQUFDRixNQUFNO1lBRS9DLElBQUl3QixVQUFVLFFBQVExSixPQUFPQSxJQUFJdUMsSUFBSSxDQUFDZ04sSUFBSTlKLFdBQVcsR0FBRyxFQUFFO2dCQUN4RCxPQUFPekYsSUFBSXdQLEdBQUcsQ0FBQyxJQUFJLENBQUN0TSxNQUFNLENBQUNJLFFBQVEsS0FBS2lNO1lBQzFDO1lBRUEsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsSUFBSS9OO1lBRUosSUFBSSxDQUFDK0gsR0FBRztnQkFDTixNQUFNLElBQUk5SSxVQUFVO1lBQ3RCLE9BQU8sSUFBSThJLEVBQUU5RyxLQUFLLENBQUMsa0JBQWtCO2dCQUNuQyxJQUFJekMsT0FBT0EsSUFBSWdPLEVBQUUsQ0FBQ3pFLElBQUk7b0JBQ3BCL0gsVUFBVSxJQUFJOE4sT0FBT2hPLFlBQVksSUFBSSxDQUFDaU8sR0FBRyxNQUFNO29CQUMvQyxJQUFJLENBQUNyTSxNQUFNLENBQUNJLFFBQVEsR0FBRyxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDOUIsT0FBTyxDQUFDQSxTQUFTK0g7Z0JBQy9ELE9BQU87b0JBQ0wsTUFBTSxJQUFJOUksVUFBVSxVQUFVOEksSUFBSTtnQkFDcEM7WUFDRixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNyRyxNQUFNLENBQUNJLFFBQVEsSUFBSSxJQUFJLENBQUMwSyxFQUFFLENBQUMsT0FBTztnQkFDakQsTUFBTSxJQUFJeUIsZUFBZTtZQUMzQixPQUFPO2dCQUNMak8sVUFBVSxJQUFJOE4sT0FBT2hPLFlBQVksSUFBSSxDQUFDaU8sR0FBRyxNQUFNO2dCQUMvQyxJQUFJLENBQUNyTSxNQUFNLENBQUNJLFFBQVEsR0FBRyxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ksUUFBUSxDQUFDOUIsT0FBTyxDQUFDQSxTQUFTK0g7WUFDL0Q7WUFFQSxJQUFJLENBQUNHLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFDQXpJLEVBQUV5TyxTQUFTLEdBQUcsU0FBU25HLENBQUMsRUFBRUcsS0FBSztRQUM3QixJQUFJLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE9BQU9nRyxNQUFNL0ksWUFBWSxLQUFLLElBQUk7UUFDcEM7UUFFQSxJQUFJK0ksTUFBTS9JLGFBQWErSSxNQUFNLE1BQU07WUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ3JHLE1BQU0sQ0FBQ08sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDUCxNQUFNLENBQUNJLFFBQVEsRUFBRTtnQkFDOUMsT0FBTztZQUNUO1lBRUEsSUFBSSxJQUFJLENBQUNKLE1BQU0sQ0FBQ08sSUFBSSxLQUFLLEtBQUs7Z0JBQzVCLE9BQU87WUFDVDtZQUVBLElBQUljLE1BQU0sSUFBSSxDQUFDckIsTUFBTSxDQUFDTyxJQUFJLENBQUNuRCxNQUFNLEdBQUcsSUFBSSxDQUFDcVAsUUFBUSxHQUFHclAsTUFBTSxHQUFHO1lBQzdELElBQUlzTixNQUFNLElBQUksQ0FBQzFLLE1BQU0sQ0FBQ08sSUFBSSxDQUFDMkUsU0FBUyxDQUFDLEdBQUc3RCxRQUFTLEtBQUksQ0FBQ3JCLE1BQU0sQ0FBQ0ksUUFBUSxHQUFHLE1BQU0sRUFBQztZQUUvRSxPQUFPaUcsSUFBSTNKLElBQUkrSCxVQUFVLENBQUNpRyxPQUFPQTtRQUVuQyxPQUFPO1lBQ0wsSUFBSTlHLElBQUksSUFBSSxDQUFDNUQsTUFBTSxDQUFDTyxJQUFJLENBQUNuRCxNQUFNLEdBQUcsSUFBSSxDQUFDcVAsUUFBUSxHQUFHclAsTUFBTTtZQUN4RCxJQUFJb1AsWUFBWSxJQUFJLENBQUN4TSxNQUFNLENBQUNPLElBQUksQ0FBQzJFLFNBQVMsQ0FBQyxHQUFHdEI7WUFDOUMsSUFBSXRGLFVBQVUsSUFBSThOLE9BQU8sTUFBTWhPLFlBQVlvTztZQUUzQyxpREFBaUQ7WUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQzFCLEVBQUUsQ0FBQyxhQUFhO2dCQUN4QixJQUFJLENBQUN6RSxHQUFHO29CQUNOQSxJQUFJO2dCQUNOO2dCQUVBLElBQUlBLEVBQUVkLE1BQU0sQ0FBQyxPQUFPLEtBQUs7b0JBQ3ZCYyxJQUFJLE1BQU1BO2dCQUNaO1lBQ0Y7WUFFQSxzQ0FBc0M7WUFDdEMsSUFBSUEsS0FBS0EsRUFBRWQsTUFBTSxDQUFDYyxFQUFFakosTUFBTSxHQUFHLE9BQU8sS0FBSztnQkFDdkNpSixLQUFLO1lBQ1A7WUFFQUEsSUFBSTNKLElBQUlpSSxVQUFVLENBQUMwQjtZQUNuQixJQUFJLENBQUNyRyxNQUFNLENBQUNPLElBQUksR0FBRyxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sSUFBSSxDQUFDakMsT0FBTyxDQUFDQSxTQUFTK0g7WUFDckQsSUFBSSxDQUFDRyxLQUFLLENBQUMsQ0FBQ0E7WUFDWixPQUFPLElBQUk7UUFDYjtJQUNGO0lBQ0F6SSxFQUFFME8sUUFBUSxHQUFHLFNBQVNwRyxDQUFDLEVBQUVHLEtBQUs7UUFDNUIsSUFBSSxJQUFJLENBQUN4RyxNQUFNLENBQUNLLEdBQUcsRUFBRTtZQUNuQixPQUFPZ0csTUFBTS9JLFlBQVksS0FBSyxJQUFJO1FBQ3BDO1FBRUEsSUFBSSxPQUFPK0ksTUFBTSxVQUFVO1lBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUNyRyxNQUFNLENBQUNPLElBQUksSUFBSSxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sSUFBSSxLQUFLLEtBQUs7Z0JBQ2pELE9BQU87WUFDVDtZQUVBLElBQUl5RSxNQUFNLElBQUksQ0FBQ2hGLE1BQU0sQ0FBQ08sSUFBSSxDQUFDeUYsV0FBVyxDQUFDO1lBQ3ZDLElBQUkwRSxNQUFNLElBQUksQ0FBQzFLLE1BQU0sQ0FBQ08sSUFBSSxDQUFDMkUsU0FBUyxDQUFDRixNQUFJO1lBRXpDLE9BQU9xQixJQUFJM0osSUFBSWdRLGlCQUFpQixDQUFDaEMsT0FBT0E7UUFDMUMsT0FBTztZQUNMLElBQUlpQyxtQkFBbUI7WUFFdkIsSUFBSXRHLEVBQUVkLE1BQU0sQ0FBQyxPQUFPLEtBQUs7Z0JBQ3ZCYyxJQUFJQSxFQUFFbkIsU0FBUyxDQUFDO1lBQ2xCO1lBRUEsSUFBSW1CLEVBQUU5RyxLQUFLLENBQUMsVUFBVTtnQkFDcEJvTixtQkFBbUI7WUFDckI7WUFFQSxJQUFJck8sVUFBVSxJQUFJOE4sT0FBT2hPLFlBQVksSUFBSSxDQUFDcU8sUUFBUSxNQUFNO1lBQ3hEcEcsSUFBSTNKLElBQUlpSSxVQUFVLENBQUMwQjtZQUNuQixJQUFJLENBQUNyRyxNQUFNLENBQUNPLElBQUksR0FBRyxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sSUFBSSxDQUFDakMsT0FBTyxDQUFDQSxTQUFTK0g7WUFFckQsSUFBSXNHLGtCQUFrQjtnQkFDcEIsSUFBSSxDQUFDQyxhQUFhLENBQUNwRztZQUNyQixPQUFPO2dCQUNMLElBQUksQ0FBQ0EsS0FBSyxDQUFDLENBQUNBO1lBQ2Q7WUFFQSxPQUFPLElBQUk7UUFDYjtJQUNGO0lBQ0F6SSxFQUFFOE8sTUFBTSxHQUFHLFNBQVN4RyxDQUFDLEVBQUVHLEtBQUs7UUFDMUIsSUFBSSxJQUFJLENBQUN4RyxNQUFNLENBQUNLLEdBQUcsRUFBRTtZQUNuQixPQUFPZ0csTUFBTS9JLFlBQVksS0FBSyxJQUFJO1FBQ3BDO1FBRUEsSUFBSStJLE1BQU0vSSxhQUFhK0ksTUFBTSxNQUFNO1lBQ2pDLElBQUksQ0FBQyxJQUFJLENBQUNyRyxNQUFNLENBQUNPLElBQUksSUFBSSxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sSUFBSSxLQUFLLEtBQUs7Z0JBQ2pELE9BQU87WUFDVDtZQUVBLElBQUlrTSxXQUFXLElBQUksQ0FBQ0EsUUFBUTtZQUM1QixJQUFJekgsTUFBTXlILFNBQVN6RyxXQUFXLENBQUM7WUFDL0IsSUFBSWdDLEdBQUcwQztZQUVQLElBQUkxRixRQUFRLENBQUMsR0FBRztnQkFDZCxPQUFPO1lBQ1Q7WUFFQSxrRUFBa0U7WUFDbEVnRCxJQUFJeUUsU0FBU3ZILFNBQVMsQ0FBQ0YsTUFBSTtZQUMzQjBGLE1BQU0sZ0JBQWtCN00sSUFBSSxDQUFDbUssS0FBS0EsSUFBSTtZQUN0QyxPQUFPM0IsSUFBSTNKLElBQUlnUSxpQkFBaUIsQ0FBQ2hDLE9BQU9BO1FBQzFDLE9BQU87WUFDTCxJQUFJckUsRUFBRWQsTUFBTSxDQUFDLE9BQU8sS0FBSztnQkFDdkJjLElBQUlBLEVBQUVuQixTQUFTLENBQUM7WUFDbEI7WUFFQSxJQUFJMkgsU0FBUyxJQUFJLENBQUNBLE1BQU07WUFDeEIsSUFBSXZPO1lBRUosSUFBSSxDQUFDdU8sUUFBUTtnQkFDWCxJQUFJLENBQUN4RyxHQUFHO29CQUNOLE9BQU8sSUFBSTtnQkFDYjtnQkFFQSxJQUFJLENBQUNyRyxNQUFNLENBQUNPLElBQUksSUFBSSxNQUFNN0QsSUFBSWlJLFVBQVUsQ0FBQzBCO1lBQzNDLE9BQU8sSUFBSSxDQUFDQSxHQUFHO2dCQUNiL0gsVUFBVSxJQUFJOE4sT0FBT2hPLFlBQVksTUFBTXlPLFVBQVU7WUFDbkQsT0FBTztnQkFDTHZPLFVBQVUsSUFBSThOLE9BQU9oTyxZQUFZeU8sVUFBVTtZQUM3QztZQUVBLElBQUl2TyxTQUFTO2dCQUNYK0gsSUFBSTNKLElBQUlpSSxVQUFVLENBQUMwQjtnQkFDbkIsSUFBSSxDQUFDckcsTUFBTSxDQUFDTyxJQUFJLEdBQUcsSUFBSSxDQUFDUCxNQUFNLENBQUNPLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQ0EsU0FBUytIO1lBQ3ZEO1lBRUEsSUFBSSxDQUFDRyxLQUFLLENBQUMsQ0FBQ0E7WUFDWixPQUFPLElBQUk7UUFDYjtJQUNGO0lBQ0F6SSxFQUFFZ0ssT0FBTyxHQUFHLFNBQVNBLE9BQU8sRUFBRTFCLENBQUMsRUFBRUcsS0FBSztRQUNwQyxJQUFJc0csWUFBWSxJQUFJLENBQUM5TSxNQUFNLENBQUNLLEdBQUcsR0FBRyxNQUFNO1FBQ3hDLElBQUlFLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3BCLElBQUl3TSxXQUFXeE0sS0FBSzJFLFNBQVMsQ0FBQyxHQUFHLE9BQU87UUFDeEMsSUFBSVosV0FBVy9ELEtBQUtnRSxLQUFLLENBQUN1STtRQUUxQixJQUFJL0UsWUFBWXpLLGFBQWEsT0FBT3lLLFlBQVksVUFBVTtZQUN4RHZCLFFBQVFIO1lBQ1JBLElBQUkwQjtZQUNKQSxVQUFVeks7UUFDWjtRQUVBLElBQUl5SyxZQUFZekssYUFBYSxPQUFPeUssWUFBWSxVQUFVO1lBQ3hELE1BQU0sSUFBSWlGLE1BQU0sa0JBQWtCakYsVUFBVTtRQUM5QztRQUVBLElBQUlnRixVQUFVO1lBQ1p6SSxTQUFTMkIsS0FBSztRQUNoQjtRQUVBLElBQUk4QixVQUFVLEdBQUc7WUFDZixpREFBaUQ7WUFDakRBLFVBQVVLLEtBQUtlLEdBQUcsQ0FBQzdFLFNBQVNsSCxNQUFNLEdBQUcySyxTQUFTO1FBQ2hEO1FBRUEsSUFBSTFCLE1BQU0vSSxXQUFXO1lBQ25CLHdCQUF3QixHQUN4QixPQUFPeUssWUFBWXpLLFlBQ2ZnSCxXQUNBQSxRQUFRLENBQUN5RCxRQUFRO1FBQ3JCLHlCQUF5QixHQUMzQixPQUFPLElBQUlBLFlBQVksUUFBUXpELFFBQVEsQ0FBQ3lELFFBQVEsS0FBS3pLLFdBQVc7WUFDOUQsSUFBSXNCLFFBQVF5SCxJQUFJO2dCQUNkL0IsV0FBVyxFQUFFO2dCQUNiLHVDQUF1QztnQkFDdkMsSUFBSyxJQUFJckYsSUFBRSxHQUFHVyxJQUFFeUcsRUFBRWpKLE1BQU0sRUFBRTZCLElBQUlXLEdBQUdYLElBQUs7b0JBQ3BDLElBQUksQ0FBQ29ILENBQUMsQ0FBQ3BILEVBQUUsQ0FBQzdCLE1BQU0sSUFBSyxFQUFDa0gsU0FBU2xILE1BQU0sSUFBSSxDQUFDa0gsUUFBUSxDQUFDQSxTQUFTbEgsTUFBTSxHQUFFLEVBQUUsQ0FBQ0EsTUFBTSxHQUFHO3dCQUM5RTtvQkFDRjtvQkFFQSxJQUFJa0gsU0FBU2xILE1BQU0sSUFBSSxDQUFDa0gsUUFBUSxDQUFDQSxTQUFTbEgsTUFBTSxHQUFFLEVBQUUsQ0FBQ0EsTUFBTSxFQUFFO3dCQUMzRGtILFNBQVMySSxHQUFHO29CQUNkO29CQUVBM0ksU0FBU2lDLElBQUksQ0FBQzFHLFlBQVl3RyxDQUFDLENBQUNwSCxFQUFFO2dCQUNoQztZQUNGLE9BQU8sSUFBSW9ILEtBQUssT0FBT0EsTUFBTSxVQUFVO2dCQUNyQ0EsSUFBSXhHLFlBQVl3RztnQkFDaEIsSUFBSS9CLFFBQVEsQ0FBQ0EsU0FBU2xILE1BQU0sR0FBRSxFQUFFLEtBQUssSUFBSTtvQkFDdkMsaURBQWlEO29CQUNqRCx1Q0FBdUM7b0JBQ3ZDa0gsUUFBUSxDQUFDQSxTQUFTbEgsTUFBTSxHQUFFLEVBQUUsR0FBR2lKO2dCQUNqQyxPQUFPO29CQUNML0IsU0FBU2lDLElBQUksQ0FBQ0Y7Z0JBQ2hCO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSUEsR0FBRztnQkFDTC9CLFFBQVEsQ0FBQ3lELFFBQVEsR0FBR2xJLFlBQVl3RztZQUNsQyxPQUFPO2dCQUNML0IsU0FBU25GLE1BQU0sQ0FBQzRJLFNBQVM7WUFDM0I7UUFDRjtRQUVBLElBQUlnRixVQUFVO1lBQ1p6SSxTQUFTNEksT0FBTyxDQUFDO1FBQ25CO1FBRUEsT0FBTyxJQUFJLENBQUMzTSxJQUFJLENBQUMrRCxTQUFTRSxJQUFJLENBQUNzSSxZQUFZdEc7SUFDN0M7SUFDQXpJLEVBQUVvUCxZQUFZLEdBQUcsU0FBU3BGLE9BQU8sRUFBRTFCLENBQUMsRUFBRUcsS0FBSztRQUN6QyxJQUFJbEMsVUFBVXJGLEdBQUdXO1FBRWpCLElBQUksT0FBT21JLFlBQVksVUFBVTtZQUMvQnZCLFFBQVFIO1lBQ1JBLElBQUkwQjtZQUNKQSxVQUFVeks7UUFDWjtRQUVBLElBQUkrSSxNQUFNL0ksV0FBVztZQUNuQmdILFdBQVcsSUFBSSxDQUFDeUQsT0FBTyxDQUFDQSxTQUFTMUIsR0FBR0c7WUFDcEMsSUFBSSxDQUFDNUgsUUFBUTBGLFdBQVc7Z0JBQ3RCQSxXQUFXQSxhQUFhaEgsWUFBWVosSUFBSW9HLE1BQU0sQ0FBQ3dCLFlBQVloSDtZQUM3RCxPQUFPO2dCQUNMLElBQUsyQixJQUFJLEdBQUdXLElBQUkwRSxTQUFTbEgsTUFBTSxFQUFFNkIsSUFBSVcsR0FBR1gsSUFBSztvQkFDM0NxRixRQUFRLENBQUNyRixFQUFFLEdBQUd2QyxJQUFJb0csTUFBTSxDQUFDd0IsUUFBUSxDQUFDckYsRUFBRTtnQkFDdEM7WUFDRjtZQUVBLE9BQU9xRjtRQUNUO1FBRUEsSUFBSSxDQUFDMUYsUUFBUXlILElBQUk7WUFDZkEsSUFBSSxPQUFRQSxNQUFNLFlBQVlBLGFBQWE3SCxTQUFVOUIsSUFBSW1HLE1BQU0sQ0FBQ3dELEtBQUtBO1FBQ3ZFLE9BQU87WUFDTCxJQUFLcEgsSUFBSSxHQUFHVyxJQUFJeUcsRUFBRWpKLE1BQU0sRUFBRTZCLElBQUlXLEdBQUdYLElBQUs7Z0JBQ3BDb0gsQ0FBQyxDQUFDcEgsRUFBRSxHQUFHdkMsSUFBSW1HLE1BQU0sQ0FBQ3dELENBQUMsQ0FBQ3BILEVBQUU7WUFDeEI7UUFDRjtRQUVBLE9BQU8sSUFBSSxDQUFDOEksT0FBTyxDQUFDQSxTQUFTMUIsR0FBR0c7SUFDbEM7SUFFQSx3QkFBd0I7SUFDeEIsSUFBSTRHLElBQUlyUCxFQUFFeUMsS0FBSztJQUNmekMsRUFBRXlDLEtBQUssR0FBRyxTQUFTNkYsQ0FBQyxFQUFFRyxLQUFLO1FBQ3pCLElBQUlILE1BQU0sTUFBTTtZQUNkLE9BQU8zSixJQUFJd0osVUFBVSxDQUFDLElBQUksQ0FBQ2xHLE1BQU0sQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ1IsTUFBTSxDQUFDWSxnQkFBZ0I7UUFDdkUsT0FBTyxJQUFJLE9BQU95RixNQUFNLFlBQVk7WUFDbEMsSUFBSXRILE9BQU9yQyxJQUFJd0osVUFBVSxDQUFDLElBQUksQ0FBQ2xHLE1BQU0sQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ1IsTUFBTSxDQUFDWSxnQkFBZ0I7WUFDekUsSUFBSTZJLFNBQVNwRCxFQUFFM0gsSUFBSSxDQUFDLElBQUksRUFBRUs7WUFDMUIsSUFBSSxDQUFDaUIsTUFBTSxDQUFDUSxLQUFLLEdBQUc5RCxJQUFJbUssVUFBVSxDQUFDNEMsVUFBVTFLLE1BQU0sSUFBSSxDQUFDaUIsTUFBTSxDQUFDVyx3QkFBd0IsRUFBRSxJQUFJLENBQUNYLE1BQU0sQ0FBQ1ksZ0JBQWdCO1lBQ3JILElBQUksQ0FBQzRGLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiLE9BQU8sSUFBSUgsTUFBTS9JLGFBQWEsT0FBTytJLE1BQU0sVUFBVTtZQUNuRCxJQUFJLENBQUNyRyxNQUFNLENBQUNRLEtBQUssR0FBRzlELElBQUltSyxVQUFVLENBQUNSLEdBQUcsSUFBSSxDQUFDckcsTUFBTSxDQUFDVyx3QkFBd0IsRUFBRSxJQUFJLENBQUNYLE1BQU0sQ0FBQ1ksZ0JBQWdCO1lBQ3hHLElBQUksQ0FBQzRGLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiLE9BQU87WUFDTCxPQUFPNEcsRUFBRTFPLElBQUksQ0FBQyxJQUFJLEVBQUUySCxHQUFHRztRQUN6QjtJQUNGO0lBQ0F6SSxFQUFFb0osUUFBUSxHQUFHLFNBQVNiLElBQUksRUFBRTFJLEtBQUssRUFBRTRJLEtBQUs7UUFDdEMsSUFBSXpILE9BQU9yQyxJQUFJd0osVUFBVSxDQUFDLElBQUksQ0FBQ2xHLE1BQU0sQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ1IsTUFBTSxDQUFDWSxnQkFBZ0I7UUFFekUsSUFBSSxPQUFPMEYsU0FBUyxZQUFZQSxnQkFBZ0I5SCxRQUFRO1lBQ3RETyxJQUFJLENBQUN1SCxLQUFLLEdBQUcxSSxVQUFVTixZQUFZTSxRQUFRO1FBQzdDLE9BQU8sSUFBSSxPQUFPMEksU0FBUyxVQUFVO1lBQ25DLElBQUssSUFBSVMsT0FBT1QsS0FBTTtnQkFDcEIsSUFBSXJJLE9BQU9TLElBQUksQ0FBQzRILE1BQU1TLE1BQU07b0JBQzFCaEksSUFBSSxDQUFDZ0ksSUFBSSxHQUFHVCxJQUFJLENBQUNTLElBQUk7Z0JBQ3ZCO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsTUFBTSxJQUFJeEosVUFBVTtRQUN0QjtRQUVBLElBQUksQ0FBQ3lDLE1BQU0sQ0FBQ1EsS0FBSyxHQUFHOUQsSUFBSW1LLFVBQVUsQ0FBQzlILE1BQU0sSUFBSSxDQUFDaUIsTUFBTSxDQUFDVyx3QkFBd0IsRUFBRSxJQUFJLENBQUNYLE1BQU0sQ0FBQ1ksZ0JBQWdCO1FBQzNHLElBQUksT0FBTzBGLFNBQVMsVUFBVTtZQUM1QkUsUUFBUTVJO1FBQ1Y7UUFFQSxJQUFJLENBQUM0SSxLQUFLLENBQUMsQ0FBQ0E7UUFDWixPQUFPLElBQUk7SUFDYjtJQUNBekksRUFBRWtKLFFBQVEsR0FBRyxTQUFTWCxJQUFJLEVBQUUxSSxLQUFLLEVBQUU0SSxLQUFLO1FBQ3RDLElBQUl6SCxPQUFPckMsSUFBSXdKLFVBQVUsQ0FBQyxJQUFJLENBQUNsRyxNQUFNLENBQUNRLEtBQUssRUFBRSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1ksZ0JBQWdCO1FBQ3pFbEUsSUFBSXVLLFFBQVEsQ0FBQ2xJLE1BQU11SCxNQUFNMUksVUFBVU4sWUFBWSxPQUFPTTtRQUN0RCxJQUFJLENBQUNvQyxNQUFNLENBQUNRLEtBQUssR0FBRzlELElBQUltSyxVQUFVLENBQUM5SCxNQUFNLElBQUksQ0FBQ2lCLE1BQU0sQ0FBQ1csd0JBQXdCLEVBQUUsSUFBSSxDQUFDWCxNQUFNLENBQUNZLGdCQUFnQjtRQUMzRyxJQUFJLE9BQU8wRixTQUFTLFVBQVU7WUFDNUJFLFFBQVE1STtRQUNWO1FBRUEsSUFBSSxDQUFDNEksS0FBSyxDQUFDLENBQUNBO1FBQ1osT0FBTyxJQUFJO0lBQ2I7SUFDQXpJLEVBQUVxSixXQUFXLEdBQUcsU0FBU2QsSUFBSSxFQUFFMUksS0FBSyxFQUFFNEksS0FBSztRQUN6QyxJQUFJekgsT0FBT3JDLElBQUl3SixVQUFVLENBQUMsSUFBSSxDQUFDbEcsTUFBTSxDQUFDUSxLQUFLLEVBQUUsSUFBSSxDQUFDUixNQUFNLENBQUNZLGdCQUFnQjtRQUN6RWxFLElBQUkwSyxXQUFXLENBQUNySSxNQUFNdUgsTUFBTTFJO1FBQzVCLElBQUksQ0FBQ29DLE1BQU0sQ0FBQ1EsS0FBSyxHQUFHOUQsSUFBSW1LLFVBQVUsQ0FBQzlILE1BQU0sSUFBSSxDQUFDaUIsTUFBTSxDQUFDVyx3QkFBd0IsRUFBRSxJQUFJLENBQUNYLE1BQU0sQ0FBQ1ksZ0JBQWdCO1FBQzNHLElBQUksT0FBTzBGLFNBQVMsVUFBVTtZQUM1QkUsUUFBUTVJO1FBQ1Y7UUFFQSxJQUFJLENBQUM0SSxLQUFLLENBQUMsQ0FBQ0E7UUFDWixPQUFPLElBQUk7SUFDYjtJQUNBekksRUFBRXNKLFFBQVEsR0FBRyxTQUFTZixJQUFJLEVBQUUxSSxLQUFLLEVBQUUwSixXQUFXO1FBQzVDLElBQUl2SSxPQUFPckMsSUFBSXdKLFVBQVUsQ0FBQyxJQUFJLENBQUNsRyxNQUFNLENBQUNRLEtBQUssRUFBRSxJQUFJLENBQUNSLE1BQU0sQ0FBQ1ksZ0JBQWdCO1FBQ3pFLE9BQU9sRSxJQUFJMkssUUFBUSxDQUFDdEksTUFBTXVILE1BQU0xSSxPQUFPMEo7SUFDekM7SUFDQXZKLEVBQUVzUCxTQUFTLEdBQUd0UCxFQUFFb0osUUFBUTtJQUN4QnBKLEVBQUV1UCxTQUFTLEdBQUd2UCxFQUFFa0osUUFBUTtJQUN4QmxKLEVBQUV3UCxZQUFZLEdBQUd4UCxFQUFFcUosV0FBVztJQUM5QnJKLEVBQUV5UCxTQUFTLEdBQUd6UCxFQUFFc0osUUFBUTtJQUV4QixrQkFBa0I7SUFDbEJ0SixFQUFFbUssU0FBUyxHQUFHO1FBQ1osSUFBSSxJQUFJLENBQUNsSSxNQUFNLENBQUNLLEdBQUcsRUFBRTtZQUNuQixPQUFPLElBQUksQ0FDUm9OLGlCQUFpQixDQUFDLE9BQ2xCYixhQUFhLENBQUMsT0FDZGMsY0FBYyxDQUFDLE9BQ2ZDLGlCQUFpQixDQUFDLE9BQ2xCbkgsS0FBSztRQUNWO1FBRUEsT0FBTyxJQUFJLENBQ1JpSCxpQkFBaUIsQ0FBQyxPQUNsQkcsaUJBQWlCLENBQUMsT0FDbEJDLGFBQWEsQ0FBQyxPQUNkakIsYUFBYSxDQUFDLE9BQ2RjLGNBQWMsQ0FBQyxPQUNmQyxpQkFBaUIsQ0FBQyxPQUNsQm5ILEtBQUs7SUFDVjtJQUNBekksRUFBRTBQLGlCQUFpQixHQUFHLFNBQVNqSCxLQUFLO1FBQ2xDLElBQUksT0FBTyxJQUFJLENBQUN4RyxNQUFNLENBQUNDLFFBQVEsS0FBSyxVQUFVO1lBQzVDLElBQUksQ0FBQ0QsTUFBTSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDRCxNQUFNLENBQUNDLFFBQVEsQ0FBQ3NDLFdBQVc7WUFDdkQsSUFBSSxDQUFDaUUsS0FBSyxDQUFDLENBQUNBO1FBQ2Q7UUFFQSxPQUFPLElBQUk7SUFDYjtJQUNBekksRUFBRTZQLGlCQUFpQixHQUFHLFNBQVNwSCxLQUFLO1FBQ2xDLElBQUksSUFBSSxDQUFDeEcsTUFBTSxDQUFDSSxRQUFRLEVBQUU7WUFDeEIsSUFBSSxJQUFJLENBQUMwSyxFQUFFLENBQUMsVUFBVW5PLFVBQVU7Z0JBQzlCLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ0ksUUFBUSxHQUFHekQsU0FBU2tOLE9BQU8sQ0FBQyxJQUFJLENBQUM3SixNQUFNLENBQUNJLFFBQVE7WUFDOUQsT0FBTyxJQUFJLElBQUksQ0FBQzBLLEVBQUUsQ0FBQyxXQUFXbE8sTUFBTTtnQkFDbEMsSUFBSSxDQUFDb0QsTUFBTSxDQUFDSSxRQUFRLEdBQUd4RCxLQUFLa1IsSUFBSSxDQUFDLElBQUksQ0FBQzlOLE1BQU0sQ0FBQ0ksUUFBUTtZQUN2RDtZQUVBLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxRQUFRLEdBQUcsSUFBSSxDQUFDSixNQUFNLENBQUNJLFFBQVEsQ0FBQ21DLFdBQVc7WUFDdkQsSUFBSSxDQUFDaUUsS0FBSyxDQUFDLENBQUNBO1FBQ2Q7UUFFQSxPQUFPLElBQUk7SUFDYjtJQUNBekksRUFBRThQLGFBQWEsR0FBRyxTQUFTckgsS0FBSztRQUM5Qiw2Q0FBNkM7UUFDN0MsSUFBSSxPQUFPLElBQUksQ0FBQ3hHLE1BQU0sQ0FBQ0MsUUFBUSxLQUFLLFlBQVksSUFBSSxDQUFDRCxNQUFNLENBQUNNLElBQUksS0FBSzVELElBQUlnRixZQUFZLENBQUMsSUFBSSxDQUFDMUIsTUFBTSxDQUFDQyxRQUFRLENBQUMsRUFBRTtZQUMzRyxJQUFJLENBQUNELE1BQU0sQ0FBQ00sSUFBSSxHQUFHO1lBQ25CLElBQUksQ0FBQ2tHLEtBQUssQ0FBQyxDQUFDQTtRQUNkO1FBRUEsT0FBTyxJQUFJO0lBQ2I7SUFDQXpJLEVBQUU2TyxhQUFhLEdBQUcsU0FBU3BHLEtBQUs7UUFDOUIsSUFBSXVILFFBQVEsSUFBSSxDQUFDL04sTUFBTSxDQUFDTyxJQUFJO1FBQzVCLElBQUksQ0FBQ3dOLE9BQU87WUFDVixPQUFPLElBQUk7UUFDYjtRQUVBLElBQUksSUFBSSxDQUFDL04sTUFBTSxDQUFDSyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxDQUFDTCxNQUFNLENBQUNPLElBQUksR0FBRzdELElBQUlrSSxhQUFhLENBQUMsSUFBSSxDQUFDNUUsTUFBTSxDQUFDTyxJQUFJO1lBQ3JELElBQUksQ0FBQ2lHLEtBQUssQ0FBQyxDQUFDQTtZQUNaLE9BQU8sSUFBSTtRQUNiO1FBRUEsSUFBSSxJQUFJLENBQUN4RyxNQUFNLENBQUNPLElBQUksS0FBSyxLQUFLO1lBQzVCLE9BQU8sSUFBSTtRQUNiO1FBRUF3TixRQUFRclIsSUFBSWlJLFVBQVUsQ0FBQ29KO1FBRXZCLElBQUlDO1FBQ0osSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUlDLFNBQVNDO1FBRWIsd0JBQXdCO1FBQ3hCLElBQUlKLE1BQU14SSxNQUFNLENBQUMsT0FBTyxLQUFLO1lBQzNCeUksZ0JBQWdCO1lBQ2hCRCxRQUFRLE1BQU1BO1FBQ2hCO1FBRUEsb0RBQW9EO1FBQ3BELElBQUlBLE1BQU1wUCxLQUFLLENBQUMsQ0FBQyxPQUFPLFNBQVNvUCxNQUFNcFAsS0FBSyxDQUFDLENBQUMsT0FBTyxNQUFNO1lBQ3pEb1AsU0FBUztRQUNYO1FBRUEsa0JBQWtCO1FBQ2xCQSxRQUFRQSxNQUNMelAsT0FBTyxDQUFDLHdCQUF3QixLQUNoQ0EsT0FBTyxDQUFDLFdBQVc7UUFFdEIsMkJBQTJCO1FBQzNCLElBQUkwUCxlQUFlO1lBQ2pCQyxrQkFBa0JGLE1BQU03SSxTQUFTLENBQUMsR0FBRzNGLEtBQUssQ0FBQyxpQkFBaUI7WUFDNUQsSUFBSTBPLGlCQUFpQjtnQkFDbkJBLGtCQUFrQkEsZUFBZSxDQUFDLEVBQUU7WUFDdEM7UUFDRjtRQUVBLGtCQUFrQjtRQUNsQixNQUFPLEtBQU07WUFDWEMsVUFBVUgsTUFBTTNFLE1BQU0sQ0FBQztZQUN2QixJQUFJOEUsWUFBWSxDQUFDLEdBQUc7Z0JBRWxCO1lBQ0YsT0FBTyxJQUFJQSxZQUFZLEdBQUc7Z0JBQ3hCLHdDQUF3QztnQkFDeENILFFBQVFBLE1BQU03SSxTQUFTLENBQUM7Z0JBQ3hCO1lBQ0Y7WUFFQWlKLE9BQU9KLE1BQU03SSxTQUFTLENBQUMsR0FBR2dKLFNBQVNsSSxXQUFXLENBQUM7WUFDL0MsSUFBSW1JLFNBQVMsQ0FBQyxHQUFHO2dCQUNmQSxPQUFPRDtZQUNUO1lBQ0FILFFBQVFBLE1BQU03SSxTQUFTLENBQUMsR0FBR2lKLFFBQVFKLE1BQU03SSxTQUFTLENBQUNnSixVQUFVO1FBQy9EO1FBRUEscUJBQXFCO1FBQ3JCLElBQUlGLGlCQUFpQixJQUFJLENBQUNsRCxFQUFFLENBQUMsYUFBYTtZQUN4Q2lELFFBQVFFLGtCQUFrQkYsTUFBTTdJLFNBQVMsQ0FBQztRQUM1QztRQUVBLElBQUksQ0FBQ2xGLE1BQU0sQ0FBQ08sSUFBSSxHQUFHd047UUFDbkIsSUFBSSxDQUFDdkgsS0FBSyxDQUFDLENBQUNBO1FBQ1osT0FBTyxJQUFJO0lBQ2I7SUFDQXpJLEVBQUVxUSxpQkFBaUIsR0FBR3JRLEVBQUU2TyxhQUFhO0lBQ3JDN08sRUFBRTJQLGNBQWMsR0FBRyxTQUFTbEgsS0FBSztRQUMvQixJQUFJLE9BQU8sSUFBSSxDQUFDeEcsTUFBTSxDQUFDUSxLQUFLLEtBQUssVUFBVTtZQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDUixNQUFNLENBQUNRLEtBQUssQ0FBQ3BELE1BQU0sRUFBRTtnQkFDN0IsSUFBSSxDQUFDNEMsTUFBTSxDQUFDUSxLQUFLLEdBQUc7WUFDdEIsT0FBTztnQkFDTCxJQUFJLENBQUNBLEtBQUssQ0FBQzlELElBQUl3SixVQUFVLENBQUMsSUFBSSxDQUFDbEcsTUFBTSxDQUFDUSxLQUFLLEVBQUUsSUFBSSxDQUFDUixNQUFNLENBQUNZLGdCQUFnQjtZQUMzRTtZQUVBLElBQUksQ0FBQzRGLEtBQUssQ0FBQyxDQUFDQTtRQUNkO1FBRUEsT0FBTyxJQUFJO0lBQ2I7SUFDQXpJLEVBQUU0UCxpQkFBaUIsR0FBRyxTQUFTbkgsS0FBSztRQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDeEcsTUFBTSxDQUFDUyxRQUFRLEVBQUU7WUFDekIsSUFBSSxDQUFDVCxNQUFNLENBQUNTLFFBQVEsR0FBRztZQUN2QixJQUFJLENBQUMrRixLQUFLLENBQUMsQ0FBQ0E7UUFDZDtRQUVBLE9BQU8sSUFBSTtJQUNiO0lBQ0F6SSxFQUFFc1EsZUFBZSxHQUFHdFEsRUFBRTJQLGNBQWM7SUFDcEMzUCxFQUFFdVEsYUFBYSxHQUFHdlEsRUFBRTRQLGlCQUFpQjtJQUVyQzVQLEVBQUVpRixPQUFPLEdBQUc7UUFDVix1Q0FBdUM7UUFDdkMsSUFBSVksSUFBSWxILElBQUltRyxNQUFNO1FBQ2xCLElBQUkwTCxJQUFJN1IsSUFBSW9HLE1BQU07UUFFbEJwRyxJQUFJbUcsTUFBTSxHQUFHSDtRQUNiaEcsSUFBSW9HLE1BQU0sR0FBR0M7UUFDYixJQUFJO1lBQ0YsSUFBSSxDQUFDbUYsU0FBUztRQUNoQixTQUFVO1lBQ1J4TCxJQUFJbUcsTUFBTSxHQUFHZTtZQUNibEgsSUFBSW9HLE1BQU0sR0FBR3lMO1FBQ2Y7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUVBeFEsRUFBRW1GLE9BQU8sR0FBRztRQUNWLHVDQUF1QztRQUN2QyxJQUFJVSxJQUFJbEgsSUFBSW1HLE1BQU07UUFDbEIsSUFBSTBMLElBQUk3UixJQUFJb0csTUFBTTtRQUVsQnBHLElBQUltRyxNQUFNLEdBQUdGO1FBQ2JqRyxJQUFJb0csTUFBTSxHQUFHRztRQUNiLElBQUk7WUFDRixJQUFJLENBQUNpRixTQUFTO1FBQ2hCLFNBQVU7WUFDUnhMLElBQUltRyxNQUFNLEdBQUdlO1lBQ2JsSCxJQUFJb0csTUFBTSxHQUFHeUw7UUFDZjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBRUF4USxFQUFFeVEsUUFBUSxHQUFHO1FBQ1gsSUFBSXZHLE1BQU0sSUFBSSxDQUFDb0MsS0FBSztRQUNwQix5RkFBeUY7UUFDekZwQyxJQUFJL0gsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxJQUFJK0gsU0FBUztRQUN2QyxJQUFJNUMsSUFBSTtRQUNSLElBQUkyQyxJQUFJakksTUFBTSxDQUFDQyxRQUFRLEVBQUU7WUFDdkJxRixLQUFLMkMsSUFBSWpJLE1BQU0sQ0FBQ0MsUUFBUSxHQUFHO1FBQzdCO1FBRUEsSUFBSWdJLElBQUlqSSxNQUFNLENBQUNJLFFBQVEsRUFBRTtZQUN2QixJQUFJNkgsSUFBSTZDLEVBQUUsQ0FBQyxlQUFlbk8sVUFBVTtnQkFDbEMySSxLQUFLM0ksU0FBUzhSLFNBQVMsQ0FBQ3hHLElBQUlqSSxNQUFNLENBQUNJLFFBQVE7Z0JBQzNDLElBQUk2SCxJQUFJakksTUFBTSxDQUFDTSxJQUFJLEVBQUU7b0JBQ25CZ0YsS0FBSyxNQUFNMkMsSUFBSWpJLE1BQU0sQ0FBQ00sSUFBSTtnQkFDNUI7WUFDRixPQUFPO2dCQUNMZ0YsS0FBSzJDLElBQUk2RCxJQUFJO1lBQ2Y7UUFDRjtRQUVBLElBQUk3RCxJQUFJakksTUFBTSxDQUFDSSxRQUFRLElBQUk2SCxJQUFJakksTUFBTSxDQUFDTyxJQUFJLElBQUkwSCxJQUFJakksTUFBTSxDQUFDTyxJQUFJLENBQUNnRixNQUFNLENBQUMsT0FBTyxLQUFLO1lBQy9FRCxLQUFLO1FBQ1A7UUFFQUEsS0FBSzJDLElBQUkxSCxJQUFJLENBQUM7UUFDZCxJQUFJMEgsSUFBSWpJLE1BQU0sQ0FBQ1EsS0FBSyxFQUFFO1lBQ3BCLElBQUk0TSxJQUFJO1lBQ1IsSUFBSyxJQUFJbk8sSUFBSSxHQUFHeVAsS0FBS3pHLElBQUlqSSxNQUFNLENBQUNRLEtBQUssQ0FBQytELEtBQUssQ0FBQyxNQUFNM0UsSUFBSThPLEdBQUd0UixNQUFNLEVBQUU2QixJQUFJVyxHQUFHWCxJQUFLO2dCQUMzRSxJQUFJMFAsS0FBSyxDQUFDRCxFQUFFLENBQUN6UCxFQUFFLElBQUksRUFBQyxFQUFHc0YsS0FBSyxDQUFDO2dCQUM3QjZJLEtBQUssTUFBTTFRLElBQUlpSCxXQUFXLENBQUNnTCxFQUFFLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQzNPLE1BQU0sQ0FBQ1ksZ0JBQWdCLEVBQzNEdEMsT0FBTyxDQUFDLE1BQU07Z0JBRWpCLElBQUlxUSxFQUFFLENBQUMsRUFBRSxLQUFLclIsV0FBVztvQkFDdkI4UCxLQUFLLE1BQU0xUSxJQUFJaUgsV0FBVyxDQUFDZ0wsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMzTyxNQUFNLENBQUNZLGdCQUFnQixFQUMzRHRDLE9BQU8sQ0FBQyxNQUFNO2dCQUNuQjtZQUNGO1lBQ0FnSCxLQUFLLE1BQU04SCxFQUFFbEksU0FBUyxDQUFDO1FBQ3pCO1FBRUFJLEtBQUs1SSxJQUFJaUgsV0FBVyxDQUFDc0UsSUFBSXdDLElBQUksSUFBSTtRQUNqQyxPQUFPbkY7SUFDVDtJQUVBLHVDQUF1QztJQUN2Q3ZILEVBQUVMLFVBQVUsR0FBRyxTQUFTVCxJQUFJO1FBQzFCLElBQUkyUixXQUFXLElBQUksQ0FBQ3ZFLEtBQUs7UUFDekIsSUFBSXdFLGFBQWE7WUFBQztZQUFZO1lBQVk7WUFBWTtZQUFZO1NBQU87UUFDekUsSUFBSUMsU0FBUzdQLEdBQUdsQjtRQUVoQixJQUFJLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ25CLE1BQU0sSUFBSTJNLE1BQU07UUFDbEI7UUFFQSxJQUFJLENBQUUvUCxDQUFBQSxnQkFBZ0JQLEdBQUUsR0FBSTtZQUMxQk8sT0FBTyxJQUFJUCxJQUFJTztRQUNqQjtRQUVBLElBQUkyUixTQUFTNU8sTUFBTSxDQUFDQyxRQUFRLEVBQUU7WUFDNUIsMERBQTBEO1lBQzFELE9BQU8yTztRQUNULE9BQU87WUFDTEEsU0FBUzVPLE1BQU0sQ0FBQ0MsUUFBUSxHQUFHaEQsS0FBSytDLE1BQU0sQ0FBQ0MsUUFBUTtRQUNqRDtRQUVBLElBQUksSUFBSSxDQUFDRCxNQUFNLENBQUNJLFFBQVEsRUFBRTtZQUN4QixPQUFPd087UUFDVDtRQUVBLElBQUszUCxJQUFJLEdBQUlsQixJQUFJOFEsVUFBVSxDQUFDNVAsRUFBRSxFQUFHQSxJQUFLO1lBQ3BDMlAsU0FBUzVPLE1BQU0sQ0FBQ2pDLEVBQUUsR0FBR2QsS0FBSytDLE1BQU0sQ0FBQ2pDLEVBQUU7UUFDckM7UUFFQSxJQUFJLENBQUM2USxTQUFTNU8sTUFBTSxDQUFDTyxJQUFJLEVBQUU7WUFDekJxTyxTQUFTNU8sTUFBTSxDQUFDTyxJQUFJLEdBQUd0RCxLQUFLK0MsTUFBTSxDQUFDTyxJQUFJO1lBQ3ZDLElBQUksQ0FBQ3FPLFNBQVM1TyxNQUFNLENBQUNRLEtBQUssRUFBRTtnQkFDMUJvTyxTQUFTNU8sTUFBTSxDQUFDUSxLQUFLLEdBQUd2RCxLQUFLK0MsTUFBTSxDQUFDUSxLQUFLO1lBQzNDO1FBQ0YsT0FBTztZQUNMLElBQUlvTyxTQUFTNU8sTUFBTSxDQUFDTyxJQUFJLENBQUMyRSxTQUFTLENBQUMsQ0FBQyxPQUFPLE1BQU07Z0JBQy9DMEosU0FBUzVPLE1BQU0sQ0FBQ08sSUFBSSxJQUFJO1lBQzFCO1lBRUEsSUFBSXFPLFNBQVNyTyxJQUFJLEdBQUdnRixNQUFNLENBQUMsT0FBTyxLQUFLO2dCQUNyQ3VKLFVBQVU3UixLQUFLdVAsU0FBUztnQkFDeEJzQyxVQUFVQSxVQUFVQSxVQUFVN1IsS0FBS3NELElBQUksR0FBRzBFLE9BQU8sQ0FBQyxTQUFTLElBQUksTUFBTTtnQkFDckUySixTQUFTNU8sTUFBTSxDQUFDTyxJQUFJLEdBQUcsQ0FBQ3VPLFVBQVdBLFVBQVUsTUFBTyxFQUFDLElBQUtGLFNBQVM1TyxNQUFNLENBQUNPLElBQUk7Z0JBQzlFcU8sU0FBU2hDLGFBQWE7WUFDeEI7UUFDRjtRQUVBZ0MsU0FBU3BJLEtBQUs7UUFDZCxPQUFPb0k7SUFDVDtJQUNBN1EsRUFBRWdSLFVBQVUsR0FBRyxTQUFTOVIsSUFBSTtRQUMxQixJQUFJb08sV0FBVyxJQUFJLENBQUNoQixLQUFLLEdBQUduQyxTQUFTO1FBQ3JDLElBQUk4RyxlQUFlQyxXQUFXQyxRQUFRQyxjQUFjQztRQUVwRCxJQUFJL0QsU0FBU3JMLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSTJNLE1BQU07UUFDbEI7UUFFQS9QLE9BQU8sSUFBSVAsSUFBSU8sTUFBTWlMLFNBQVM7UUFDOUI4RyxnQkFBZ0IzRCxTQUFTckwsTUFBTTtRQUMvQmlQLFlBQVloUyxLQUFLK0MsTUFBTTtRQUN2Qm1QLGVBQWU5RCxTQUFTOUssSUFBSTtRQUM1QjZPLFdBQVduUyxLQUFLc0QsSUFBSTtRQUVwQixJQUFJNE8sYUFBYTVKLE1BQU0sQ0FBQyxPQUFPLEtBQUs7WUFDbEMsTUFBTSxJQUFJeUgsTUFBTTtRQUNsQjtRQUVBLElBQUlvQyxTQUFTN0osTUFBTSxDQUFDLE9BQU8sS0FBSztZQUM5QixNQUFNLElBQUl5SCxNQUFNO1FBQ2xCO1FBRUEsSUFBSWdDLGNBQWMvTyxRQUFRLEtBQUtnUCxVQUFVaFAsUUFBUSxFQUFFO1lBQ2pEK08sY0FBYy9PLFFBQVEsR0FBRztRQUMzQjtRQUVBLElBQUkrTyxjQUFjOU8sUUFBUSxLQUFLK08sVUFBVS9PLFFBQVEsSUFBSThPLGNBQWM3TyxRQUFRLEtBQUs4TyxVQUFVOU8sUUFBUSxFQUFFO1lBQ2xHLE9BQU9rTCxTQUFTN0UsS0FBSztRQUN2QjtRQUVBLElBQUl3SSxjQUFjL08sUUFBUSxLQUFLLFFBQVErTyxjQUFjOU8sUUFBUSxLQUFLLFFBQVE4TyxjQUFjN08sUUFBUSxLQUFLLE1BQU07WUFDekcsT0FBT2tMLFNBQVM3RSxLQUFLO1FBQ3ZCO1FBRUEsSUFBSXdJLGNBQWM1TyxRQUFRLEtBQUs2TyxVQUFVN08sUUFBUSxJQUFJNE8sY0FBYzFPLElBQUksS0FBSzJPLFVBQVUzTyxJQUFJLEVBQUU7WUFDMUYwTyxjQUFjNU8sUUFBUSxHQUFHO1lBQ3pCNE8sY0FBYzFPLElBQUksR0FBRztRQUN2QixPQUFPO1lBQ0wsT0FBTytLLFNBQVM3RSxLQUFLO1FBQ3ZCO1FBRUEsSUFBSTJJLGlCQUFpQkMsVUFBVTtZQUM3QkosY0FBY3pPLElBQUksR0FBRztZQUNyQixPQUFPOEssU0FBUzdFLEtBQUs7UUFDdkI7UUFFQSw0QkFBNEI7UUFDNUIwSSxTQUFTeFMsSUFBSXlMLFVBQVUsQ0FBQ2dILGNBQWNDO1FBRXRDLHFGQUFxRjtRQUNyRixJQUFJLENBQUNGLFFBQVE7WUFDWCxPQUFPN0QsU0FBUzdFLEtBQUs7UUFDdkI7UUFFQSxJQUFJNkksVUFBVUosVUFBVTFPLElBQUksQ0FDekIyRSxTQUFTLENBQUNnSyxPQUFPOVIsTUFBTSxFQUN2QmtCLE9BQU8sQ0FBQyxXQUFXLElBQ25CQSxPQUFPLENBQUMsVUFBVTtRQUVyQjBRLGNBQWN6TyxJQUFJLEdBQUcsVUFBV3lPLGNBQWN6TyxJQUFJLENBQUMyRSxTQUFTLENBQUNnSyxPQUFPOVIsTUFBTSxLQUFNO1FBRWhGLE9BQU9pTyxTQUFTN0UsS0FBSztJQUN2QjtJQUVBLGlCQUFpQjtJQUNqQnpJLEVBQUV1UixNQUFNLEdBQUcsU0FBU3JILEdBQUc7UUFDckIsSUFBSXhJLE1BQU0sSUFBSSxDQUFDNEssS0FBSztRQUNwQixJQUFJM0ssTUFBTSxJQUFJaEQsSUFBSXVMO1FBQ2xCLElBQUlzSCxVQUFVLENBQUM7UUFDZixJQUFJQyxVQUFVLENBQUM7UUFDZixJQUFJQyxVQUFVLENBQUM7UUFDZixJQUFJQyxXQUFXQyxXQUFXNUk7UUFFMUJ0SCxJQUFJeUksU0FBUztRQUNieEksSUFBSXdJLFNBQVM7UUFFYixjQUFjO1FBQ2QsSUFBSXpJLElBQUloQixRQUFRLE9BQU9pQixJQUFJakIsUUFBUSxJQUFJO1lBQ3JDLE9BQU87UUFDVDtRQUVBLHVCQUF1QjtRQUN2QmlSLFlBQVlqUSxJQUFJZSxLQUFLO1FBQ3JCbVAsWUFBWWpRLElBQUljLEtBQUs7UUFDckJmLElBQUllLEtBQUssQ0FBQztRQUNWZCxJQUFJYyxLQUFLLENBQUM7UUFFVix5REFBeUQ7UUFDekQsSUFBSWYsSUFBSWhCLFFBQVEsT0FBT2lCLElBQUlqQixRQUFRLElBQUk7WUFDckMsT0FBTztRQUNUO1FBRUEsa0VBQWtFO1FBQ2xFLElBQUlpUixVQUFVdFMsTUFBTSxLQUFLdVMsVUFBVXZTLE1BQU0sRUFBRTtZQUN6QyxPQUFPO1FBQ1Q7UUFFQW1TLFVBQVU3UyxJQUFJd0osVUFBVSxDQUFDd0osV0FBVyxJQUFJLENBQUMxUCxNQUFNLENBQUNZLGdCQUFnQjtRQUNoRTRPLFVBQVU5UyxJQUFJd0osVUFBVSxDQUFDeUosV0FBVyxJQUFJLENBQUMzUCxNQUFNLENBQUNZLGdCQUFnQjtRQUVoRSxJQUFLbUcsT0FBT3dJLFFBQVM7WUFDbkIsSUFBSXRSLE9BQU9TLElBQUksQ0FBQzZRLFNBQVN4SSxNQUFNO2dCQUM3QixJQUFJLENBQUNuSSxRQUFRMlEsT0FBTyxDQUFDeEksSUFBSSxHQUFHO29CQUMxQixJQUFJd0ksT0FBTyxDQUFDeEksSUFBSSxLQUFLeUksT0FBTyxDQUFDekksSUFBSSxFQUFFO3dCQUNqQyxPQUFPO29CQUNUO2dCQUNGLE9BQU8sSUFBSSxDQUFDdkgsWUFBWStQLE9BQU8sQ0FBQ3hJLElBQUksRUFBRXlJLE9BQU8sQ0FBQ3pJLElBQUksR0FBRztvQkFDbkQsT0FBTztnQkFDVDtnQkFFQTBJLE9BQU8sQ0FBQzFJLElBQUksR0FBRztZQUNqQjtRQUNGO1FBRUEsSUFBS0EsT0FBT3lJLFFBQVM7WUFDbkIsSUFBSXZSLE9BQU9TLElBQUksQ0FBQzhRLFNBQVN6SSxNQUFNO2dCQUM3QixJQUFJLENBQUMwSSxPQUFPLENBQUMxSSxJQUFJLEVBQUU7b0JBQ2pCLDhDQUE4QztvQkFDOUMsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxRQUFRO0lBQ1JoSixFQUFFMkMsc0JBQXNCLEdBQUcsU0FBUzJGLENBQUM7UUFDbkMsSUFBSSxDQUFDckcsTUFBTSxDQUFDVSxzQkFBc0IsR0FBRyxDQUFDLENBQUMyRjtRQUN2QyxPQUFPLElBQUk7SUFDYjtJQUVBdEksRUFBRTRDLHdCQUF3QixHQUFHLFNBQVMwRixDQUFDO1FBQ3JDLElBQUksQ0FBQ3JHLE1BQU0sQ0FBQ1csd0JBQXdCLEdBQUcsQ0FBQyxDQUFDMEY7UUFDekMsT0FBTyxJQUFJO0lBQ2I7SUFFQXRJLEVBQUU2QyxnQkFBZ0IsR0FBRyxTQUFTeUYsQ0FBQztRQUM3QixJQUFJLENBQUNyRyxNQUFNLENBQUNZLGdCQUFnQixHQUFHLENBQUMsQ0FBQ3lGO1FBQ2pDLE9BQU8sSUFBSTtJQUNiO0lBRUEsT0FBTzNKO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy91cmlqcy9zcmMvVVJJLmpzPzY1ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBVUkkuanMgLSBNdXRhdGluZyBVUkxzXG4gKlxuICogVmVyc2lvbjogMS4xOS4xMVxuICpcbiAqIEF1dGhvcjogUm9kbmV5IFJlaG1cbiAqIFdlYjogaHR0cDovL21lZGlhbGl6ZS5naXRodWIuaW8vVVJJLmpzL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyXG4gKiAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqXG4gKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJy4vcHVueWNvZGUnKSwgcmVxdWlyZSgnLi9JUHY2JyksIHJlcXVpcmUoJy4vU2Vjb25kTGV2ZWxEb21haW5zJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoWycuL3B1bnljb2RlJywgJy4vSVB2NicsICcuL1NlY29uZExldmVsRG9tYWlucyddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgIHJvb3QuVVJJID0gZmFjdG9yeShyb290LnB1bnljb2RlLCByb290LklQdjYsIHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zLCByb290KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAocHVueWNvZGUsIElQdjYsIFNMRCwgcm9vdCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qZ2xvYmFsIGxvY2F0aW9uLCBlc2NhcGUsIHVuZXNjYXBlICovXG4gIC8vIEZJWE1FOiB2Mi4wLjAgcmVuYW1jZSBub24tY2FtZWxDYXNlIHByb3BlcnRpZXMgdG8gdXBwZXJjYXNlXG4gIC8qanNoaW50IGNhbWVsY2FzZTogZmFsc2UgKi9cblxuICAvLyBzYXZlIGN1cnJlbnQgVVJJIHZhcmlhYmxlLCBpZiBhbnlcbiAgdmFyIF9VUkkgPSByb290ICYmIHJvb3QuVVJJO1xuXG4gIGZ1bmN0aW9uIFVSSSh1cmwsIGJhc2UpIHtcbiAgICB2YXIgX3VybFN1cHBsaWVkID0gYXJndW1lbnRzLmxlbmd0aCA+PSAxO1xuICAgIHZhciBfYmFzZVN1cHBsaWVkID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyO1xuXG4gICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICAgIGlmIChfdXJsU3VwcGxpZWQpIHtcbiAgICAgICAgaWYgKF9iYXNlU3VwcGxpZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVSSSh1cmwsIGJhc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBVUkkodXJsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBVUkkoKTtcbiAgICB9XG5cbiAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChfdXJsU3VwcGxpZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIGFyZ3VtZW50IGZvciBVUkknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdXJsID0gbG9jYXRpb24uaHJlZiArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgaWYgKF91cmxTdXBwbGllZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdudWxsIGlzIG5vdCBhIHZhbGlkIGFyZ3VtZW50IGZvciBVUkknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmhyZWYodXJsKTtcblxuICAgIC8vIHJlc29sdmUgdG8gYmFzZSBhY2NvcmRpbmcgdG8gaHR0cDovL2R2Y3MudzMub3JnL2hnL3VybC9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbCNjb25zdHJ1Y3RvclxuICAgIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlVG8oYmFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gL15bMC05XSskLy50ZXN0KHZhbHVlKTtcbiAgfVxuXG4gIFVSSS52ZXJzaW9uID0gJzEuMTkuMTEnO1xuXG4gIHZhciBwID0gVVJJLnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXgoc3RyaW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvY29tbWl0Lzg1YWMyMTc4M2MxMWY4Y2NhYjA2MTA2ZGJhOTczNWEzMWE4NjkyNGQjY29tbWl0Y29tbWVudC04MjE5NjNcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyhbLiorP149IToke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICAvLyBJRTggZG9lc24ndCByZXR1cm4gW09iamVjdCBVbmRlZmluZWRdIGJ1dCBbT2JqZWN0IE9iamVjdF0gZm9yIHVuZGVmaW5lZCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJ1VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpKS5zbGljZSg4LCAtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBnZXRUeXBlKG9iaikgPT09ICdBcnJheSc7XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJBcnJheVZhbHVlcyhkYXRhLCB2YWx1ZSkge1xuICAgIHZhciBsb29rdXAgPSB7fTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnUmVnRXhwJykge1xuICAgICAgbG9va3VwID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsb29rdXBbdmFsdWVbaV1dID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9va3VwW3ZhbHVlXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgLypqc2hpbnQgbGF4YnJlYWs6IHRydWUgKi9cbiAgICAgIHZhciBfbWF0Y2ggPSBsb29rdXAgJiYgbG9va3VwW2RhdGFbaV1dICE9PSB1bmRlZmluZWRcbiAgICAgICAgfHwgIWxvb2t1cCAmJiB2YWx1ZS50ZXN0KGRhdGFbaV0pO1xuICAgICAgLypqc2hpbnQgbGF4YnJlYWs6IGZhbHNlICovXG4gICAgICBpZiAoX21hdGNoKSB7XG4gICAgICAgIGRhdGEuc3BsaWNlKGksIDEpO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250YWlucyhsaXN0LCB2YWx1ZSkge1xuICAgIHZhciBpLCBsZW5ndGg7XG5cbiAgICAvLyB2YWx1ZSBtYXkgYmUgc3RyaW5nLCBudW1iZXIsIGFycmF5LCByZWdleHBcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIE5vdGU6IHRoaXMgY2FuIGJlIG9wdGltaXplZCB0byBPKG4pIChpbnN0ZWFkIG9mIGN1cnJlbnQgTyhtICogbikpXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWFycmF5Q29udGFpbnMobGlzdCwgdmFsdWVbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBfdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfdHlwZSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0W2ldID09PSAnc3RyaW5nJyAmJiBsaXN0W2ldLm1hdGNoKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxpc3RbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5c0VxdWFsKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFpc0FycmF5KG9uZSkgfHwgIWlzQXJyYXkodHdvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFycmF5cyBjYW4ndCBiZSBlcXVhbCBpZiB0aGV5IGhhdmUgZGlmZmVyZW50IGFtb3VudCBvZiBjb250ZW50XG4gICAgaWYgKG9uZS5sZW5ndGggIT09IHR3by5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvbmUuc29ydCgpO1xuICAgIHR3by5zb3J0KCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9uZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChvbmVbaV0gIT09IHR3b1tpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB0cmltU2xhc2hlcyh0ZXh0KSB7XG4gICAgdmFyIHRyaW1fZXhwcmVzc2lvbiA9IC9eXFwvK3xcXC8rJC9nO1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UodHJpbV9leHByZXNzaW9uLCAnJyk7XG4gIH1cblxuICBVUkkuX3BhcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvY29sOiBudWxsLFxuICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgIGhvc3RuYW1lOiBudWxsLFxuICAgICAgdXJuOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBxdWVyeTogbnVsbCxcbiAgICAgIGZyYWdtZW50OiBudWxsLFxuICAgICAgLy8gc3RhdGVcbiAgICAgIHByZXZlbnRJbnZhbGlkSG9zdG5hbWU6IFVSSS5wcmV2ZW50SW52YWxpZEhvc3RuYW1lLFxuICAgICAgZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzOiBVUkkuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgZXNjYXBlUXVlcnlTcGFjZTogVVJJLmVzY2FwZVF1ZXJ5U3BhY2VcbiAgICB9O1xuICB9O1xuICAvLyBzdGF0ZTogdGhyb3cgb24gaW52YWxpZCBob3N0bmFtZVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvcHVsbC8zNDVcbiAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvVVJJLmpzL2lzc3Vlcy8zNTRcbiAgVVJJLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUgPSBmYWxzZTtcbiAgLy8gc3RhdGU6IGFsbG93IGR1cGxpY2F0ZSBxdWVyeSBwYXJhbWV0ZXJzIChhPTEmYT0xKVxuICBVUkkuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzID0gZmFsc2U7XG4gIC8vIHN0YXRlOiByZXBsYWNlcyArIHdpdGggJTIwIChzcGFjZSBpbiBxdWVyeSBzdHJpbmdzKVxuICBVUkkuZXNjYXBlUXVlcnlTcGFjZSA9IHRydWU7XG4gIC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG4gIFVSSS5wcm90b2NvbF9leHByZXNzaW9uID0gL15bYS16XVthLXowLTkuKy1dKiQvaTtcbiAgVVJJLmlkbl9leHByZXNzaW9uID0gL1teYS16MC05XFwuXy1dL2k7XG4gIFVSSS5wdW55Y29kZV9leHByZXNzaW9uID0gLyh4bi0tKS9pO1xuICAvLyB3ZWxsLCAzMzMuNDQ0LjU1NS42NjYgbWF0Y2hlcywgYnV0IGl0IHN1cmUgYWluJ3Qgbm8gSVB2NCAtIGRvIHdlIGNhcmU/XG4gIFVSSS5pcDRfZXhwcmVzc2lvbiA9IC9eXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM30kLztcbiAgLy8gY3JlZGl0cyB0byBSaWNoIEJyb3duXG4gIC8vIHNvdXJjZTogaHR0cDovL2ZvcnVtcy5pbnRlcm1hcHBlci5jb20vdmlld3RvcGljLnBocD9wPTEwOTYjMTA5NlxuICAvLyBzcGVjaWZpY2F0aW9uOiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmM0MjkxLnR4dFxuICBVUkkuaXA2X2V4cHJlc3Npb24gPSAvXlxccyooKChbMC05QS1GYS1mXXsxLDR9Oil7N30oWzAtOUEtRmEtZl17MSw0fXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7Nn0oOlswLTlBLUZhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs1fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs0fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05QS1GYS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7M30oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXsyfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezF9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNn0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoJS4rKT9cXHMqJC87XG4gIC8vIGV4cHJlc3Npb24gdXNlZCBpcyBcImdydWJlciByZXZpc2VkXCIgKEBncnViZXIgdjIpIGRldGVybWluZWQgdG8gYmUgdGhlXG4gIC8vIGJlc3Qgc29sdXRpb24gaW4gYSByZWdleC1nb2xmIHdlIGRpZCBhIGNvdXBsZSBvZiBhZ2VzIGFnbyBhdFxuICAvLyAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gIC8vICogaHR0cDovL3JvZG5leXJlaG0uZGUvdC91cmwtcmVnZXguaHRtbFxuICBVUkkuZmluZF91cmlfZXhwcmVzc2lvbiA9IC9cXGIoKD86W2Etel1bXFx3LV0rOig/OlxcL3sxLDN9fFthLXowLTklXSl8d3d3XFxkezAsM31bLl18W2EtejAtOS5cXC1dK1suXVthLXpdezIsNH1cXC8pKD86W15cXHMoKTw+XSt8XFwoKFteXFxzKCk8Pl0rfChcXChbXlxccygpPD5dK1xcKSkpKlxcKSkrKD86XFwoKFteXFxzKCk8Pl0rfChcXChbXlxccygpPD5dK1xcKSkpKlxcKXxbXlxcc2AhKClcXFtcXF17fTs6J1wiLiw8Pj/Cq8K74oCc4oCd4oCY4oCZXSkpL2lnO1xuICBVUkkuZmluZFVyaSA9IHtcbiAgICAvLyB2YWxpZCBcInNjaGVtZTovL1wiIG9yIFwid3d3LlwiXG4gICAgc3RhcnQ6IC9cXGIoPzooW2Etel1bYS16MC05ListXSo6XFwvXFwvKXx3d3dcXC4pL2dpLFxuICAgIC8vIGV2ZXJ5dGhpbmcgdXAgdG8gdGhlIG5leHQgd2hpdGVzcGFjZVxuICAgIGVuZDogL1tcXHNcXHJcXG5dfCQvLFxuICAgIC8vIHRyaW0gdHJhaWxpbmcgcHVuY3R1YXRpb24gY2FwdHVyZWQgYnkgZW5kIFJlZ0V4cFxuICAgIHRyaW06IC9bYCEoKVxcW1xcXXt9OzonXCIuLDw+P8KrwrvigJzigJ3igJ7igJjigJldKyQvLFxuICAgIC8vIGJhbGFuY2VkIHBhcmVucyBpbmNsdXNpb24gKCksIFtdLCB7fSwgPD5cbiAgICBwYXJlbnM6IC8oXFwoW15cXCldKlxcKXxcXFtbXlxcXV0qXFxdfFxce1tefV0qXFx9fDxbXj5dKj4pL2csXG4gIH07XG4gIFVSSS5sZWFkaW5nX3doaXRlc3BhY2VfZXhwcmVzc2lvbiA9IC9eW1xceDAwLVxceDIwXFx1MDBhMFxcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdKy9cbiAgLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4gIFVSSS5hc2NpaV90YWJfd2hpdGVzcGFjZSA9IC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBEXSsvZ1xuICAvLyBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL3VyaS1zY2hlbWVzLmh0bWxcbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX1RDUF9hbmRfVURQX3BvcnRfbnVtYmVycyNXZWxsLWtub3duX3BvcnRzXG4gIFVSSS5kZWZhdWx0UG9ydHMgPSB7XG4gICAgaHR0cDogJzgwJyxcbiAgICBodHRwczogJzQ0MycsXG4gICAgZnRwOiAnMjEnLFxuICAgIGdvcGhlcjogJzcwJyxcbiAgICB3czogJzgwJyxcbiAgICB3c3M6ICc0NDMnXG4gIH07XG4gIC8vIGxpc3Qgb2YgcHJvdG9jb2xzIHdoaWNoIGFsd2F5cyByZXF1aXJlIGEgaG9zdG5hbWVcbiAgVVJJLmhvc3RQcm90b2NvbHMgPSBbXG4gICAgJ2h0dHAnLFxuICAgICdodHRwcydcbiAgXTtcblxuICAvLyBhbGxvd2VkIGhvc3RuYW1lIGNoYXJhY3RlcnMgYWNjb3JkaW5nIHRvIFJGQyAzOTg2XG4gIC8vIEFMUEhBIERJR0lUIFwiLVwiIFwiLlwiIFwiX1wiIFwiflwiIFwiIVwiIFwiJFwiIFwiJlwiIFwiJ1wiIFwiKFwiIFwiKVwiIFwiKlwiIFwiK1wiIFwiLFwiIFwiO1wiIFwiPVwiICVlbmNvZGVkXG4gIC8vIEkndmUgbmV2ZXIgc2VlbiBhIChub24tSUROKSBob3N0bmFtZSBvdGhlciB0aGFuOiBBTFBIQSBESUdJVCAuIC0gX1xuICBVUkkuaW52YWxpZF9ob3N0bmFtZV9jaGFyYWN0ZXJzID0gL1teYS16QS1aMC05XFwuXFwtOl9dLztcbiAgLy8gbWFwIERPTSBFbGVtZW50cyB0byB0aGVpciBVUkkgYXR0cmlidXRlXG4gIFVSSS5kb21BdHRyaWJ1dGVzID0ge1xuICAgICdhJzogJ2hyZWYnLFxuICAgICdibG9ja3F1b3RlJzogJ2NpdGUnLFxuICAgICdsaW5rJzogJ2hyZWYnLFxuICAgICdiYXNlJzogJ2hyZWYnLFxuICAgICdzY3JpcHQnOiAnc3JjJyxcbiAgICAnZm9ybSc6ICdhY3Rpb24nLFxuICAgICdpbWcnOiAnc3JjJyxcbiAgICAnYXJlYSc6ICdocmVmJyxcbiAgICAnaWZyYW1lJzogJ3NyYycsXG4gICAgJ2VtYmVkJzogJ3NyYycsXG4gICAgJ3NvdXJjZSc6ICdzcmMnLFxuICAgICd0cmFjayc6ICdzcmMnLFxuICAgICdpbnB1dCc6ICdzcmMnLCAvLyBidXQgb25seSBpZiB0eXBlPVwiaW1hZ2VcIlxuICAgICdhdWRpbyc6ICdzcmMnLFxuICAgICd2aWRlbyc6ICdzcmMnXG4gIH07XG4gIFVSSS5nZXREb21BdHRyaWJ1dGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLm5vZGVOYW1lKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyA8aW5wdXQ+IHNob3VsZCBvbmx5IGV4cG9zZSBzcmMgZm9yIHR5cGU9XCJpbWFnZVwiXG4gICAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIG5vZGUudHlwZSAhPT0gJ2ltYWdlJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gVVJJLmRvbUF0dHJpYnV0ZXNbbm9kZU5hbWVdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUZvckR1bWJGaXJlZm94MzYodmFsdWUpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcy9pc3N1ZXMvOTFcbiAgICByZXR1cm4gZXNjYXBlKHZhbHVlKTtcbiAgfVxuXG4gIC8vIGVuY29kaW5nIC8gZGVjb2RpbmcgYWNjb3JkaW5nIHRvIFJGQzM5ODZcbiAgZnVuY3Rpb24gc3RyaWN0RW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykge1xuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2VuY29kZVVSSUNvbXBvbmVudFxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKVxuICAgICAgLnJlcGxhY2UoL1shJygpKl0vZywgZXNjYXBlRm9yRHVtYkZpcmVmb3gzNilcbiAgICAgIC5yZXBsYWNlKC9cXCovZywgJyUyQScpO1xuICB9XG4gIFVSSS5lbmNvZGUgPSBzdHJpY3RFbmNvZGVVUklDb21wb25lbnQ7XG4gIFVSSS5kZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG4gIFVSSS5pc284ODU5ID0gZnVuY3Rpb24oKSB7XG4gICAgVVJJLmVuY29kZSA9IGVzY2FwZTtcbiAgICBVUkkuZGVjb2RlID0gdW5lc2NhcGU7XG4gIH07XG4gIFVSSS51bmljb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgVVJJLmVuY29kZSA9IHN0cmljdEVuY29kZVVSSUNvbXBvbmVudDtcbiAgICBVUkkuZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuICB9O1xuICBVUkkuY2hhcmFjdGVycyA9IHtcbiAgICBwYXRobmFtZToge1xuICAgICAgZW5jb2RlOiB7XG4gICAgICAgIC8vIFJGQzM5ODYgMi4xOiBGb3IgY29uc2lzdGVuY3ksIFVSSSBwcm9kdWNlcnMgYW5kIG5vcm1hbGl6ZXJzIHNob3VsZFxuICAgICAgICAvLyB1c2UgdXBwZXJjYXNlIGhleGFkZWNpbWFsIGRpZ2l0cyBmb3IgYWxsIHBlcmNlbnQtZW5jb2RpbmdzLlxuICAgICAgICBleHByZXNzaW9uOiAvJSgyNHwyNnwyQnwyQ3wzQnwzRHwzQXw0MCkvaWcsXG4gICAgICAgIG1hcDoge1xuICAgICAgICAgIC8vIC0uX34hJygpKlxuICAgICAgICAgICclMjQnOiAnJCcsXG4gICAgICAgICAgJyUyNic6ICcmJyxcbiAgICAgICAgICAnJTJCJzogJysnLFxuICAgICAgICAgICclMkMnOiAnLCcsXG4gICAgICAgICAgJyUzQic6ICc7JyxcbiAgICAgICAgICAnJTNEJzogJz0nLFxuICAgICAgICAgICclM0EnOiAnOicsXG4gICAgICAgICAgJyU0MCc6ICdAJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVjb2RlOiB7XG4gICAgICAgIGV4cHJlc3Npb246IC9bXFwvXFw/I10vZyxcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgJy8nOiAnJTJGJyxcbiAgICAgICAgICAnPyc6ICclM0YnLFxuICAgICAgICAgICcjJzogJyUyMydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXJ2ZWQ6IHtcbiAgICAgIGVuY29kZToge1xuICAgICAgICAvLyBSRkMzOTg2IDIuMTogRm9yIGNvbnNpc3RlbmN5LCBVUkkgcHJvZHVjZXJzIGFuZCBub3JtYWxpemVycyBzaG91bGRcbiAgICAgICAgLy8gdXNlIHVwcGVyY2FzZSBoZXhhZGVjaW1hbCBkaWdpdHMgZm9yIGFsbCBwZXJjZW50LWVuY29kaW5ncy5cbiAgICAgICAgZXhwcmVzc2lvbjogLyUoMjF8MjN8MjR8MjZ8Mjd8Mjh8Mjl8MkF8MkJ8MkN8MkZ8M0F8M0J8M0R8M0Z8NDB8NUJ8NUQpL2lnLFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAvLyBnZW4tZGVsaW1zXG4gICAgICAgICAgJyUzQSc6ICc6JyxcbiAgICAgICAgICAnJTJGJzogJy8nLFxuICAgICAgICAgICclM0YnOiAnPycsXG4gICAgICAgICAgJyUyMyc6ICcjJyxcbiAgICAgICAgICAnJTVCJzogJ1snLFxuICAgICAgICAgICclNUQnOiAnXScsXG4gICAgICAgICAgJyU0MCc6ICdAJyxcbiAgICAgICAgICAvLyBzdWItZGVsaW1zXG4gICAgICAgICAgJyUyMSc6ICchJyxcbiAgICAgICAgICAnJTI0JzogJyQnLFxuICAgICAgICAgICclMjYnOiAnJicsXG4gICAgICAgICAgJyUyNyc6ICdcXCcnLFxuICAgICAgICAgICclMjgnOiAnKCcsXG4gICAgICAgICAgJyUyOSc6ICcpJyxcbiAgICAgICAgICAnJTJBJzogJyonLFxuICAgICAgICAgICclMkInOiAnKycsXG4gICAgICAgICAgJyUyQyc6ICcsJyxcbiAgICAgICAgICAnJTNCJzogJzsnLFxuICAgICAgICAgICclM0QnOiAnPSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdXJucGF0aDoge1xuICAgICAgLy8gVGhlIGNoYXJhY3RlcnMgdW5kZXIgYGVuY29kZWAgYXJlIHRoZSBjaGFyYWN0ZXJzIGNhbGxlZCBvdXQgYnkgUkZDIDIxNDEgYXMgYmVpbmcgYWNjZXB0YWJsZVxuICAgICAgLy8gZm9yIHVzYWdlIGluIGEgVVJOLiBSRkMyMTQxIGFsc28gY2FsbHMgb3V0IFwiLVwiLCBcIi5cIiwgYW5kIFwiX1wiIGFzIGFjY2VwdGFibGUgY2hhcmFjdGVycywgYnV0XG4gICAgICAvLyB0aGVzZSBhcmVuJ3QgZW5jb2RlZCBieSBlbmNvZGVVUklDb21wb25lbnQsIHNvIHdlIGRvbid0IGhhdmUgdG8gY2FsbCB0aGVtIG91dCBoZXJlLiBBbHNvXG4gICAgICAvLyBub3RlIHRoYXQgdGhlIGNvbG9uIGNoYXJhY3RlciBpcyBub3QgZmVhdHVyZWQgaW4gdGhlIGVuY29kaW5nIG1hcDsgdGhpcyBpcyBiZWNhdXNlIFVSSS5qc1xuICAgICAgLy8gZ2l2ZXMgdGhlIGNvbG9ucyBpbiBVUk5zIHNlbWFudGljIG1lYW5pbmcgYXMgdGhlIGRlbGltaXRlcnMgb2YgcGF0aCBzZWdlbWVudHMsIGFuZCBzbyBpdFxuICAgICAgLy8gc2hvdWxkIG5vdCBhcHBlYXIgdW5lbmNvZGVkIGluIGEgc2VnbWVudCBpdHNlbGYuXG4gICAgICAvLyBTZWUgYWxzbyB0aGUgbm90ZSBhYm92ZSBhYm91dCBSRkMzOTg2IGFuZCBjYXBpdGFsYWxpemVkIGhleCBkaWdpdHMuXG4gICAgICBlbmNvZGU6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogLyUoMjF8MjR8Mjd8Mjh8Mjl8MkF8MkJ8MkN8M0J8M0R8NDApL2lnLFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAnJTIxJzogJyEnLFxuICAgICAgICAgICclMjQnOiAnJCcsXG4gICAgICAgICAgJyUyNyc6ICdcXCcnLFxuICAgICAgICAgICclMjgnOiAnKCcsXG4gICAgICAgICAgJyUyOSc6ICcpJyxcbiAgICAgICAgICAnJTJBJzogJyonLFxuICAgICAgICAgICclMkInOiAnKycsXG4gICAgICAgICAgJyUyQyc6ICcsJyxcbiAgICAgICAgICAnJTNCJzogJzsnLFxuICAgICAgICAgICclM0QnOiAnPScsXG4gICAgICAgICAgJyU0MCc6ICdAJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVGhlc2UgY2hhcmFjdGVycyBhcmUgdGhlIGNoYXJhY3RlcnMgY2FsbGVkIG91dCBieSBSRkMyMTQxIGFzIFwicmVzZXJ2ZWRcIiBjaGFyYWN0ZXJzIHRoYXRcbiAgICAgIC8vIHNob3VsZCBuZXZlciBhcHBlYXIgaW4gYSBVUk4sIHBsdXMgdGhlIGNvbG9uIGNoYXJhY3RlciAoc2VlIG5vdGUgYWJvdmUpLlxuICAgICAgZGVjb2RlOiB7XG4gICAgICAgIGV4cHJlc3Npb246IC9bXFwvXFw/IzpdL2csXG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICcvJzogJyUyRicsXG4gICAgICAgICAgJz8nOiAnJTNGJyxcbiAgICAgICAgICAnIyc6ICclMjMnLFxuICAgICAgICAgICc6JzogJyUzQSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgVVJJLmVuY29kZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBlc2NhcGVRdWVyeVNwYWNlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBVUkkuZW5jb2RlKHN0cmluZyArICcnKTtcbiAgICBpZiAoZXNjYXBlUXVlcnlTcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlc2NhcGVRdWVyeVNwYWNlID0gVVJJLmVzY2FwZVF1ZXJ5U3BhY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZVF1ZXJ5U3BhY2UgPyBlc2NhcGVkLnJlcGxhY2UoLyUyMC9nLCAnKycpIDogZXNjYXBlZDtcbiAgfTtcbiAgVVJJLmRlY29kZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBlc2NhcGVRdWVyeVNwYWNlKSB7XG4gICAgc3RyaW5nICs9ICcnO1xuICAgIGlmIChlc2NhcGVRdWVyeVNwYWNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVzY2FwZVF1ZXJ5U3BhY2UgPSBVUkkuZXNjYXBlUXVlcnlTcGFjZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFVSSS5kZWNvZGUoZXNjYXBlUXVlcnlTcGFjZSA/IHN0cmluZy5yZXBsYWNlKC9cXCsvZywgJyUyMCcpIDogc3RyaW5nKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIHdlJ3JlIG5vdCBnb2luZyB0byBtZXNzIHdpdGggd2VpcmQgZW5jb2RpbmdzLFxuICAgICAgLy8gZ2l2ZSB1cCBhbmQgcmV0dXJuIHRoZSB1bmRlY29kZWQgb3JpZ2luYWwgc3RyaW5nXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvaXNzdWVzLzg3XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMvaXNzdWVzLzkyXG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgfTtcbiAgLy8gZ2VuZXJhdGUgZW5jb2RlL2RlY29kZSBwYXRoIGZ1bmN0aW9uc1xuICB2YXIgX3BhcnRzID0geydlbmNvZGUnOidlbmNvZGUnLCAnZGVjb2RlJzonZGVjb2RlJ307XG4gIHZhciBfcGFydDtcbiAgdmFyIGdlbmVyYXRlQWNjZXNzb3IgPSBmdW5jdGlvbihfZ3JvdXAsIF9wYXJ0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFVSSVtfcGFydF0oc3RyaW5nICsgJycpLnJlcGxhY2UoVVJJLmNoYXJhY3RlcnNbX2dyb3VwXVtfcGFydF0uZXhwcmVzc2lvbiwgZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiBVUkkuY2hhcmFjdGVyc1tfZ3JvdXBdW19wYXJ0XS5tYXBbY107XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gbWVzcyB3aXRoIHdlaXJkIGVuY29kaW5ncyxcbiAgICAgICAgLy8gZ2l2ZSB1cCBhbmQgcmV0dXJuIHRoZSB1bmRlY29kZWQgb3JpZ2luYWwgc3RyaW5nXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcy9pc3N1ZXMvODdcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvVVJJLmpzL2lzc3Vlcy85MlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZm9yIChfcGFydCBpbiBfcGFydHMpIHtcbiAgICBVUklbX3BhcnQgKyAnUGF0aFNlZ21lbnQnXSA9IGdlbmVyYXRlQWNjZXNzb3IoJ3BhdGhuYW1lJywgX3BhcnRzW19wYXJ0XSk7XG4gICAgVVJJW19wYXJ0ICsgJ1VyblBhdGhTZWdtZW50J10gPSBnZW5lcmF0ZUFjY2Vzc29yKCd1cm5wYXRoJywgX3BhcnRzW19wYXJ0XSk7XG4gIH1cblxuICB2YXIgZ2VuZXJhdGVTZWdtZW50ZWRQYXRoRnVuY3Rpb24gPSBmdW5jdGlvbihfc2VwLCBfY29kaW5nRnVuY05hbWUsIF9pbm5lckNvZGluZ0Z1bmNOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgLy8gV2h5IHBhc3MgaW4gbmFtZXMgb2YgZnVuY3Rpb25zLCByYXRoZXIgdGhhbiB0aGUgZnVuY3Rpb24gb2JqZWN0cyB0aGVtc2VsdmVzPyBUaGVcbiAgICAgIC8vIGRlZmluaXRpb25zIG9mIHNvbWUgZnVuY3Rpb25zIChidXQgaW4gcGFydGljdWxhciwgVVJJLmRlY29kZSkgd2lsbCBvY2Nhc2lvbmFsbHkgY2hhbmdlIGR1ZVxuICAgICAgLy8gdG8gVVJJLmpzIGhhdmluZyBJU084ODU5IGFuZCBVbmljb2RlIG1vZGVzLiBQYXNzaW5nIGluIHRoZSBuYW1lIGFuZCBnZXR0aW5nIGl0IHdpbGwgZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBmdW5jdGlvbnMgd2UgdXNlIGhlcmUgYXJlIFwiZnJlc2hcIi5cbiAgICAgIHZhciBhY3R1YWxDb2RpbmdGdW5jO1xuICAgICAgaWYgKCFfaW5uZXJDb2RpbmdGdW5jTmFtZSkge1xuICAgICAgICBhY3R1YWxDb2RpbmdGdW5jID0gVVJJW19jb2RpbmdGdW5jTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWxDb2RpbmdGdW5jID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFVSSVtfY29kaW5nRnVuY05hbWVdKFVSSVtfaW5uZXJDb2RpbmdGdW5jTmFtZV0oc3RyaW5nKSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50cyA9IChzdHJpbmcgKyAnJykuc3BsaXQoX3NlcCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50c1tpXSA9IGFjdHVhbENvZGluZ0Z1bmMoc2VnbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VnbWVudHMuam9pbihfc2VwKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgdGFrZXMgcGxhY2Ugb3V0c2lkZSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGRvbid0IHdhbnQsIGUuZy4sIGVuY29kZVVyblBhdGggZnVuY3Rpb25zLlxuICBVUkkuZGVjb2RlUGF0aCA9IGdlbmVyYXRlU2VnbWVudGVkUGF0aEZ1bmN0aW9uKCcvJywgJ2RlY29kZVBhdGhTZWdtZW50Jyk7XG4gIFVSSS5kZWNvZGVVcm5QYXRoID0gZ2VuZXJhdGVTZWdtZW50ZWRQYXRoRnVuY3Rpb24oJzonLCAnZGVjb2RlVXJuUGF0aFNlZ21lbnQnKTtcbiAgVVJJLnJlY29kZVBhdGggPSBnZW5lcmF0ZVNlZ21lbnRlZFBhdGhGdW5jdGlvbignLycsICdlbmNvZGVQYXRoU2VnbWVudCcsICdkZWNvZGUnKTtcbiAgVVJJLnJlY29kZVVyblBhdGggPSBnZW5lcmF0ZVNlZ21lbnRlZFBhdGhGdW5jdGlvbignOicsICdlbmNvZGVVcm5QYXRoU2VnbWVudCcsICdkZWNvZGUnKTtcblxuICBVUkkuZW5jb2RlUmVzZXJ2ZWQgPSBnZW5lcmF0ZUFjY2Vzc29yKCdyZXNlcnZlZCcsICdlbmNvZGUnKTtcblxuICBVUkkucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7XG4gICAgdmFyIHBvcztcbiAgICBpZiAoIXBhcnRzKSB7XG4gICAgICBwYXJ0cyA9IHtcbiAgICAgICAgcHJldmVudEludmFsaWRIb3N0bmFtZTogVVJJLnByZXZlbnRJbnZhbGlkSG9zdG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoVVJJLmxlYWRpbmdfd2hpdGVzcGFjZV9leHByZXNzaW9uLCAnJylcbiAgICAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShVUkkuYXNjaWlfdGFiX3doaXRlc3BhY2UsICcnKVxuXG4gICAgLy8gW3Byb3RvY29sXCI6Ly9cIlt1c2VybmFtZVtcIjpcInBhc3N3b3JkXVwiQFwiXWhvc3RuYW1lW1wiOlwicG9ydF1cIi9cIj9dW3BhdGhdW1wiP1wicXVlcnlzdHJpbmddW1wiI1wiZnJhZ21lbnRdXG5cbiAgICAvLyBleHRyYWN0IGZyYWdtZW50XG4gICAgcG9zID0gc3RyaW5nLmluZGV4T2YoJyMnKTtcbiAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgIC8vIGVzY2FwaW5nP1xuICAgICAgcGFydHMuZnJhZ21lbnQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpIHx8IG51bGw7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBxdWVyeVxuICAgIHBvcyA9IHN0cmluZy5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAvLyBlc2NhcGluZz9cbiAgICAgIHBhcnRzLnF1ZXJ5ID0gc3RyaW5nLnN1YnN0cmluZyhwb3MgKyAxKSB8fCBudWxsO1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIH1cblxuICAgIC8vIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzIGhhdmUgbG9zdCBhbGwgbWVhbmluZyBmb3IgdGhlIHdlYiBwcm90b2NvbHMgKGh0dHBzLCBodHRwLCB3c3MsIHdzKVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKGh0dHBzP3xmdHB8d3NzPyk/OitbL1xcXFxdKi9pLCAnJDE6Ly8nKTtcbiAgICAvLyBzbGFzaGVzIGFuZCBiYWNrc2xhc2hlcyBoYXZlIGxvc3QgYWxsIG1lYW5pbmcgZm9yIHNjaGVtZSByZWxhdGl2ZSBVUkxzXG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL15bL1xcXFxdezIsfS9pLCAnLy8nKTtcblxuICAgIC8vIGV4dHJhY3QgcHJvdG9jb2xcbiAgICBpZiAoc3RyaW5nLnN1YnN0cmluZygwLCAyKSA9PT0gJy8vJykge1xuICAgICAgLy8gcmVsYXRpdmUtc2NoZW1lXG4gICAgICBwYXJ0cy5wcm90b2NvbCA9IG51bGw7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKDIpO1xuICAgICAgLy8gZXh0cmFjdCBcInVzZXI6cGFzc0Bob3N0OnBvcnRcIlxuICAgICAgc3RyaW5nID0gVVJJLnBhcnNlQXV0aG9yaXR5KHN0cmluZywgcGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBzdHJpbmcuaW5kZXhPZignOicpO1xuICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgIHBhcnRzLnByb3RvY29sID0gc3RyaW5nLnN1YnN0cmluZygwLCBwb3MpIHx8IG51bGw7XG4gICAgICAgIGlmIChwYXJ0cy5wcm90b2NvbCAmJiAhcGFydHMucHJvdG9jb2wubWF0Y2goVVJJLnByb3RvY29sX2V4cHJlc3Npb24pKSB7XG4gICAgICAgICAgLy8gOiBtYXkgYmUgd2l0aGluIHRoZSBwYXRoXG4gICAgICAgICAgcGFydHMucHJvdG9jb2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLnN1YnN0cmluZyhwb3MgKyAxLCBwb3MgKyAzKS5yZXBsYWNlKC9cXFxcL2csICcvJykgPT09ICcvLycpIHtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDMpO1xuXG4gICAgICAgICAgLy8gZXh0cmFjdCBcInVzZXI6cGFzc0Bob3N0OnBvcnRcIlxuICAgICAgICAgIHN0cmluZyA9IFVSSS5wYXJzZUF1dGhvcml0eShzdHJpbmcsIHBhcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpO1xuICAgICAgICAgIHBhcnRzLnVybiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3aGF0J3MgbGVmdCBtdXN0IGJlIHRoZSBwYXRoXG4gICAgcGFydHMucGF0aCA9IHN0cmluZztcblxuICAgIC8vIGFuZCB3ZSdyZSBkb25lXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9O1xuICBVUkkucGFyc2VIb3N0ID0gZnVuY3Rpb24oc3RyaW5nLCBwYXJ0cykge1xuICAgIGlmICghc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSAnJztcbiAgICB9XG5cbiAgICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iLzM4NmZkMjRmNDliMGU5ZDFhOGEwNzY1OTJhNDA0MTY4ZmFlZWNjMzQvbGliL3VybC5qcyNMMTE1LUwxMjRcbiAgICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvVVJJLmpzL3B1bGwvMjMzXG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblxuICAgIC8vIGV4dHJhY3QgaG9zdDpwb3J0XG4gICAgdmFyIHBvcyA9IHN0cmluZy5pbmRleE9mKCcvJyk7XG4gICAgdmFyIGJyYWNrZXRQb3M7XG4gICAgdmFyIHQ7XG5cbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcG9zID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gJ1snKSB7XG4gICAgICAvLyBJUHY2IGhvc3QgLSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLTZtYW4tdGV4dC1hZGRyLXJlcHJlc2VudGF0aW9uLTA0I3NlY3Rpb24tNlxuICAgICAgLy8gSSBjbGFpbSBtb3N0IGNsaWVudCBzb2Z0d2FyZSBicmVha3Mgb24gSVB2NiBhbnl3YXlzLiBUbyBzaW1wbGlmeSB0aGluZ3MsIFVSSSBvbmx5IGFjY2VwdHNcbiAgICAgIC8vIElQdjYrcG9ydCBpbiB0aGUgZm9ybWF0IFsyMDAxOmRiODo6MV06ODAgKGZvciB0aGUgdGltZSBiZWluZylcbiAgICAgIGJyYWNrZXRQb3MgPSBzdHJpbmcuaW5kZXhPZignXScpO1xuICAgICAgcGFydHMuaG9zdG5hbWUgPSBzdHJpbmcuc3Vic3RyaW5nKDEsIGJyYWNrZXRQb3MpIHx8IG51bGw7XG4gICAgICBwYXJ0cy5wb3J0ID0gc3RyaW5nLnN1YnN0cmluZyhicmFja2V0UG9zICsgMiwgcG9zKSB8fCBudWxsO1xuICAgICAgaWYgKHBhcnRzLnBvcnQgPT09ICcvJykge1xuICAgICAgICBwYXJ0cy5wb3J0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0Q29sb24gPSBzdHJpbmcuaW5kZXhPZignOicpO1xuICAgICAgdmFyIGZpcnN0U2xhc2ggPSBzdHJpbmcuaW5kZXhPZignLycpO1xuICAgICAgdmFyIG5leHRDb2xvbiA9IHN0cmluZy5pbmRleE9mKCc6JywgZmlyc3RDb2xvbiArIDEpO1xuICAgICAgaWYgKG5leHRDb2xvbiAhPT0gLTEgJiYgKGZpcnN0U2xhc2ggPT09IC0xIHx8IG5leHRDb2xvbiA8IGZpcnN0U2xhc2gpKSB7XG4gICAgICAgIC8vIElQdjYgaG9zdCBjb250YWlucyBtdWx0aXBsZSBjb2xvbnMgLSBidXQgbm8gcG9ydFxuICAgICAgICAvLyB0aGlzIG5vdGF0aW9uIGlzIGFjdHVhbGx5IG5vdCBhbGxvd2VkIGJ5IFJGQyAzOTg2LCBidXQgd2UncmUgYSBsaWJlcmFsIHBhcnNlclxuICAgICAgICBwYXJ0cy5ob3N0bmFtZSA9IHN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKSB8fCBudWxsO1xuICAgICAgICBwYXJ0cy5wb3J0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIHBvcykuc3BsaXQoJzonKTtcbiAgICAgICAgcGFydHMuaG9zdG5hbWUgPSB0WzBdIHx8IG51bGw7XG4gICAgICAgIHBhcnRzLnBvcnQgPSB0WzFdIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLmhvc3RuYW1lICYmIHN0cmluZy5zdWJzdHJpbmcocG9zKS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgcG9zKys7XG4gICAgICBzdHJpbmcgPSAnLycgKyBzdHJpbmc7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUpIHtcbiAgICAgIFVSSS5lbnN1cmVWYWxpZEhvc3RuYW1lKHBhcnRzLmhvc3RuYW1lLCBwYXJ0cy5wcm90b2NvbCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLnBvcnQpIHtcbiAgICAgIFVSSS5lbnN1cmVWYWxpZFBvcnQocGFydHMucG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcocG9zKSB8fCAnLyc7XG4gIH07XG4gIFVSSS5wYXJzZUF1dGhvcml0eSA9IGZ1bmN0aW9uKHN0cmluZywgcGFydHMpIHtcbiAgICBzdHJpbmcgPSBVUkkucGFyc2VVc2VyaW5mbyhzdHJpbmcsIHBhcnRzKTtcbiAgICByZXR1cm4gVVJJLnBhcnNlSG9zdChzdHJpbmcsIHBhcnRzKTtcbiAgfTtcbiAgVVJJLnBhcnNlVXNlcmluZm8gPSBmdW5jdGlvbihzdHJpbmcsIHBhcnRzKSB7XG4gICAgLy8gZXh0cmFjdCB1c2VybmFtZTpwYXNzd29yZFxuICAgIHZhciBfc3RyaW5nID0gc3RyaW5nXG4gICAgdmFyIGZpcnN0QmFja1NsYXNoID0gc3RyaW5nLmluZGV4T2YoJ1xcXFwnKTtcbiAgICBpZiAoZmlyc3RCYWNrU2xhc2ggIT09IC0xKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgfVxuICAgIHZhciBmaXJzdFNsYXNoID0gc3RyaW5nLmluZGV4T2YoJy8nKTtcbiAgICB2YXIgcG9zID0gc3RyaW5nLmxhc3RJbmRleE9mKCdAJywgZmlyc3RTbGFzaCA+IC0xID8gZmlyc3RTbGFzaCA6IHN0cmluZy5sZW5ndGggLSAxKTtcbiAgICB2YXIgdDtcblxuICAgIC8vIGF1dGhvcml0eUAgbXVzdCBjb21lIGJlZm9yZSAvcGF0aCBvciBcXHBhdGhcbiAgICBpZiAocG9zID4gLTEgJiYgKGZpcnN0U2xhc2ggPT09IC0xIHx8IHBvcyA8IGZpcnN0U2xhc2gpKSB7XG4gICAgICB0ID0gc3RyaW5nLnN1YnN0cmluZygwLCBwb3MpLnNwbGl0KCc6Jyk7XG4gICAgICBwYXJ0cy51c2VybmFtZSA9IHRbMF0gPyBVUkkuZGVjb2RlKHRbMF0pIDogbnVsbDtcbiAgICAgIHQuc2hpZnQoKTtcbiAgICAgIHBhcnRzLnBhc3N3b3JkID0gdFswXSA/IFVSSS5kZWNvZGUodC5qb2luKCc6JykpIDogbnVsbDtcbiAgICAgIHN0cmluZyA9IF9zdHJpbmcuc3Vic3RyaW5nKHBvcyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy51c2VybmFtZSA9IG51bGw7XG4gICAgICBwYXJ0cy5wYXNzd29yZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbiAgVVJJLnBhcnNlUXVlcnkgPSBmdW5jdGlvbihzdHJpbmcsIGVzY2FwZVF1ZXJ5U3BhY2UpIHtcbiAgICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8vIHRocm93IG91dCB0aGUgZnVua3kgYnVzaW5lc3MgLSBcIj9cIltuYW1lXCI9XCJ2YWx1ZVwiJlwiXStcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvJisvZywgJyYnKS5yZXBsYWNlKC9eXFw/KiYqfCYrJC9nLCAnJyk7XG5cbiAgICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHZhciBpdGVtcyA9IHt9O1xuICAgIHZhciBzcGxpdHMgPSBzdHJpbmcuc3BsaXQoJyYnKTtcbiAgICB2YXIgbGVuZ3RoID0gc3BsaXRzLmxlbmd0aDtcbiAgICB2YXIgdiwgbmFtZSwgdmFsdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2ID0gc3BsaXRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICBuYW1lID0gVVJJLmRlY29kZVF1ZXJ5KHYuc2hpZnQoKSwgZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgICAvLyBubyBcIj1cIiBpcyBudWxsIGFjY29yZGluZyB0byBodHRwOi8vZHZjcy53My5vcmcvaGcvdXJsL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcbiAgICAgIHZhbHVlID0gdi5sZW5ndGggPyBVUkkuZGVjb2RlUXVlcnkodi5qb2luKCc9JyksIGVzY2FwZVF1ZXJ5U3BhY2UpIDogbnVsbDtcblxuICAgICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIC8vIGlnbm9yZSBhdHRlbXB0IGF0IGV4cGxvaXRpbmcgSmF2YVNjcmlwdCBpbnRlcm5hbHNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc093bi5jYWxsKGl0ZW1zLCBuYW1lKSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1zW25hbWVdID09PSAnc3RyaW5nJyB8fCBpdGVtc1tuYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgIGl0ZW1zW25hbWVdID0gW2l0ZW1zW25hbWVdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zW25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgVVJJLmJ1aWxkID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICB2YXIgdCA9ICcnO1xuICAgIHZhciByZXF1aXJlQWJzb2x1dGVQYXRoID0gZmFsc2VcblxuICAgIGlmIChwYXJ0cy5wcm90b2NvbCkge1xuICAgICAgdCArPSBwYXJ0cy5wcm90b2NvbCArICc6JztcbiAgICB9XG5cbiAgICBpZiAoIXBhcnRzLnVybiAmJiAodCB8fCBwYXJ0cy5ob3N0bmFtZSkpIHtcbiAgICAgIHQgKz0gJy8vJztcbiAgICAgIHJlcXVpcmVBYnNvbHV0ZVBhdGggPSB0cnVlXG4gICAgfVxuXG4gICAgdCArPSAoVVJJLmJ1aWxkQXV0aG9yaXR5KHBhcnRzKSB8fCAnJyk7XG5cbiAgICBpZiAodHlwZW9mIHBhcnRzLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAocGFydHMucGF0aC5jaGFyQXQoMCkgIT09ICcvJyAmJiByZXF1aXJlQWJzb2x1dGVQYXRoKSB7XG4gICAgICAgIHQgKz0gJy8nO1xuICAgICAgfVxuXG4gICAgICB0ICs9IHBhcnRzLnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJ0cy5xdWVyeSA9PT0gJ3N0cmluZycgJiYgcGFydHMucXVlcnkpIHtcbiAgICAgIHQgKz0gJz8nICsgcGFydHMucXVlcnk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJ0cy5mcmFnbWVudCA9PT0gJ3N0cmluZycgJiYgcGFydHMuZnJhZ21lbnQpIHtcbiAgICAgIHQgKz0gJyMnICsgcGFydHMuZnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICBVUkkuYnVpbGRIb3N0ID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICB2YXIgdCA9ICcnO1xuXG4gICAgaWYgKCFwYXJ0cy5ob3N0bmFtZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAoVVJJLmlwNl9leHByZXNzaW9uLnRlc3QocGFydHMuaG9zdG5hbWUpKSB7XG4gICAgICB0ICs9ICdbJyArIHBhcnRzLmhvc3RuYW1lICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ICs9IHBhcnRzLmhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChwYXJ0cy5wb3J0KSB7XG4gICAgICB0ICs9ICc6JyArIHBhcnRzLnBvcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIFVSSS5idWlsZEF1dGhvcml0eSA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgcmV0dXJuIFVSSS5idWlsZFVzZXJpbmZvKHBhcnRzKSArIFVSSS5idWlsZEhvc3QocGFydHMpO1xuICB9O1xuICBVUkkuYnVpbGRVc2VyaW5mbyA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgdmFyIHQgPSAnJztcblxuICAgIGlmIChwYXJ0cy51c2VybmFtZSkge1xuICAgICAgdCArPSBVUkkuZW5jb2RlKHBhcnRzLnVzZXJuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAocGFydHMucGFzc3dvcmQpIHtcbiAgICAgIHQgKz0gJzonICsgVVJJLmVuY29kZShwYXJ0cy5wYXNzd29yZCk7XG4gICAgfVxuXG4gICAgaWYgKHQpIHtcbiAgICAgIHQgKz0gJ0AnO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuICBVUkkuYnVpbGRRdWVyeSA9IGZ1bmN0aW9uKGRhdGEsIGR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgZXNjYXBlUXVlcnlTcGFjZSkge1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2IG9yIGh0dHA6Ly9sYWJzLmFwYWNoZS5vcmcvd2ViYXJjaC91cmkvcmZjL3JmYzM5ODYuaHRtbFxuICAgIC8vIGJlaW5nIMK7LS5ffiEkJicoKSorLDs9OkAvP8KrICVIRVggYW5kIGFsbnVtIGFyZSBhbGxvd2VkXG4gICAgLy8gdGhlIFJGQyBleHBsaWNpdGx5IHN0YXRlcyA/L2ZvbyBiZWluZyBhIHZhbGlkIHVzZSBjYXNlLCBubyBtZW50aW9uIG9mIHBhcmFtZXRlciBzeW50YXghXG4gICAgLy8gVVJJLmpzIHRyZWF0cyB0aGUgcXVlcnkgc3RyaW5nIGFzIGJlaW5nIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMtaHRtbDQwL2ludGVyYWN0L2Zvcm1zLmh0bWwjZm9ybS1jb250ZW50LXR5cGVcblxuICAgIHZhciB0ID0gJyc7XG4gICAgdmFyIHVuaXF1ZSwga2V5LCBpLCBsZW5ndGg7XG4gICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgLy8gaWdub3JlIGF0dGVtcHQgYXQgZXhwbG9pdGluZyBKYXZhU2NyaXB0IGludGVybmFsc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duLmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICBpZiAoaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgICAgdW5pcXVlID0ge307XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZGF0YVtrZXldLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtrZXldW2ldICE9PSB1bmRlZmluZWQgJiYgdW5pcXVlW2RhdGFba2V5XVtpXSArICcnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHQgKz0gJyYnICsgVVJJLmJ1aWxkUXVlcnlQYXJhbWV0ZXIoa2V5LCBkYXRhW2tleV1baV0sIGVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlW2RhdGFba2V5XVtpXSArICcnXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ICs9ICcmJyArIFVSSS5idWlsZFF1ZXJ5UGFyYW1ldGVyKGtleSwgZGF0YVtrZXldLCBlc2NhcGVRdWVyeVNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0LnN1YnN0cmluZygxKTtcbiAgfTtcbiAgVVJJLmJ1aWxkUXVlcnlQYXJhbWV0ZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgZXNjYXBlUXVlcnlTcGFjZSkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAvaW50ZXJhY3QvZm9ybXMuaHRtbCNmb3JtLWNvbnRlbnQtdHlwZSAtLSBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICAvLyBkb24ndCBhcHBlbmQgXCI9XCIgZm9yIG51bGwgdmFsdWVzLCBhY2NvcmRpbmcgdG8gaHR0cDovL2R2Y3MudzMub3JnL2hnL3VybC9yYXctZmlsZS90aXAvT3ZlcnZpZXcuaHRtbCN1cmwtcGFyYW1ldGVyLXNlcmlhbGl6YXRpb25cbiAgICByZXR1cm4gVVJJLmVuY29kZVF1ZXJ5KG5hbWUsIGVzY2FwZVF1ZXJ5U3BhY2UpICsgKHZhbHVlICE9PSBudWxsID8gJz0nICsgVVJJLmVuY29kZVF1ZXJ5KHZhbHVlLCBlc2NhcGVRdWVyeVNwYWNlKSA6ICcnKTtcbiAgfTtcblxuICBVUkkuYWRkUXVlcnkgPSBmdW5jdGlvbihkYXRhLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBrZXkpKSB7XG4gICAgICAgICAgVVJJLmFkZFF1ZXJ5KGRhdGEsIGtleSwgbmFtZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZGF0YVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGFbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtuYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YVtuYW1lXSA9IFtkYXRhW25hbWVdXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIGRhdGFbbmFtZV0gPSAoZGF0YVtuYW1lXSB8fCBbXSkuY29uY2F0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVVJJLmFkZFF1ZXJ5KCkgYWNjZXB0cyBhbiBvYmplY3QsIHN0cmluZyBhcyB0aGUgbmFtZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gIH07XG5cbiAgVVJJLnNldFF1ZXJ5ID0gZnVuY3Rpb24oZGF0YSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwobmFtZSwga2V5KSkge1xuICAgICAgICAgIFVSSS5zZXRRdWVyeShkYXRhLCBrZXksIG5hbWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VSSS5zZXRRdWVyeSgpIGFjY2VwdHMgYW4gb2JqZWN0LCBzdHJpbmcgYXMgdGhlIG5hbWUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICB9O1xuXG4gIFVSSS5yZW1vdmVRdWVyeSA9IGZ1bmN0aW9uKGRhdGEsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGksIGxlbmd0aCwga2V5O1xuXG4gICAgaWYgKGlzQXJyYXkobmFtZSkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG5hbWUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtuYW1lW2ldXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdldFR5cGUobmFtZSkgPT09ICdSZWdFeHAnKSB7XG4gICAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChuYW1lLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIGRhdGFba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKGtleSBpbiBuYW1lKSB7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBrZXkpKSB7XG4gICAgICAgICAgVVJJLnJlbW92ZVF1ZXJ5KGRhdGEsIGtleSwgbmFtZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdSZWdFeHAnKSB7XG4gICAgICAgICAgaWYgKCFpc0FycmF5KGRhdGFbbmFtZV0pICYmIHZhbHVlLnRlc3QoZGF0YVtuYW1lXSkpIHtcbiAgICAgICAgICAgIGRhdGFbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFbbmFtZV0gPSBmaWx0ZXJBcnJheVZhbHVlcyhkYXRhW25hbWVdLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFbbmFtZV0gPT09IFN0cmluZyh2YWx1ZSkgJiYgKCFpc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDEpKSB7XG4gICAgICAgICAgZGF0YVtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGFbbmFtZV0pKSB7XG4gICAgICAgICAgZGF0YVtuYW1lXSA9IGZpbHRlckFycmF5VmFsdWVzKGRhdGFbbmFtZV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVVJJLnJlbW92ZVF1ZXJ5KCkgYWNjZXB0cyBhbiBvYmplY3QsIHN0cmluZywgUmVnRXhwIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gIH07XG4gIFVSSS5oYXNRdWVyeSA9IGZ1bmN0aW9uKGRhdGEsIG5hbWUsIHZhbHVlLCB3aXRoaW5BcnJheSkge1xuICAgIHN3aXRjaCAoZ2V0VHlwZShuYW1lKSkge1xuICAgICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyBoZXJlXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmIChoYXNPd24uY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAobmFtZS50ZXN0KGtleSkgJiYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgVVJJLmhhc1F1ZXJ5KGRhdGEsIGtleSwgdmFsdWUpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgIGZvciAodmFyIF9rZXkgaW4gbmFtZSkge1xuICAgICAgICAgIGlmIChoYXNPd24uY2FsbChuYW1lLCBfa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFVUkkuaGFzUXVlcnkoZGF0YSwgX2tleSwgbmFtZVtfa2V5XSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVUkkuaGFzUXVlcnkoKSBhY2NlcHRzIGEgc3RyaW5nLCByZWd1bGFyIGV4cHJlc3Npb24gb3Igb2JqZWN0IGFzIHRoZSBuYW1lIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZCc6XG4gICAgICAgIC8vIHRydWUgaWYgZXhpc3RzIChidXQgbWF5IGJlIGVtcHR5KVxuICAgICAgICByZXR1cm4gbmFtZSBpbiBkYXRhOyAvLyBkYXRhW25hbWVdICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAvLyB0cnVlIGlmIGV4aXN0cyBhbmQgbm9uLWVtcHR5XG4gICAgICAgIHZhciBfYm9vbHkgPSBCb29sZWFuKGlzQXJyYXkoZGF0YVtuYW1lXSkgPyBkYXRhW25hbWVdLmxlbmd0aCA6IGRhdGFbbmFtZV0pO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IF9ib29seTtcblxuICAgICAgY2FzZSAnRnVuY3Rpb24nOlxuICAgICAgICAvLyBhbGxvdyBjb21wbGV4IGNvbXBhcmlzb25cbiAgICAgICAgcmV0dXJuICEhdmFsdWUoZGF0YVtuYW1lXSwgbmFtZSwgZGF0YSk7XG5cbiAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgaWYgKCFpc0FycmF5KGRhdGFbbmFtZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wID0gd2l0aGluQXJyYXkgPyBhcnJheUNvbnRhaW5zIDogYXJyYXlzRXF1YWw7XG4gICAgICAgIHJldHVybiBvcChkYXRhW25hbWVdLCB2YWx1ZSk7XG5cbiAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgIGlmICghaXNBcnJheShkYXRhW25hbWVdKSkge1xuICAgICAgICAgIHJldHVybiBCb29sZWFuKGRhdGFbbmFtZV0gJiYgZGF0YVtuYW1lXS5tYXRjaCh2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3aXRoaW5BcnJheSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheUNvbnRhaW5zKGRhdGFbbmFtZV0sIHZhbHVlKTtcblxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YVtuYW1lXSkpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVtuYW1lXSA9PT0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdpdGhpbkFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5Q29udGFpbnMoZGF0YVtuYW1lXSwgdmFsdWUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVUkkuaGFzUXVlcnkoKSBhY2NlcHRzIHVuZGVmaW5lZCwgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIsIFJlZ0V4cCwgRnVuY3Rpb24gYXMgdGhlIHZhbHVlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgfTtcblxuXG4gIFVSSS5qb2luUGF0aHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5wdXQgPSBbXTtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICB2YXIgbm9uRW1wdHlTZWdtZW50cyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVybCA9IG5ldyBVUkkoYXJndW1lbnRzW2ldKTtcbiAgICAgIGlucHV0LnB1c2godXJsKTtcbiAgICAgIHZhciBfc2VnbWVudHMgPSB1cmwuc2VnbWVudCgpO1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBfc2VnbWVudHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfc2VnbWVudHNbc10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChfc2VnbWVudHNbc10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9zZWdtZW50c1tzXSkge1xuICAgICAgICAgIG5vbkVtcHR5U2VnbWVudHMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2VnbWVudHMubGVuZ3RoIHx8ICFub25FbXB0eVNlZ21lbnRzKSB7XG4gICAgICByZXR1cm4gbmV3IFVSSSgnJyk7XG4gICAgfVxuXG4gICAgdmFyIHVyaSA9IG5ldyBVUkkoJycpLnNlZ21lbnQoc2VnbWVudHMpO1xuXG4gICAgaWYgKGlucHV0WzBdLnBhdGgoKSA9PT0gJycgfHwgaW5wdXRbMF0ucGF0aCgpLnNsaWNlKDAsIDEpID09PSAnLycpIHtcbiAgICAgIHVyaS5wYXRoKCcvJyArIHVyaS5wYXRoKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1cmkubm9ybWFsaXplKCk7XG4gIH07XG5cbiAgVVJJLmNvbW1vblBhdGggPSBmdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihvbmUubGVuZ3RoLCB0d28ubGVuZ3RoKTtcbiAgICB2YXIgcG9zO1xuXG4gICAgLy8gZmluZCBmaXJzdCBub24tbWF0Y2hpbmcgY2hhcmFjdGVyXG4gICAgZm9yIChwb3MgPSAwOyBwb3MgPCBsZW5ndGg7IHBvcysrKSB7XG4gICAgICBpZiAob25lLmNoYXJBdChwb3MpICE9PSB0d28uY2hhckF0KHBvcykpIHtcbiAgICAgICAgcG9zLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3MgPCAxKSB7XG4gICAgICByZXR1cm4gb25lLmNoYXJBdCgwKSA9PT0gdHdvLmNoYXJBdCgwKSAmJiBvbmUuY2hhckF0KDApID09PSAnLycgPyAnLycgOiAnJztcbiAgICB9XG5cbiAgICAvLyByZXZlcnQgdG8gbGFzdCAvXG4gICAgaWYgKG9uZS5jaGFyQXQocG9zKSAhPT0gJy8nIHx8IHR3by5jaGFyQXQocG9zKSAhPT0gJy8nKSB7XG4gICAgICBwb3MgPSBvbmUuc3Vic3RyaW5nKDAsIHBvcykubGFzdEluZGV4T2YoJy8nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb25lLnN1YnN0cmluZygwLCBwb3MgKyAxKTtcbiAgfTtcblxuICBVUkkud2l0aGluU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdmFyIF9zdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgVVJJLmZpbmRVcmkuc3RhcnQ7XG4gICAgdmFyIF9lbmQgPSBvcHRpb25zLmVuZCB8fCBVUkkuZmluZFVyaS5lbmQ7XG4gICAgdmFyIF90cmltID0gb3B0aW9ucy50cmltIHx8IFVSSS5maW5kVXJpLnRyaW07XG4gICAgdmFyIF9wYXJlbnMgPSBvcHRpb25zLnBhcmVucyB8fCBVUkkuZmluZFVyaS5wYXJlbnM7XG4gICAgdmFyIF9hdHRyaWJ1dGVPcGVuID0gL1thLXowLTktXT1bXCInXT8kL2k7XG5cbiAgICBfc3RhcnQubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIG1hdGNoID0gX3N0YXJ0LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydCA9IG1hdGNoLmluZGV4O1xuICAgICAgaWYgKG9wdGlvbnMuaWdub3JlSHRtbCkge1xuICAgICAgICAvLyBhdHRyaWJ1dChlPVtcIiddPyQpXG4gICAgICAgIHZhciBhdHRyaWJ1dGVPcGVuID0gc3RyaW5nLnNsaWNlKE1hdGgubWF4KHN0YXJ0IC0gMywgMCksIHN0YXJ0KTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU9wZW4gJiYgX2F0dHJpYnV0ZU9wZW4udGVzdChhdHRyaWJ1dGVPcGVuKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmQgPSBzdGFydCArIHN0cmluZy5zbGljZShzdGFydCkuc2VhcmNoKF9lbmQpO1xuICAgICAgdmFyIHNsaWNlID0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGluY2x1ZGUgd2VsbCBiYWxhbmNlZCBwYXJlbnNcbiAgICAgIHZhciBwYXJlbnNFbmQgPSAtMTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBwYXJlbnNNYXRjaCA9IF9wYXJlbnMuZXhlYyhzbGljZSk7XG4gICAgICAgIGlmICghcGFyZW5zTWF0Y2gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnNNYXRjaEVuZCA9IHBhcmVuc01hdGNoLmluZGV4ICsgcGFyZW5zTWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBwYXJlbnNFbmQgPSBNYXRoLm1heChwYXJlbnNFbmQsIHBhcmVuc01hdGNoRW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVuc0VuZCA+IC0xKSB7XG4gICAgICAgIHNsaWNlID0gc2xpY2Uuc2xpY2UoMCwgcGFyZW5zRW5kKSArIHNsaWNlLnNsaWNlKHBhcmVuc0VuZCkucmVwbGFjZShfdHJpbSwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpY2UgPSBzbGljZS5yZXBsYWNlKF90cmltLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbGljZS5sZW5ndGggPD0gbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHRoZSBleHRyYWN0IG9ubHkgY29udGFpbnMgdGhlIHN0YXJ0aW5nIG1hcmtlciBvZiBhIFVSSSxcbiAgICAgICAgLy8gZS5nLiBcInd3d1wiIG9yIFwiaHR0cDovL1wiXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5pZ25vcmUgJiYgb3B0aW9ucy5pZ25vcmUudGVzdChzbGljZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IHN0YXJ0ICsgc2xpY2UubGVuZ3RoO1xuICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKHNsaWNlLCBzdGFydCwgZW5kLCBzdHJpbmcpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9zdGFydC5sYXN0SW5kZXggPSBlbmQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBTdHJpbmcocmVzdWx0KTtcbiAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBzdGFydCkgKyByZXN1bHQgKyBzdHJpbmcuc2xpY2UoZW5kKTtcbiAgICAgIF9zdGFydC5sYXN0SW5kZXggPSBzdGFydCArIHJlc3VsdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgX3N0YXJ0Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcblxuICBVUkkuZW5zdXJlVmFsaWRIb3N0bmFtZSA9IGZ1bmN0aW9uKHYsIHByb3RvY29sKSB7XG4gICAgLy8gVGhlb3JldGljYWxseSBVUklzIGFsbG93IHBlcmNlbnQtZW5jb2RpbmcgaW4gSG9zdG5hbWVzIChhY2NvcmRpbmcgdG8gUkZDIDM5ODYpXG4gICAgLy8gdGhleSBhcmUgbm90IHBhcnQgb2YgRE5TIGFuZCB0aGVyZWZvcmUgaWdub3JlZCBieSBVUkkuanNcblxuICAgIHZhciBoYXNIb3N0bmFtZSA9ICEhdjsgLy8gbm90IG51bGwgYW5kIG5vdCBhbiBlbXB0eSBzdHJpbmdcbiAgICB2YXIgaGFzUHJvdG9jb2wgPSAhIXByb3RvY29sO1xuICAgIHZhciByZWplY3RFbXB0eUhvc3RuYW1lID0gZmFsc2U7XG5cbiAgICBpZiAoaGFzUHJvdG9jb2wpIHtcbiAgICAgIHJlamVjdEVtcHR5SG9zdG5hbWUgPSBhcnJheUNvbnRhaW5zKFVSSS5ob3N0UHJvdG9jb2xzLCBwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgaWYgKHJlamVjdEVtcHR5SG9zdG5hbWUgJiYgIWhhc0hvc3RuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSBjYW5ub3QgYmUgZW1wdHksIGlmIHByb3RvY29sIGlzICcgKyBwcm90b2NvbCk7XG4gICAgfSBlbHNlIGlmICh2ICYmIHYubWF0Y2goVVJJLmludmFsaWRfaG9zdG5hbWVfY2hhcmFjdGVycykpIHtcbiAgICAgIC8vIHRlc3QgcHVueWNvZGVcbiAgICAgIGlmICghcHVueWNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgXCInICsgdiArICdcIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tOl9dIGFuZCBQdW55Y29kZS5qcyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICB9XG4gICAgICBpZiAocHVueWNvZGUudG9BU0NJSSh2KS5tYXRjaChVUkkuaW52YWxpZF9ob3N0bmFtZV9jaGFyYWN0ZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIb3N0bmFtZSBcIicgKyB2ICsgJ1wiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05Li06X10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVVJJLmVuc3VyZVZhbGlkUG9ydCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKCF2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcnQgPSBOdW1iZXIodik7XG4gICAgaWYgKGlzSW50ZWdlcihwb3J0KSAmJiAocG9ydCA+IDApICYmIChwb3J0IDwgNjU1MzYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUG9ydCBcIicgKyB2ICsgJ1wiIGlzIG5vdCBhIHZhbGlkIHBvcnQnKTtcbiAgfTtcblxuICAvLyBub0NvbmZsaWN0XG4gIFVSSS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24ocmVtb3ZlQWxsKSB7XG4gICAgaWYgKHJlbW92ZUFsbCkge1xuICAgICAgdmFyIHVuY29uZmxpY3RlZCA9IHtcbiAgICAgICAgVVJJOiB0aGlzLm5vQ29uZmxpY3QoKVxuICAgICAgfTtcblxuICAgICAgaWYgKHJvb3QuVVJJVGVtcGxhdGUgJiYgdHlwZW9mIHJvb3QuVVJJVGVtcGxhdGUubm9Db25mbGljdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1bmNvbmZsaWN0ZWQuVVJJVGVtcGxhdGUgPSByb290LlVSSVRlbXBsYXRlLm5vQ29uZmxpY3QoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvb3QuSVB2NiAmJiB0eXBlb2Ygcm9vdC5JUHY2Lm5vQ29uZmxpY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdW5jb25mbGljdGVkLklQdjYgPSByb290LklQdjYubm9Db25mbGljdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocm9vdC5TZWNvbmRMZXZlbERvbWFpbnMgJiYgdHlwZW9mIHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zLm5vQ29uZmxpY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdW5jb25mbGljdGVkLlNlY29uZExldmVsRG9tYWlucyA9IHJvb3QuU2Vjb25kTGV2ZWxEb21haW5zLm5vQ29uZmxpY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuY29uZmxpY3RlZDtcbiAgICB9IGVsc2UgaWYgKHJvb3QuVVJJID09PSB0aGlzKSB7XG4gICAgICByb290LlVSSSA9IF9VUkk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5idWlsZCA9IGZ1bmN0aW9uKGRlZmVyQnVpbGQpIHtcbiAgICBpZiAoZGVmZXJCdWlsZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fZGVmZXJyZWRfYnVpbGQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGVmZXJCdWlsZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2RlZmVycmVkX2J1aWxkKSB7XG4gICAgICB0aGlzLl9zdHJpbmcgPSBVUkkuYnVpbGQodGhpcy5fcGFydHMpO1xuICAgICAgdGhpcy5fZGVmZXJyZWRfYnVpbGQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBVUkkodGhpcyk7XG4gIH07XG5cbiAgcC52YWx1ZU9mID0gcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkKGZhbHNlKS5fc3RyaW5nO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTaW1wbGVBY2Nlc3NvcihfcGFydCl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0c1tfcGFydF0gfHwgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJ0c1tfcGFydF0gPSB2IHx8IG51bGw7XG4gICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUHJlZml4QWNjZXNzb3IoX3BhcnQsIF9rZXkpe1xuICAgIHJldHVybiBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydHNbX3BhcnRdIHx8ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT09IG51bGwpIHtcbiAgICAgICAgICB2ID0gdiArICcnO1xuICAgICAgICAgIGlmICh2LmNoYXJBdCgwKSA9PT0gX2tleSkge1xuICAgICAgICAgICAgdiA9IHYuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BhcnRzW19wYXJ0XSA9IHY7XG4gICAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHAucHJvdG9jb2wgPSBnZW5lcmF0ZVNpbXBsZUFjY2Vzc29yKCdwcm90b2NvbCcpO1xuICBwLnVzZXJuYW1lID0gZ2VuZXJhdGVTaW1wbGVBY2Nlc3NvcigndXNlcm5hbWUnKTtcbiAgcC5wYXNzd29yZCA9IGdlbmVyYXRlU2ltcGxlQWNjZXNzb3IoJ3Bhc3N3b3JkJyk7XG4gIHAuaG9zdG5hbWUgPSBnZW5lcmF0ZVNpbXBsZUFjY2Vzc29yKCdob3N0bmFtZScpO1xuICBwLnBvcnQgPSBnZW5lcmF0ZVNpbXBsZUFjY2Vzc29yKCdwb3J0Jyk7XG4gIHAucXVlcnkgPSBnZW5lcmF0ZVByZWZpeEFjY2Vzc29yKCdxdWVyeScsICc/Jyk7XG4gIHAuZnJhZ21lbnQgPSBnZW5lcmF0ZVByZWZpeEFjY2Vzc29yKCdmcmFnbWVudCcsICcjJyk7XG5cbiAgcC5zZWFyY2ggPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIHZhciB0ID0gdGhpcy5xdWVyeSh2LCBidWlsZCk7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09PSAnc3RyaW5nJyAmJiB0Lmxlbmd0aCA/ICgnPycgKyB0KSA6IHQ7XG4gIH07XG4gIHAuaGFzaCA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgdmFyIHQgPSB0aGlzLmZyYWdtZW50KHYsIGJ1aWxkKTtcbiAgICByZXR1cm4gdHlwZW9mIHQgPT09ICdzdHJpbmcnICYmIHQubGVuZ3RoID8gKCcjJyArIHQpIDogdDtcbiAgfTtcblxuICBwLnBhdGhuYW1lID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IHRydWUpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLl9wYXJ0cy5wYXRoIHx8ICh0aGlzLl9wYXJ0cy5ob3N0bmFtZSA/ICcvJyA6ICcnKTtcbiAgICAgIHJldHVybiB2ID8gKHRoaXMuX3BhcnRzLnVybiA/IFVSSS5kZWNvZGVVcm5QYXRoIDogVVJJLmRlY29kZVBhdGgpKHJlcykgOiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHYgPyBVUkkucmVjb2RlVXJuUGF0aCh2KSA6ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHYgPyBVUkkucmVjb2RlUGF0aCh2KSA6ICcvJztcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5wYXRoID0gcC5wYXRobmFtZTtcbiAgcC5ocmVmID0gZnVuY3Rpb24oaHJlZiwgYnVpbGQpIHtcbiAgICB2YXIga2V5O1xuXG4gICAgaWYgKGhyZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpbmcgPSAnJztcbiAgICB0aGlzLl9wYXJ0cyA9IFVSSS5fcGFydHMoKTtcblxuICAgIHZhciBfVVJJID0gaHJlZiBpbnN0YW5jZW9mIFVSSTtcbiAgICB2YXIgX29iamVjdCA9IHR5cGVvZiBocmVmID09PSAnb2JqZWN0JyAmJiAoaHJlZi5ob3N0bmFtZSB8fCBocmVmLnBhdGggfHwgaHJlZi5wYXRobmFtZSk7XG4gICAgaWYgKGhyZWYubm9kZU5hbWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBVUkkuZ2V0RG9tQXR0cmlidXRlKGhyZWYpO1xuICAgICAgaHJlZiA9IGhyZWZbYXR0cmlidXRlXSB8fCAnJztcbiAgICAgIF9vYmplY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyB3aW5kb3cubG9jYXRpb24gaXMgcmVwb3J0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgaXQncyBub3QgdGhlIHNvcnRcbiAgICAvLyBvZiBvYmplY3Qgd2UncmUgbG9va2luZyBmb3I6XG4gICAgLy8gKiBsb2NhdGlvbi5wcm90b2NvbCBlbmRzIHdpdGggYSBjb2xvblxuICAgIC8vICogbG9jYXRpb24ucXVlcnkgIT0gb2JqZWN0LnNlYXJjaFxuICAgIC8vICogbG9jYXRpb24uaGFzaCAhPSBvYmplY3QuZnJhZ21lbnRcbiAgICAvLyBzaW1wbHkgc2VyaWFsaXppbmcgdGhlIHVua25vd24gb2JqZWN0IHNob3VsZCBkbyB0aGUgdHJpY2tcbiAgICAvLyAoZm9yIGxvY2F0aW9uLCBub3QgZm9yIGV2ZXJ5dGhpbmcuLi4pXG4gICAgaWYgKCFfVVJJICYmIF9vYmplY3QgJiYgaHJlZi5wYXRobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBocmVmID0gaHJlZi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycgfHwgaHJlZiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgdGhpcy5fcGFydHMgPSBVUkkucGFyc2UoU3RyaW5nKGhyZWYpLCB0aGlzLl9wYXJ0cyk7XG4gICAgfSBlbHNlIGlmIChfVVJJIHx8IF9vYmplY3QpIHtcbiAgICAgIHZhciBzcmMgPSBfVVJJID8gaHJlZi5fcGFydHMgOiBocmVmO1xuICAgICAgZm9yIChrZXkgaW4gc3JjKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdxdWVyeScpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKGhhc093bi5jYWxsKHRoaXMuX3BhcnRzLCBrZXkpKSB7XG4gICAgICAgICAgdGhpcy5fcGFydHNba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3JjLnF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkoc3JjLnF1ZXJ5LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW5wdXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gaWRlbnRpZmljYXRpb24gYWNjZXNzb3JzXG4gIHAuaXMgPSBmdW5jdGlvbih3aGF0KSB7XG4gICAgdmFyIGlwID0gZmFsc2U7XG4gICAgdmFyIGlwNCA9IGZhbHNlO1xuICAgIHZhciBpcDYgPSBmYWxzZTtcbiAgICB2YXIgbmFtZSA9IGZhbHNlO1xuICAgIHZhciBzbGQgPSBmYWxzZTtcbiAgICB2YXIgaWRuID0gZmFsc2U7XG4gICAgdmFyIHB1bnljb2RlID0gZmFsc2U7XG4gICAgdmFyIHJlbGF0aXZlID0gIXRoaXMuX3BhcnRzLnVybjtcblxuICAgIGlmICh0aGlzLl9wYXJ0cy5ob3N0bmFtZSkge1xuICAgICAgcmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgIGlwNCA9IFVSSS5pcDRfZXhwcmVzc2lvbi50ZXN0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKTtcbiAgICAgIGlwNiA9IFVSSS5pcDZfZXhwcmVzc2lvbi50ZXN0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKTtcbiAgICAgIGlwID0gaXA0IHx8IGlwNjtcbiAgICAgIG5hbWUgPSAhaXA7XG4gICAgICBzbGQgPSBuYW1lICYmIFNMRCAmJiBTTEQuaGFzKHRoaXMuX3BhcnRzLmhvc3RuYW1lKTtcbiAgICAgIGlkbiA9IG5hbWUgJiYgVVJJLmlkbl9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgICAgcHVueWNvZGUgPSBuYW1lICYmIFVSSS5wdW55Y29kZV9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAod2hhdC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdyZWxhdGl2ZSc6XG4gICAgICAgIHJldHVybiByZWxhdGl2ZTtcblxuICAgICAgY2FzZSAnYWJzb2x1dGUnOlxuICAgICAgICByZXR1cm4gIXJlbGF0aXZlO1xuXG4gICAgICAvLyBob3N0bmFtZSBpZGVudGlmaWNhdGlvblxuICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICByZXR1cm4gbmFtZTtcblxuICAgICAgY2FzZSAnc2xkJzpcbiAgICAgICAgcmV0dXJuIHNsZDtcblxuICAgICAgY2FzZSAnaXAnOlxuICAgICAgICByZXR1cm4gaXA7XG5cbiAgICAgIGNhc2UgJ2lwNCc6XG4gICAgICBjYXNlICdpcHY0JzpcbiAgICAgIGNhc2UgJ2luZXQ0JzpcbiAgICAgICAgcmV0dXJuIGlwNDtcblxuICAgICAgY2FzZSAnaXA2JzpcbiAgICAgIGNhc2UgJ2lwdjYnOlxuICAgICAgY2FzZSAnaW5ldDYnOlxuICAgICAgICByZXR1cm4gaXA2O1xuXG4gICAgICBjYXNlICdpZG4nOlxuICAgICAgICByZXR1cm4gaWRuO1xuXG4gICAgICBjYXNlICd1cmwnOlxuICAgICAgICByZXR1cm4gIXRoaXMuX3BhcnRzLnVybjtcblxuICAgICAgY2FzZSAndXJuJzpcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcGFydHMudXJuO1xuXG4gICAgICBjYXNlICdwdW55Y29kZSc6XG4gICAgICAgIHJldHVybiBwdW55Y29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvLyBjb21wb25lbnQgc3BlY2lmaWMgaW5wdXQgdmFsaWRhdGlvblxuICB2YXIgX3Byb3RvY29sID0gcC5wcm90b2NvbDtcbiAgdmFyIF9wb3J0ID0gcC5wb3J0O1xuICB2YXIgX2hvc3RuYW1lID0gcC5ob3N0bmFtZTtcblxuICBwLnByb3RvY29sID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodikge1xuICAgICAgLy8gYWNjZXB0IHRyYWlsaW5nIDovL1xuICAgICAgdiA9IHYucmVwbGFjZSgvOihcXC9cXC8pPyQvLCAnJyk7XG5cbiAgICAgIGlmICghdi5tYXRjaChVUkkucHJvdG9jb2xfZXhwcmVzc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdG9jb2wgXCInICsgdiArICdcIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4rLV0gb3IgZG9lc25cXCd0IHN0YXJ0IHdpdGggW0EtWl0nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3Byb3RvY29sLmNhbGwodGhpcywgdiwgYnVpbGQpO1xuICB9O1xuICBwLnNjaGVtZSA9IHAucHJvdG9jb2w7XG4gIHAucG9ydCA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICB2ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHYpIHtcbiAgICAgICAgdiArPSAnJztcbiAgICAgICAgaWYgKHYuY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgICAgICB2ID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBVUkkuZW5zdXJlVmFsaWRQb3J0KHYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3BvcnQuY2FsbCh0aGlzLCB2LCBidWlsZCk7XG4gIH07XG4gIHAuaG9zdG5hbWUgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHggPSB7IHByZXZlbnRJbnZhbGlkSG9zdG5hbWU6IHRoaXMuX3BhcnRzLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUgfTtcbiAgICAgIHZhciByZXMgPSBVUkkucGFyc2VIb3N0KHYsIHgpO1xuICAgICAgaWYgKHJlcyAhPT0gJy8nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hvc3RuYW1lIFwiJyArIHYgKyAnXCIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTkuLV0nKTtcbiAgICAgIH1cblxuICAgICAgdiA9IHguaG9zdG5hbWU7XG4gICAgICBpZiAodGhpcy5fcGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZSkge1xuICAgICAgICBVUkkuZW5zdXJlVmFsaWRIb3N0bmFtZSh2LCB0aGlzLl9wYXJ0cy5wcm90b2NvbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9ob3N0bmFtZS5jYWxsKHRoaXMsIHYsIGJ1aWxkKTtcbiAgfTtcblxuICAvLyBjb21wb3VuZCBhY2Nlc3NvcnNcbiAgcC5vcmlnaW4gPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCgpO1xuICAgICAgdmFyIGF1dGhvcml0eSA9IHRoaXMuYXV0aG9yaXR5KCk7XG4gICAgICBpZiAoIWF1dGhvcml0eSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAocHJvdG9jb2wgPyBwcm90b2NvbCArICc6Ly8nIDogJycpICsgdGhpcy5hdXRob3JpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9yaWdpbiA9IFVSSSh2KTtcbiAgICAgIHRoaXNcbiAgICAgICAgLnByb3RvY29sKG9yaWdpbi5wcm90b2NvbCgpKVxuICAgICAgICAuYXV0aG9yaXR5KG9yaWdpbi5hdXRob3JpdHkoKSlcbiAgICAgICAgLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHAuaG9zdCA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCA/ICcnIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFydHMuaG9zdG5hbWUgPyBVUkkuYnVpbGRIb3N0KHRoaXMuX3BhcnRzKSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gVVJJLnBhcnNlSG9zdCh2LCB0aGlzLl9wYXJ0cyk7XG4gICAgICBpZiAocmVzICE9PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgXCInICsgdiArICdcIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tXScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHAuYXV0aG9yaXR5ID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gJycgOiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA/IFVSSS5idWlsZEF1dGhvcml0eSh0aGlzLl9wYXJ0cykgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IFVSSS5wYXJzZUF1dGhvcml0eSh2LCB0aGlzLl9wYXJ0cyk7XG4gICAgICBpZiAocmVzICE9PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgXCInICsgdiArICdcIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tXScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHAudXNlcmluZm8gPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHQgPSBVUkkuYnVpbGRVc2VyaW5mbyh0aGlzLl9wYXJ0cyk7XG4gICAgICByZXR1cm4gdCA/IHQuc3Vic3RyaW5nKDAsIHQubGVuZ3RoIC0xKSA6IHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2W3YubGVuZ3RoLTFdICE9PSAnQCcpIHtcbiAgICAgICAgdiArPSAnQCc7XG4gICAgICB9XG5cbiAgICAgIFVSSS5wYXJzZVVzZXJpbmZvKHYsIHRoaXMuX3BhcnRzKTtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5yZXNvdXJjZSA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgdmFyIHBhcnRzO1xuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCgpICsgdGhpcy5zZWFyY2goKSArIHRoaXMuaGFzaCgpO1xuICAgIH1cblxuICAgIHBhcnRzID0gVVJJLnBhcnNlKHYpO1xuICAgIHRoaXMuX3BhcnRzLnBhdGggPSBwYXJ0cy5wYXRoO1xuICAgIHRoaXMuX3BhcnRzLnF1ZXJ5ID0gcGFydHMucXVlcnk7XG4gICAgdGhpcy5fcGFydHMuZnJhZ21lbnQgPSBwYXJ0cy5mcmFnbWVudDtcbiAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZnJhY3Rpb24gYWNjZXNzb3JzXG4gIHAuc3ViZG9tYWluID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gJycgOiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGNvbnZlbmllbmNlLCByZXR1cm4gXCJ3d3dcIiBmcm9tIFwid3d3LmV4YW1wbGUub3JnXCJcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcnRzLmhvc3RuYW1lIHx8IHRoaXMuaXMoJ0lQJykpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBncmFiIGRvbWFpbiBhbmQgYWRkIGFub3RoZXIgc2VnbWVudFxuICAgICAgdmFyIGVuZCA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLmxlbmd0aCAtIHRoaXMuZG9tYWluKCkubGVuZ3RoIC0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoMCwgZW5kKSB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5sZW5ndGggLSB0aGlzLmRvbWFpbigpLmxlbmd0aDtcbiAgICAgIHZhciBzdWIgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoMCwgZSk7XG4gICAgICB2YXIgcmVwbGFjZSA9IG5ldyBSZWdFeHAoJ14nICsgZXNjYXBlUmVnRXgoc3ViKSk7XG5cbiAgICAgIGlmICh2ICYmIHYuY2hhckF0KHYubGVuZ3RoIC0gMSkgIT09ICcuJykge1xuICAgICAgICB2ICs9ICcuJztcbiAgICAgIH1cblxuICAgICAgaWYgKHYuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEb21haW5zIGNhbm5vdCBjb250YWluIGNvbG9ucycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodikge1xuICAgICAgICBVUkkuZW5zdXJlVmFsaWRIb3N0bmFtZSh2LCB0aGlzLl9wYXJ0cy5wcm90b2NvbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhcnRzLmhvc3RuYW1lID0gdGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShyZXBsYWNlLCB2KTtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5kb21haW4gPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGJ1aWxkID0gdjtcbiAgICAgIHYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVuaWVuY2UsIHJldHVybiBcImV4YW1wbGUub3JnXCIgZnJvbSBcInd3dy5leGFtcGxlLm9yZ1wiXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5ob3N0bmFtZSB8fCB0aGlzLmlzKCdJUCcpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgaG9zdG5hbWUgY29uc2lzdHMgb2YgMSBvciAyIHNlZ21lbnRzLCBpdCBtdXN0IGJlIHRoZSBkb21haW5cbiAgICAgIHZhciB0ID0gdGhpcy5fcGFydHMuaG9zdG5hbWUubWF0Y2goL1xcLi9nKTtcbiAgICAgIGlmICh0ICYmIHQubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydHMuaG9zdG5hbWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGdyYWIgdGxkIGFuZCBhZGQgYW5vdGhlciBzZWdtZW50XG4gICAgICB2YXIgZW5kID0gdGhpcy5fcGFydHMuaG9zdG5hbWUubGVuZ3RoIC0gdGhpcy50bGQoYnVpbGQpLmxlbmd0aCAtIDE7XG4gICAgICBlbmQgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5sYXN0SW5kZXhPZignLicsIGVuZCAtMSkgKyAxO1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnRzLmhvc3RuYW1lLnN1YnN0cmluZyhlbmQpIHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBkb21haW4gZW1wdHknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEb21haW5zIGNhbm5vdCBjb250YWluIGNvbG9ucycpO1xuICAgICAgfVxuXG4gICAgICBVUkkuZW5zdXJlVmFsaWRIb3N0bmFtZSh2LCB0aGlzLl9wYXJ0cy5wcm90b2NvbCk7XG5cbiAgICAgIGlmICghdGhpcy5fcGFydHMuaG9zdG5hbWUgfHwgdGhpcy5pcygnSVAnKSkge1xuICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXgodGhpcy5kb21haW4oKSkgKyAnJCcpO1xuICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLnJlcGxhY2UocmVwbGFjZSwgdik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC50bGQgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGJ1aWxkID0gdjtcbiAgICAgIHYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIFwib3JnXCIgZnJvbSBcInd3dy5leGFtcGxlLm9yZ1wiXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5ob3N0bmFtZSB8fCB0aGlzLmlzKCdJUCcpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICB2YXIgdGxkID0gdGhpcy5fcGFydHMuaG9zdG5hbWUuc3Vic3RyaW5nKHBvcyArIDEpO1xuXG4gICAgICBpZiAoYnVpbGQgIT09IHRydWUgJiYgU0xEICYmIFNMRC5saXN0W3RsZC50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICByZXR1cm4gU0xELmdldCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSkgfHwgdGxkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGxkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVwbGFjZTtcblxuICAgICAgaWYgKCF2KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgVExEIGVtcHR5Jyk7XG4gICAgICB9IGVsc2UgaWYgKHYubWF0Y2goL1teYS16QS1aMC05LV0vKSkge1xuICAgICAgICBpZiAoU0xEICYmIFNMRC5pcyh2KSkge1xuICAgICAgICAgIHJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4KHRoaXMudGxkKCkpICsgJyQnKTtcbiAgICAgICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLnJlcGxhY2UocmVwbGFjZSwgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVExEIFwiJyArIHYgKyAnXCIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTldJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BhcnRzLmhvc3RuYW1lIHx8IHRoaXMuaXMoJ0lQJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdjYW5ub3Qgc2V0IFRMRCBvbiBub24tZG9tYWluIGhvc3QnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4KHRoaXMudGxkKCkpICsgJyQnKTtcbiAgICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5yZXBsYWNlKHJlcGxhY2UsIHYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHAuZGlyZWN0b3J5ID0gZnVuY3Rpb24odiwgYnVpbGQpIHtcbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gJycgOiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5wYXRoICYmICF0aGlzLl9wYXJ0cy5ob3N0bmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wYXJ0cy5wYXRoID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICAgIH1cblxuICAgICAgdmFyIGVuZCA9IHRoaXMuX3BhcnRzLnBhdGgubGVuZ3RoIC0gdGhpcy5maWxlbmFtZSgpLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fcGFydHMucGF0aC5zdWJzdHJpbmcoMCwgZW5kKSB8fCAodGhpcy5fcGFydHMuaG9zdG5hbWUgPyAnLycgOiAnJyk7XG5cbiAgICAgIHJldHVybiB2ID8gVVJJLmRlY29kZVBhdGgocmVzKSA6IHJlcztcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3BhcnRzLnBhdGgubGVuZ3RoIC0gdGhpcy5maWxlbmFtZSgpLmxlbmd0aDtcbiAgICAgIHZhciBkaXJlY3RvcnkgPSB0aGlzLl9wYXJ0cy5wYXRoLnN1YnN0cmluZygwLCBlKTtcbiAgICAgIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cCgnXicgKyBlc2NhcGVSZWdFeChkaXJlY3RvcnkpKTtcblxuICAgICAgLy8gZnVsbHkgcXVhbGlmaWVyIGRpcmVjdG9yaWVzIGJlZ2luIHdpdGggYSBzbGFzaFxuICAgICAgaWYgKCF0aGlzLmlzKCdyZWxhdGl2ZScpKSB7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgIHYgPSAnLyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodi5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICAgIHYgPSAnLycgKyB2O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRpcmVjdG9yaWVzIGFsd2F5cyBlbmQgd2l0aCBhIHNsYXNoXG4gICAgICBpZiAodiAmJiB2LmNoYXJBdCh2Lmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgICAgdiArPSAnLyc7XG4gICAgICB9XG5cbiAgICAgIHYgPSBVUkkucmVjb2RlUGF0aCh2KTtcbiAgICAgIHRoaXMuX3BhcnRzLnBhdGggPSB0aGlzLl9wYXJ0cy5wYXRoLnJlcGxhY2UocmVwbGFjZSwgdik7XG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHAuZmlsZW5hbWUgPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCF0aGlzLl9wYXJ0cy5wYXRoIHx8IHRoaXMuX3BhcnRzLnBhdGggPT09ICcvJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3MgPSB0aGlzLl9wYXJ0cy5wYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fcGFydHMucGF0aC5zdWJzdHJpbmcocG9zKzEpO1xuXG4gICAgICByZXR1cm4gdiA/IFVSSS5kZWNvZGVQYXRoU2VnbWVudChyZXMpIDogcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbXV0YXRlZERpcmVjdG9yeSA9IGZhbHNlO1xuXG4gICAgICBpZiAodi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICB2ID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2Lm1hdGNoKC9cXC4/XFwvLykpIHtcbiAgICAgICAgbXV0YXRlZERpcmVjdG9yeSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeCh0aGlzLmZpbGVuYW1lKCkpICsgJyQnKTtcbiAgICAgIHYgPSBVUkkucmVjb2RlUGF0aCh2KTtcbiAgICAgIHRoaXMuX3BhcnRzLnBhdGggPSB0aGlzLl9wYXJ0cy5wYXRoLnJlcGxhY2UocmVwbGFjZSwgdik7XG5cbiAgICAgIGlmIChtdXRhdGVkRGlyZWN0b3J5KSB7XG4gICAgICAgIHRoaXMubm9ybWFsaXplUGF0aChidWlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcC5zdWZmaXggPSBmdW5jdGlvbih2LCBidWlsZCkge1xuICAgIGlmICh0aGlzLl9wYXJ0cy51cm4pIHtcbiAgICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgPyAnJyA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSB0cnVlKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcnRzLnBhdGggfHwgdGhpcy5fcGFydHMucGF0aCA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbGVuYW1lID0gdGhpcy5maWxlbmFtZSgpO1xuICAgICAgdmFyIHBvcyA9IGZpbGVuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICB2YXIgcywgcmVzO1xuXG4gICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIHN1ZmZpeCBtYXkgb25seSBjb250YWluIGFsbnVtIGNoYXJhY3RlcnMgKHl1cCwgSSBtYWRlIHRoaXMgdXAuKVxuICAgICAgcyA9IGZpbGVuYW1lLnN1YnN0cmluZyhwb3MrMSk7XG4gICAgICByZXMgPSAoL15bYS16MC05JV0rJC9pKS50ZXN0KHMpID8gcyA6ICcnO1xuICAgICAgcmV0dXJuIHYgPyBVUkkuZGVjb2RlUGF0aFNlZ21lbnQocmVzKSA6IHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHYuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgdiA9IHYuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3VmZml4ID0gdGhpcy5zdWZmaXgoKTtcbiAgICAgIHZhciByZXBsYWNlO1xuXG4gICAgICBpZiAoIXN1ZmZpeCkge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BhcnRzLnBhdGggKz0gJy4nICsgVVJJLnJlY29kZVBhdGgodik7XG4gICAgICB9IGVsc2UgaWYgKCF2KSB7XG4gICAgICAgIHJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4KCcuJyArIHN1ZmZpeCkgKyAnJCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXgoc3VmZml4KSArICckJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgIHYgPSBVUkkucmVjb2RlUGF0aCh2KTtcbiAgICAgICAgdGhpcy5fcGFydHMucGF0aCA9IHRoaXMuX3BhcnRzLnBhdGgucmVwbGFjZShyZXBsYWNlLCB2KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBwLnNlZ21lbnQgPSBmdW5jdGlvbihzZWdtZW50LCB2LCBidWlsZCkge1xuICAgIHZhciBzZXBhcmF0b3IgPSB0aGlzLl9wYXJ0cy51cm4gPyAnOicgOiAnLyc7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGgoKTtcbiAgICB2YXIgYWJzb2x1dGUgPSBwYXRoLnN1YnN0cmluZygwLCAxKSA9PT0gJy8nO1xuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoc2VwYXJhdG9yKTtcblxuICAgIGlmIChzZWdtZW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHNlZ21lbnQgIT09ICdudW1iZXInKSB7XG4gICAgICBidWlsZCA9IHY7XG4gICAgICB2ID0gc2VnbWVudDtcbiAgICAgIHNlZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc2VnbWVudCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHNlZ21lbnQgXCInICsgc2VnbWVudCArICdcIiwgbXVzdCBiZSAwLWJhc2VkIGludGVnZXInKTtcbiAgICB9XG5cbiAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgIHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQgPCAwKSB7XG4gICAgICAvLyBhbGxvdyBuZWdhdGl2ZSBpbmRleGVzIHRvIGFkZHJlc3MgZnJvbSB0aGUgZW5kXG4gICAgICBzZWdtZW50ID0gTWF0aC5tYXgoc2VnbWVudHMubGVuZ3RoICsgc2VnbWVudCwgMCk7XG4gICAgfVxuXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLypqc2hpbnQgbGF4YnJlYWs6IHRydWUgKi9cbiAgICAgIHJldHVybiBzZWdtZW50ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBzZWdtZW50c1xuICAgICAgICA6IHNlZ21lbnRzW3NlZ21lbnRdO1xuICAgICAgLypqc2hpbnQgbGF4YnJlYWs6IGZhbHNlICovXG4gICAgfSBlbHNlIGlmIChzZWdtZW50ID09PSBudWxsIHx8IHNlZ21lbnRzW3NlZ21lbnRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KHYpKSB7XG4gICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgIC8vIGNvbGxhcHNlIGVtcHR5IGVsZW1lbnRzIHdpdGhpbiBhcnJheVxuICAgICAgICBmb3IgKHZhciBpPTAsIGw9di5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZbaV0ubGVuZ3RoICYmICghc2VnbWVudHMubGVuZ3RoIHx8ICFzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLTFdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggJiYgIXNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHRyaW1TbGFzaGVzKHZbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2IHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2ID0gdHJpbVNsYXNoZXModik7XG4gICAgICAgIGlmIChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLTFdID09PSAnJykge1xuICAgICAgICAgIC8vIGVtcHR5IHRyYWlsaW5nIGVsZW1lbnRzIGhhdmUgdG8gYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAvLyB0byBwcmV2ZW50IHJlc3VsdHMgc3VjaCBhcyAvZm9vLy9iYXJcbiAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLTFdID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIHNlZ21lbnRzW3NlZ21lbnRdID0gdHJpbVNsYXNoZXModik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50cy5zcGxpY2Uoc2VnbWVudCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFic29sdXRlKSB7XG4gICAgICBzZWdtZW50cy51bnNoaWZ0KCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXRoKHNlZ21lbnRzLmpvaW4oc2VwYXJhdG9yKSwgYnVpbGQpO1xuICB9O1xuICBwLnNlZ21lbnRDb2RlZCA9IGZ1bmN0aW9uKHNlZ21lbnQsIHYsIGJ1aWxkKSB7XG4gICAgdmFyIHNlZ21lbnRzLCBpLCBsO1xuXG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgYnVpbGQgPSB2O1xuICAgICAgdiA9IHNlZ21lbnQ7XG4gICAgICBzZWdtZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50KHNlZ21lbnQsIHYsIGJ1aWxkKTtcbiAgICAgIGlmICghaXNBcnJheShzZWdtZW50cykpIHtcbiAgICAgICAgc2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gVVJJLmRlY29kZShzZWdtZW50cykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgc2VnbWVudHNbaV0gPSBVUkkuZGVjb2RlKHNlZ21lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FycmF5KHYpKSB7XG4gICAgICB2ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB2IGluc3RhbmNlb2YgU3RyaW5nKSA/IFVSSS5lbmNvZGUodikgOiB2O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdltpXSA9IFVSSS5lbmNvZGUodltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2VnbWVudChzZWdtZW50LCB2LCBidWlsZCk7XG4gIH07XG5cbiAgLy8gbXV0YXRpbmcgcXVlcnkgc3RyaW5nXG4gIHZhciBxID0gcC5xdWVyeTtcbiAgcC5xdWVyeSA9IGZ1bmN0aW9uKHYsIGJ1aWxkKSB7XG4gICAgaWYgKHYgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBVUkkucGFyc2VRdWVyeSh0aGlzLl9wYXJ0cy5xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGRhdGEgPSBVUkkucGFyc2VRdWVyeSh0aGlzLl9wYXJ0cy5xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gdi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgdGhpcy5fcGFydHMucXVlcnkgPSBVUkkuYnVpbGRRdWVyeShyZXN1bHQgfHwgZGF0YSwgdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcGFydHMucXVlcnkgPSBVUkkuYnVpbGRRdWVyeSh2LCB0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBxLmNhbGwodGhpcywgdiwgYnVpbGQpO1xuICAgIH1cbiAgfTtcbiAgcC5zZXRRdWVyeSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBidWlsZCkge1xuICAgIHZhciBkYXRhID0gVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyB8fCBuYW1lIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBkYXRhW25hbWVdID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKG5hbWUsIGtleSkpIHtcbiAgICAgICAgICBkYXRhW2tleV0gPSBuYW1lW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVVJJLmFkZFF1ZXJ5KCkgYWNjZXB0cyBhbiBvYmplY3QsIHN0cmluZyBhcyB0aGUgbmFtZSBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KGRhdGEsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgYnVpbGQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAuYWRkUXVlcnkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgYnVpbGQpIHtcbiAgICB2YXIgZGF0YSA9IFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICBVUkkuYWRkUXVlcnkoZGF0YSwgbmFtZSwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZSk7XG4gICAgdGhpcy5fcGFydHMucXVlcnkgPSBVUkkuYnVpbGRRdWVyeShkYXRhLCB0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1aWxkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBwLnJlbW92ZVF1ZXJ5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGJ1aWxkKSB7XG4gICAgdmFyIGRhdGEgPSBVUkkucGFyc2VRdWVyeSh0aGlzLl9wYXJ0cy5xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgVVJJLnJlbW92ZVF1ZXJ5KGRhdGEsIG5hbWUsIHZhbHVlKTtcbiAgICB0aGlzLl9wYXJ0cy5xdWVyeSA9IFVSSS5idWlsZFF1ZXJ5KGRhdGEsIHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycywgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgYnVpbGQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAuaGFzUXVlcnkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgd2l0aGluQXJyYXkpIHtcbiAgICB2YXIgZGF0YSA9IFVSSS5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LCB0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtcbiAgICByZXR1cm4gVVJJLmhhc1F1ZXJ5KGRhdGEsIG5hbWUsIHZhbHVlLCB3aXRoaW5BcnJheSk7XG4gIH07XG4gIHAuc2V0U2VhcmNoID0gcC5zZXRRdWVyeTtcbiAgcC5hZGRTZWFyY2ggPSBwLmFkZFF1ZXJ5O1xuICBwLnJlbW92ZVNlYXJjaCA9IHAucmVtb3ZlUXVlcnk7XG4gIHAuaGFzU2VhcmNoID0gcC5oYXNRdWVyeTtcblxuICAvLyBzYW5pdGl6aW5nIFVSTHNcbiAgcC5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcGFydHMudXJuKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAubm9ybWFsaXplUHJvdG9jb2woZmFsc2UpXG4gICAgICAgIC5ub3JtYWxpemVQYXRoKGZhbHNlKVxuICAgICAgICAubm9ybWFsaXplUXVlcnkoZmFsc2UpXG4gICAgICAgIC5ub3JtYWxpemVGcmFnbWVudChmYWxzZSlcbiAgICAgICAgLmJ1aWxkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgICAgIC5ub3JtYWxpemVQcm90b2NvbChmYWxzZSlcbiAgICAgIC5ub3JtYWxpemVIb3N0bmFtZShmYWxzZSlcbiAgICAgIC5ub3JtYWxpemVQb3J0KGZhbHNlKVxuICAgICAgLm5vcm1hbGl6ZVBhdGgoZmFsc2UpXG4gICAgICAubm9ybWFsaXplUXVlcnkoZmFsc2UpXG4gICAgICAubm9ybWFsaXplRnJhZ21lbnQoZmFsc2UpXG4gICAgICAuYnVpbGQoKTtcbiAgfTtcbiAgcC5ub3JtYWxpemVQcm90b2NvbCA9IGZ1bmN0aW9uKGJ1aWxkKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wYXJ0cy5wcm90b2NvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3BhcnRzLnByb3RvY29sID0gdGhpcy5fcGFydHMucHJvdG9jb2wudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcC5ub3JtYWxpemVIb3N0bmFtZSA9IGZ1bmN0aW9uKGJ1aWxkKSB7XG4gICAgaWYgKHRoaXMuX3BhcnRzLmhvc3RuYW1lKSB7XG4gICAgICBpZiAodGhpcy5pcygnSUROJykgJiYgcHVueWNvZGUpIHtcbiAgICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuX3BhcnRzLmhvc3RuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pcygnSVB2NicpICYmIElQdjYpIHtcbiAgICAgICAgdGhpcy5fcGFydHMuaG9zdG5hbWUgPSBJUHY2LmJlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYXJ0cy5ob3N0bmFtZSA9IHRoaXMuX3BhcnRzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAubm9ybWFsaXplUG9ydCA9IGZ1bmN0aW9uKGJ1aWxkKSB7XG4gICAgLy8gcmVtb3ZlIHBvcnQgb2YgaXQncyB0aGUgcHJvdG9jb2wncyBkZWZhdWx0XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wYXJ0cy5wcm90b2NvbCA9PT0gJ3N0cmluZycgJiYgdGhpcy5fcGFydHMucG9ydCA9PT0gVVJJLmRlZmF1bHRQb3J0c1t0aGlzLl9wYXJ0cy5wcm90b2NvbF0pIHtcbiAgICAgIHRoaXMuX3BhcnRzLnBvcnQgPSBudWxsO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBwLm5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihidWlsZCkge1xuICAgIHZhciBfcGF0aCA9IHRoaXMuX3BhcnRzLnBhdGg7XG4gICAgaWYgKCFfcGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgdGhpcy5fcGFydHMucGF0aCA9IFVSSS5yZWNvZGVVcm5QYXRoKHRoaXMuX3BhcnRzLnBhdGgpO1xuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnRzLnBhdGggPT09ICcvJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3BhdGggPSBVUkkucmVjb2RlUGF0aChfcGF0aCk7XG5cbiAgICB2YXIgX3dhc19yZWxhdGl2ZTtcbiAgICB2YXIgX2xlYWRpbmdQYXJlbnRzID0gJyc7XG4gICAgdmFyIF9wYXJlbnQsIF9wb3M7XG5cbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHNcbiAgICBpZiAoX3BhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIF93YXNfcmVsYXRpdmUgPSB0cnVlO1xuICAgICAgX3BhdGggPSAnLycgKyBfcGF0aDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgZmlsZXMgKGFzIG9wcG9zZWQgdG8gZGlyZWN0b3JpZXMpXG4gICAgaWYgKF9wYXRoLnNsaWNlKC0zKSA9PT0gJy8uLicgfHwgX3BhdGguc2xpY2UoLTIpID09PSAnLy4nKSB7XG4gICAgICBfcGF0aCArPSAnLyc7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBzaW1wbGVzXG4gICAgX3BhdGggPSBfcGF0aFxuICAgICAgLnJlcGxhY2UoLyhcXC8oXFwuXFwvKSspfChcXC9cXC4kKS9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpO1xuXG4gICAgLy8gcmVtZW1iZXIgbGVhZGluZyBwYXJlbnRzXG4gICAgaWYgKF93YXNfcmVsYXRpdmUpIHtcbiAgICAgIF9sZWFkaW5nUGFyZW50cyA9IF9wYXRoLnN1YnN0cmluZygxKS5tYXRjaCgvXihcXC5cXC5cXC8pKy8pIHx8ICcnO1xuICAgICAgaWYgKF9sZWFkaW5nUGFyZW50cykge1xuICAgICAgICBfbGVhZGluZ1BhcmVudHMgPSBfbGVhZGluZ1BhcmVudHNbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBwYXJlbnRzXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIF9wYXJlbnQgPSBfcGF0aC5zZWFyY2goL1xcL1xcLlxcLihcXC98JCkvKTtcbiAgICAgIGlmIChfcGFyZW50ID09PSAtMSkge1xuICAgICAgICAvLyBubyBtb3JlIC4uLyB0byByZXNvbHZlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChfcGFyZW50ID09PSAwKSB7XG4gICAgICAgIC8vIHRvcCBsZXZlbCBjYW5ub3QgYmUgcmVsYXRpdmUsIHNraXAgaXRcbiAgICAgICAgX3BhdGggPSBfcGF0aC5zdWJzdHJpbmcoMyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBfcG9zID0gX3BhdGguc3Vic3RyaW5nKDAsIF9wYXJlbnQpLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBpZiAoX3BvcyA9PT0gLTEpIHtcbiAgICAgICAgX3BvcyA9IF9wYXJlbnQ7XG4gICAgICB9XG4gICAgICBfcGF0aCA9IF9wYXRoLnN1YnN0cmluZygwLCBfcG9zKSArIF9wYXRoLnN1YnN0cmluZyhfcGFyZW50ICsgMyk7XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJ0IHRvIHJlbGF0aXZlXG4gICAgaWYgKF93YXNfcmVsYXRpdmUgJiYgdGhpcy5pcygncmVsYXRpdmUnKSkge1xuICAgICAgX3BhdGggPSBfbGVhZGluZ1BhcmVudHMgKyBfcGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFydHMucGF0aCA9IF9wYXRoO1xuICAgIHRoaXMuYnVpbGQoIWJ1aWxkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcC5ub3JtYWxpemVQYXRobmFtZSA9IHAubm9ybWFsaXplUGF0aDtcbiAgcC5ub3JtYWxpemVRdWVyeSA9IGZ1bmN0aW9uKGJ1aWxkKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wYXJ0cy5xdWVyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghdGhpcy5fcGFydHMucXVlcnkubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3BhcnRzLnF1ZXJ5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVlcnkoVVJJLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZCghYnVpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBwLm5vcm1hbGl6ZUZyYWdtZW50ID0gZnVuY3Rpb24oYnVpbGQpIHtcbiAgICBpZiAoIXRoaXMuX3BhcnRzLmZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9wYXJ0cy5mcmFnbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmJ1aWxkKCFidWlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHAubm9ybWFsaXplU2VhcmNoID0gcC5ub3JtYWxpemVRdWVyeTtcbiAgcC5ub3JtYWxpemVIYXNoID0gcC5ub3JtYWxpemVGcmFnbWVudDtcblxuICBwLmlzbzg4NTkgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBleHBlY3QgdW5pY29kZSBpbnB1dCwgaXNvODg1OSBvdXRwdXRcbiAgICB2YXIgZSA9IFVSSS5lbmNvZGU7XG4gICAgdmFyIGQgPSBVUkkuZGVjb2RlO1xuXG4gICAgVVJJLmVuY29kZSA9IGVzY2FwZTtcbiAgICBVUkkuZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBVUkkuZW5jb2RlID0gZTtcbiAgICAgIFVSSS5kZWNvZGUgPSBkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLnVuaWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBleHBlY3QgaXNvODg1OSBpbnB1dCwgdW5pY29kZSBvdXRwdXRcbiAgICB2YXIgZSA9IFVSSS5lbmNvZGU7XG4gICAgdmFyIGQgPSBVUkkuZGVjb2RlO1xuXG4gICAgVVJJLmVuY29kZSA9IHN0cmljdEVuY29kZVVSSUNvbXBvbmVudDtcbiAgICBVUkkuZGVjb2RlID0gdW5lc2NhcGU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubm9ybWFsaXplKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFVSSS5lbmNvZGUgPSBlO1xuICAgICAgVVJJLmRlY29kZSA9IGQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHAucmVhZGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXJpID0gdGhpcy5jbG9uZSgpO1xuICAgIC8vIHJlbW92aW5nIHVzZXJuYW1lLCBwYXNzd29yZCwgYmVjYXVzZSB0aGV5IHNob3VsZG4ndCBiZSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvIFJGQyAzOTg2XG4gICAgdXJpLnVzZXJuYW1lKCcnKS5wYXNzd29yZCgnJykubm9ybWFsaXplKCk7XG4gICAgdmFyIHQgPSAnJztcbiAgICBpZiAodXJpLl9wYXJ0cy5wcm90b2NvbCkge1xuICAgICAgdCArPSB1cmkuX3BhcnRzLnByb3RvY29sICsgJzovLyc7XG4gICAgfVxuXG4gICAgaWYgKHVyaS5fcGFydHMuaG9zdG5hbWUpIHtcbiAgICAgIGlmICh1cmkuaXMoJ3B1bnljb2RlJykgJiYgcHVueWNvZGUpIHtcbiAgICAgICAgdCArPSBwdW55Y29kZS50b1VuaWNvZGUodXJpLl9wYXJ0cy5ob3N0bmFtZSk7XG4gICAgICAgIGlmICh1cmkuX3BhcnRzLnBvcnQpIHtcbiAgICAgICAgICB0ICs9ICc6JyArIHVyaS5fcGFydHMucG9ydDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCArPSB1cmkuaG9zdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1cmkuX3BhcnRzLmhvc3RuYW1lICYmIHVyaS5fcGFydHMucGF0aCAmJiB1cmkuX3BhcnRzLnBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIHQgKz0gJy8nO1xuICAgIH1cblxuICAgIHQgKz0gdXJpLnBhdGgodHJ1ZSk7XG4gICAgaWYgKHVyaS5fcGFydHMucXVlcnkpIHtcbiAgICAgIHZhciBxID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcXAgPSB1cmkuX3BhcnRzLnF1ZXJ5LnNwbGl0KCcmJyksIGwgPSBxcC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGt2ID0gKHFwW2ldIHx8ICcnKS5zcGxpdCgnPScpO1xuICAgICAgICBxICs9ICcmJyArIFVSSS5kZWNvZGVRdWVyeShrdlswXSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSlcbiAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJTI2Jyk7XG5cbiAgICAgICAgaWYgKGt2WzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBxICs9ICc9JyArIFVSSS5kZWNvZGVRdWVyeShrdlsxXSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICclMjYnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdCArPSAnPycgKyBxLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICB0ICs9IFVSSS5kZWNvZGVRdWVyeSh1cmkuaGFzaCgpLCB0cnVlKTtcbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyByZXNvbHZpbmcgcmVsYXRpdmUgYW5kIGFic29sdXRlIFVSTHNcbiAgcC5hYnNvbHV0ZVRvID0gZnVuY3Rpb24oYmFzZSkge1xuICAgIHZhciByZXNvbHZlZCA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgcHJvcGVydGllcyA9IFsncHJvdG9jb2wnLCAndXNlcm5hbWUnLCAncGFzc3dvcmQnLCAnaG9zdG5hbWUnLCAncG9ydCddO1xuICAgIHZhciBiYXNlZGlyLCBpLCBwO1xuXG4gICAgaWYgKHRoaXMuX3BhcnRzLnVybikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVUk5zIGRvIG5vdCBoYXZlIGFueSBnZW5lcmFsbHkgZGVmaW5lZCBoaWVyYXJjaGljYWwgY29tcG9uZW50cycpO1xuICAgIH1cblxuICAgIGlmICghKGJhc2UgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAgICBiYXNlID0gbmV3IFVSSShiYXNlKTtcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZWQuX3BhcnRzLnByb3RvY29sKSB7XG4gICAgICAvLyBEaXJlY3RseSByZXR1cm5zIGV2ZW4gaWYgdGhpcy5fcGFydHMuaG9zdG5hbWUgaXMgZW1wdHkuXG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkLl9wYXJ0cy5wcm90b2NvbCA9IGJhc2UuX3BhcnRzLnByb3RvY29sO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJ0cy5ob3N0bmFtZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IChwID0gcHJvcGVydGllc1tpXSk7IGkrKykge1xuICAgICAgcmVzb2x2ZWQuX3BhcnRzW3BdID0gYmFzZS5fcGFydHNbcF07XG4gICAgfVxuXG4gICAgaWYgKCFyZXNvbHZlZC5fcGFydHMucGF0aCkge1xuICAgICAgcmVzb2x2ZWQuX3BhcnRzLnBhdGggPSBiYXNlLl9wYXJ0cy5wYXRoO1xuICAgICAgaWYgKCFyZXNvbHZlZC5fcGFydHMucXVlcnkpIHtcbiAgICAgICAgcmVzb2x2ZWQuX3BhcnRzLnF1ZXJ5ID0gYmFzZS5fcGFydHMucXVlcnk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXNvbHZlZC5fcGFydHMucGF0aC5zdWJzdHJpbmcoLTIpID09PSAnLi4nKSB7XG4gICAgICAgIHJlc29sdmVkLl9wYXJ0cy5wYXRoICs9ICcvJztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc29sdmVkLnBhdGgoKS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICBiYXNlZGlyID0gYmFzZS5kaXJlY3RvcnkoKTtcbiAgICAgICAgYmFzZWRpciA9IGJhc2VkaXIgPyBiYXNlZGlyIDogYmFzZS5wYXRoKCkuaW5kZXhPZignLycpID09PSAwID8gJy8nIDogJyc7XG4gICAgICAgIHJlc29sdmVkLl9wYXJ0cy5wYXRoID0gKGJhc2VkaXIgPyAoYmFzZWRpciArICcvJykgOiAnJykgKyByZXNvbHZlZC5fcGFydHMucGF0aDtcbiAgICAgICAgcmVzb2x2ZWQubm9ybWFsaXplUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmVkLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkO1xuICB9O1xuICBwLnJlbGF0aXZlVG8gPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgdmFyIHJlbGF0aXZlID0gdGhpcy5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuICAgIHZhciByZWxhdGl2ZVBhcnRzLCBiYXNlUGFydHMsIGNvbW1vbiwgcmVsYXRpdmVQYXRoLCBiYXNlUGF0aDtcblxuICAgIGlmIChyZWxhdGl2ZS5fcGFydHMudXJuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTnMgZG8gbm90IGhhdmUgYW55IGdlbmVyYWxseSBkZWZpbmVkIGhpZXJhcmNoaWNhbCBjb21wb25lbnRzJyk7XG4gICAgfVxuXG4gICAgYmFzZSA9IG5ldyBVUkkoYmFzZSkubm9ybWFsaXplKCk7XG4gICAgcmVsYXRpdmVQYXJ0cyA9IHJlbGF0aXZlLl9wYXJ0cztcbiAgICBiYXNlUGFydHMgPSBiYXNlLl9wYXJ0cztcbiAgICByZWxhdGl2ZVBhdGggPSByZWxhdGl2ZS5wYXRoKCk7XG4gICAgYmFzZVBhdGggPSBiYXNlLnBhdGgoKTtcblxuICAgIGlmIChyZWxhdGl2ZVBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVVJJIGlzIGFscmVhZHkgcmVsYXRpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVBhdGguY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBhIFVSSSByZWxhdGl2ZSB0byBhbm90aGVyIHJlbGF0aXZlIFVSSScpO1xuICAgIH1cblxuICAgIGlmIChyZWxhdGl2ZVBhcnRzLnByb3RvY29sID09PSBiYXNlUGFydHMucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlUGFydHMucHJvdG9jb2wgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChyZWxhdGl2ZVBhcnRzLnVzZXJuYW1lICE9PSBiYXNlUGFydHMudXNlcm5hbWUgfHwgcmVsYXRpdmVQYXJ0cy5wYXNzd29yZCAhPT0gYmFzZVBhcnRzLnBhc3N3b3JkKSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmUuYnVpbGQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVsYXRpdmVQYXJ0cy5wcm90b2NvbCAhPT0gbnVsbCB8fCByZWxhdGl2ZVBhcnRzLnVzZXJuYW1lICE9PSBudWxsIHx8IHJlbGF0aXZlUGFydHMucGFzc3dvcmQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpO1xuICAgIH1cblxuICAgIGlmIChyZWxhdGl2ZVBhcnRzLmhvc3RuYW1lID09PSBiYXNlUGFydHMuaG9zdG5hbWUgJiYgcmVsYXRpdmVQYXJ0cy5wb3J0ID09PSBiYXNlUGFydHMucG9ydCkge1xuICAgICAgcmVsYXRpdmVQYXJ0cy5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZVBhcnRzLnBvcnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmUuYnVpbGQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVsYXRpdmVQYXRoID09PSBiYXNlUGF0aCkge1xuICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gJyc7XG4gICAgICByZXR1cm4gcmVsYXRpdmUuYnVpbGQoKTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgY29tbW9uIHN1YiBwYXRoXG4gICAgY29tbW9uID0gVVJJLmNvbW1vblBhdGgocmVsYXRpdmVQYXRoLCBiYXNlUGF0aCk7XG5cbiAgICAvLyBJZiB0aGUgcGF0aHMgaGF2ZSBub3RoaW5nIGluIGNvbW1vbiwgcmV0dXJuIGEgcmVsYXRpdmUgVVJMIHdpdGggdGhlIGFic29sdXRlIHBhdGguXG4gICAgaWYgKCFjb21tb24pIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZS5idWlsZCgpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRzID0gYmFzZVBhcnRzLnBhdGhcbiAgICAgIC5zdWJzdHJpbmcoY29tbW9uLmxlbmd0aClcbiAgICAgIC5yZXBsYWNlKC9bXlxcL10qJC8sICcnKVxuICAgICAgLnJlcGxhY2UoLy4qP1xcLy9nLCAnLi4vJyk7XG5cbiAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSAocGFyZW50cyArIHJlbGF0aXZlUGFydHMucGF0aC5zdWJzdHJpbmcoY29tbW9uLmxlbmd0aCkpIHx8ICcuLyc7XG5cbiAgICByZXR1cm4gcmVsYXRpdmUuYnVpbGQoKTtcbiAgfTtcblxuICAvLyBjb21wYXJpbmcgVVJJc1xuICBwLmVxdWFscyA9IGZ1bmN0aW9uKHVyaSkge1xuICAgIHZhciBvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIHR3byA9IG5ldyBVUkkodXJpKTtcbiAgICB2YXIgb25lX21hcCA9IHt9O1xuICAgIHZhciB0d29fbWFwID0ge307XG4gICAgdmFyIGNoZWNrZWQgPSB7fTtcbiAgICB2YXIgb25lX3F1ZXJ5LCB0d29fcXVlcnksIGtleTtcblxuICAgIG9uZS5ub3JtYWxpemUoKTtcbiAgICB0d28ubm9ybWFsaXplKCk7XG5cbiAgICAvLyBleGFjdCBtYXRjaFxuICAgIGlmIChvbmUudG9TdHJpbmcoKSA9PT0gdHdvLnRvU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgcXVlcnkgc3RyaW5nXG4gICAgb25lX3F1ZXJ5ID0gb25lLnF1ZXJ5KCk7XG4gICAgdHdvX3F1ZXJ5ID0gdHdvLnF1ZXJ5KCk7XG4gICAgb25lLnF1ZXJ5KCcnKTtcbiAgICB0d28ucXVlcnkoJycpO1xuXG4gICAgLy8gZGVmaW5pdGVseSBub3QgZXF1YWwgaWYgbm90IGV2ZW4gbm9uLXF1ZXJ5IHBhcnRzIG1hdGNoXG4gICAgaWYgKG9uZS50b1N0cmluZygpICE9PSB0d28udG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMgaGF2ZSB0aGUgc2FtZSBsZW5ndGgsIGV2ZW4gaWYgdGhleSdyZSBwZXJtdXRlZFxuICAgIGlmIChvbmVfcXVlcnkubGVuZ3RoICE9PSB0d29fcXVlcnkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25lX21hcCA9IFVSSS5wYXJzZVF1ZXJ5KG9uZV9xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG4gICAgdHdvX21hcCA9IFVSSS5wYXJzZVF1ZXJ5KHR3b19xdWVyeSwgdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7XG5cbiAgICBmb3IgKGtleSBpbiBvbmVfbWFwKSB7XG4gICAgICBpZiAoaGFzT3duLmNhbGwob25lX21hcCwga2V5KSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkob25lX21hcFtrZXldKSkge1xuICAgICAgICAgIGlmIChvbmVfbWFwW2tleV0gIT09IHR3b19tYXBba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghYXJyYXlzRXF1YWwob25lX21hcFtrZXldLCB0d29fbWFwW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tlZFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiB0d29fbWFwKSB7XG4gICAgICBpZiAoaGFzT3duLmNhbGwodHdvX21hcCwga2V5KSkge1xuICAgICAgICBpZiAoIWNoZWNrZWRba2V5XSkge1xuICAgICAgICAgIC8vIHR3byBjb250YWlucyBhIHBhcmFtZXRlciBub3QgcHJlc2VudCBpbiBvbmVcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBzdGF0ZVxuICBwLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUgPSBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy5fcGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZSA9ICEhdjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycyA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMgPSAhIXY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5lc2NhcGVRdWVyeVNwYWNlID0gZnVuY3Rpb24odikge1xuICAgIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UgPSAhIXY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIFVSSTtcbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiVVJJIiwicHVueWNvZGUiLCJJUHY2IiwiU2Vjb25kTGV2ZWxEb21haW5zIiwiU0xEIiwiX1VSSSIsInVybCIsImJhc2UiLCJfdXJsU3VwcGxpZWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJfYmFzZVN1cHBsaWVkIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwibG9jYXRpb24iLCJocmVmIiwiYWJzb2x1dGVUbyIsImlzSW50ZWdlciIsInZhbHVlIiwidGVzdCIsInZlcnNpb24iLCJwIiwicHJvdG90eXBlIiwiaGFzT3duIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJlc2NhcGVSZWdFeCIsInN0cmluZyIsInJlcGxhY2UiLCJnZXRUeXBlIiwiU3RyaW5nIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJpc0FycmF5Iiwib2JqIiwiZmlsdGVyQXJyYXlWYWx1ZXMiLCJkYXRhIiwibG9va3VwIiwiaSIsIl9tYXRjaCIsInNwbGljZSIsImFycmF5Q29udGFpbnMiLCJsaXN0IiwiX3R5cGUiLCJtYXRjaCIsImFycmF5c0VxdWFsIiwib25lIiwidHdvIiwic29ydCIsImwiLCJ0cmltU2xhc2hlcyIsInRleHQiLCJ0cmltX2V4cHJlc3Npb24iLCJfcGFydHMiLCJwcm90b2NvbCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJob3N0bmFtZSIsInVybiIsInBvcnQiLCJwYXRoIiwicXVlcnkiLCJmcmFnbWVudCIsInByZXZlbnRJbnZhbGlkSG9zdG5hbWUiLCJkdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMiLCJlc2NhcGVRdWVyeVNwYWNlIiwicHJvdG9jb2xfZXhwcmVzc2lvbiIsImlkbl9leHByZXNzaW9uIiwicHVueWNvZGVfZXhwcmVzc2lvbiIsImlwNF9leHByZXNzaW9uIiwiaXA2X2V4cHJlc3Npb24iLCJmaW5kX3VyaV9leHByZXNzaW9uIiwiZmluZFVyaSIsInN0YXJ0IiwiZW5kIiwidHJpbSIsInBhcmVucyIsImxlYWRpbmdfd2hpdGVzcGFjZV9leHByZXNzaW9uIiwiYXNjaWlfdGFiX3doaXRlc3BhY2UiLCJkZWZhdWx0UG9ydHMiLCJodHRwIiwiaHR0cHMiLCJmdHAiLCJnb3BoZXIiLCJ3cyIsIndzcyIsImhvc3RQcm90b2NvbHMiLCJpbnZhbGlkX2hvc3RuYW1lX2NoYXJhY3RlcnMiLCJkb21BdHRyaWJ1dGVzIiwiZ2V0RG9tQXR0cmlidXRlIiwibm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJ0eXBlIiwiZXNjYXBlRm9yRHVtYkZpcmVmb3gzNiIsImVzY2FwZSIsInN0cmljdEVuY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsImVuY29kZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlzbzg4NTkiLCJ1bmVzY2FwZSIsInVuaWNvZGUiLCJjaGFyYWN0ZXJzIiwicGF0aG5hbWUiLCJleHByZXNzaW9uIiwibWFwIiwicmVzZXJ2ZWQiLCJ1cm5wYXRoIiwiZW5jb2RlUXVlcnkiLCJlc2NhcGVkIiwiZGVjb2RlUXVlcnkiLCJlIiwiX3BhcnQiLCJnZW5lcmF0ZUFjY2Vzc29yIiwiX2dyb3VwIiwiYyIsImdlbmVyYXRlU2VnbWVudGVkUGF0aEZ1bmN0aW9uIiwiX3NlcCIsIl9jb2RpbmdGdW5jTmFtZSIsIl9pbm5lckNvZGluZ0Z1bmNOYW1lIiwiYWN0dWFsQ29kaW5nRnVuYyIsInNlZ21lbnRzIiwic3BsaXQiLCJqb2luIiwiZGVjb2RlUGF0aCIsImRlY29kZVVyblBhdGgiLCJyZWNvZGVQYXRoIiwicmVjb2RlVXJuUGF0aCIsImVuY29kZVJlc2VydmVkIiwicGFyc2UiLCJwYXJ0cyIsInBvcyIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJwYXJzZUF1dGhvcml0eSIsInBhcnNlSG9zdCIsImJyYWNrZXRQb3MiLCJ0IiwiY2hhckF0IiwiZmlyc3RDb2xvbiIsImZpcnN0U2xhc2giLCJuZXh0Q29sb24iLCJlbnN1cmVWYWxpZEhvc3RuYW1lIiwiZW5zdXJlVmFsaWRQb3J0IiwicGFyc2VVc2VyaW5mbyIsIl9zdHJpbmciLCJmaXJzdEJhY2tTbGFzaCIsImxhc3RJbmRleE9mIiwic2hpZnQiLCJwYXJzZVF1ZXJ5IiwiaXRlbXMiLCJzcGxpdHMiLCJ2IiwibmFtZSIsInB1c2giLCJidWlsZCIsInJlcXVpcmVBYnNvbHV0ZVBhdGgiLCJidWlsZEF1dGhvcml0eSIsImJ1aWxkSG9zdCIsImJ1aWxkVXNlcmluZm8iLCJidWlsZFF1ZXJ5IiwidW5pcXVlIiwia2V5IiwiYnVpbGRRdWVyeVBhcmFtZXRlciIsImFkZFF1ZXJ5IiwiY29uY2F0Iiwic2V0UXVlcnkiLCJyZW1vdmVRdWVyeSIsImhhc1F1ZXJ5Iiwid2l0aGluQXJyYXkiLCJfa2V5IiwiX2Jvb2x5IiwiQm9vbGVhbiIsIm9wIiwiam9pblBhdGhzIiwiaW5wdXQiLCJub25FbXB0eVNlZ21lbnRzIiwiX3NlZ21lbnRzIiwic2VnbWVudCIsInMiLCJ1cmkiLCJub3JtYWxpemUiLCJjb21tb25QYXRoIiwiTWF0aCIsIm1pbiIsIndpdGhpblN0cmluZyIsImNhbGxiYWNrIiwib3B0aW9ucyIsIl9zdGFydCIsIl9lbmQiLCJfdHJpbSIsIl9wYXJlbnMiLCJfYXR0cmlidXRlT3BlbiIsImxhc3RJbmRleCIsImV4ZWMiLCJpbmRleCIsImlnbm9yZUh0bWwiLCJhdHRyaWJ1dGVPcGVuIiwibWF4Iiwic2VhcmNoIiwicGFyZW5zRW5kIiwicGFyZW5zTWF0Y2giLCJwYXJlbnNNYXRjaEVuZCIsImlnbm9yZSIsInJlc3VsdCIsImhhc0hvc3RuYW1lIiwiaGFzUHJvdG9jb2wiLCJyZWplY3RFbXB0eUhvc3RuYW1lIiwidG9BU0NJSSIsIk51bWJlciIsIm5vQ29uZmxpY3QiLCJyZW1vdmVBbGwiLCJ1bmNvbmZsaWN0ZWQiLCJVUklUZW1wbGF0ZSIsImRlZmVyQnVpbGQiLCJfZGVmZXJyZWRfYnVpbGQiLCJjbG9uZSIsInZhbHVlT2YiLCJnZW5lcmF0ZVNpbXBsZUFjY2Vzc29yIiwiZ2VuZXJhdGVQcmVmaXhBY2Nlc3NvciIsImhhc2giLCJyZXMiLCJfb2JqZWN0IiwiYXR0cmlidXRlIiwic3JjIiwiaXMiLCJ3aGF0IiwiaXAiLCJpcDQiLCJpcDYiLCJzbGQiLCJpZG4iLCJyZWxhdGl2ZSIsImhhcyIsIl9wcm90b2NvbCIsIl9wb3J0IiwiX2hvc3RuYW1lIiwic2NoZW1lIiwieCIsIm9yaWdpbiIsImF1dGhvcml0eSIsImhvc3QiLCJ1c2VyaW5mbyIsInJlc291cmNlIiwic3ViZG9tYWluIiwiZG9tYWluIiwic3ViIiwiUmVnRXhwIiwidGxkIiwiZ2V0IiwiUmVmZXJlbmNlRXJyb3IiLCJkaXJlY3RvcnkiLCJmaWxlbmFtZSIsImRlY29kZVBhdGhTZWdtZW50IiwibXV0YXRlZERpcmVjdG9yeSIsIm5vcm1hbGl6ZVBhdGgiLCJzdWZmaXgiLCJzZXBhcmF0b3IiLCJhYnNvbHV0ZSIsIkVycm9yIiwicG9wIiwidW5zaGlmdCIsInNlZ21lbnRDb2RlZCIsInEiLCJzZXRTZWFyY2giLCJhZGRTZWFyY2giLCJyZW1vdmVTZWFyY2giLCJoYXNTZWFyY2giLCJub3JtYWxpemVQcm90b2NvbCIsIm5vcm1hbGl6ZVF1ZXJ5Iiwibm9ybWFsaXplRnJhZ21lbnQiLCJub3JtYWxpemVIb3N0bmFtZSIsIm5vcm1hbGl6ZVBvcnQiLCJiZXN0IiwiX3BhdGgiLCJfd2FzX3JlbGF0aXZlIiwiX2xlYWRpbmdQYXJlbnRzIiwiX3BhcmVudCIsIl9wb3MiLCJub3JtYWxpemVQYXRobmFtZSIsIm5vcm1hbGl6ZVNlYXJjaCIsIm5vcm1hbGl6ZUhhc2giLCJkIiwicmVhZGFibGUiLCJ0b1VuaWNvZGUiLCJxcCIsImt2IiwicmVzb2x2ZWQiLCJwcm9wZXJ0aWVzIiwiYmFzZWRpciIsInJlbGF0aXZlVG8iLCJyZWxhdGl2ZVBhcnRzIiwiYmFzZVBhcnRzIiwiY29tbW9uIiwicmVsYXRpdmVQYXRoIiwiYmFzZVBhdGgiLCJwYXJlbnRzIiwiZXF1YWxzIiwib25lX21hcCIsInR3b19tYXAiLCJjaGVja2VkIiwib25lX3F1ZXJ5IiwidHdvX3F1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/URI.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/urijs/src/punycode.js":
/*!********************************************!*\
  !*** ./node_modules/urijs/src/punycode.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;;\n(function(root) {\n    /** Detect free variables */ var freeExports =  true && exports && !exports.nodeType && exports;\n    var freeModule =  true && module && !module.nodeType && module;\n    var freeGlobal = typeof global == \"object\" && global;\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n        root = freeGlobal;\n    }\n    /**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */ var punycode, /** Highest positive signed 32-bit float value */ maxInt = 2147483647, /** Bootstring parameters */ base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = \"-\", /** Regular expressions */ regexPunycode = /^xn--/, regexNonASCII = /[^\\x20-\\x7E]/, regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, /** Error messages */ errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    }, /** Convenience shortcuts */ baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, /** Temporary variable */ key;\n    /*--------------------------------------------------------------------------*/ /**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */ function error(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */ function map(array, fn) {\n        var length = array.length;\n        var result = [];\n        while(length--){\n            result[length] = fn(array[length]);\n        }\n        return result;\n    }\n    /**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */ function ucs2decode(string) {\n        var output = [], counter = 0, length = string.length, value, extra;\n        while(counter < length){\n            value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // unmatched surrogate; only append this code unit, in case the next\n                    // code unit is the high surrogate of a surrogate pair\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n    /**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */ function ucs2encode(array) {\n        return map(array, function(value) {\n            var output = \"\";\n            if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n            }\n            output += stringFromCharCode(value);\n            return output;\n        }).join(\"\");\n    }\n    /**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */ function basicToDigit(codePoint) {\n        if (codePoint - 48 < 10) {\n            return codePoint - 22;\n        }\n        if (codePoint - 65 < 26) {\n            return codePoint - 65;\n        }\n        if (codePoint - 97 < 26) {\n            return codePoint - 97;\n        }\n        return base;\n    }\n    /**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */ function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    }\n    /**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */ function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base){\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    }\n    /**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */ function decode(input) {\n        // Don't use UCS-2\n        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, /** Cached calculation results */ baseMinusT;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n        for(j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error(\"not-basic\");\n            }\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(index = basic > 0 ? basic + 1 : 0; index < inputLength;){\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            for(oldi = i, w = 1, k = base;; k += base){\n                if (index >= inputLength) {\n                    error(\"invalid-input\");\n                }\n                digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error(\"overflow\");\n                }\n                i += digit * w;\n                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error(\"overflow\");\n                }\n                w *= baseMinusT;\n            }\n            out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error(\"overflow\");\n            }\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output\n            output.splice(i++, 0, n);\n        }\n        return ucs2encode(output);\n    }\n    /**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */ function encode(input) {\n        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], /** `inputLength` will hold the number of code points in `input`. */ inputLength, /** Cached calculation results */ handledCPCountPlusOne, baseMinusT, qMinusT;\n        // Convert the input in UCS-2 to Unicode\n        input = ucs2decode(input);\n        // Cache the length\n        inputLength = input.length;\n        // Initialize the state\n        n = initialN;\n        delta = 0;\n        bias = initialBias;\n        // Handle the basic code points\n        for(j = 0; j < inputLength; ++j){\n            currentValue = input[j];\n            if (currentValue < 0x80) {\n                output.push(stringFromCharCode(currentValue));\n            }\n        }\n        handledCPCount = basicLength = output.length;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string - if it is not empty - with a delimiter\n        if (basicLength) {\n            output.push(delimiter);\n        }\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            for(m = maxInt, j = 0; j < inputLength; ++j){\n                currentValue = input[j];\n                if (currentValue >= n && currentValue < m) {\n                    m = currentValue;\n                }\n            }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow\n            handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error(\"overflow\");\n            }\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            for(j = 0; j < inputLength; ++j){\n                currentValue = input[j];\n                if (currentValue < n && ++delta > maxInt) {\n                    error(\"overflow\");\n                }\n                if (currentValue == n) {\n                    // Represent delta as a generalized variable-length integer\n                    for(q = delta, k = base;; k += base){\n                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                        if (q < t) {\n                            break;\n                        }\n                        qMinusT = q - t;\n                        baseMinusT = base - t;\n                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                        q = floor(qMinusT / baseMinusT);\n                    }\n                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                    delta = 0;\n                    ++handledCPCount;\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    }\n    /**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */ function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    }\n    /**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */ function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    }\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ punycode = {\n        /**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */ \"version\": \"1.3.2\",\n        /**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns\n    // like the following:\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return punycode;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXJpanMvc3JjL3B1bnljb2RlLmpzIiwibWFwcGluZ3MiOiI7O0FBQ0UsVUFBU0EsSUFBSTtJQUVkLDBCQUEwQixHQUMxQixJQUFJQyxjQUFjLEtBQWtCLElBQVlDLFdBQy9DLENBQUNBLFFBQVFDLFFBQVEsSUFBSUQ7SUFDdEIsSUFBSUUsYUFBYSxLQUFpQixJQUFZQyxVQUM3QyxDQUFDQSxPQUFPRixRQUFRLElBQUlFO0lBQ3JCLElBQUlDLGFBQWEsT0FBT0MsVUFBVSxZQUFZQTtJQUM5QyxJQUNDRCxXQUFXQyxNQUFNLEtBQUtELGNBQ3RCQSxXQUFXRSxNQUFNLEtBQUtGLGNBQ3RCQSxXQUFXRyxJQUFJLEtBQUtILFlBQ25CO1FBQ0ROLE9BQU9NO0lBQ1I7SUFFQTs7OztFQUlDLEdBQ0QsSUFBSUksVUFFSiwrQ0FBK0MsR0FDL0NDLFNBQVMsWUFFVCwwQkFBMEIsR0FDMUJDLE9BQU8sSUFDUEMsT0FBTyxHQUNQQyxPQUFPLElBQ1BDLE9BQU8sSUFDUEMsT0FBTyxLQUNQQyxjQUFjLElBQ2RDLFdBQVcsS0FDWEMsWUFBWSxLQUVaLHdCQUF3QixHQUN4QkMsZ0JBQWdCLFNBQ2hCQyxnQkFBZ0IsZ0JBQ2hCQyxrQkFBa0IsNkJBRWxCLG1CQUFtQixHQUNuQkMsU0FBUztRQUNSLFlBQVk7UUFDWixhQUFhO1FBQ2IsaUJBQWlCO0lBQ2xCLEdBRUEsMEJBQTBCLEdBQzFCQyxnQkFBZ0JaLE9BQU9DLE1BQ3ZCWSxRQUFRQyxLQUFLRCxLQUFLLEVBQ2xCRSxxQkFBcUJDLE9BQU9DLFlBQVksRUFFeEMsdUJBQXVCLEdBQ3ZCQztJQUVBLDRFQUE0RSxHQUU1RTs7Ozs7RUFLQyxHQUNELFNBQVNDLE1BQU1DLElBQUk7UUFDbEIsTUFBTSxJQUFJQyxXQUFXVixNQUFNLENBQUNTLEtBQUs7SUFDbEM7SUFFQTs7Ozs7OztFQU9DLEdBQ0QsU0FBU0UsSUFBSUMsS0FBSyxFQUFFQyxFQUFFO1FBQ3JCLElBQUlDLFNBQVNGLE1BQU1FLE1BQU07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Q1gsYUFBYUo7SUFDZDtJQUVBLHNCQUFzQixHQUN0Qiw4RUFBOEU7SUFDOUUsc0JBQXNCO0lBQ3RCLElBQ0MsSUFFVSxFQUNUO1FBQ0RLLG1DQUFtQjtZQUNsQixPQUFPcEY7UUFDUixDQUFDO0FBQUEsa0dBQUM7SUFDSCxPQUFPLEVBYU47QUFFRixHQUFFLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy91cmlqcy9zcmMvcHVueWNvZGUuanM/ZDQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwid2luZG93Iiwic2VsZiIsInB1bnljb2RlIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwiZmxvb3IiLCJNYXRoIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwia2V5IiwiZXJyb3IiLCJ0eXBlIiwiUmFuZ2VFcnJvciIsIm1hcCIsImFycmF5IiwiZm4iLCJsZW5ndGgiLCJyZXN1bHQiLCJtYXBEb21haW4iLCJzdHJpbmciLCJwYXJ0cyIsInNwbGl0IiwicmVwbGFjZSIsImxhYmVscyIsImVuY29kZWQiLCJqb2luIiwidWNzMmRlY29kZSIsIm91dHB1dCIsImNvdW50ZXIiLCJ2YWx1ZSIsImV4dHJhIiwiY2hhckNvZGVBdCIsInB1c2giLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImsiLCJkZWNvZGUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwib3V0IiwiaSIsIm4iLCJiaWFzIiwiYmFzaWMiLCJqIiwiaW5kZXgiLCJvbGRpIiwidyIsInQiLCJiYXNlTWludXNUIiwibGFzdEluZGV4T2YiLCJzcGxpY2UiLCJlbmNvZGUiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwibSIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidGVzdCIsInNsaWNlIiwidG9Mb3dlckNhc2UiLCJ0b0FTQ0lJIiwiZGVmaW5lIiwiYW1kIiwiaGFzT3duUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/urijs/src/punycode.js\n");

/***/ })

};
;