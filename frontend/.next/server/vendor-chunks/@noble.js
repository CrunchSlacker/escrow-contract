"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/curves/_shortw_utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/_shortw_utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createCurve = exports.getHash = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes\n    };\n}\nexports.getHash = getHash;\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, weierstrass_js_1.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n}\nexports.createCurve = createCurve; //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDN0Msb0VBQW9FLEdBQ3BFLE1BQU1JLFNBQVNDLG1CQUFPQSxDQUFDLGlHQUFvQjtBQUMzQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxtR0FBcUI7QUFDN0MsTUFBTUUsbUJBQW1CRixtQkFBT0EsQ0FBQyw2RkFBMkI7QUFDNUQsd0NBQXdDO0FBQ3hDLFNBQVNGLFFBQVFLLElBQUk7SUFDakIsT0FBTztRQUNIQTtRQUNBQyxNQUFNLENBQUNDLEtBQUssR0FBR0MsT0FBUyxDQUFDLEdBQUdQLE9BQU9LLElBQUksRUFBRUQsTUFBTUUsS0FBSyxDQUFDLEdBQUdKLFFBQVFNLFdBQVcsS0FBS0Q7UUFDaEZFLGFBQWFQLFFBQVFPLFdBQVc7SUFDcEM7QUFDSjtBQUNBYixlQUFlLEdBQUdHO0FBQ2xCLFNBQVNELFlBQVlZLFFBQVEsRUFBRUMsT0FBTztJQUNsQyxNQUFNQyxTQUFTLENBQUNSLE9BQVMsQ0FBQyxHQUFHRCxpQkFBaUJVLFdBQVcsRUFBRTtZQUFFLEdBQUdILFFBQVE7WUFBRSxHQUFHWCxRQUFRSyxLQUFLO1FBQUM7SUFDM0YsT0FBT1YsT0FBT29CLE1BQU0sQ0FBQztRQUFFLEdBQUdGLE9BQU9ELFFBQVE7UUFBRUM7SUFBTztBQUN0RDtBQUNBaEIsbUJBQW1CLEdBQUdFLGFBQ3RCLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcz8zMmUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVDdXJ2ZSA9IGV4cG9ydHMuZ2V0SGFzaCA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IGhtYWNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2htYWNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCB3ZWllcnN0cmFzc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIik7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5mdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiAoMCwgaG1hY18xLmhtYWMpKGhhc2gsIGtleSwgKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0SGFzaCA9IGdldEhhc2g7XG5mdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS53ZWllcnN0cmFzcykoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVDdXJ2ZSA9IGNyZWF0ZUN1cnZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVDdXJ2ZSIsImdldEhhc2giLCJobWFjXzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsIndlaWVyc3RyYXNzX2pzXzEiLCJoYXNoIiwiaG1hYyIsImtleSIsIm1zZ3MiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIiwid2VpZXJzdHJhc3MiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/abstract/curve.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/curve.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nexports.validateBasic = validateBasic; //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQzVDLG9FQUFvRSxHQUNwRSwwQkFBMEI7QUFDMUIsTUFBTUksZUFBZUMsbUJBQU9BLENBQUMsNEVBQWM7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsd0VBQVk7QUFDdkMsTUFBTUUsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLDZEQUE2RDtBQUM3RCxtR0FBbUc7QUFDbkcseURBQXlEO0FBQ3pELDREQUE0RDtBQUM1RCwrRUFBK0U7QUFDL0Usb0dBQW9HO0FBQ3BHLG9HQUFvRztBQUNwRyxxQ0FBcUM7QUFDckMsa0dBQWtHO0FBQ2xHLGdHQUFnRztBQUNoRyw4Q0FBOEM7QUFDOUMsU0FBU0wsS0FBS08sQ0FBQyxFQUFFQyxJQUFJO0lBQ2pCLE1BQU1DLGtCQUFrQixDQUFDQyxXQUFXQztRQUNoQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO1FBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0lBQzdCO0lBQ0EsTUFBTUcsT0FBTyxDQUFDQztRQUNWLE1BQU1DLFVBQVVDLEtBQUtDLElBQUksQ0FBQ1YsT0FBT08sS0FBSyxHQUFHLGNBQWM7UUFDdkQsTUFBTUksYUFBYSxLQUFNSixDQUFBQSxJQUFJLElBQUksMEJBQTBCO1FBQzNELE9BQU87WUFBRUM7WUFBU0c7UUFBVztJQUNqQztJQUNBLE9BQU87UUFDSFY7UUFDQSx1Q0FBdUM7UUFDdkNXLGNBQWFDLEdBQUcsRUFBRUMsQ0FBQztZQUNmLElBQUlDLElBQUloQixFQUFFaUIsSUFBSTtZQUNkLElBQUlDLElBQUlKO1lBQ1IsTUFBT0MsSUFBSWxCLElBQUs7Z0JBQ1osSUFBSWtCLElBQUloQixLQUNKaUIsSUFBSUEsRUFBRUcs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WUFDSjtZQUNBLE9BQU8sSUFBSSxDQUFDckQsSUFBSSxDQUFDZSxHQUFHc0MsTUFBTS9CO1FBQzlCO0lBQ0o7QUFDSjtBQUNBekIsWUFBWSxHQUFHRztBQUNmLFNBQVNELGNBQWN5RCxLQUFLO0lBQ3ZCLElBQUd2RCxhQUFhd0QsYUFBYSxFQUFFRCxNQUFNRSxFQUFFO0lBQ3ZDLElBQUd2RCxXQUFXd0QsY0FBYyxFQUFFSCxPQUFPO1FBQ2xDbEMsR0FBRztRQUNIc0MsR0FBRztRQUNIQyxJQUFJO1FBQ0pDLElBQUk7SUFDUixHQUFHO1FBQ0NDLFlBQVk7UUFDWkMsYUFBYTtJQUNqQjtJQUNBLGVBQWU7SUFDZixPQUFPckUsT0FBT3NFLE1BQU0sQ0FBQztRQUNqQixHQUFHLENBQUMsR0FBR2hFLGFBQWFpRSxPQUFPLEVBQUVWLE1BQU1sQyxDQUFDLEVBQUVrQyxNQUFNTyxVQUFVLENBQUM7UUFDdkQsR0FBR1AsS0FBSztRQUNSLEdBQUc7WUFBRWpDLEdBQUdpQyxNQUFNRSxFQUFFLENBQUNTLEtBQUs7UUFBQyxDQUFDO0lBQzVCO0FBQ0o7QUFDQXRFLHFCQUFxQixHQUFHRSxlQUN4QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2N1cnZlLmpzPzg4ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSBleHBvcnRzLndOQUYgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLndOQUYgPSB3TkFGO1xuZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgICgwLCBtb2R1bGFyX2pzXzEudmFsaWRhdGVGaWVsZCkoY3VydmUuRnApO1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLigwLCBtb2R1bGFyX2pzXzEubkxlbmd0aCkoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmFsaWRhdGVCYXNpYyIsIndOQUYiLCJtb2R1bGFyX2pzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImMiLCJiaXRzIiwiY29uc3RUaW1lTmVnYXRlIiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIm5lZ2F0ZSIsIm9wdHMiLCJXIiwid2luZG93cyIsIk1hdGgiLCJjZWlsIiwid2luZG93U2l6ZSIsInVuc2FmZUxhZGRlciIsImVsbSIsIm4iLCJwIiwiWkVSTyIsImQiLCJhZGQiLCJkb3VibGUiLCJwcmVjb21wdXRlV2luZG93IiwicG9pbnRzIiwiYmFzZSIsIndpbmRvdyIsInB1c2giLCJpIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGQ2FjaGVkIiwiUCIsInByZWNvbXB1dGVzTWFwIiwidHJhbnNmb3JtIiwiX1dJTkRPV19TSVpFIiwiY29tcCIsImdldCIsInNldCIsImN1cnZlIiwidmFsaWRhdGVGaWVsZCIsIkZwIiwidmFsaWRhdGVPYmplY3QiLCJoIiwiR3giLCJHeSIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsImZyZWV6ZSIsIm5MZW5ndGgiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!**************************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array) return dst;\n    if (typeof dst === \"string\") return (0, utils_js_1.utf8ToBytes)(dst);\n    throw new Error(\"DST must be Uint8Array or string\");\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    if (DST.length > 255) DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0, utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\nexports.expand_message_xof = expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: \"string\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n}\nexports.createHasher = createHasher; //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUcsS0FBSztBQUNuSSxNQUFNTyxlQUFlQyxtQkFBT0EsQ0FBQyw0RUFBYztBQUMzQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyx3RUFBWTtBQUN2QyxTQUFTRSxZQUFZQyxHQUFHO0lBQ3BCLElBQUlBLGVBQWVDLFlBQ2YsT0FBT0Q7SUFDWCxJQUFJLE9BQU9BLFFBQVEsVUFDZixPQUFPLENBQUMsR0FBR0YsV0FBV0ksV0FBVyxFQUFFRjtJQUN2QyxNQUFNLElBQUlHLE1BQU07QUFDcEI7QUFDQSw2RkFBNkY7QUFDN0YsTUFBTUMsUUFBUU4sV0FBV08sZUFBZTtBQUN4Qyw0Q0FBNEM7QUFDNUMsU0FBU0MsTUFBTWhCLEtBQUssRUFBRWlCLE1BQU07SUFDeEIsSUFBSWpCLFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlpQixRQUFTO1FBQ3pDLE1BQU0sSUFBSUosTUFBTSxDQUFDLHNCQUFzQixFQUFFYixNQUFNLFFBQVEsRUFBRWlCLE9BQU8sQ0FBQztJQUNyRTtJQUNBLE1BQU1DLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFSDtJQUFPLEdBQUdJLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlMLFNBQVMsR0FBR0ssS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR3RCLFFBQVE7UUFDakJBLFdBQVc7SUFDZjtJQUNBLE9BQU8sSUFBSVcsV0FBV087QUFDMUI7QUFDQSxTQUFTSyxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsTUFBTUMsTUFBTSxJQUFJZixXQUFXYSxFQUFFUCxNQUFNO0lBQ25DLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJRSxFQUFFUCxNQUFNLEVBQUVLLElBQUs7UUFDL0JJLEdBQUcsQ0FBQ0osRUFBRSxHQUFHRSxDQUFDLENBQUNGLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFO0lBQ3hCO0lBQ0EsT0FBT0k7QUFDWDtBQUNBLFNBQVNDLFFBQVFDLElBQUk7SUFDakIsSUFBSSxDQUFFQSxDQUFBQSxnQkFBZ0JqQixVQUFTLEdBQzNCLE1BQU0sSUFBSUUsTUFBTTtBQUN4QjtBQUNBLFNBQVNnQixNQUFNRCxJQUFJO0lBQ2YsSUFBSSxDQUFDRSxPQUFPQyxhQUFhLENBQUNILE9BQ3RCLE1BQU0sSUFBSWYsTUFBTTtBQUN4QjtBQUNBLG9HQUFvRztBQUNwRyx1RkFBdUY7QUFDdkYsU0FBU1IsbUJBQW1CMkIsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQztJQUMvQ1IsUUFBUUs7SUFDUkwsUUFBUU07SUFDUkosTUFBTUs7SUFDTix1RkFBdUY7SUFDdkYsSUFBSUQsSUFBSWhCLE1BQU0sR0FBRyxLQUNiZ0IsTUFBTUUsRUFBRSxDQUFDLEdBQUczQixXQUFXNEIsV0FBVyxFQUFFLENBQUMsR0FBRzVCLFdBQVdJLFdBQVcsRUFBRSxzQkFBc0JxQjtJQUMxRixNQUFNLEVBQUVJLFdBQVdDLFVBQVUsRUFBRUMsVUFBVUMsVUFBVSxFQUFFLEdBQUdMO0lBQ3hELE1BQU1NLE1BQU1DLEtBQUtDLElBQUksQ0FBQ1QsYUFBYUk7SUFDbkMsSUFBSUcsTUFBTSxLQUNOLE1BQU0sSUFBSTVCLE1BQU07SUFDcEIsTUFBTStCLFlBQVksQ0FBQyxHQUFHcEMsV0FBVzRCLFdBQVcsRUFBRUgsS0FBS2pCLE1BQU1pQixJQUFJaEIsTUFBTSxFQUFFO0lBQ3JFLE1BQU00QixRQUFRN0IsTUFBTSxHQUFHd0I7SUFDdkIsTUFBTU0sWUFBWTlCLE1BQU1rQixZQUFZLElBQUksbUJBQW1CO0lBQzNELE1BQU1ULElBQUksSUFBSU4sTUFBTXNCO0lBQ3BCLE1BQU1NLE1BQU1aLEVBQUUsQ0FBQyxHQUFHM0IsV0FBVzRCLFdBQVcsRUFBRVMsT0FBT2IsS0FBS2MsV0FBVzlCLE1BQU0sR0FBRyxJQUFJNEI7SUFDOUVuQixDQUFDLENBQUMsRUFBRSxHQUFHVSxFQUFFLENBQUMsR0FBRzNCLFdBQVc0QixXQUFXLEVBQUVXLEtBQUsvQixNQUFNLEdBQUcsSUFBSTRCO0lBQ3ZELElBQUssSUFBSXRCLElBQUksR0FBR0EsS0FBS21CLEtBQUtuQixJQUFLO1FBQzNCLE1BQU0wQixPQUFPO1lBQUN6QixPQUFPd0IsS0FBS3RCLENBQUMsQ0FBQ0gsSUFBSSxFQUFFO1lBQUdOLE1BQU1NLElBQUksR0FBRztZQUFJc0I7U0FBVTtRQUNoRW5CLENBQUMsQ0FBQ0gsRUFBRSxHQUFHYSxFQUFFLENBQUMsR0FBRzNCLFdBQVc0QixXQUFXLEtBQUtZO0lBQzVDO0lBQ0EsTUFBTUMsc0JBQXNCLENBQUMsR0FBR3pDLFdBQVc0QixXQUFXLEtBQUtYO0lBQzNELE9BQU93QixvQkFBb0JDLEtBQUssQ0FBQyxHQUFHaEI7QUFDeEM7QUFDQW5DLDBCQUEwQixHQUFHTTtBQUM3QixTQUFTRCxtQkFBbUI0QixHQUFHLEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFaUIsQ0FBQyxFQUFFaEIsQ0FBQztJQUNsRFIsUUFBUUs7SUFDUkwsUUFBUU07SUFDUkosTUFBTUs7SUFDTix1RkFBdUY7SUFDdkYsb0ZBQW9GO0lBQ3BGLElBQUlELElBQUloQixNQUFNLEdBQUcsS0FBSztRQUNsQixNQUFNbUMsUUFBUVYsS0FBS0MsSUFBSSxDQUFDLElBQUtRLElBQUs7UUFDbENsQixNQUFNRSxFQUFFa0IsTUFBTSxDQUFDO1lBQUVEO1FBQU0sR0FBR0UsTUFBTSxDQUFDLENBQUMsR0FBRzlDLFdBQVdJLFdBQVcsRUFBRSxzQkFBc0IwQyxNQUFNLENBQUNyQixLQUFLc0IsTUFBTTtJQUN6RztJQUNBLElBQUlyQixhQUFhLFNBQVNELElBQUloQixNQUFNLEdBQUcsS0FDbkMsTUFBTSxJQUFJSixNQUFNO0lBQ3BCLE9BQVFzQixFQUFFa0IsTUFBTSxDQUFDO1FBQUVELE9BQU9sQjtJQUFXLEdBQ2hDb0IsTUFBTSxDQUFDdEIsS0FDUHNCLE1BQU0sQ0FBQ3RDLE1BQU1rQixZQUFZLEdBQzFCLDJDQUEyQztLQUMxQ29CLE1BQU0sQ0FBQ3JCLEtBQ1BxQixNQUFNLENBQUN0QyxNQUFNaUIsSUFBSWhCLE1BQU0sRUFBRSxJQUN6QnNDLE1BQU07QUFDZjtBQUNBeEQsMEJBQTBCLEdBQUdLO0FBQzdCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRCxjQUFjNkIsR0FBRyxFQUFFd0IsS0FBSyxFQUFFQyxPQUFPO0lBQ3JDLElBQUdqRCxXQUFXa0QsY0FBYyxFQUFFRCxTQUFTO1FBQ3BDeEIsS0FBSztRQUNMMEIsR0FBRztRQUNIQyxHQUFHO1FBQ0hULEdBQUc7UUFDSFUsTUFBTTtJQUNWO0lBQ0EsTUFBTSxFQUFFRixDQUFDLEVBQUVSLENBQUMsRUFBRVMsQ0FBQyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTdCLEtBQUs4QixJQUFJLEVBQUUsR0FBR047SUFDN0M5QixRQUFRSztJQUNSSCxNQUFNMkI7SUFDTixNQUFNdkIsTUFBTXhCLFlBQVlzRDtJQUN4QixNQUFNQyxRQUFRTCxFQUFFTSxRQUFRLENBQUMsR0FBR2hELE1BQU07SUFDbEMsTUFBTWlELElBQUl4QixLQUFLQyxJQUFJLENBQUMsQ0FBQ3FCLFFBQVFiLENBQUFBLElBQUssSUFBSSx1Q0FBdUM7SUFDN0UsTUFBTWdCLGVBQWVYLFFBQVFJLElBQUlNO0lBQ2pDLElBQUlFLEtBQUssc0JBQXNCO0lBQy9CLElBQUlOLFdBQVcsT0FBTztRQUNsQk0sTUFBTS9ELG1CQUFtQjJCLEtBQUtDLEtBQUtrQyxjQUFjTjtJQUNyRCxPQUNLLElBQUlDLFdBQVcsT0FBTztRQUN2Qk0sTUFBTWhFLG1CQUFtQjRCLEtBQUtDLEtBQUtrQyxjQUFjaEIsR0FBR1U7SUFDeEQsT0FDSyxJQUFJQyxXQUFXLGtCQUFrQjtRQUNsQywwQkFBMEI7UUFDMUJNLE1BQU1wQztJQUNWLE9BQ0s7UUFDRCxNQUFNLElBQUluQixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdELElBQUksSUFBSWxELE1BQU1xQztJQUNwQixJQUFLLElBQUlsQyxJQUFJLEdBQUdBLElBQUlrQyxPQUFPbEMsSUFBSztRQUM1QixNQUFNZ0QsSUFBSSxJQUFJbkQsTUFBTXlDO1FBQ3BCLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJWCxHQUFHVyxJQUFLO1lBQ3hCLE1BQU1DLGFBQWFOLElBQUtLLENBQUFBLElBQUlqRCxJQUFJc0MsQ0FBQUE7WUFDaEMsTUFBTWEsS0FBS0wsSUFBSU0sUUFBUSxDQUFDRixZQUFZQSxhQUFhTjtZQUNqREksQ0FBQyxDQUFDQyxFQUFFLEdBQUcsQ0FBQyxHQUFHakUsYUFBYXFFLEdBQUcsRUFBRTdELE1BQU0yRCxLQUFLZDtRQUM1QztRQUNBVSxDQUFDLENBQUMvQyxFQUFFLEdBQUdnRDtJQUNYO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBdEUscUJBQXFCLEdBQUdJO0FBQ3hCLFNBQVNELFdBQVcwRSxLQUFLLEVBQUVDLEdBQUc7SUFDMUIsNkJBQTZCO0lBQzdCLE1BQU1DLFFBQVFELElBQUlBLEdBQUcsQ0FBQyxDQUFDdkQsSUFBTUgsTUFBTUMsSUFBSSxDQUFDRSxHQUFHeUQsT0FBTztJQUNsRCxPQUFPLENBQUNDLEdBQUdDO1FBQ1AsTUFBTSxDQUFDQyxNQUFNQyxNQUFNQyxNQUFNQyxLQUFLLEdBQUdQLE1BQU1ELEdBQUcsQ0FBQyxDQUFDUyxNQUFRQSxJQUFJQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS2xFLElBQU1zRCxNQUFNYSxHQUFHLENBQUNiLE1BQU1jLEdBQUcsQ0FBQ0YsS0FBS1IsSUFBSTFEO1FBQ3hHMEQsSUFBSUosTUFBTWUsR0FBRyxDQUFDVCxNQUFNQyxPQUFPLGNBQWM7UUFDekNGLElBQUlMLE1BQU1jLEdBQUcsQ0FBQ1QsR0FBR0wsTUFBTWUsR0FBRyxDQUFDUCxNQUFNQyxRQUFRLG9CQUFvQjtRQUM3RCxPQUFPO1lBQUVMO1lBQUdDO1FBQUU7SUFDbEI7QUFDSjtBQUNBbEYsa0JBQWtCLEdBQUdHO0FBQ3JCLFNBQVNELGFBQWEyRixLQUFLLEVBQUVDLFVBQVUsRUFBRUMsR0FBRztJQUN4QyxJQUFJLE9BQU9ELGVBQWUsWUFDdEIsTUFBTSxJQUFJaEYsTUFBTTtJQUNwQixPQUFPO1FBQ0gsd0NBQXdDO1FBQ3hDLG1GQUFtRjtRQUNuRmtGLGFBQVkvRCxHQUFHLEVBQUV5QixPQUFPO1lBQ3BCLE1BQU1ZLElBQUlsRSxjQUFjNkIsS0FBSyxHQUFHO2dCQUFFLEdBQUc4RCxHQUFHO2dCQUFFN0QsS0FBSzZELElBQUk3RCxHQUFHO2dCQUFFLEdBQUd3QixPQUFPO1lBQUM7WUFDbkUsTUFBTXVDLEtBQUtKLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3hCLENBQUMsQ0FBQyxFQUFFO1lBQzNDLE1BQU02QixLQUFLTixNQUFNSyxVQUFVLENBQUNKLFdBQVd4QixDQUFDLENBQUMsRUFBRTtZQUMzQyxNQUFNOEIsSUFBSUgsR0FBR1AsR0FBRyxDQUFDUyxJQUFJRSxhQUFhO1lBQ2xDRCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7UUFDQSxtRkFBbUY7UUFDbkZHLGVBQWN0RSxHQUFHLEVBQUV5QixPQUFPO1lBQ3RCLE1BQU1ZLElBQUlsRSxjQUFjNkIsS0FBSyxHQUFHO2dCQUFFLEdBQUc4RCxHQUFHO2dCQUFFN0QsS0FBSzZELElBQUlTLFNBQVM7Z0JBQUUsR0FBRzlDLE9BQU87WUFBQztZQUN6RSxNQUFNMEMsSUFBSVAsTUFBTUssVUFBVSxDQUFDSixXQUFXeEIsQ0FBQyxDQUFDLEVBQUUsR0FBRytCLGFBQWE7WUFDMURELEVBQUVFLGNBQWM7WUFDaEIsT0FBT0Y7UUFDWDtJQUNKO0FBQ0o7QUFDQXBHLG9CQUFvQixHQUFHRSxjQUN2Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanM/MzI5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGFzaGVyID0gZXhwb3J0cy5pc29nZW55TWFwID0gZXhwb3J0cy5oYXNoX3RvX2ZpZWxkID0gZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94b2YgPSBleHBvcnRzLmV4cGFuZF9tZXNzYWdlX3htZCA9IHZvaWQgMDtcbmNvbnN0IG1vZHVsYXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoZHN0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RTVCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3Igc3RyaW5nJyk7XG59XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xMSNzZWN0aW9uLTUuNC4xXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3htZCA9IGV4cGFuZF9tZXNzYWdlX3htZDtcbmZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNiNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cGFuZF9tZXNzYWdlX3hvZjtcbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTExI3NlY3Rpb24tNS4zXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmcnLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0cy5oYXNoX3RvX2ZpZWxkID0gaGFzaF90b19maWVsZDtcbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMuaXNvZ2VueU1hcCA9IGlzb2dlbnlNYXA7XG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZVxuICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2I3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2I3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlSGFzaGVyID0gY3JlYXRlSGFzaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVIYXNoZXIiLCJpc29nZW55TWFwIiwiaGFzaF90b19maWVsZCIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImV4cGFuZF9tZXNzYWdlX3htZCIsIm1vZHVsYXJfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwidmFsaWRhdGVEU1QiLCJkc3QiLCJVaW50OEFycmF5IiwidXRmOFRvQnl0ZXMiLCJFcnJvciIsIm9zMmlwIiwiYnl0ZXNUb051bWJlckJFIiwiaTJvc3AiLCJsZW5ndGgiLCJyZXMiLCJBcnJheSIsImZyb20iLCJmaWxsIiwiaSIsInN0cnhvciIsImEiLCJiIiwiYXJyIiwiaXNCeXRlcyIsIml0ZW0iLCJpc051bSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJtc2ciLCJEU1QiLCJsZW5JbkJ5dGVzIiwiSCIsImNvbmNhdEJ5dGVzIiwib3V0cHV0TGVuIiwiYl9pbl9ieXRlcyIsImJsb2NrTGVuIiwicl9pbl9ieXRlcyIsImVsbCIsIk1hdGgiLCJjZWlsIiwiRFNUX3ByaW1lIiwiWl9wYWQiLCJsX2lfYl9zdHIiLCJiXzAiLCJhcmdzIiwicHNldWRvX3JhbmRvbV9ieXRlcyIsInNsaWNlIiwiayIsImRrTGVuIiwiY3JlYXRlIiwidXBkYXRlIiwiZGlnZXN0IiwiY291bnQiLCJvcHRpb25zIiwidmFsaWRhdGVPYmplY3QiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJfRFNUIiwibG9nMnAiLCJ0b1N0cmluZyIsIkwiLCJsZW5faW5fYnl0ZXMiLCJwcmIiLCJ1IiwiZSIsImoiLCJlbG1fb2Zmc2V0IiwidHYiLCJzdWJhcnJheSIsIm1vZCIsImZpZWxkIiwibWFwIiwiQ09FRkYiLCJyZXZlcnNlIiwieCIsInkiLCJ4TnVtIiwieERlbiIsInlOdW0iLCJ5RGVuIiwidmFsIiwicmVkdWNlIiwiYWNjIiwiYWRkIiwibXVsIiwiZGl2IiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmIiwiaGFzaFRvQ3VydmUiLCJ1MCIsImZyb21BZmZpbmUiLCJ1MSIsIlAiLCJjbGVhckNvZmFjdG9yIiwiYXNzZXJ0VmFsaWRpdHkiLCJlbmNvZGVUb0N1cnZlIiwiZW5jb2RlRFNUIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/abstract/modular.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/modular.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nexports.invert = invert;\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\n// Generic field functions\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\n// 0 is non-invertible: non-batched version will throw on 0\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\nexports.nLength = nLength;\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar; //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0Esa0JBQWtCLEdBQUdBLGlCQUFpQixHQUFHQSxhQUFhLEdBQUdBLGVBQWUsR0FBR0Esa0JBQWtCLEdBQUdBLGFBQWEsR0FBR0EscUJBQXFCLEdBQUdBLGFBQWEsR0FBR0EscUJBQXFCLEdBQUdBLG9CQUFvQixHQUFHQSxjQUFjLEdBQUdBLHFCQUFxQixHQUFHQSxjQUFjLEdBQUdBLFlBQVksR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUcsS0FBSztBQUMvVSxvRUFBb0UsR0FDcEUsc0RBQXNEO0FBQ3RELE1BQU1tQixhQUFhQyxtQkFBT0EsQ0FBQyx3RUFBWTtBQUN2QyxrQkFBa0I7QUFDbEIsTUFBTUMsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTUksTUFBTUosT0FBTyxJQUFJSyxNQUFNTCxPQUFPLElBQUlNLE1BQU1OLE9BQU87QUFDckQsa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU1QLE9BQU8sSUFBSVEsT0FBT1IsT0FBTztBQUNyQyx3QkFBd0I7QUFDeEIsU0FBU0osSUFBSWEsQ0FBQyxFQUFFQyxDQUFDO0lBQ2IsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVVosTUFBTVksU0FBU0QsSUFBSUM7QUFDeEM7QUFDQWpDLFdBQVcsR0FBR2tCO0FBQ2Q7Ozs7O0NBS0MsR0FDRCxvQ0FBb0M7QUFDcEMsU0FBU0QsSUFBSWlCLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQzNCLElBQUlBLFVBQVVmLE9BQU9jLFFBQVFkLEtBQ3pCLE1BQU0sSUFBSWdCLE1BQU07SUFDcEIsSUFBSUQsV0FBV2IsS0FDWCxP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LElBQUksQ0FBQ1k7SUFDckIsT0FBT2xGLEdBQUcrRCxLQUFLLENBQUM5RCxRQUFRQSxPQUFPRCxHQUFHTSxHQUFHLENBQUNMO0FBQzFDO0FBQ0F6RCxpQkFBaUIsR0FBR0k7QUFDcEIsU0FBU0QsV0FBV3FELEVBQUUsRUFBRWtGLEdBQUc7SUFDdkIsSUFBSSxDQUFDbEYsR0FBRytELEtBQUssRUFDVCxNQUFNLElBQUlsRixNQUFNLENBQUMsd0JBQXdCLENBQUM7SUFDOUMsTUFBTW9CLE9BQU9ELEdBQUdzRSxJQUFJLENBQUNZO0lBQ3JCLE9BQU9sRixHQUFHK0QsS0FBSyxDQUFDOUQsUUFBUUQsR0FBR00sR0FBRyxDQUFDTCxRQUFRQTtBQUMzQztBQUNBekQsa0JBQWtCLEdBQUdHO0FBQ3JCOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTRCxvQkFBb0J5SSxJQUFJLEVBQUVDLFVBQVUsRUFBRTVCLE9BQU8sS0FBSztJQUN2RDJCLE9BQU8sQ0FBQyxHQUFHeEgsV0FBVzBILFdBQVcsRUFBRSxlQUFlRjtJQUNsRCxNQUFNRyxVQUFVSCxLQUFLN0MsTUFBTTtJQUMzQixNQUFNaUQsU0FBU3pJLFFBQVFzSSxZQUFZaEMsV0FBVyxHQUFHO0lBQ2pELElBQUltQyxTQUFTLE1BQU1ELFVBQVVDLFVBQVVELFVBQVUsTUFDN0MsTUFBTSxJQUFJekcsTUFBTSxDQUFDLDhCQUE4QixFQUFFMEcsT0FBTywwQkFBMEIsRUFBRUQsUUFBUSxDQUFDO0lBQ2pHLE1BQU01RyxNQUFNOEUsT0FBTyxDQUFDLEdBQUc3RixXQUFXcUgsZUFBZSxFQUFFRyxRQUFRLENBQUMsR0FBR3hILFdBQVdzSCxlQUFlLEVBQUVFO0lBQzNGLE9BQU96SCxJQUFJZ0IsS0FBSzBHLGFBQWFySCxPQUFPQTtBQUN4QztBQUNBdkIsMkJBQTJCLEdBQUdFLHFCQUM5QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXIuanM/OTcwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFRvUHJpdmF0ZVNjYWxhciA9IGV4cG9ydHMuRnBTcXJ0RXZlbiA9IGV4cG9ydHMuRnBTcXJ0T2RkID0gZXhwb3J0cy5GaWVsZCA9IGV4cG9ydHMubkxlbmd0aCA9IGV4cG9ydHMuRnBJc1NxdWFyZSA9IGV4cG9ydHMuRnBEaXYgPSBleHBvcnRzLkZwSW52ZXJ0QmF0Y2ggPSBleHBvcnRzLkZwUG93ID0gZXhwb3J0cy52YWxpZGF0ZUZpZWxkID0gZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSBleHBvcnRzLkZwU3FydCA9IGV4cG9ydHMudG9uZWxsaVNoYW5rcyA9IGV4cG9ydHMuaW52ZXJ0ID0gZXhwb3J0cy5wb3cyID0gZXhwb3J0cy5wb3cgPSBleHBvcnRzLm1vZCA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuZXhwb3J0cy5tb2QgPSBtb2Q7XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMucG93ID0gcG93O1xuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMucG93MiA9IHBvdzI7XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG4vLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbi8vIFBhcGVyIDE6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbi8vIFBhcGVyIDI6IFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydHMudG9uZWxsaVNoYW5rcyA9IHRvbmVsbGlTaGFua3M7XG5mdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbmV4cG9ydHMuRnBTcXJ0ID0gRnBTcXJ0O1xuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5jb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSBpc05lZ2F0aXZlTEU7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShmaWVsZCwgb3B0cyk7XG59XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5leHBvcnRzLkZwUG93ID0gRnBQb3c7XG4vLyAwIGlzIG5vbi1pbnZlcnRpYmxlOiBub24tYmF0Y2hlZCB2ZXJzaW9uIHdpbGwgdGhyb3cgb24gMFxuZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnRzLkZwSW52ZXJ0QmF0Y2ggPSBGcEludmVydEJhdGNoO1xuZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG5leHBvcnRzLkZwRGl2ID0gRnBEaXY7XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuZXhwb3J0cy5GcElzU3F1YXJlID0gRnBJc1NxdWFyZTtcbi8vIENVUlZFLm4gbGVuZ3Roc1xuZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbmV4cG9ydHMubkxlbmd0aCA9IG5MZW5ndGg7XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZ2Fsb2lzIGZpZWxkIG92ZXIgcHJpbWUuIE5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBnYWluczpcbiAqIGEpIG5vbi1ub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiBiKSBgT2JqZWN0LmZyZWV6ZWBcbiAqIGMpIFNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZwIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogKDAsIHV0aWxzX2pzXzEuYml0TWFzaykoQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShudW0sIEJZVEVTKSA6ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5mdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0cy5GcFNxcnRPZGQgPSBGcFNxcnRPZGQ7XG5mdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbmV4cG9ydHMuRnBTcXJ0RXZlbiA9IEZwU3FydEV2ZW47XG4vKipcbiAqIEZJUFMgMTg2IEIuNC4xLWNvbXBsaWFudCBcImNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobis4KSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQwIGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gY3VydmVGbi5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5mdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGhhc2gpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG5leHBvcnRzLmhhc2hUb1ByaXZhdGVTY2FsYXIgPSBoYXNoVG9Qcml2YXRlU2NhbGFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiRnBTcXJ0RXZlbiIsIkZwU3FydE9kZCIsIkZpZWxkIiwibkxlbmd0aCIsIkZwSXNTcXVhcmUiLCJGcERpdiIsIkZwSW52ZXJ0QmF0Y2giLCJGcFBvdyIsInZhbGlkYXRlRmllbGQiLCJpc05lZ2F0aXZlTEUiLCJGcFNxcnQiLCJ0b25lbGxpU2hhbmtzIiwiaW52ZXJ0IiwicG93MiIsInBvdyIsIm1vZCIsInV0aWxzX2pzXzEiLCJyZXF1aXJlIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiXzVuIiwiXzhuIiwiXzluIiwiXzE2biIsImEiLCJiIiwicmVzdWx0IiwibnVtIiwicG93ZXIiLCJtb2R1bG8iLCJFcnJvciIsInJlcyIsIngiLCJudW1iZXIiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwiUCIsImxlZ2VuZHJlQyIsIlEiLCJTIiwiWiIsInAxZGl2NCIsInRvbmVsbGlGYXN0IiwiRnAiLCJyb290IiwiZXFsIiwic3FyIiwiUTFkaXYyIiwidG9uZWxsaVNsb3ciLCJuZWciLCJPTkUiLCJnIiwibXVsIiwiWkVSTyIsInQyIiwiZ2UiLCJzcXJ0M21vZDQiLCJjMSIsInNxcnQ1bW9kOCIsIm4yIiwibnYiLCJpIiwic3ViIiwiRklFTERfRklFTERTIiwiZmllbGQiLCJpbml0aWFsIiwiT1JERVIiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsInZhbGlkYXRlT2JqZWN0IiwiZiIsInAiLCJkIiwibnVtcyIsInRtcCIsIkFycmF5IiwibGVuZ3RoIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpczAiLCJpbnZlcnRlZCIsImludiIsInJlZHVjZVJpZ2h0IiwibGhzIiwicmhzIiwibGVnZW5kcmVDb25zdCIsIm5CaXRMZW5ndGgiLCJfbkJpdExlbmd0aCIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwibkJ5dGVMZW5ndGgiLCJNYXRoIiwiY2VpbCIsImJpdExlbiIsImlzTEUiLCJyZWRlZiIsInNxcnRQIiwiZnJlZXplIiwiYml0TWFzayIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc09kZCIsImFkZCIsImRpdiIsInNxck4iLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJ0IiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJjbW92IiwiYyIsInRvQnl0ZXMiLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb0J5dGVzQkUiLCJmcm9tQnl0ZXMiLCJieXRlcyIsImJ5dGVzVG9OdW1iZXJMRSIsImJ5dGVzVG9OdW1iZXJCRSIsImVsbSIsImhhc2giLCJncm91cE9yZGVyIiwiZW5zdXJlQnl0ZXMiLCJoYXNoTGVuIiwibWluTGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/abstract/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject; // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHNCQUFzQixHQUFHQSxlQUFlLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsMkJBQTJCLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDdGIsb0VBQW9FLEdBQ3BFLDBFQUEwRTtBQUMxRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLHVDQUF1QztBQUN2QyxNQUFNcUIsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTSxDQUFDQyxJQUFNQSxhQUFhQztBQUNoQyxNQUFNQyxRQUFRQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO0FBQy9FOztDQUVDLEdBQ0QsU0FBU2YsV0FBV2dCLEtBQUs7SUFDckIsSUFBSSxDQUFDWCxJQUFJVyxRQUNMLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixvQ0FBb0M7SUFDcEMsSUFBSUMsTUFBTTtJQUNWLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJRyxNQUFNTCxNQUFNLEVBQUVFLElBQUs7UUFDbkNLLE9BQU9WLEtBQUssQ0FBQ1EsS0FBSyxDQUFDSCxFQUFFLENBQUM7SUFDMUI7SUFDQSxPQUFPSztBQUNYO0FBQ0F0Qyxr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QVdDLEtBQUssSUFBSTdHLE9BQU9pSCxPQUFPLENBQUNSLFlBQzNDRSxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUk3RyxPQUFPaUgsT0FBTyxDQUFDUCxlQUMzQ0MsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxPQUFPVDtBQUNYO0FBQ0FsRyxzQkFBc0IsR0FBR0UsZ0JBQ3pCLHNCQUFzQjtDQUN0Qix1RUFBdUU7Q0FDdkUsZ0ZBQWdGO0NBQ2hGLDRCQUE0QjtDQUM1QiwyREFBMkQ7Q0FDM0QscUVBQXFFO0NBQ3JFLCtEQUErRDtDQUMvRCw0REFBNEQ7Q0FDNUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscy5qcz9jN2QyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IGV4cG9ydHMuY3JlYXRlSG1hY0RyYmcgPSBleHBvcnRzLmJpdE1hc2sgPSBleHBvcnRzLmJpdFNldCA9IGV4cG9ydHMuYml0R2V0ID0gZXhwb3J0cy5iaXRMZW4gPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMuZW5zdXJlQnl0ZXMgPSBleHBvcnRzLm51bWJlclRvVmFyQnl0ZXNCRSA9IGV4cG9ydHMubnVtYmVyVG9CeXRlc0xFID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzQkUgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXJMRSA9IGV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMubnVtYmVyVG9IZXhVbnBhZGRlZCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gbnVtYmVyVG9IZXhVbnBhZGRlZDtcbmZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBudW1iZXJUb0J5dGVzTEU7XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG5leHBvcnRzLm51bWJlclRvVmFyQnl0ZXNCRSA9IG51bWJlclRvVmFyQnl0ZXNCRTtcbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuZXhwb3J0cy5iaXRMZW4gPSBiaXRMZW47XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuZXhwb3J0cy5iaXRHZXQgPSBiaXRHZXQ7XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG5leHBvcnRzLmJpdFNldCA9IGJpdFNldDtcbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuZXhwb3J0cy5iaXRNYXNrID0gYml0TWFzaztcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGNyZWF0ZUhtYWNEcmJnO1xuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmFsaWRhdGVPYmplY3QiLCJjcmVhdGVIbWFjRHJiZyIsImJpdE1hc2siLCJiaXRTZXQiLCJiaXRHZXQiLCJiaXRMZW4iLCJ1dGY4VG9CeXRlcyIsImVxdWFsQnl0ZXMiLCJjb25jYXRCeXRlcyIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9CeXRlc0JFIiwiYnl0ZXNUb051bWJlckxFIiwiYnl0ZXNUb051bWJlckJFIiwiaGV4VG9CeXRlcyIsImhleFRvTnVtYmVyIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsImJ5dGVzVG9IZXgiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidiIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXMiLCJFcnJvciIsImhleCIsIm51bSIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwicmV2ZXJzZSIsIm4iLCJ0aXRsZSIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImFycmF5cyIsInIiLCJyZWR1Y2UiLCJzdW0iLCJwYWQiLCJmb3JFYWNoIiwic2V0IiwiYjEiLCJiMiIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwicG9zIiwidThuIiwiZGF0YSIsInU4ZnIiLCJhcnIiLCJoYXNoTGVuIiwicUJ5dGVMZW4iLCJobWFjRm4iLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsImIiLCJyZXNlZWQiLCJzZWVkIiwiZ2VuIiwib3V0Iiwic2wiLCJwdXNoIiwiZ2VuVW50aWwiLCJwcmVkIiwidW5kZWZpbmVkIiwidmFsaWRhdG9yRm5zIiwiYmlnaW50IiwidmFsIiwiZnVuY3Rpb24iLCJib29sZWFuIiwic3RyaW5nIiwiaXNTYWZlSW50ZWdlciIsImlzQXJyYXkiLCJmaWVsZCIsIm9iamVjdCIsIkZwIiwiaXNWYWxpZCIsImhhc2giLCJvdXRwdXRMZW4iLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiZW50cmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/abstract/weierstrass.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/weierstrass.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b\nconst mod = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/abstract/modular.js\");\nconst ut = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst curve_js_1 = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@noble/curves/abstract/curve.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = exports.DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((c, point, isCompressed)=>{\n        const a = point.toAffine();\n        return ut.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            // Zero is valid point too!\n            if (this.is0()) {\n                if (CURVE.allowInfinityPoint) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y¬≤\n            const right = weierstrassEquation(x); // x¬≥ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nexports.weierstrassPoints = weierstrassPoints;\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size (nBitLength+64)\n         * as per FIPS 186 B.4.1 with modulo bias being neglible.\n         */ randomPrivateKey: ()=>{\n            const rand = CURVE.randomBytes(Fp.BYTES + 8);\n            const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);\n            return ut.numberToBytesBE(num, CURVE.nByteLength);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0, utils_js_1.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)(\"extraEntropy\", e, Fp.BYTES)); // check for being of size BYTES\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof exports.DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\nexports.weierstrass = weierstrass;\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n}\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU; //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLFdBQVcsR0FBRyxLQUFLO0FBQzVILG9FQUFvRSxHQUNwRSw0REFBNEQ7QUFDNUQsTUFBTU8sTUFBTUMsbUJBQU9BLENBQUMsNEVBQWM7QUFDbEMsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsd0VBQVk7QUFDL0IsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsd0VBQVk7QUFDdkMsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsd0VBQVk7QUFDdkMsU0FBU0ksa0JBQWtCQyxLQUFLO0lBQzVCLE1BQU1DLE9BQU8sQ0FBQyxHQUFHSCxXQUFXSSxhQUFhLEVBQUVGO0lBQzNDSixHQUFHTyxjQUFjLENBQUNGLE1BQU07UUFDcEJHLEdBQUc7UUFDSEMsR0FBRztJQUNQLEdBQUc7UUFDQ0MsMEJBQTBCO1FBQzFCQyxnQkFBZ0I7UUFDaEJDLGVBQWU7UUFDZkMsZUFBZTtRQUNmQyxvQkFBb0I7UUFDcEJDLFdBQVc7UUFDWEMsU0FBUztJQUNiO0lBQ0EsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRVYsQ0FBQyxFQUFFLEdBQUdIO0lBQ3hCLElBQUlZLE1BQU07UUFDTixJQUFJLENBQUNDLEdBQUdDLEdBQUcsQ0FBQ1gsR0FBR1UsR0FBR0UsSUFBSSxHQUFHO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBT0osU0FBUyxZQUNoQixPQUFPQSxLQUFLSyxJQUFJLEtBQUssWUFDckIsT0FBT0wsS0FBS00sV0FBVyxLQUFLLFlBQVk7WUFDeEMsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPaEMsT0FBT21DLE1BQU0sQ0FB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QUErQjtRQUN2RUEsSUFBSXpELEdBQUd5UyxJQUFJLENBQUN6UyxHQUFHNkgsR0FBRyxDQUFDcEUsSUFBSUEsR0FBR2tQLEtBQUssNEJBQTRCO1FBQzNEblAsSUFBSXhELEdBQUdpVCxHQUFHLENBQUN6UCxHQUFHK08sTUFBTSxvQkFBb0I7UUFDeEMsT0FBTztZQUFFL087WUFBR0M7UUFBRTtJQUNsQjtBQUNKO0FBQ0FwRiwyQkFBMkIsR0FBR0UscUJBQzlCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/MTNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IGV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBleHBvcnRzLndlaWVyc3RyYXNzID0gZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IGV4cG9ydHMuREVSID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmNvbnN0IG1vZCA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dCA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgY3VydmVfanNfMSA9IHJlcXVpcmUoXCIuL2N1cnZlLmpzXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gKDAsIGN1cnZlX2pzXzEudmFsaWRhdGVCYXNpYykoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydHMuREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gZXhwb3J0cy5ERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IGV4cG9ydHMuREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICAgICAgY29uc3Qgc2xpY2UgPSAocykgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHNsaWNlKGgoc2lnLnMpKTtcbiAgICAgICAgY29uc3QgciA9IHNsaWNlKGgoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCByaGwgPSByLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNsID0gaChzaGwpO1xuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICAgICAgcmV0dXJuIGAzMCR7aChyaGwgKyBzaGwgKyA0KX0wMiR7cmx9JHtyfTAyJHtzbH0ke3N9YDtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKGMsIHBvaW50LCBpc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBaZXJvIGlzIHZhbGlkIHBvaW50IHRvbyFcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmV4cG9ydHMud2VpZXJzdHJhc3NQb2ludHMgPSB3ZWllcnN0cmFzc1BvaW50cztcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKGMsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBleHBvcnRzLkRFUi50b1NpZygoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZSAobkJpdExlbmd0aCs2NClcbiAgICAgICAgICogYXMgcGVyIEZJUFMgMTg2IEIuNC4xIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlibGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5kID0gQ1VSVkUucmFuZG9tQnl0ZXMoRnAuQllURVMgKyA4KTtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9IG1vZC5oYXNoVG9Qcml2YXRlU2NhbGFyKHJhbmQsIENVUlZFX09SREVSKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlLCBGcC5CWVRFUykpOyAvLyBjaGVjayBmb3IgYmVpbmcgb2Ygc2l6ZSBCWVRFU1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIGV4cG9ydHMuREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzZztcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1BBUlNFJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG5leHBvcnRzLndlaWVyc3RyYXNzID0gd2VpZXJzdHJhc3M7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG5leHBvcnRzLlNXVUZwU3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW87XG4vKipcbiAqIEZyb20gZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTZcbiAqL1xuZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJTV1VGcFNxcnRSYXRpbyIsIndlaWVyc3RyYXNzIiwid2VpZXJzdHJhc3NQb2ludHMiLCJERVIiLCJtb2QiLCJyZXF1aXJlIiwidXQiLCJ1dGlsc19qc18xIiwiY3VydmVfanNfMSIsInZhbGlkYXRlUG9pbnRPcHRzIiwiY3VydmUiLCJvcHRzIiwidmFsaWRhdGVCYXNpYyIsInZhbGlkYXRlT2JqZWN0IiwiYSIsImIiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJ3cmFwUHJpdmF0ZUtleSIsImlzVG9yc2lvbkZyZWUiLCJjbGVhckNvZmFjdG9yIiwiYWxsb3dJbmZpbml0eVBvaW50IiwiZnJvbUJ5dGVzIiwidG9CeXRlcyIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsImZyZWV6ZSIsImJ5dGVzVG9OdW1iZXJCRSIsImIybiIsImhleFRvQnl0ZXMiLCJoMmIiLCJFcnIiLCJERVJFcnIiLCJjb25zdHJ1Y3RvciIsIm0iLCJfcGFyc2VJbnQiLCJkYXRhIiwiRSIsImxlbmd0aCIsImxlbiIsInJlcyIsInN1YmFycmF5IiwiZCIsImwiLCJ0b1NpZyIsImhleCIsIlVpbnQ4QXJyYXkiLCJyIiwic0J5dGVzIiwicyIsInJCeXRlc0xlZnQiLCJoZXhGcm9tU2lnIiwic2lnIiwic2xpY2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImgiLCJudW0iLCJ0b1N0cmluZyIsInNobCIsInJobCIsInNsIiwicmwiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJDVVJWRSIsImMiLCJwb2ludCIsImlzQ29tcHJlc3NlZCIsInRvQWZmaW5lIiwiY29uY2F0Qnl0ZXMiLCJmcm9tIiwieCIsInkiLCJieXRlcyIsInRhaWwiLCJCWVRFUyIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJ4MiIsInNxciIsIngzIiwibXVsIiwiYWRkIiwiR3kiLCJHeCIsImlzV2l0aGluQ3VydmVPcmRlciIsIm4iLCJhc3NlcnRHRSIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJrZXkiLCJsZW5ndGhzIiwibkJ5dGVMZW5ndGgiLCJieXRlc1RvSGV4IiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVuc3VyZUJ5dGVzIiwiZXJyb3IiLCJwb2ludFByZWNvbXB1dGVzIiwiTWFwIiwiYXNzZXJ0UHJqUG9pbnQiLCJvdGhlciIsIlBvaW50IiwicHgiLCJweSIsInB6IiwiaXNWYWxpZCIsImZyb21BZmZpbmUiLCJwIiwiaXMwIiwiaSIsIk9ORSIsIm5vcm1hbGl6ZVoiLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiZnJvbUhleCIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJtdWx0aXBseSIsIl9zZXRXaW5kb3dTaXplIiwid2luZG93U2l6ZSIsIl9XSU5ET1dfU0laRSIsImRlbGV0ZSIsImxlZnQiLCJyaWdodCIsImhhc0V2ZW5ZIiwiaXNPZGQiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsIndOQUYiLCJ3bmFmIiwid05BRkNhY2hlZCIsImNvbXAiLCJtdWx0aXBseVVuc2FmZSIsIkkiLCJ1bnNhZmVMYWRkZXIiLCJrMW5lZyIsImsxIiwiazJuZWciLCJrMiIsImsxcCIsImsycCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsInVuZGVmaW5lZCIsIml6IiwieiIsImludiIsImF4IiwiYXkiLCJ6eiIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsInRvSGV4IiwiX2JpdHMiLCJuQml0TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJQcm9qZWN0aXZlUG9pbnQiLCJ2YWxpZGF0ZU9wdHMiLCJoYXNoIiwiaG1hYyIsInJhbmRvbUJ5dGVzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibG93UyIsImN1cnZlRGVmIiwiQ1VSVkVfT1JERVIiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwiaXNWYWxpZEZpZWxkRWxlbWVudCIsIk9SREVSIiwibW9kTiIsImludk4iLCJpbnZlcnQiLCJjYXQiLCJoZWFkIiwieTIiLCJzcXJ0IiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsInJhbmQiLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwicHJlY29tcHV0ZSIsImdldFB1YmxpY0tleSIsImlzUHJvYlB1YiIsIml0ZW0iLCJhcnIiLCJzdHIiLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJiaXRNYXNrIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsInNvbWUiLCJrIiwicHJlaGFzaCIsImV4dHJhRW50cm9weSIsImVudCIsImgxaW50Iiwic2VlZEFyZ3MiLCJlIiwicHVzaCIsInNlZWQiLCJrMnNpZyIsImtCeXRlcyIsImlrIiwicSIsIm5vcm1TIiwiZGVmYXVsdFZlck9wdHMiLCJzaWduIiwicHJpdktleSIsIkMiLCJkcmJnIiwiY3JlYXRlSG1hY0RyYmciLCJvdXRwdXRMZW4iLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJzZyIsIl9zaWciLCJkZXJFcnJvciIsIm1lc3NhZ2UiLCJpcyIsInYiLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJwb3ciLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInkxIiwidmFsaWRhdGVGaWVsZCIsIkEiLCJCIiwidHY2IiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\nexports[\"default\"] = assert; //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsWUFBWSxHQUFHQSxhQUFhLEdBQUdBLFlBQVksR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdEcsU0FBU08sT0FBT0MsQ0FBQztJQUNiLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixNQUFNQSxJQUFJLEdBQ2hDLE1BQU0sSUFBSUcsTUFBTSxDQUFDLHdCQUF3QixFQUFFSCxFQUFFLENBQUM7QUFDdEQ7QUFDQVIsY0FBYyxHQUFHTztBQUNqQixTQUFTRCxLQUFLTSxDQUFDO0lBQ1gsSUFBSSxPQUFPQSxNQUFNLFdBQ2IsTUFBTSxJQUFJRCxNQUFNLENBQUMsc0JBQXNCLEVBQUVDLEVBQUUsQ0FBQztBQUNwRDtBQUNBWixZQUFZLEdBQUdNO0FBQ2YsU0FBU0QsTUFBTU8sQ0FBQyxFQUFFLEdBQUdDLE9BQU87SUFDeEIsSUFBSSxDQUFFRCxDQUFBQSxhQUFhRSxVQUFTLEdBQ3hCLE1BQU0sSUFBSUgsTUFBTTtJQUNwQixJQUFJRSxRQUFRRSxNQUFNLEdBQUcsS0FBSyxDQUFDRixRQUFRRyxRQUFRLENBQUNKLEVBQUVHLE1BQU0sR0FDaEQsTUFBTSxJQUFJSixNQUFNLENBQUMsOEJBQThCLEVBQUVFLFFBQVEsZ0JBQWdCLEVBQUVELEVBQUVHLE1BQU0sQ0FBQyxDQUFDO0FBQzdGO0FBQ0FmLGFBQWEsR0FBR0s7QUFDaEIsU0FBU0QsS0FBS0EsSUFBSTtJQUNkLElBQUksT0FBT0EsU0FBUyxjQUFjLE9BQU9BLEtBQUthLE1BQU0sS0FBSyxZQUNyRCxNQUFNLElBQUlOLE1BQU07SUFDcEJKLE9BQU9ILEtBQUtjLFNBQVM7SUFDckJYLE9BQU9ILEtBQUtlLFFBQVE7QUFDeEI7QUFDQW5CLFlBQVksR0FBR0k7QUFDZixTQUFTRCxPQUFPaUIsUUFBUSxFQUFFQyxnQkFBZ0IsSUFBSTtJQUMxQyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSVgsTUFBTTtJQUNwQixJQUFJVSxpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJWixNQUFNO0FBQ3hCO0FBQ0FYLGNBQWMsR0FBR0c7QUFDakIsU0FBU0QsT0FBT3NCLEdBQUcsRUFBRUosUUFBUTtJQUN6QmYsTUFBTW1CO0lBQ04sTUFBTUMsTUFBTUwsU0FBU0YsU0FBUztJQUM5QixJQUFJTSxJQUFJVCxNQUFNLEdBQUdVLEtBQUs7UUFDbEIsTUFBTSxJQUFJZCxNQUFNLENBQUMsc0RBQXNELEVBQUVjLElBQUksQ0FBQztJQUNsRjtBQUNKO0FBQ0F6QixjQUFjLEdBQUdFO0FBQ2pCLE1BQU13QixTQUFTO0lBQ1huQjtJQUNBRDtJQUNBRDtJQUNBRDtJQUNBRDtJQUNBRDtBQUNKO0FBQ0FGLGtCQUFlLEdBQUcwQixRQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanM/YTQwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm91dHB1dCIsImV4aXN0cyIsImhhc2giLCJieXRlcyIsImJvb2wiLCJudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYiIsImxlbmd0aHMiLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJjcmVhdGUiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwib3V0IiwibWluIiwiYXNzZXJ0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js":
/*!************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2; //# sourceMappingURL=_sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHLEtBQUs7QUFDcEIsTUFBTUcsZUFBZUMsbUJBQU9BLENBQUMsOEZBQWM7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEZBQVk7QUFDdkMseUJBQXlCO0FBQ3pCLFNBQVNFLGFBQWFDLElBQUksRUFBRUMsVUFBVSxFQUFFUCxLQUFLLEVBQUVRLElBQUk7SUFDL0MsSUFBSSxPQUFPRixLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDRSxZQUFZUCxPQUFPUTtJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPYixRQUFRVztJQUMxQixNQUFNSSxJQUFJUCxPQUFPLElBQUk7SUFDckIsTUFBTVEsSUFBSVIsT0FBTyxJQUFJO0lBQ3JCRixLQUFLVyxTQUFTLENBQUNWLGFBQWFRLEdBQUdILElBQUlKO0lBQ25DRixLQUFLVyxTQUFTLENBQUNWLGFBQWFTLEdBQUdGLElBQUlOO0FBQ3ZDO0FBQ0EsNkJBQTZCO0FBQzdCLE1BQU1QLGFBQWFHLFdBQVdjLElBQUk7SUFDOUJDLFlBQVlDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVkLElBQUksQ0FBRTtRQUM5QyxLQUFLO1FBQ0wsSUFBSSxDQUFDWSxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDZCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDZSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxD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SUFBSWUsTUFBTTtRQUNwQixNQUFNQyxTQUFTaEIsTUFBTTtRQUNyQixNQUFNaUIsUUFBUSxJQUFJLENBQUNDLEdBQUc7UUFDdEIsSUFBSUYsU0FBU0MsTUFBTTVCLE1BQU0sRUFDckIsTUFBTSxJQUFJMEIsTUFBTTtRQUNwQixJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSUcsUUFBUUgsSUFDeEJDLE1BQU1oQyxTQUFTLENBQUMsSUFBSStCLEdBQUdJLEtBQUssQ0FBQ0osRUFBRSxFQUFFeEM7SUFDekM7SUFDQThDLFNBQVM7UUFDTCxNQUFNLEVBQUUzQixNQUFNLEVBQUVOLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDbEMsSUFBSSxDQUFDdUIsVUFBVSxDQUFDakI7UUFDaEIsTUFBTTRCLE1BQU01QixPQUFPNkIsS0FBSyxDQUFDLEdBQUduQztRQUM1QixJQUFJLENBQUNvQyxPQUFPO1FBQ1osT0FBT0Y7SUFDWDtJQUNBRyxXQUFXQyxFQUFFLEVBQUU7UUFDWEEsTUFBT0EsQ0FBQUEsS0FBSyxJQUFJLElBQUksQ0FBQ3hDLFdBQVcsRUFBQztRQUNqQ3dDLEdBQUdsQixHQUFHLElBQUksSUFBSSxDQUFDWSxHQUFHO1FBQ2xCLE1BQU0sRUFBRWpDLFFBQVEsRUFBRU8sTUFBTSxFQUFFSCxNQUFNLEVBQUVELFFBQVEsRUFBRUcsU0FBUyxFQUFFRCxHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ25Fa0MsR0FBR25DLE1BQU0sR0FBR0E7UUFDWm1DLEdBQUdsQyxHQUFHLEdBQUdBO1FBQ1RrQyxHQUFHcEMsUUFBUSxHQUFHQTtRQUNkb0MsR0FBR2pDLFNBQVMsR0FBR0E7UUFDZixJQUFJRixTQUFTSixVQUNUdUMsR0FBR2hDLE1BQU0sQ0FBQ2MsR0FBRyxDQUFDZDtRQUNsQixPQUFPZ0M7SUFDWDtBQUNKO0FBQ0E1RCxZQUFZLEdBQUdFLE1BQ2YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fc2hhMi5qcz81OGRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEEyID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuY2xhc3MgU0hBMiBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyID0gU0hBMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNIQTIiLCJfYXNzZXJ0X2pzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwiY3JlYXRlVmlldyIsInVwZGF0ZSIsImRhdGEiLCJkZWZhdWx0IiwiZXhpc3RzIiwidG9CeXRlcyIsImxlbiIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsIm91dHB1dCIsImZpbGwiLCJpIiwib3ZpZXciLCJFcnJvciIsIm91dExlbiIsInN0YXRlIiwiZ2V0IiwiZGlnZXN0IiwicmVzIiwic2xpY2UiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/cryptoNode.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/cryptoNode.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixvRkFBb0Y7QUFDcEYsNEJBQTRCO0FBQzVCLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2IsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaENKLGNBQWMsR0FBR0csTUFBTSxPQUFPQSxPQUFPLFlBQVksZUFBZUEsS0FBS0EsR0FBR0UsU0FBUyxHQUFHQyxXQUNwRixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanM/ZmY5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4vLyBUaGUgZmlsZSB3aWxsIHRocm93IG9uIG5vZGUuanMgMTQgYW5kIGVhcmxpZXIuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBuYyA9IHJlcXVpcmUoXCJub2RlOmNyeXB0b1wiKTtcbmV4cG9ydHMuY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuYyA/IG5jLndlYmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3J5cHRvIiwibmMiLCJyZXF1aXJlIiwid2ViY3J5cHRvIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js_1.default.hash(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js_1.default.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxZQUFZLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ25DLE1BQU1JLGVBQWVDLG1CQUFPQSxDQUFDLDhGQUFjO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDBGQUFZO0FBQ3ZDLGtCQUFrQjtBQUNsQixNQUFNRixhQUFhRyxXQUFXQyxJQUFJO0lBQzlCQyxZQUFZQyxJQUFJLEVBQUVDLElBQUksQ0FBRTtRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakJSLGFBQWFTLE9BQU8sQ0FBQ0osSUFBSSxDQUFDQTtRQUMxQixNQUFNSyxNQUFNLENBQUMsR0FBR1IsV0FBV1MsT0FBTyxFQUFFTDtRQUNwQyxJQUFJLENBQUNNLEtBQUssR0FBR1AsS0FBS1EsTUFBTTtRQUN4QixJQUFJLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNFLE1BQU0sS0FBSyxZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNJLFFBQVE7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLFNBQVM7UUFDckMsTUFBTUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXSDtRQUMzQix3Q0FBd0M7UUFDeENFLElBQUlFLEdBQUcsQ0FBQ1YsSUFBSVcsTUFBTSxHQUFHTCxXQUFXWCxLQUFLUSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0osS0FBS1ksTUFBTSxLQUFLWjtRQUNyRSxJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUduQixLQUFLUSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNsQkEsSUFBSU8sSUFBSSxDQUFDO0lBQ2I7SUFDQVgsT0FBT1ksR0FBRyxFQUFFO1FBQ1IxQixhQUFhUyxPQUFPLENBQUNrQixNQUFNLENBQUMsSUFBSTtRQUNoQyxJQUFJLENBQUNmLEtBQUssQ0FBQ0UsTUFBTSxDQUFDWTtRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBRSxXQUFXQyxHQUFHLEVBQUU7UUFDWjdCLGFBQWFTLE9BQU8sQ0FBQ2tCLE1BQU0sQ0FBQyxJQUFJO1FBQ2hDM0IsYUFBYVMsT0FBTyxDQUFDcUIsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ1osU0FBUztRQUM5QyxJQUFJLENBQUNWLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNLLEtBQUssQ0FBQ2dCLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDTCxLQUFLLENBQUNWLE1BQU0sQ0FBQ2U7UUFDbEIsSUFBSSxDQUFDTCxLQUFLLENBQUNJLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDRSxPQUFPO0lBQ2hCO0lBQ0FULFNBQVM7UUFDTCxNQUFNTyxNQUFNLElBQUlWLFdBQVcsSUFBSSxDQUFDSyxLQUFLLENBQUNQLFNBQVM7UUFDL0MsSUFBSSxDQUFDVyxVQUFVLENBQUNDO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsbUdBQW1HO1FBQ25HQSxNQUFPQSxDQUFBQSxLQUFLdkMsT0FBT21CLE1BQU0sQ0FBQ25CLE9BQU93QyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVWLEtBQUssRUFBRVosS0FBSyxFQUFFTCxRQUFRLEVBQUVDLFNBQVMsRUFBRVEsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFZ0IsS0FBS0E7UUFDTEEsR0FBRzFCLFFBQVEsR0FBR0E7UUFDZDBCLEdBQUd6QixTQUFTLEdBQUdBO1FBQ2Z5QixHQUFHakIsUUFBUSxHQUFHQTtRQUNkaUIsR0FBR2hCLFNBQVMsR0FBR0E7UUFDZmdCLEdBQUdULEtBQUssR0FBR0EsTUFBTVEsVUFBVSxDQUFDQyxHQUFHVCxLQUFLO1FBQ3BDUyxHQUFHckIsS0FBSyxHQUFHQSxNQUFNb0IsVUFBVSxDQUFDQyxHQUFHckIsS0FBSztRQUNwQyxPQUFPcUI7SUFDWDtJQUNBRixVQUFVO1FBQ04sSUFBSSxDQUFDdkIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ08sT0FBTztRQUNsQixJQUFJLENBQUNuQixLQUFLLENBQUNtQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQW5DLFlBQVksR0FBR0c7QUFDZjs7Ozs7Q0FLQyxHQUNELE1BQU1ELE9BQU8sQ0FBQ08sTUFBTUssS0FBS3lCLFVBQVksSUFBSXBDLEtBQUtNLE1BQU1LLEtBQUtJLE1BQU0sQ0FBQ3FCLFNBQVNiLE1BQU07QUFDL0UxQixZQUFZLEdBQUdFO0FBQ2ZGLG1CQUFtQixHQUFHLENBQUNTLE1BQU1LLE1BQVEsSUFBSVgsS0FBS00sTUFBTUssTUFDcEQsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzPzU0NTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtYWMgPSBleHBvcnRzLkhNQUMgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5jbGFzcyBITUFDIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5ieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmV4cG9ydHMuaG1hYyA9IGhtYWM7XG5leHBvcnRzLmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaG1hYyIsIkhNQUMiLCJfYXNzZXJ0X2pzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImhhc2giLCJfa2V5IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJkZWZhdWx0Iiwia2V5IiwidG9CeXRlcyIsImlIYXNoIiwiY3JlYXRlIiwidXBkYXRlIiwiRXJyb3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJkaWdlc3QiLCJpIiwib0hhc2giLCJmaWxsIiwiYnVmIiwiZXhpc3RzIiwiZGlnZXN0SW50byIsIm91dCIsImJ5dGVzIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImdldFByb3RvdHlwZU9mIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = sigma0 + Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ exports.sha256 = (0, utils_js_1.wrapConstructor)(()=>new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdkMsTUFBTUksYUFBYUMsbUJBQU9BLENBQUMsMEZBQVk7QUFDdkMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEZBQVk7QUFDdkMsb0JBQW9CO0FBQ3BCLE1BQU1FLE1BQU0sQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNLENBQUNELElBQUlFO0FBQ3pDLG9EQUFvRDtBQUNwRCxNQUFNQyxNQUFNLENBQUNILEdBQUdDLEdBQUdDLElBQU0sSUFBS0QsSUFBTUQsSUFBSUUsSUFBTUQsSUFBSUM7QUFDbEQsbUJBQW1CO0FBQ25CLHlGQUF5RjtBQUN6RixrQkFBa0I7QUFDbEIsTUFBTUUsV0FBVyxJQUFJQyxZQUFZO0lBQzdCO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELHlHQUF5RztBQUN6RyxrQkFBa0I7QUFDbEIsTUFBTUMsS0FBSyxJQUFJRCxZQUFZO0lBQ3ZCO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJ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UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQixJQUFJLENBQUNFLEdBQUcsQ0FBQ1QsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0M7SUFDbEM7SUFDQWlCLGFBQWE7UUFDVDVCLFNBQVM2QixJQUFJLENBQUM7SUFDbEI7SUFDQUMsVUFBVTtRQUNOLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQzlCLElBQUksQ0FBQ2tCLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDO0lBQ3JCO0FBQ0o7QUFDQSw0RUFBNEU7QUFDNUUsTUFBTUcsZUFBZS9CO0lBQ2pCRSxhQUFjO1FBQ1YsS0FBSztRQUNMLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNzQixTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNEaEQsY0FBYyxHQUFHLENBQUMsR0FBR00sV0FBVzJDLGVBQWUsRUFBRSxJQUFNLElBQUlqQztBQUMzRGhCLGNBQWMsR0FBRyxDQUFDLEdBQUdNLFdBQVcyQyxlQUFlLEVBQUUsSUFBTSxJQUFJRixXQUMzRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcz82YzMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IHZvaWQgMDtcbmNvbnN0IF9zaGEyX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hhMi5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBfc2hhMl9qc18xLlNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAxMykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnRzLnNoYTIyNCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaGEyMjQiLCJzaGEyNTYiLCJfc2hhMl9qc18xIiwicmVxdWlyZSIsInV0aWxzX2pzXzEiLCJDaGkiLCJhIiwiYiIsImMiLCJNYWoiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiSVYiLCJTSEEyNTZfVyIsIlNIQTI1NiIsIlNIQTIiLCJjb25zdHJ1Y3RvciIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInJvdHIiLCJzMSIsInNpZ21hMSIsIlQxIiwic2lnbWEwIiwiVDIiLCJyb3VuZENsZWFuIiwiZmlsbCIsImRlc3Ryb3kiLCJidWZmZXIiLCJTSEEyMjQiLCJvdXRwdXRMZW4iLCJ3cmFwQ29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js":
/*!************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/cryptoNode.js\");\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!exports.isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n}\nexports.randomBytes = randomBytes; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9FQUFvRSxHQUNwRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsWUFBWSxHQUFHQSxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHQSxrQkFBa0IsR0FBR0EsV0FBVyxHQUFHQSxVQUFVLEdBQUcsS0FBSztBQUM1WCxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDhEQUE4RDtBQUM5RCxNQUFNb0IsV0FBV0MsbUJBQU9BLENBQUMseUdBQXNCO0FBQy9DLE1BQU1DLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsK0JBQStCO0FBQy9CLE1BQU1MLEtBQUssQ0FBQ00sTUFBUSxJQUFJRCxXQUFXQyxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVTtBQUM3RTVCLFVBQVUsR0FBR21CO0FBQ2IsTUFBTUQsTUFBTSxDQUFDTyxNQUFRLElBQUlJLFlBQVlKLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRyxLQUFLQyxLQUFLLENBQUNOLElBQUlHLFVBQVUsR0FBRztBQUM3RjVCLFdBQVcsR0FBR2tCO0FBQ2QscUJBQXFCO0FBQ3JCLE1BQU1ELGFBQWEsQ0FBQ1EsTUFBUSxJQUFJTyxTQUFTUCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVTtBQUNuRjVCLGtCQUFr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LGVBQWUsQ0FBQyxJQUFJeEUsV0FBV3NFO0lBQzFEO0lBQ0EsTUFBTSxJQUFJM0QsTUFBTTtBQUNwQjtBQUNBbkMsbUJBQW1CLEdBQUdFLGFBQ3RCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanM/MmRmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5jb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLnU4ID0gdTg7XG5jb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5leHBvcnRzLnUzMiA9IHUzMjtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gd3JhcENvbnN0cnVjdG9yO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM7XG5mdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cztcbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJhbmRvbUJ5dGVzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBDb25zdHJ1Y3RvciIsImNoZWNrT3B0cyIsIkhhc2giLCJjb25jYXRCeXRlcyIsInRvQnl0ZXMiLCJ1dGY4VG9CeXRlcyIsImFzeW5jTG9vcCIsIm5leHRUaWNrIiwiaGV4VG9CeXRlcyIsImJ5dGVzVG9IZXgiLCJpc0xFIiwicm90ciIsImNyZWF0ZVZpZXciLCJ1MzIiLCJ1OCIsImNyeXB0b18xIiwicmVxdWlyZSIsInU4YSIsImEiLCJVaW50OEFycmF5IiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsIkRhdGFWaWV3Iiwid29yZCIsInNoaWZ0IiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInYiLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzIiwiaGV4IiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImRhdGEiLCJhcnJheXMiLCJyIiwicmVkdWNlIiwic3VtIiwicGFkIiwiZm9yRWFjaCIsInNldCIsImNsb25lIiwiX2Nsb25lSW50byIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90b3R5cGUiLCJjYWxsIiwiY29uc3RydWN0b3IiLCJkZWZhdWx0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJtZXJnZWQiLCJhc3NpZ24iLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJjcmVhdGUiLCJieXRlc0xlbmd0aCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/secp256k1.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/curves/secp256k1.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\nconst modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@noble/curves/abstract/modular.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/abstract/weierstrass.js\");\nconst utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@noble/curves/_shortw_utils.js\");\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x)=>(0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)(\"signature\", signature, 64);\n    const m = (0, utils_js_1.ensureBytes)(\"message\", message);\n    const pub = (0, utils_js_1.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!fe(r)) return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: utils_js_1.numberToBytesBE,\n            bytesToNumberBE: utils_js_1.bytesToNumberBE,\n            taggedHash,\n            mod: modular_js_1.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: sha256_1.sha256\n    }))();\nexports.hashToCurve = (()=>htf.hashToCurve)();\nexports.encodeToCurve = (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pGLG9FQUFvRSxHQUNwRSxNQUFNTSxXQUFXQyxtQkFBT0EsQ0FBQyxxR0FBc0I7QUFDL0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsbUdBQXFCO0FBQzdDLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLHFGQUF1QjtBQUNwRCxNQUFNRyxtQkFBbUJILG1CQUFPQSxDQUFDLDZGQUEyQjtBQUM1RCxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyxpRkFBcUI7QUFDaEQsTUFBTUsscUJBQXFCTCxtQkFBT0EsQ0FBQyxpR0FBNkI7QUFDaEUsTUFBTU0scUJBQXFCTixtQkFBT0EsQ0FBQywrRUFBb0I7QUFDdkQsTUFBTU8sYUFBYUMsT0FBTztBQUMxQixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxhQUFhLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0QsSUFBSUMsSUFBSUgsR0FBRSxJQUFLRztBQUM3Qzs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsTUFBTUMsSUFBSVY7SUFDVixrQkFBa0I7SUFDbEIsTUFBTVcsTUFBTVYsT0FBTyxJQUFJVyxNQUFNWCxPQUFPLElBQUlZLE9BQU9aLE9BQU8sS0FBS2EsT0FBT2IsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTWMsT0FBT2QsT0FBTyxLQUFLZSxPQUFPZixPQUFPLEtBQUtnQixPQUFPaEIsT0FBTztJQUMxRCxNQUFNaUIsS0FBSyxJQUFLVCxJQUFJQSxJQUFLQyxHQUFHLFVBQVU7SUFDdEMsTUFBTVMsS0FBSyxLQUFNRCxL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QVMsQ0FBQytGLGVBQWUsRUFBRSxDQUFDaUU7UUFDeEcsTUFBTSxFQUFFdkYsQ0FBQyxFQUFFdkQsQ0FBQyxFQUFFLEdBQUdzSSxPQUFPOUcsR0FBR21ILE1BQU0sQ0FBQ0csT0FBTyxDQUFDLEVBQUU7UUFDNUMsT0FBT2IsT0FBTzFFLEdBQUd2RDtJQUNyQixHQUFHO1FBQ0MrSSxLQUFLO1FBQ0xDLFdBQVc7UUFDWHpELEdBQUcvRCxHQUFHeUgsS0FBSztRQUNYekMsR0FBRztRQUNIaEUsR0FBRztRQUNIMEcsUUFBUTtRQUNSQyxNQUFNcEssU0FBU3FFLE1BQU07SUFDekIsRUFBQztBQUNEM0UsbUJBQW1CLEdBQUcsQ0FBQyxJQUFNbUssSUFBSWhLLFdBQVc7QUFDNUNILHFCQUFxQixHQUFHLENBQUMsSUFBTW1LLElBQUlqSyxhQUFhLEtBQ2hELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzP2QwZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSBleHBvcnRzLmhhc2hUb0N1cnZlID0gZXhwb3J0cy5zY2hub3JyID0gZXhwb3J0cy5zZWNwMjU2azEgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IG1vZHVsYXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIik7XG5jb25zdCB3ZWllcnN0cmFzc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvdXRpbHMuanNcIik7XG5jb25zdCBoYXNoX3RvX2N1cnZlX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCIpO1xuY29uc3QgX3Nob3J0d191dGlsc19qc18xID0gcmVxdWlyZShcIi4vX3Nob3J0d191dGlscy5qc1wiKTtcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSAoMCwgbW9kdWxhcl9qc18xLnBvdzIpKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gKDAsIG1vZHVsYXJfanNfMS5GaWVsZCkoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydHMuc2VjcDI1NmsxID0gKDAsIF9zaG9ydHdfdXRpbHNfanNfMS5jcmVhdGVDdXJ2ZSkoe1xuICAgIGE6IEJpZ0ludCgwKSxcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgRnAsXG4gICAgbjogc2VjcDI1NmsxTixcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gICAgICogRW5kb21vcnBoaXNtIHVzZXMgMnggbGVzcyBSQU0sIHNwZWVkcyB1cCBwcmVjb21wdXRhdGlvbiBieSAyeCBhbmQgRUNESCAvIGtleSByZWNvdmVyeSBieSAyMCUuXG4gICAgICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICAgICAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjZcbiAgICAgKi9cbiAgICBlbmRvOiB7XG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7IC8vICgybioqMTI4bikudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAgICAgICAgIGxldCBrMSA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKShrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICAgICAgbGV0IGsyID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICAgICAgfSxcbiAgICB9LFxufSwgc2hhMjU2XzEuc2hhMjU2KTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgZmUgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMVA7XG5jb25zdCBnZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IGV4cG9ydHMuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gZXhwb3J0cy5zZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKCgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkodGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQn4omlbi4gUmV0IGJ5dGVzKGQn4ouFRylcbn1cbi8qKlxuICogQ3JlYXRlcyBTY2hub3JyIHNpZ25hdHVyZSBhcyBwZXIgQklQMzQwLiBWZXJpZmllcyBpdHNlbGYgYmVmb3JlIHJldHVybmluZyBhbnl0aGluZy5cbiAqIGF1eFJhbmQgaXMgb3B0aW9uYWwgYW5kIGlzIG5vdCB0aGUgc29sZSBzb3VyY2Ugb2YgayBnZW5lcmF0aW9uOiBiYWQgQ1NQUk5HIHdvbid0IGJlIGRhbmdlcm91cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9ICgwLCB1dGlsc18xLnJhbmRvbUJ5dGVzKSgzMikpIHtcbiAgICBjb25zdCBtID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKCgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5zY2hub3JyID0gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFOiB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFOiB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kOiBtb2R1bGFyX2pzXzEubW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIGhhc2hfdG9fY3VydmVfanNfMS5pc29nZW55TWFwKShGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIHdlaWVyc3RyYXNzX2pzXzEubWFwVG9DdXJ2ZVNpbXBsZVNXVSkoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmNyZWF0ZUhhc2hlcikoZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTZfMS5zaGEyNTYsXG59KSkoKTtcbmV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVuY29kZVRvQ3VydmUiLCJoYXNoVG9DdXJ2ZSIsInNjaG5vcnIiLCJzZWNwMjU2azEiLCJzaGEyNTZfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwibW9kdWxhcl9qc18xIiwid2VpZXJzdHJhc3NfanNfMSIsInV0aWxzX2pzXzEiLCJoYXNoX3RvX2N1cnZlX2pzXzEiLCJfc2hvcnR3X3V0aWxzX2pzXzEiLCJzZWNwMjU2azFQIiwiQmlnSW50Iiwic2VjcDI1NmsxTiIsIl8xbiIsIl8ybiIsImRpdk5lYXJlc3QiLCJhIiwiYiIsInNxcnRNb2QiLCJ5IiwiUCIsIl8zbiIsIl82biIsIl8xMW4iLCJfMjJuIiwiXzIzbiIsIl80NG4iLCJfODhuIiwiYjIiLCJiMyIsImI2IiwicG93MiIsImI5IiwiYjExIiwiYjIyIiwiYjQ0IiwiYjg4IiwiYjE3NiIsImIyMjAiLCJiMjIzIiwidDEiLCJ0MiIsInJvb3QiLCJGcCIsImVxbCIsInNxciIsIkVycm9yIiwiRmllbGQiLCJ1bmRlZmluZWQiLCJzcXJ0IiwiY3JlYXRlQ3VydmUiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJtb2QiLCJrMiIsImsxbmVnIiwiazJuZWciLCJzaGEyNTYiLCJfMG4iLCJmZSIsIngiLCJnZSIsIlRBR0dFRF9IQVNIX1BSRUZJWEVTIiwidGFnZ2VkSGFzaCIsInRhZyIsIm1lc3NhZ2VzIiwidGFnUCIsInRhZ0giLCJVaW50OEFycmF5IiwiZnJvbSIsImMiLCJjaGFyQ29kZUF0IiwiY29uY2F0Qnl0ZXMiLCJwb2ludFRvQnl0ZXMiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJzbGljZSIsIm51bVRvMzJiIiwibnVtYmVyVG9CeXRlc0JFIiwibW9kUCIsIm1vZE4iLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsIkdtdWxBZGQiLCJRIiwiQkFTRSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInAiLCJmcm9tUHJpdmF0ZUtleSIsInNjYWxhciIsImhhc0V2ZW5ZIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4eCIsImFzc2VydFZhbGlkaXR5IiwiY2hhbGxlbmdlIiwiYXJncyIsImJ5dGVzVG9OdW1iZXJCRSIsInNjaG5vcnJHZXRQdWJsaWNLZXkiLCJwcml2YXRlS2V5Iiwic2Nobm9yclNpZ24iLCJtZXNzYWdlIiwiYXV4UmFuZCIsInJhbmRvbUJ5dGVzIiwibSIsImVuc3VyZUJ5dGVzIiwicHgiLCJkIiwidCIsInJhbmQiLCJrXyIsInJ4IiwiZSIsInNpZyIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJnZXRQdWJsaWNLZXkiLCJzaWduIiwidmVyaWZ5IiwicmFuZG9tUHJpdmF0ZUtleSIsImlzb01hcCIsImlzb2dlbnlNYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJBIiwiQiIsIloiLCJjcmVhdGUiLCJodGYiLCJjcmVhdGVIYXNoZXIiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwiT1JERVIiLCJleHBhbmQiLCJoYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/secp256k1.js\n");

/***/ })

};
;