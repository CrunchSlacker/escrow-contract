"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-core-method";
exports.ids = ["vendor-chunks/web3-core-method"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-core-method/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/web3-core-method/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/ /**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */ \nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").errors);\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/web3-utils/lib/index.js\");\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"(ssr)/./node_modules/web3-core-promievent/lib/index.js\");\nvar Subscriptions = (__webpack_require__(/*! web3-core-subscriptions */ \"(ssr)/./node_modules/web3-core-subscriptions/lib/index.js\").subscriptions);\nvar EthersTransactionUtils = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js\");\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || \"latest\";\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n    this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function(requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function(requestManager, accounts) {\n    var func = this.buildCall();\n    Object.defineProperty(func, \"call\", {\n        configurable: true,\n        writable: true,\n        value: this.call\n    });\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function(obj) {\n    var func = this.buildCall();\n    Object.defineProperty(func, \"call\", {\n        configurable: true,\n        writable: true,\n        value: this.call\n    });\n    var name = this.name.split(\".\");\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */ Method.prototype.getCall = function(args) {\n    return typeof this.call === \"function\" ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */ Method.prototype.extractCallback = function(args) {\n    if (typeof args[args.length - 1] === \"function\") {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */ Method.prototype.validateArgs = function(args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */ Method.prototype.formatInput = function(args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function(formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */ Method.prototype.formatOutput = function(result) {\n    var _this = this;\n    if (Array.isArray(result)) {\n        return result.map(function(res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res, this?.hexFormat) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result, this?.hexFormat) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */ Method.prototype.toPayload = function(args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function(defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = \"\", gasProvided = !!payload.params[0] && typeof payload.params[0] === \"object\" && payload.params[0].gas ? payload.params[0].gas : null, isContractDeployment = !!payload.params[0] && typeof payload.params[0] === \"object\" && payload.params[0].data && payload.params[0].from && !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: \"getBlockByNumber\",\n            call: \"eth_getBlockByNumber\",\n            params: 2,\n            inputFormatter: [\n                formatters.inputBlockNumberFormatter,\n                function(val) {\n                    return !!val;\n                }\n            ],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: \"getTransactionReceipt\",\n            call: \"eth_getTransactionReceipt\",\n            params: 1,\n            inputFormatter: [\n                null\n            ],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: \"getCode\",\n            call: \"eth_getCode\",\n            params: 2,\n            inputFormatter: [\n                formatters.inputAddressFormatter,\n                formatters.inputDefaultBlockNumberFormatter\n            ]\n        }),\n        new Method({\n            name: \"getTransactionByHash\",\n            call: \"eth_getTransactionByHash\",\n            params: 1,\n            inputFormatter: [\n                null\n            ],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: \"subscribe\",\n            type: \"eth\",\n            subscriptions: {\n                \"newBlockHeaders\": {\n                    subscriptionName: \"newHeads\",\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _ethereumCalls.forEach((mthd)=>{\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function(existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function() {\n                        clearInterval(intervalId);\n                        clearTimeout(blockHeaderTimeoutId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))// catch error from requesting receipt\n            .catch(function(err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: \"Failed to check for transaction receipt:\",\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })// if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n            .then(async function(receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error(\"Receipt missing or blockHash null\");\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners(\"confirmation\").length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber(\"latest\");\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) {\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit(\"confirmation\", confirmationCount, receipt, latestBlockHash);\n                                }\n                            } else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit(\"confirmation\", confirmationCount, receipt, latestBlockHash);\n                            }\n                        } else {\n                            defer.eventEmitter.emit(\"confirmation\", confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if (isPolling && block || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })// CHECK for CONTRACT DEPLOYMENT\n            .then(async function(receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    } catch (err) {\n                    // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit(\"receipt\", receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        } else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    } else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })// CHECK for normal tx check for receipt only\n            .then(async function(receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === \"0x1\" || typeof receipt.status === \"undefined\")) {\n                        defer.eventEmitter.emit(\"receipt\", receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    } else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === \"0x0\") {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert && (method.call === \"eth_sendTransaction\" || method.call === \"eth_sendRawTransaction\")) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === \"eth_sendRawTransaction\") {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice ? parsedTx.gasPrice.toHexString() : undefined,\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) {\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    } else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                } else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            } catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        } else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })// time out the transaction if not mined after 50 blocks\n            .catch(function() {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError(\"Transaction was not mined within \" + method.transactionPollingTimeout + \" seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!\"), defer.eventEmitter, defer.reject);\n                    }\n                } else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError(\"Transaction was not mined within \" + method.transactionBlockTimeout + \" blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!\"), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: \"Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.\",\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = (function(existingReceipt) {\n        let blockHeaderArrived = false;\n        const startInterval = ()=>{\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n        };\n        // If provider do not support event subscription use polling\n        if (!this.requestManager.provider.on) {\n            return startInterval();\n        }\n        // Subscribe to new block headers to look for tx receipt\n        _ethereumCall.subscribe(\"newBlockHeaders\", function(err, blockHeader, sub) {\n            blockHeaderArrived = true;\n            if (err || !blockHeader) {\n                // fall back to polling\n                return startInterval();\n            }\n            checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        });\n        // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n        blockHeaderTimeoutId = setTimeout(()=>{\n            if (!blockHeaderArrived) {\n                startInterval();\n            }\n        }, this.blockHeaderTimeout * 1000);\n    }).bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result).then(function(receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners(\"confirmation\").length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        } else if (!promiseResolved) {\n            startWatching();\n        }\n    }).catch(function() {\n        if (!promiseResolved) startWatching();\n    });\n};\nvar getWallet = function(from, accounts) {\n    var wallet = null;\n    // is index given\n    if (typeof from === \"number\") {\n        wallet = accounts.wallet[from];\n    // is account given\n    } else if (!!from && typeof from === \"object\" && from.address && from.privateKey) {\n        wallet = from;\n    // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function() {\n    var method = this, isSendTx = method.call === \"eth_sendTransaction\" || method.call === \"eth_sendRawTransaction\", isCall = method.call === \"eth_call\";\n    // actual send function\n    var send = function() {\n        let args = Array.prototype.slice.call(arguments);\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(args);\n        method.hexFormat = false;\n        if (method.call === \"eth_getTransactionReceipt\" || method.call === \"eth_getTransactionByHash\" || method.name === \"getBlock\") {\n            method.hexFormat = payload.params.length < args.length && args[args.length - 1] === \"hex\";\n        }\n        // CALLBACK function\n        var sendTxCallback = function(err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                } else if (err && err.data) {\n                    // workaround embedded error details got from some providers like MetaMask\n                    if (typeof err.data === \"object\") {\n                        // Ganache has no `originalError` sub-object unlike others\n                        var originalError = err.data.originalError ?? err.data;\n                        reasonData = originalError.data.substring(10);\n                    } else {\n                        reasonData = err.data.substring(10);\n                    }\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter(\"string\", \"0x\" + reasonData);\n                    var signature = \"Error(String)\";\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            } catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n            // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit(\"transactionHash\", result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function(sign) {\n            var signedPayload = {\n                ...payload,\n                method: \"eth_sendRawTransaction\",\n                params: [\n                    sign.rawTransaction\n                ]\n            };\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function(payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === \"eth_sendTransaction\") {\n                    var tx = payload.params[0];\n                    wallet = getWallet(!!tx && typeof tx === \"object\" ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var tx = JSON.parse(JSON.stringify(tx));\n                        delete tx.from;\n                        if (method.defaultChain && !tx.chain) {\n                            tx.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !tx.hardfork) {\n                            tx.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !tx.common) {\n                            tx.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(tx, wallet.privateKey).then(sendSignedTx).catch(function(err) {\n                            if (typeof defer.eventEmitter.listeners === \"function\" && defer.eventEmitter.listeners(\"error\").length) {\n                                try {\n                                    defer.eventEmitter.emit(\"error\", err);\n                                } catch (err) {\n                                // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function() {});\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                // ETH_SIGN\n                } else if (payload.method === \"eth_sign\") {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        const hasSendTxObject = isSendTx && !!payload.params[0] && typeof payload.params[0] === \"object\";\n        if (hasSendTxObject && payload.params[0].type === \"0x1\" && typeof payload.params[0].accessList === \"undefined\") {\n            payload.params[0].accessList = [];\n        }\n        // Send the actual transaction\n        if (hasSendTxObject && typeof payload.params[0].gasPrice === \"undefined\" && (typeof payload.params[0].maxPriorityFeePerGas === \"undefined\" || typeof payload.params[0].maxFeePerGas === \"undefined\")) {\n            _handleTxPricing(method, payload.params[0]).then((txPricing)=>{\n                if (txPricing.gasPrice !== undefined) {\n                    payload.params[0].gasPrice = txPricing.gasPrice;\n                } else if (txPricing.maxPriorityFeePerGas !== undefined && txPricing.maxFeePerGas !== undefined) {\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n                }\n                if (isSendTx) {\n                    setTimeout(()=>{\n                        defer.eventEmitter.emit(\"sending\", payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        } else {\n            if (isSendTx) {\n                setTimeout(()=>{\n                    defer.eventEmitter.emit(\"sending\", payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(()=>{\n                defer.eventEmitter.emit(\"sent\", payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\nfunction _handleTxPricing(method, tx) {\n    return new Promise((resolve, reject)=>{\n        try {\n            var getBlockByNumber = new Method({\n                name: \"getBlockByNumber\",\n                call: \"eth_getBlockByNumber\",\n                params: 2,\n                inputFormatter: [\n                    function(blockNumber) {\n                        return blockNumber ? utils.toHex(blockNumber) : \"latest\";\n                    },\n                    function() {\n                        return false;\n                    }\n                ]\n            }).createFunction(method.requestManager);\n            var getGasPrice = new Method({\n                name: \"getGasPrice\",\n                call: \"eth_gasPrice\",\n                params: 0\n            }).createFunction(method.requestManager);\n            Promise.all([\n                getBlockByNumber(),\n                getGasPrice()\n            ]).then((responses)=>{\n                const [block, gasPrice] = responses;\n                if ((tx.type === \"0x2\" || tx.type === undefined) && block && block.baseFeePerGas) {\n                    // The network supports EIP-1559\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                    let maxPriorityFeePerGas, maxFeePerGas;\n                    if (tx.gasPrice) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        maxPriorityFeePerGas = tx.gasPrice;\n                        maxFeePerGas = tx.gasPrice;\n                        delete tx.gasPrice;\n                    } else {\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || \"0x9502F900\"; // 2.5 Gwei\n                        maxFeePerGas = tx.maxFeePerGas || utils.toHex(utils.toBN(block.baseFeePerGas).mul(utils.toBN(2)).add(utils.toBN(maxPriorityFeePerGas)));\n                    }\n                    resolve({\n                        maxFeePerGas,\n                        maxPriorityFeePerGas\n                    });\n                } else {\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas) throw Error(\"Network doesn't support eip-1559\");\n                    resolve({\n                        gasPrice\n                    });\n                }\n            });\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */ Method.prototype.getRevertReason = function(txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function(resolve, reject) {\n        new Method({\n            name: \"call\",\n            call: \"eth_call\",\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function() {\n            resolve(false);\n        }).catch(function(error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            } else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */ Method.prototype.isRevertReasonString = function(data) {\n    return typeof data === \"string\" && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === \"0x08c379a0\";\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */ Method.prototype.request = function() {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBLEdBQ0E7Ozs7O0NBS0MsR0FDRDtBQUNBLElBQUlBLFNBQVNDLDRHQUFtQztBQUNoRCxJQUFJQyxhQUFhRCxnSEFBdUM7QUFDeEQsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUM7QUFDekIsSUFBSUksZ0JBQWdCSiwrSEFBZ0Q7QUFDcEUsSUFBSU0seUJBQXlCTixtQkFBT0EsQ0FBQztBQUNyQyxJQUFJTyxTQUFTLFNBQVNBLE9BQU9DLE9BQU87SUFDaEMsSUFBSSxDQUFDQSxRQUFRQyxJQUFJLElBQUksQ0FBQ0QsUUFBUUUsSUFBSSxFQUFFO1FBQ2hDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ0QsSUFBSSxHQUFHRixRQUFRRSxJQUFJO0lBQ3hCLElBQUksQ0FBQ0QsSUFBSSxHQUFHRCxRQUFRQyxJQUFJO0lBQ3hCLElBQUksQ0FBQ0csTUFBTSxHQUFHSixRQUFRSSxNQUFNLElBQUk7SUFDaEMsSUFBSSxDQUFDQyxjQUFjLEdBQUdMLFFBQVFLLGNBQWM7SUFDNUMsSUFBSSxDQUFDQyxlQUFlLEdBQUdOLFFBQVFNLGVBQWU7SUFDOUMsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR1AsUUFBUU8sZ0JBQWdCO0lBQ2hELElBQUksQ0FBQ0MsZUFBZSxHQUFHUixRQUFRUSxlQUFlO0lBQzlDLElBQUksQ0FBQ0MsUUFBUSxHQUFHVCxRQUFRUyxRQUFRLEVBQUUsa0RBQWtEO0lBQ3BGLElBQUksQ0FBQ0MsY0FBYyxHQUFHVixRQUFRVSxjQUFjO0lBQzVDLDRCQUE0QjtJQUM1QixJQUFJLENBQUNDLFFBQVEsR0FBR1gsUUFBUVcsUUFBUTtJQUNoQyxJQUFJLENBQUNDLFlBQVksR0FBR1osUUFBUVksWUFBWSxJQUFJO0lBQzVDLElBQUksQ0FBQ0MsY0FB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bmQvLi9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanM/MTgxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBpbmRleC5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGRhdGUgMjAxN1xuICovXG4ndXNlIHN0cmljdCc7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5lcnJvcnM7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZm9ybWF0dGVycztcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBwcm9taUV2ZW50ID0gcmVxdWlyZSgnd2ViMy1jb3JlLXByb21pZXZlbnQnKTtcbnZhciBTdWJzY3JpcHRpb25zID0gcmVxdWlyZSgnd2ViMy1jb3JlLXN1YnNjcmlwdGlvbnMnKS5zdWJzY3JpcHRpb25zO1xudmFyIEV0aGVyc1RyYW5zYWN0aW9uVXRpbHMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMnKTtcbnZhciBNZXRob2QgPSBmdW5jdGlvbiBNZXRob2Qob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jYWxsIHx8ICFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGNyZWF0aW5nIGEgbWV0aG9kIHlvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3QgdGhlIFwibmFtZVwiIGFuZCBcImNhbGxcIiBwcm9wZXJ0eS4nKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuY2FsbCA9IG9wdGlvbnMuY2FsbDtcbiAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zIHx8IDA7XG4gICAgdGhpcy5pbnB1dEZvcm1hdHRlciA9IG9wdGlvbnMuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5vdXRwdXRGb3JtYXR0ZXIgPSBvcHRpb25zLm91dHB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLnRyYW5zZm9ybVBheWxvYWQgPSBvcHRpb25zLnRyYW5zZm9ybVBheWxvYWQ7XG4gICAgdGhpcy5leHRyYUZvcm1hdHRlcnMgPSBvcHRpb25zLmV4dHJhRm9ybWF0dGVycztcbiAgICB0aGlzLmFiaUNvZGVyID0gb3B0aW9ucy5hYmlDb2RlcjsgLy8gV2lsbCBiZSB1c2VkIHRvIGVuY29kZSB0aGUgcmV2ZXJ0IHJlYXNvbiBzdHJpbmdcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gb3B0aW9ucy5yZXF1ZXN0TWFuYWdlcjtcbiAgICAvLyByZWZlcmVuY2UgdG8gZXRoLmFjY291bnRzXG4gICAgdGhpcy5hY2NvdW50cyA9IG9wdGlvbnMuYWNjb3VudHM7XG4gICAgdGhpcy5kZWZhdWx0QmxvY2sgPSBvcHRpb25zLmRlZmF1bHRCbG9jayB8fCAnbGF0ZXN0JztcbiAgICB0aGlzLmRlZmF1bHRBY2NvdW50ID0gb3B0aW9ucy5kZWZhdWx0QWNjb3VudCB8fCBudWxsO1xuICAgIHRoaXMudHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgPSBvcHRpb25zLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0IHx8IDUwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgPSBvcHRpb25zLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzIHx8IDI0O1xuICAgIHRoaXMudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCA9IG9wdGlvbnMudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCB8fCA3NTA7XG4gICAgdGhpcy50cmFuc2FjdGlvblBvbGxpbmdJbnRlcnZhbCA9IG9wdGlvbnMudHJhbnNhY3Rpb25Qb2xsaW5nSW50ZXJ2YWwgfHwgMTAwMDtcbiAgICB0aGlzLmJsb2NrSGVhZGVyVGltZW91dCA9IG9wdGlvbnMuYmxvY2tIZWFkZXJUaW1lb3V0IHx8IDEwOyAvLyAxMCBzZWNvbmRzXG4gICAgdGhpcy5kZWZhdWx0Q29tbW9uID0gb3B0aW9ucy5kZWZhdWx0Q29tbW9uO1xuICAgIHRoaXMuZGVmYXVsdENoYWluID0gb3B0aW9ucy5kZWZhdWx0Q2hhaW47XG4gICAgdGhpcy5kZWZhdWx0SGFyZGZvcmsgPSBvcHRpb25zLmRlZmF1bHRIYXJkZm9yaztcbiAgICB0aGlzLmhhbmRsZVJldmVydCA9IG9wdGlvbnMuaGFuZGxlUmV2ZXJ0O1xufTtcbk1ldGhvZC5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGFjY291bnRzKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIC8vIHJlZmVyZW5jZSB0byBldGguYWNjb3VudHNcbiAgICBpZiAoYWNjb3VudHMpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50cyA9IGFjY291bnRzO1xuICAgIH1cbn07XG5NZXRob2QucHJvdG90eXBlLmNyZWF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBhY2NvdW50cykge1xuICAgIHZhciBmdW5jID0gdGhpcy5idWlsZENhbGwoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuYywgJ2NhbGwnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzLmNhbGwgfSk7XG4gICAgdGhpcy5zZXRSZXF1ZXN0TWFuYWdlcihyZXF1ZXN0TWFuYWdlciB8fCB0aGlzLnJlcXVlc3RNYW5hZ2VyLCBhY2NvdW50cyB8fCB0aGlzLmFjY291bnRzKTtcbiAgICByZXR1cm4gZnVuYztcbn07XG5NZXRob2QucHJvdG90eXBlLmF0dGFjaFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBmdW5jID0gdGhpcy5idWlsZENhbGwoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuYywgJ2NhbGwnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzLmNhbGwgfSk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUuc3BsaXQoJy4nKTtcbiAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIG9ialtuYW1lWzBdXSA9IG9ialtuYW1lWzBdXSB8fCB7fTtcbiAgICAgICAgb2JqW25hbWVbMF1dW25hbWVbMV1dID0gZnVuYztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9ialtuYW1lWzBdXSA9IGZ1bmM7XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIG5hbWUgb2YgdGhlIGpzb25ycGMgbWV0aG9kIGJhc2VkIG9uIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgZ2V0Q2FsbFxuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5hbWUgb2YganNvbnJwYyBtZXRob2RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5nZXRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuY2FsbCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY2FsbChhcmdzKSA6IHRoaXMuY2FsbDtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGV4dHJhY3QgY2FsbGJhY2sgZnJvbSBhcnJheSBvZiBhcmd1bWVudHMuIE1vZGlmaWVzIGlucHV0IHBhcmFtXG4gKlxuICogQG1ldGhvZCBleHRyYWN0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7RnVuY3Rpb258TnVsbH0gY2FsbGJhY2ssIGlmIGV4aXN0c1xuICovXG5NZXRob2QucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYXJncy5wb3AoKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICpcbiAqIEBtZXRob2QgdmFsaWRhdGVBcmdzXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBub3RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS52YWxpZGF0ZUFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWROdW1iZXJPZlBhcmFtcyhhcmdzLmxlbmd0aCwgdGhpcy5wYXJhbXMsIHRoaXMubmFtZSk7XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgaW5wdXQgYXJncyBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0XG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0SW5wdXQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlci5tYXAoZnVuY3Rpb24gKGZvcm1hdHRlciwgaW5kZXgpIHtcbiAgICAgICAgLy8gYmluZCB0aGlzIGZvciBkZWZhdWx0QmxvY2ssIGFuZCBkZWZhdWx0QWNjb3VudFxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyID8gZm9ybWF0dGVyLmNhbGwoX3RoaXMsIGFyZ3NbaW5kZXhdKSA6IGFyZ3NbaW5kZXhdO1xuICAgIH0pO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgb3V0cHV0KHJlc3VsdCkgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5NZXRob2QucHJvdG90eXBlLmZvcm1hdE91dHB1dCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXMgPyBfdGhpcy5vdXRwdXRGb3JtYXR0ZXIocmVzLCB0aGlzPy5oZXhGb3JtYXQpIDogcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXN1bHQgPyB0aGlzLm91dHB1dEZvcm1hdHRlcihyZXN1bHQsIHRoaXM/LmhleEZvcm1hdCkgOiByZXN1bHQ7XG4gICAgfVxufTtcbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBwYXlsb2FkIGZyb20gZ2l2ZW4gaW5wdXQgYXJnc1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgY2FsbCA9IHRoaXMuZ2V0Q2FsbChhcmdzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5mb3JtYXRJbnB1dChhcmdzKTtcbiAgICB0aGlzLnZhbGlkYXRlQXJncyhwYXJhbXMpO1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICBtZXRob2Q6IGNhbGwsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xuICAgIGlmICh0aGlzLnRyYW5zZm9ybVBheWxvYWQpIHtcbiAgICAgICAgcGF5bG9hZCA9IHRoaXMudHJhbnNmb3JtUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5fY29uZmlybVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGRlZmVyLCByZXN1bHQsIHBheWxvYWQpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcywgcHJvbWlzZVJlc29sdmVkID0gZmFsc2UsIGNhblVuc3Vic2NyaWJlID0gdHJ1ZSwgdGltZW91dENvdW50ID0gMCwgY29uZmlybWF0aW9uQ291bnQgPSAwLCBpbnRlcnZhbElkID0gbnVsbCwgYmxvY2tIZWFkZXJUaW1lb3V0SWQgPSBudWxsLCBsYXN0QmxvY2sgPSBudWxsLCByZWNlaXB0SlNPTiA9ICcnLCBnYXNQcm92aWRlZCA9ICgoISFwYXlsb2FkLnBhcmFtc1swXSAmJiB0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0gPT09ICdvYmplY3QnKSAmJiBwYXlsb2FkLnBhcmFtc1swXS5nYXMpID8gcGF5bG9hZC5wYXJhbXNbMF0uZ2FzIDogbnVsbCwgaXNDb250cmFjdERlcGxveW1lbnQgPSAoISFwYXlsb2FkLnBhcmFtc1swXSAmJiB0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0gPT09ICdvYmplY3QnKSAmJlxuICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5kYXRhICYmXG4gICAgICAgIHBheWxvYWQucGFyYW1zWzBdLmZyb20gJiZcbiAgICAgICAgIXBheWxvYWQucGFyYW1zWzBdLnRvLCBoYXNCeXRlY29kZSA9IGlzQ29udHJhY3REZXBsb3ltZW50ICYmIHBheWxvYWQucGFyYW1zWzBdLmRhdGEubGVuZ3RoID4gMjtcbiAgICAvLyBhZGQgY3VzdG9tIHNlbmQgTWV0aG9kc1xuICAgIHZhciBfZXRoZXJldW1DYWxscyA9IFtcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsO1xuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldENvZGUnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRDb2RlJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBTdWJzY3JpcHRpb25zKHtcbiAgICAgICAgICAgIG5hbWU6ICdzdWJzY3JpYmUnLFxuICAgICAgICAgICAgdHlwZTogJ2V0aCcsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgJ25ld0Jsb2NrSGVhZGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uTmFtZTogJ25ld0hlYWRzJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbiAgICAvLyBhdHRhY2ggbWV0aG9kcyB0byB0aGlzLl9ldGhlcmV1bUNhbGxcbiAgICB2YXIgX2V0aGVyZXVtQ2FsbCA9IHt9O1xuICAgIF9ldGhlcmV1bUNhbGxzLmZvckVhY2gobXRoZCA9PiB7XG4gICAgICAgIG10aGQuYXR0YWNoVG9PYmplY3QoX2V0aGVyZXVtQ2FsbCk7XG4gICAgICAgIG10aGQucmVxdWVzdE1hbmFnZXIgPSBtZXRob2QucmVxdWVzdE1hbmFnZXI7IC8vIGFzc2lnbiByYXRoZXIgdGhhbiBjYWxsIHNldFJlcXVlc3RNYW5hZ2VyKClcbiAgICB9KTtcbiAgICAvLyBmaXJlIFwicmVjZWlwdFwiIGFuZCBjb25maXJtYXRpb24gZXZlbnRzIGFuZCByZXNvbHZlIGFmdGVyXG4gICAgdmFyIGNoZWNrQ29uZmlybWF0aW9uID0gZnVuY3Rpb24gKGV4aXN0aW5nUmVjZWlwdCwgaXNQb2xsaW5nLCBlcnIsIGJsb2NrSGVhZGVyLCBzdWIpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBmYWtlIHVuc3Vic2NyaWJlXG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHN1YiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYmxvY2tIZWFkZXJUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSB2YWxpZCByZWNlaXB0IHdlIGRvbid0IG5lZWQgdG8gc2VuZCBhIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiAoZXhpc3RpbmdSZWNlaXB0ID8gcHJvbWlFdmVudC5yZXNvbHZlKGV4aXN0aW5nUmVjZWlwdCkgOiBfZXRoZXJldW1DYWxsLmdldFRyYW5zYWN0aW9uUmVjZWlwdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yIGZyb20gcmVxdWVzdGluZyByZWNlaXB0XG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGNoZWNrIGZvciB0cmFuc2FjdGlvbiByZWNlaXB0OicsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgICAgICAgIH0sIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gaWYgQ09ORklSTUFUSU9OIGxpc3RlbmVyIGV4aXN0cyBjaGVjayBmb3IgY29uZmlybWF0aW9ucywgYnkgc2V0dGluZyBjYW5VbnN1YnNjcmliZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgIXJlY2VpcHQuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjZWlwdCBtaXNzaW5nIG9yIGJsb2NrSGFzaCBudWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGV4dHJhIGZvcm1hdHRlcnNcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmV4dHJhRm9ybWF0dGVycyAmJiBtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLnJlY2VpcHRGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdCA9IG1ldGhvZC5leHRyYUZvcm1hdHRlcnMucmVjZWlwdEZvcm1hdHRlcihyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgY29uZmlybWF0aW9uIGxpc3RlbmVyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzKCdjb25maXJtYXRpb24nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGltbWVkaWF0ZWx5IHJldHJpZXZlZCByZWNlaXB0LCBpdCdzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBjb25maXJtZWQgYnkgdGhlIGRpcmVjdCBjYWxsIHRvIGNoZWNrQ29uZmlybWF0aW9uIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGFyaXR5IGluc3RhbnQtc2VhbFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdSZWNlaXB0ID09PSB1bmRlZmluZWQgfHwgY29uZmlybWF0aW9uQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBsYXRlc3QgYmxvY2sgdG8gZW1pdCB3aXRoIGNvbmZpcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhdGVzdEJsb2NrID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKCdsYXRlc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXRlc3RCbG9ja0hhc2ggPSBsYXRlc3RCbG9jayA/IGxhdGVzdEJsb2NrLmhhc2ggOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUG9sbGluZykgeyAvLyBDaGVjayBpZiBhY3R1YWxseSBhIG5ldyBibG9jayBpcyBleGlzdGluZyBvbiBwb2xsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IGF3YWl0IF9ldGhlcmV1bUNhbGwuZ2V0QmxvY2tCeU51bWJlcihsYXN0QmxvY2subnVtYmVyICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnY29uZmlybWF0aW9uJywgY29uZmlybWF0aW9uQ291bnQsIHJlY2VpcHQsIGxhdGVzdEJsb2NrSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRCbG9ja0J5TnVtYmVyKHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbmZpcm1hdGlvbicsIGNvbmZpcm1hdGlvbkNvdW50LCByZWNlaXB0LCBsYXRlc3RCbG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdjb25maXJtYXRpb24nLCBjb25maXJtYXRpb25Db3VudCwgcmVjZWlwdCwgbGF0ZXN0QmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGlzUG9sbGluZyAmJiBibG9jaykgfHwgIWlzUG9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW5VbnN1YnNjcmliZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uQ291bnQgPT09IG1ldGhvZC50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyArIDEpIHsgLy8gYWRkIDEgc28gd2UgYWNjb3VudCBmb3IgY29uZiAwXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gQ0hFQ0sgZm9yIENPTlRSQUNUIERFUExPWU1FTlRcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyBmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRyYWN0RGVwbG95bWVudCAmJiAhcHJvbWlzZVJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5Ob0NvbnRyYWN0QWRkcmVzc0ZvdW5kRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldENvZGUocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZXBsb3ltZW50IGlzIHN0YXR1cy50cnVlIGFuZCB0aGVyZSB3YXMgYSByZWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5dGVjb2RlIHN0cmluZywgYXNzdW1lIGl0IHdhcyBzdWNjZXNzZnVsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwbG95bWVudFN1Y2Nlc3MgPSByZWNlaXB0LnN0YXR1cyA9PT0gdHJ1ZSAmJiBoYXNCeXRlY29kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGxveW1lbnRTdWNjZXNzIHx8IGNvZGUubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3JlY2VpcHQnLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbnRyYWN0LCByZXR1cm4gaW5zdGFuY2UgaW5zdGVhZCBvZiByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmV4dHJhRm9ybWF0dGVycyAmJiBtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLmNvbnRyYWN0RGVwbG95Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLmNvbnRyYWN0RGVwbG95Rm9ybWF0dGVyKHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGFzIHRoZXkgYXJlbid0IHJlbW92ZWQgYXV0b21hdGljYWxseSB3aGVuIHN1Y2Nlc2Z1bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLkNvbnRyYWN0Q29kZU5vdFN0b3JlZEVycm9yKHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy8gQ0hFQ0sgZm9yIG5vcm1hbCB0eCBjaGVjayBmb3IgcmVjZWlwdCBvbmx5XG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJhY3REZXBsb3ltZW50ICYmICFwcm9taXNlUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0Lm91dE9mR2FzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWdhc1Byb3ZpZGVkIHx8IGdhc1Byb3ZpZGVkICE9PSByZWNlaXB0Lmdhc1VzZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVjZWlwdC5zdGF0dXMgPT09IHRydWUgfHwgcmVjZWlwdC5zdGF0dXMgPT09ICcweDEnIHx8IHR5cGVvZiByZWNlaXB0LnN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgncmVjZWlwdCcsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVtb3ZlIGxpc3RlbmVycywgYXMgdGhleSBhcmVuJ3QgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gc3VjY2VzZnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdEpTT04gPSBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LnN0YXR1cyA9PT0gZmFsc2UgfHwgcmVjZWlwdC5zdGF0dXMgPT09ICcweDAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldmVydE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmhhbmRsZVJldmVydCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicgfHwgbWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eFJlcGxheU9wdGlvbnMgPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbmQgd2FzIHJhdywgZmV0Y2ggdGhlIHRyYW5zYWN0aW9uIGFuZCByZWNvbnN0aXR1dGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBwYXJhbXMgc28gdGhleSBjYW4gYmUgcmVwbGF5ZWQgd2l0aCBgZXRoX2NhbGxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdUcmFuc2FjdGlvbkhleCA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRUeCA9IEV0aGVyc1RyYW5zYWN0aW9uVXRpbHMucGFyc2UocmF3VHJhbnNhY3Rpb25IZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4UmVwbGF5T3B0aW9ucyA9IGZvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnNlZFR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBwYXJzZWRUeC50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogcGFyc2VkVHguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzOiBwYXJzZWRUeC5nYXNMaW1pdC50b0hleFN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZTogcGFyc2VkVHguZ2FzUHJpY2UgPyBwYXJzZWRUeC5nYXNQcmljZS50b0hleFN0cmluZygpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkVHgudmFsdWUudG9IZXhTdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHJldmVydCByZWFzb24gc3RyaW5nIHdpdGggZXRoX2NhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydE1lc3NhZ2UgPSBhd2FpdCBtZXRob2QuZ2V0UmV2ZXJ0UmVhc29uKHR4UmVwbGF5T3B0aW9ucywgcmVjZWlwdC5ibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV2ZXJ0TWVzc2FnZSkgeyAvLyBPbmx5IHRocm93IGEgcmV2ZXJ0IGVycm9yIGlmIGEgcmV2ZXJ0IHJlYXNvbiBpcyBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcihyZXZlcnRNZXNzYWdlLnJlYXNvbiwgcmV2ZXJ0TWVzc2FnZS5zaWduYXR1cmUsIHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWxzZTsgLy8gVGhyb3cgZmFsc2UgYW5kIGxldCB0aGUgdHJ5L2NhdGNoIHN0YXRlbWVudCBoYW5kbGUgdGhlIGVycm9yIGNvcnJlY3RseSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFsc2U7IC8vIFRocm93IGZhbHNlIGFuZCBsZXQgdGhlIHRyeS9jYXRjaCBzdGF0ZW1lbnQgaGFuZGxlIHRoZSBlcnJvciBjb3JyZWN0bHkgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYW4gbm9ybWFsIHJldmVydCBlcnJvciBpZiBubyByZXZlcnQgcmVhc29uIGlzIGdpdmVuIG9yIHRoZSBkZXRlY3Rpb24gb2YgaXQgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25SZXZlcnRlZFdpdGhvdXRSZWFzb25FcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRocm93IE9PRyBpZiBzdGF0dXMgaXMgbm90IGV4aXN0aW5nIGFuZCBwcm92aWRlZCBnYXMgYW5kIHVzZWQgZ2FzIGFyZSBlcXVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uT3V0T2ZHYXNFcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIHRpbWUgb3V0IHRoZSB0cmFuc2FjdGlvbiBpZiBub3QgbWluZWQgYWZ0ZXIgNTAgYmxvY2tzXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0Q291bnQrKztcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGh0dHAgcG9sbGluZ1xuICAgICAgICAgICAgICAgIGlmICghIWlzUG9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwb2xsaW5nIHRpbWVvdXQgaXMgZGlmZmVyZW50IHRoYW4gdHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQgYmxvY2tzIHNpbmNlIHdlIGFyZSB0cmlnZ2VyaW5nIGV2ZXJ5IHNlY29uZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dENvdW50IC0gMSA+PSBtZXRob2QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gd2FzIG5vdCBtaW5lZCB3aXRoaW4gJyArIG1ldGhvZC50cmFuc2FjdGlvblBvbGxpbmdUaW1lb3V0ICsgJyBzZWNvbmRzLCBwbGVhc2UgbWFrZSBzdXJlIHlvdXIgdHJhbnNhY3Rpb24gd2FzIHByb3Blcmx5IHNlbnQuIEJlIGF3YXJlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgbWluZWQhJyksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRDb3VudCAtIDEgPj0gbWV0aG9kLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiB3YXMgbm90IG1pbmVkIHdpdGhpbiAnICsgbWV0aG9kLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0ICsgJyBibG9ja3MsIHBsZWFzZSBtYWtlIHN1cmUgeW91ciB0cmFuc2FjdGlvbiB3YXMgcHJvcGVybHkgc2VudC4gQmUgYXdhcmUgdGhhdCBpdCBtaWdodCBzdGlsbCBiZSBtaW5lZCEnKSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHN1YnNjcmliZSB0byBuZXcgbmV3QmxvY2tIZWFkZXJzIHRvIGNvbmZpcm0gdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRzLicsXG4gICAgICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgICB9LCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHN0YXJ0IHdhdGNoaW5nIGZvciBjb25maXJtYXRpb24gZGVwZW5kaW5nIG9uIHRoZSBzdXBwb3J0IGZlYXR1cmVzIG9mIHRoZSBwcm92aWRlclxuICAgIHZhciBzdGFydFdhdGNoaW5nID0gZnVuY3Rpb24gKGV4aXN0aW5nUmVjZWlwdCkge1xuICAgICAgICBsZXQgYmxvY2tIZWFkZXJBcnJpdmVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW50ZXJ2YWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoY2hlY2tDb25maXJtYXRpb24uYmluZChudWxsLCBleGlzdGluZ1JlY2VpcHQsIHRydWUpLCBtZXRob2QudHJhbnNhY3Rpb25Qb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBwcm92aWRlciBkbyBub3Qgc3VwcG9ydCBldmVudCBzdWJzY3JpcHRpb24gdXNlIHBvbGxpbmdcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RNYW5hZ2VyLnByb3ZpZGVyLm9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBuZXcgYmxvY2sgaGVhZGVycyB0byBsb29rIGZvciB0eCByZWNlaXB0XG4gICAgICAgIF9ldGhlcmV1bUNhbGwuc3Vic2NyaWJlKCduZXdCbG9ja0hlYWRlcnMnLCBmdW5jdGlvbiAoZXJyLCBibG9ja0hlYWRlciwgc3ViKSB7XG4gICAgICAgICAgICBibG9ja0hlYWRlckFycml2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGVyciB8fCAhYmxvY2tIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gcG9sbGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEludGVydmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja0NvbmZpcm1hdGlvbihleGlzdGluZ1JlY2VpcHQsIGZhbHNlLCBlcnIsIGJsb2NrSGVhZGVyLCBzdWIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gcG9sbGluZyBpZiB0eCByZWNlaXB0IGRpZG4ndCBhcnJpdmVkIGluIFwiYmxvY2tIZWFkZXJUaW1lb3V0XCIgWzEwIHNlY29uZHNdXG4gICAgICAgIGJsb2NrSGVhZGVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWJsb2NrSGVhZGVyQXJyaXZlZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5ibG9ja0hlYWRlclRpbWVvdXQgKiAxMDAwKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgLy8gZmlyc3QgY2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAgX2V0aGVyZXVtQ2FsbC5nZXRUcmFuc2FjdGlvblJlY2VpcHQocmVzdWx0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICBpZiAocmVjZWlwdCAmJiByZWNlaXB0LmJsb2NrSGFzaCkge1xuICAgICAgICAgICAgaWYgKGRlZmVyLmV2ZW50RW1pdHRlci5saXN0ZW5lcnMoJ2NvbmZpcm1hdGlvbicpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGtlZXAgb24gd2F0Y2hpbmcgZm9yIG5ldyBCbG9ja3MsIGlmIGEgY29uZmlybWF0aW9uIGxpc3RlbmVyIGlzIHByZXNlbnRcbiAgICAgICAgICAgICAgICBzdGFydFdhdGNoaW5nKHJlY2VpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tDb25maXJtYXRpb24ocmVjZWlwdCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcm9taXNlUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0V2F0Y2hpbmcoKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvbWlzZVJlc29sdmVkKVxuICAgICAgICAgICAgc3RhcnRXYXRjaGluZygpO1xuICAgIH0pO1xufTtcbnZhciBnZXRXYWxsZXQgPSBmdW5jdGlvbiAoZnJvbSwgYWNjb3VudHMpIHtcbiAgICB2YXIgd2FsbGV0ID0gbnVsbDtcbiAgICAvLyBpcyBpbmRleCBnaXZlblxuICAgIGlmICh0eXBlb2YgZnJvbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgd2FsbGV0ID0gYWNjb3VudHMud2FsbGV0W2Zyb21dO1xuICAgICAgICAvLyBpcyBhY2NvdW50IGdpdmVuXG4gICAgfVxuICAgIGVsc2UgaWYgKCEhZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gJ29iamVjdCcgJiYgZnJvbS5hZGRyZXNzICYmIGZyb20ucHJpdmF0ZUtleSkge1xuICAgICAgICB3YWxsZXQgPSBmcm9tO1xuICAgICAgICAvLyBzZWFyY2ggaW4gd2FsbGV0IGZvciBhZGRyZXNzXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YWxsZXQgPSBhY2NvdW50cy53YWxsZXRbZnJvbS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHdhbGxldDtcbn07XG5NZXRob2QucHJvdG90eXBlLmJ1aWxkQ2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0aG9kID0gdGhpcywgaXNTZW5kVHggPSAobWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJyB8fCBtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nKSwgLy8gfHwgbWV0aG9kLmNhbGwgPT09ICdwZXJzb25hbF9zZW5kVHJhbnNhY3Rpb24nXG4gICAgaXNDYWxsID0gKG1ldGhvZC5jYWxsID09PSAnZXRoX2NhbGwnKTtcbiAgICAvLyBhY3R1YWwgc2VuZCBmdW5jdGlvblxuICAgIHZhciBzZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBkZWZlciA9IHByb21pRXZlbnQoIWlzU2VuZFR4KSwgcGF5bG9hZCA9IG1ldGhvZC50b1BheWxvYWQoYXJncyk7XG4gICAgICAgIG1ldGhvZC5oZXhGb3JtYXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1ldGhvZC5jYWxsID09PSAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCdcbiAgICAgICAgICAgIHx8IG1ldGhvZC5jYWxsID09PSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJ1xuICAgICAgICAgICAgfHwgbWV0aG9kLm5hbWUgPT09ICdnZXRCbG9jaycpIHtcbiAgICAgICAgICAgIG1ldGhvZC5oZXhGb3JtYXQgPSAocGF5bG9hZC5wYXJhbXMubGVuZ3RoIDwgYXJncy5sZW5ndGggJiYgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ0FMTEJBQ0sgZnVuY3Rpb25cbiAgICAgICAgdmFyIHNlbmRUeENhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kLmhhbmRsZVJldmVydCAmJiBpc0NhbGwgJiYgbWV0aG9kLmFiaUNvZGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYXNvbkRhdGE7XG4gICAgICAgICAgICAgICAgLy8gR2FuYWNoZSAvIEdldGggPD0gMS45LjEzIHJldHVybiB0aGUgcmVhc29uIGRhdGEgYXMgYSBzdWNjZXNzZnVsIGV0aF9jYWxsIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gR2V0aCA+PSAxLjkuMTUgYXR0YWNoZXMgdGhlIHJlYXNvbiBkYXRhIHRvIGFuIGVycm9yIG9iamVjdC5cbiAgICAgICAgICAgICAgICAvLyBHZXRoIDEuOS4xNCBpcyBtaXNzaW5nIHJldmVydCByZWFzb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93ZWIzLmpzL2lzc3Vlcy8zNTIwKVxuICAgICAgICAgICAgICAgIGlmICghZXJyICYmIG1ldGhvZC5pc1JldmVydFJlYXNvblN0cmluZyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbkRhdGEgPSByZXN1bHQuc3Vic3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyICYmIGVyci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZW1iZWRkZWQgZXJyb3IgZGV0YWlscyBnb3QgZnJvbSBzb21lIHByb3ZpZGVycyBsaWtlIE1ldGFNYXNrXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyLmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHYW5hY2hlIGhhcyBubyBgb3JpZ2luYWxFcnJvcmAgc3ViLW9iamVjdCB1bmxpa2Ugb3RoZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFcnJvciA9IGVyci5kYXRhLm9yaWdpbmFsRXJyb3IgPz8gZXJyLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gb3JpZ2luYWxFcnJvci5kYXRhLnN1YnN0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gZXJyLmRhdGEuc3Vic3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVhc29uRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gbWV0aG9kLmFiaUNvZGVyLmRlY29kZVBhcmFtZXRlcignc3RyaW5nJywgJzB4JyArIHJlYXNvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gJ0Vycm9yKFN0cmluZyknO1xuICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5SZXZlcnRJbnN0cnVjdGlvbkVycm9yKHJlYXNvbiwgc2lnbmF0dXJlKSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIHBheWxvYWQuY2FsbGJhY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5mb3JtYXRPdXRwdXQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyciA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuX2ZpcmVFcnJvcihlcnIsIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBwYXlsb2FkLmNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBQUk9NSVNFXG4gICAgICAgICAgICBpZiAoIWlzU2VuZFR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gUFJPTUlFVkVOVFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3RyYW5zYWN0aW9uSGFzaCcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kLl9jb25maXJtVHJhbnNhY3Rpb24oZGVmZXIsIHJlc3VsdCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNFTkRTIHRoZSBTSUdORUQgU0lHTkFUVVJFXG4gICAgICAgIHZhciBzZW5kU2lnbmVkVHggPSBmdW5jdGlvbiAoc2lnbikge1xuICAgICAgICAgICAgdmFyIHNpZ25lZFBheWxvYWQgPSB7IC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbc2lnbi5yYXdUcmFuc2FjdGlvbl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZXRob2QucmVxdWVzdE1hbmFnZXIuc2VuZChzaWduZWRQYXlsb2FkLCBzZW5kVHhDYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBtZXRob2QpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgJiYgbWV0aG9kLmFjY291bnRzICYmIG1ldGhvZC5hY2NvdW50cy53YWxsZXQgJiYgbWV0aG9kLmFjY291bnRzLndhbGxldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FsbGV0O1xuICAgICAgICAgICAgICAgIC8vIEVUSF9TRU5EVFJBTlNBQ1RJT05cbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHggPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gZ2V0V2FsbGV0KCghIXR4ICYmIHR5cGVvZiB0eCA9PT0gJ29iamVjdCcpID8gdHguZnJvbSA6IG51bGwsIG1ldGhvZC5hY2NvdW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdhbGxldCB3YXMgZm91bmQsIHNpZ24gdHgsIGFuZCBzZW5kIHVzaW5nIHNlbmRSYXdUcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAod2FsbGV0ICYmIHdhbGxldC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHggPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZGVmYXVsdENoYWluICYmICF0eC5jaGFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNoYWluID0gbWV0aG9kLmRlZmF1bHRDaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZGVmYXVsdEhhcmRmb3JrICYmICF0eC5oYXJkZm9yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmhhcmRmb3JrID0gbWV0aG9kLmRlZmF1bHRIYXJkZm9yaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZGVmYXVsdENvbW1vbiAmJiAhdHguY29tbW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29tbW9uID0gbWV0aG9kLmRlZmF1bHRDb21tb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuYWNjb3VudHMuc2lnblRyYW5zYWN0aW9uKHR4LCB3YWxsZXQucHJpdmF0ZUtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihzZW5kU2lnbmVkVHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZmVyLmV2ZW50RW1pdHRlci5saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiYgZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHVzZXJsYW5kIGVycm9yIHByZXZlbnQgaXQgdG8gYnViYmxlIHVwIHdpdGhpbiB3ZWIzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRVRIX1NJR05cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2lnbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBwYXlsb2FkLnBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gZ2V0V2FsbGV0KHBheWxvYWQucGFyYW1zWzBdLCBtZXRob2QuYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3YWxsZXQgd2FzIGZvdW5kLCBzaWduIHR4LCBhbmQgc2VuZCB1c2luZyBzZW5kUmF3VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldCAmJiB3YWxsZXQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBtZXRob2QuYWNjb3VudHMuc2lnbihkYXRhLCB3YWxsZXQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2sobnVsbCwgc2lnbi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShzaWduLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmQocGF5bG9hZCwgc2VuZFR4Q2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYXNTZW5kVHhPYmplY3QgPSBpc1NlbmRUeFxuICAgICAgICAgICAgJiYgISFwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICAgICAgJiYgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdID09PSAnb2JqZWN0JztcbiAgICAgICAgaWYgKGhhc1NlbmRUeE9iamVjdCAmJlxuICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0udHlwZSA9PT0gJzB4MSdcbiAgICAgICAgICAgICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXS5hY2Nlc3NMaXN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvblxuICAgICAgICBpZiAoaGFzU2VuZFR4T2JqZWN0XG4gICAgICAgICAgICAmJiAodHlwZW9mIHBheWxvYWQucGFyYW1zWzBdLmdhc1ByaWNlID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICYmICh0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0ubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgIHx8IHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXS5tYXhGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnKSkpIHtcbiAgICAgICAgICAgIF9oYW5kbGVUeFByaWNpbmcobWV0aG9kLCBwYXlsb2FkLnBhcmFtc1swXSkudGhlbih0eFByaWNpbmcgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eFByaWNpbmcuZ2FzUHJpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5nYXNQcmljZSA9IHR4UHJpY2luZy5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHhQcmljaW5nLm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgdHhQcmljaW5nLm1heEZlZVBlckdhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdLm1heFByaW9yaXR5RmVlUGVyR2FzID0gdHhQcmljaW5nLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5tYXhGZWVQZXJHYXMgPSB0eFByaWNpbmcubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTZW5kVHgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnc2VuZGluZycsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3QocGF5bG9hZCwgbWV0aG9kKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzU2VuZFR4KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdzZW5kaW5nJywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kUmVxdWVzdChwYXlsb2FkLCBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NlbmRUeCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbnQnLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlci5ldmVudEVtaXR0ZXI7XG4gICAgfTtcbiAgICAvLyBuZWNlc3NhcnkgdG8gYXR0YWNoIHRoaW5ncyB0byB0aGUgbWV0aG9kXG4gICAgc2VuZC5tZXRob2QgPSBtZXRob2Q7XG4gICAgLy8gbmVjZXNzYXJ5IGZvciBiYXRjaCByZXF1ZXN0c1xuICAgIHNlbmQucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBzZW5kO1xufTtcbmZ1bmN0aW9uIF9oYW5kbGVUeFByaWNpbmcobWV0aG9kLCB0eCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZ2V0QmxvY2tCeU51bWJlciA9IChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9ja051bWJlciA/IHV0aWxzLnRvSGV4KGJsb2NrTnVtYmVyKSA6ICdsYXRlc3QnO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KSkuY3JlYXRlRnVuY3Rpb24obWV0aG9kLnJlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgICAgIHZhciBnZXRHYXNQcmljZSA9IChuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZ2V0R2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKG1ldGhvZC5yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2V0QmxvY2tCeU51bWJlcigpLFxuICAgICAgICAgICAgICAgIGdldEdhc1ByaWNlKClcbiAgICAgICAgICAgIF0pLnRoZW4ocmVzcG9uc2VzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYmxvY2ssIGdhc1ByaWNlXSA9IHJlc3BvbnNlcztcbiAgICAgICAgICAgICAgICBpZiAoKHR4LnR5cGUgPT09ICcweDInIHx8IHR4LnR5cGUgPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvYmxvYi9iYTY4NTRiZGQ1YTkxMmZlODczZDVkYTQ5NGNiNWM2MmMxOTBhZGRlL3BhY2thZ2VzL2Fic3RyYWN0LXByb3ZpZGVyL3NyYy50cy9pbmRleC50cyNMMjMwXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgJzB4OTUwMkY5MDAnOyAvLyAyLjUgR3dlaVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gdHgubWF4RmVlUGVyR2FzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMudG9IZXgodXRpbHMudG9CTihibG9jay5iYXNlRmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubXVsKHV0aWxzLnRvQk4oMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQodXRpbHMudG9CTihtYXhQcmlvcml0eUZlZVBlckdhcykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCB0eC5tYXhGZWVQZXJHYXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IGVpcC0xNTU5XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgZ2FzUHJpY2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHJldmVydCByZWFzb24gc3RyaW5nIGlmIGV4aXN0aW5nIG9yIG90aGVyd2lzZSBmYWxzZS5cbiAqXG4gKiBAbWV0aG9kIGdldFJldmVydFJlYXNvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eE9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBibG9ja051bWJlclxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEJvb2xlYW58U3RyaW5nPn1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5nZXRSZXZlcnRSZWFzb24gPSBmdW5jdGlvbiAodHhPcHRpb25zLCBibG9ja051bWJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAobmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnY2FsbCcsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2NhbGwnLFxuICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgYWJpQ29kZXI6IHNlbGYuYWJpQ29kZXIsXG4gICAgICAgICAgICBoYW5kbGVSZXZlcnQ6IHRydWVcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAuY3JlYXRlRnVuY3Rpb24oc2VsZi5yZXF1ZXN0TWFuYWdlcikodHhPcHRpb25zLCB1dGlscy5udW1iZXJUb0hleChibG9ja051bWJlcikpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBlcnJvci5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogZXJyb3Iuc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gaGV4IHN0cmluZyBpcyBhIHJldmVydCBtZXNzYWdlIGZyb20gdGhlIEVWTVxuICpcbiAqIEBtZXRob2QgaXNSZXZlcnRSZWFzb25TdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSAtIEhleCBzdHJpbmcgcHJlZml4ZWQgd2l0aCAweFxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5NZXRob2QucHJvdG90eXBlLmlzUmV2ZXJ0UmVhc29uU3RyaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmICgoZGF0YS5sZW5ndGggLSAyKSAvIDIpICUgMzIgPT09IDQgJiYgZGF0YS5zdWJzdHJpbmcoMCwgMTApID09PSAnMHgwOGMzNzlhMCc7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSB0aGUgcHVyZSBKU09OUlBDIHJlcXVlc3Qgd2hpY2ggY2FuIGJlIHVzZWQgaW4gYSBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb25ycGMgcmVxdWVzdFxuICovXG5NZXRob2QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNZXRob2Q7XG4iXSwibmFtZXMiOlsiZXJyb3JzIiwicmVxdWlyZSIsImZvcm1hdHRlcnMiLCJ1dGlscyIsInByb21pRXZlbnQiLCJTdWJzY3JpcHRpb25zIiwic3Vic2NyaXB0aW9ucyIsIkV0aGVyc1RyYW5zYWN0aW9uVXRpbHMiLCJNZXRob2QiLCJvcHRpb25zIiwiY2FsbCIsIm5hbWUiLCJFcnJvciIsInBhcmFtcyIsImlucHV0Rm9ybWF0dGVyIiwib3V0cHV0Rm9ybWF0dGVyIiwidHJhbnNmb3JtUGF5bG9hZCIsImV4dHJhRm9ybWF0dGVycyIsImFiaUNvZGVyIiwicmVxdWVzdE1hbmFnZXIiLCJhY2NvdW50cyIsImRlZmF1bHRCbG9jayIsImRlZmF1bHRBY2NvdW50IiwidHJhbnNhY3Rpb25CbG9ja1RpbWVvdXQiLCJ0cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyIsInRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQiLCJ0cmFuc2FjdGlvblBvbGxpbmdJbnRlcnZhbCIsImJsb2NrSGVhZGVyVGltZW91dCIsImRlZmF1bHRDb21tb24iLCJkZWZhdWx0Q2hhaW4iLCJkZWZhdWx0SGFyZGZvcmsiLCJoYW5kbGVSZXZlcnQiLCJwcm90b3R5cGUiLCJzZXRSZXF1ZXN0TWFuYWdlciIsImNyZWF0ZUZ1bmN0aW9uIiwiZnVuYyIsImJ1aWxkQ2FsbCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImF0dGFjaFRvT2JqZWN0Iiwib2JqIiwic3BsaXQiLCJsZW5ndGgiLCJnZXRDYWxsIiwiYXJncyIsImV4dHJhY3RDYWxsYmFjayIsInBvcCIsInZhbGlkYXRlQXJncyIsIkludmFsaWROdW1iZXJPZlBhcmFtcyIsImZvcm1hdElucHV0IiwiX3RoaXMiLCJtYXAiLCJmb3JtYXR0ZXIiLCJpbmRleCIsImZvcm1hdE91dHB1dCIsInJlc3VsdCIsIkFycmF5IiwiaXNBcnJheSIsInJlcyIsImhleEZvcm1hdCIsInRvUGF5bG9hZCIsImNhbGxiYWNrIiwicGF5bG9hZCIsIm1ldGhvZCIsIl9jb25maXJtVHJhbnNhY3Rpb24iLCJkZWZlciIsInByb21pc2VSZXNvbHZlZCIsImNhblVuc3Vic2NyaWJlIiwidGltZW91dENvdW50IiwiY29uZmlybWF0aW9uQ291bnQiLCJpbnRlcnZhbElkIiwiYmxvY2tIZWFkZXJUaW1lb3V0SWQiLCJsYXN0QmxvY2siLCJyZWNlaXB0SlNPTiIsImdhc1Byb3ZpZGVkIiwiZ2FzIiwiaXNDb250cmFjdERlcGxveW1lbnQiLCJkYXRhIiwiZnJvbSIsInRvIiwiaGFzQnl0ZWNvZGUiLCJfZXRoZXJldW1DYWxscyIsImlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIiLCJ2YWwiLCJvdXRwdXRCbG9ja0Zvcm1hdHRlciIsIm91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlciIsImlucHV0QWRkcmVzc0Zvcm1hdHRlciIsImlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyIiwib3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIiLCJ0eXBlIiwic3Vic2NyaXB0aW9uTmFtZSIsIl9ldGhlcmV1bUNhbGwiLCJmb3JFYWNoIiwibXRoZCIsImNoZWNrQ29uZmlybWF0aW9uIiwiZXhpc3RpbmdSZWNlaXB0IiwiaXNQb2xsaW5nIiwiZXJyIiwiYmxvY2tIZWFkZXIiLCJzdWIiLCJ1bnN1YnNjcmliZSIsImNsZWFySW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJyZXNvbHZlIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiY2F0Y2giLCJfZmlyZUVycm9yIiwibWVzc2FnZSIsImV2ZW50RW1pdHRlciIsInJlamVjdCIsInRoZW4iLCJyZWNlaXB0IiwiYmxvY2tIYXNoIiwicmVjZWlwdEZvcm1hdHRlciIsImxpc3RlbmVycyIsImJsb2NrIiwidW5kZWZpbmVkIiwibGF0ZXN0QmxvY2siLCJnZXRCbG9ja0J5TnVtYmVyIiwibGF0ZXN0QmxvY2tIYXNoIiwiaGFzaCIsIm51bWJlciIsImVtaXQiLCJibG9ja051bWJlciIsInJlbW92ZUFsbExpc3RlbmVycyIsImNvbnRyYWN0QWRkcmVzcyIsIk5vQ29udHJhY3RBZGRyZXNzRm91bmRFcnJvciIsImNvZGUiLCJnZXRDb2RlIiwiZGVwbG95bWVudFN1Y2Nlc3MiLCJzdGF0dXMiLCJjb250cmFjdERlcGxveUZvcm1hdHRlciIsIkNvbnRyYWN0Q29kZU5vdFN0b3JlZEVycm9yIiwib3V0T2ZHYXMiLCJnYXNVc2VkIiwiSlNPTiIsInN0cmluZ2lmeSIsInJldmVydE1lc3NhZ2UiLCJ0eFJlcGxheU9wdGlvbnMiLCJyYXdUcmFuc2FjdGlvbkhleCIsInBhcnNlZFR4IiwicGFyc2UiLCJpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyIiwiZ2FzTGltaXQiLCJ0b0hleFN0cmluZyIsImdhc1ByaWNlIiwiZ2V0UmV2ZXJ0UmVhc29uIiwiVHJhbnNhY3Rpb25SZXZlcnRJbnN0cnVjdGlvbkVycm9yIiwicmVhc29uIiwic2lnbmF0dXJlIiwiZXJyb3IiLCJUcmFuc2FjdGlvblJldmVydGVkV2l0aG91dFJlYXNvbkVycm9yIiwiVHJhbnNhY3Rpb25PdXRPZkdhc0Vycm9yIiwiVHJhbnNhY3Rpb25FcnJvciIsInN0YXJ0V2F0Y2hpbmciLCJibG9ja0hlYWRlckFycml2ZWQiLCJzdGFydEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJiaW5kIiwicHJvdmlkZXIiLCJvbiIsInN1YnNjcmliZSIsInNldFRpbWVvdXQiLCJnZXRXYWxsZXQiLCJ3YWxsZXQiLCJhZGRyZXNzIiwicHJpdmF0ZUtleSIsInRvTG93ZXJDYXNlIiwiaXNTZW5kVHgiLCJpc0NhbGwiLCJzZW5kIiwic2xpY2UiLCJhcmd1bWVudHMiLCJzZW5kVHhDYWxsYmFjayIsInJlYXNvbkRhdGEiLCJpc1JldmVydFJlYXNvblN0cmluZyIsInN1YnN0cmluZyIsIm9yaWdpbmFsRXJyb3IiLCJkZWNvZGVQYXJhbWV0ZXIiLCJSZXZlcnRJbnN0cnVjdGlvbkVycm9yIiwiZSIsInNlbmRTaWduZWRUeCIsInNpZ24iLCJzaWduZWRQYXlsb2FkIiwicmF3VHJhbnNhY3Rpb24iLCJzZW5kUmVxdWVzdCIsInR4IiwiY2hhaW4iLCJoYXJkZm9yayIsImNvbW1vbiIsInNpZ25UcmFuc2FjdGlvbiIsImhhc1NlbmRUeE9iamVjdCIsImFjY2Vzc0xpc3QiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsIl9oYW5kbGVUeFByaWNpbmciLCJ0eFByaWNpbmciLCJyZXF1ZXN0IiwiUHJvbWlzZSIsInRvSGV4IiwiZ2V0R2FzUHJpY2UiLCJhbGwiLCJyZXNwb25zZXMiLCJiYXNlRmVlUGVyR2FzIiwidG9CTiIsIm11bCIsImFkZCIsInR4T3B0aW9ucyIsInNlbGYiLCJudW1iZXJUb0hleCIsImZvcm1hdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-core-method/lib/index.js\n");

/***/ })

};
;