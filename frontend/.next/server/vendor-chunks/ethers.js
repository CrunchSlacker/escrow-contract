"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.9.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFpRSxHQUNqRTs7Q0FFQyxHQUNNLE1BQU1BLFVBQVUsUUFBUSxDQUMvQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9fdmVyc2lvbi5qcz82ZTE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIERvIE5PVCBtb2RpZnkgdGhpcyBmaWxlOyBzZWUgL3NyYy50cy9fYWRtaW4vdXBkYXRlLXZlcnNpb24udHMgKi9cbi8qKlxuICogIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgRXRoZXJzLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiNi45LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/boolean.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/string.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/tuple.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_3__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(param.components.map((c)=>this.#getCoder(c)), param.name);\n        }\n        switch(param.baseType){\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_5__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_7__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Reader(data, loose));\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n} //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG1FQUFtRTtBQUNLO0FBQ1o7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUNNO0FBQ2dCO0FBQ2pFLG1FQUFtRTtBQUNuRSxNQUFNa0IsZUFBZSxJQUFJQztBQUN6QkQsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkIsTUFBTUMsaUJBQWlCLElBQUlDLE9BQU87QUFDbEMsTUFBTUMsa0JBQWtCLElBQUlELE9BQU87QUFDbkMsSUFBSUUsZUFBZTtBQUNuQixTQUFTQyx3QkFBd0JDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7SUFDdkQsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFNBQVM7SUFDYixNQUFNQyxhQUFhO0lBQ25CLElBQUlDLFNBQVM7SUFDYixJQUFJTCxNQUFNO1FBQ05FLFVBQVU7UUFDVixNQUFNSSxRQUFRbkIseURBQVFBLENBQUNhO1FBQ3ZCQSxPQUFPWix3REFBT0EsQ0FBQ1k7UUFDZixJQUFJTSxNQUFNQyxNQUFNLEtBQUssR0FBRztZQUNwQkwsV0FBVztZQUNYQyxTQUFTO1FBQ2IsT0FDSyxJQUFJRyxNQUFNQyxNQUFNLEdBQUcsT0FB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QUFJeEQsd0RBQVVBLENBQUN1RCxRQUFRO1FBQ3RDLE1BQU1LLFNBQVMsSUFBSXJFLDhEQUFNQTtRQUN6QmlFLE1BQU1FLE1BQU0sQ0FBQ0UsUUFBUUQ7UUFDckIsT0FBT0MsT0FBTzVDLElBQUk7SUFDdEI7SUFDQTs7Ozs7O0tBTUMsR0FDRFMsT0FBTzZCLEtBQUssRUFBRXRDLElBQUksRUFBRTZDLEtBQUssRUFBRTtRQUN2QixNQUFNTixTQUFTRCxNQUFNUixHQUFHLENBQUMsQ0FBQ0ksT0FBUyxJQUFJLENBQUMsQ0FBQ1gsUUFBUSxDQUFDdEMscURBQVNBLENBQUNvQyxJQUFJLENBQUNhO1FBQ2pFLE1BQU1NLFFBQVEsSUFBSXhELHdEQUFVQSxDQUFDdUQsUUFBUTtRQUNyQyxPQUFPQyxNQUFNL0IsTUFBTSxDQUFDLElBQUluQyw4REFBTUEsQ0FBQzBCLE1BQU02QztJQUN6QztJQUNBOzs7O0tBSUMsR0FDRCxPQUFPQyxrQkFBa0I7UUFDckIsSUFBSWxELGdCQUFnQixNQUFNO1lBQ3RCQSxlQUFlLElBQUkwQjtRQUN2QjtRQUNBLE9BQU8xQjtJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU9DLHdCQUF3QkMsTUFBTSxFQUFFQyxFQUFFLEVBQUVDLElBQUksRUFBRTtRQUM3QyxPQUFPSCx3QkFBd0JDLFFBQVFDLElBQUlDLE1BQU1zQixTQUFTd0IsZUFBZTtJQUM3RTtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcz9mZDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFdoZW4gc2VuZGluZyB2YWx1ZXMgdG8gb3IgcmVjZWl2aW5nIHZhbHVlcyBmcm9tIGEgW1tDb250cmFjdF1dLCB0aGVcbiAqICBkYXRhIGlzIGdlbmVyYWxseSBlbmNvZGVkIHVzaW5nIHRoZSBbQUJJIHN0YW5kYXJkXShsaW5rLXNvbGMtYWJpKS5cbiAqXG4gKiAgVGhlIEFiaUNvZGVyIHByb3ZpZGVzIGEgdXRpbGl0eSB0byBlbmNvZGUgdmFsdWVzIHRvIEFCSSBkYXRhIGFuZFxuICogIGRlY29kZSB2YWx1ZXMgZnJvbSBBQkkgZGF0YS5cbiAqXG4gKiAgTW9zdCBvZiB0aGUgdGltZSwgZGV2ZWxvcGVycyBzaG91bGQgZmF2b3VyIHRoZSBbW0NvbnRyYWN0XV0gY2xhc3MsXG4gKiAgd2hpY2ggZnVydGhlciBhYnN0cmFjdHMgYSBsb3Qgb2YgdGhlIGZpbmVyIGRldGFpbHMgb2YgQUJJIGRhdGEuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpBQkkgRW5jb2RpbmdcbiAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXNzZXJ0QXJndW1lbnRDb3VudCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheS5qc1wiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW4uanNcIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXMuanNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlcy5qc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGwuanNcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlci5qc1wiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlLmpzXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnksIG1ha2VFcnJvciB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbFxuY29uc3QgUGFuaWNSZWFzb25zID0gbmV3IE1hcCgpO1xuUGFuaWNSZWFzb25zLnNldCgweDAwLCBcIkdFTkVSSUNfUEFOSUNcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDEsIFwiQVNTRVJUX0ZBTFNFXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDExLCBcIk9WRVJGTE9XXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDEyLCBcIkRJVklERV9CWV9aRVJPXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDIxLCBcIkVOVU1fUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjIsIFwiQkFEX1NUT1JBR0VfREFUQVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMSwgXCJTVEFDS19VTkRFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MzIsIFwiQVJSQVlfUkFOR0VfRVJST1JcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4NDEsIFwiT1VUX09GX01FTU9SWVwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg1MSwgXCJVTklOSVRJQUxJWkVEX0ZVTkNUSU9OX0NBTExcIik7XG5jb25zdCBwYXJhbVR5cGVCeXRlcyA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pO1xuY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbmxldCBkZWZhdWx0Q29kZXIgPSBudWxsO1xuZnVuY3Rpb24gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgYWJpQ29kZXIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IFwibWlzc2luZyByZXZlcnQgZGF0YVwiO1xuICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSBudWxsO1xuICAgIGxldCByZXZlcnQgPSBudWxsO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImV4ZWN1dGlvbiByZXZlcnRlZFwiO1xuICAgICAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAobm8gZGF0YSBwcmVzZW50OyBsaWtlbHkgcmVxdWlyZShmYWxzZSkgb2NjdXJyZWRcIjtcbiAgICAgICAgICAgIHJlYXNvbiA9IFwicmVxdWlyZShmYWxzZSlcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggJSAzMiAhPT0gNCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSByZWFzb247IGludmFsaWQgZGF0YSBsZW5ndGgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG4gICAgICAgICAgICAvLyBFcnJvcihzdHJpbmcpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGFiaUNvZGVyLmRlY29kZShbXCJzdHJpbmdcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlYXNvbl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDogJHtKU09OLnN0cmluZ2lmeShyZWFzb24pfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBzdHJpbmcgZGF0YSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyBnZXRBZGRyZXNzKHR4LnRvKSA6IG51bGwpLFxuICAgICAgICBkYXRhOiAodHguZGF0YSB8fCBcIjB4XCIpXG4gICAgfTtcbiAgICBpZiAodHguZnJvbSkge1xuICAgICAgICB0cmFuc2FjdGlvbi5mcm9tID0gZ2V0QWRkcmVzcyh0eC5mcm9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VFcnJvcihtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICAjZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuI2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGdpdmVuICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBgYHVpbnRgYCBpcyBieSBkZWZhdWx0IGBgMGBgIGFuZCBgYGJvb2xgYFxuICAgICAqICBpcyBieSBkZWZhdWx0IGBgZmFsc2VgYC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlcy5sZW5ndGgsIHR5cGVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIpO1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gKG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgdGhlIEFCSSAlJWRhdGElJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlbG9vc2UlJSBkZWNvZGluZyBpcyBlbmFibGVkLCB0aGVuIHN0cmljdCBwYWRkaW5nIGlzXG4gICAgICogIG5vdCBlbmZvcmNlZC4gU29tZSBvbGRlciB2ZXJzaW9ucyBvZiBTb2xpZGl0eSBpbmNvcnJlY3RseVxuICAgICAqICBwYWRkZWQgZXZlbnQgZGF0YSBlbWl0dGVkIGZyb20gYGBleHRlcm5hbGBgIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZShuZXcgUmVhZGVyKGRhdGEsIGxvb3NlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydEFyZ3VtZW50Q291bnQiLCJhc3NlcnRBcmd1bWVudCIsIlJlYWRlciIsIldyaXRlciIsIkFkZHJlc3NDb2RlciIsIkFycmF5Q29kZXIiLCJCb29sZWFuQ29kZXIiLCJCeXRlc0NvZGVyIiwiRml4ZWRCeXRlc0NvZGVyIiwiTnVsbENvZGVyIiwiTnVtYmVyQ29kZXIiLCJTdHJpbmdDb2RlciIsIlR1cGxlQ29kZXIiLCJQYXJhbVR5cGUiLCJnZXRBZGRyZXNzIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibWFrZUVycm9yIiwiUGFuaWNSZWFzb25zIiwiTWFwIiwic2V0IiwicGFyYW1UeXBlQnl0ZXMiLCJSZWdFeHAiLCJwYXJhbVR5cGVOdW1iZXIiLCJkZWZhdWx0Q29kZXIiLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImFjdGlvbiIsInR4IiwiZGF0YSIsImFiaUNvZGVyIiwibWVzc2FnZSIsInJlYXNvbiIsImludm9jYXRpb24iLCJyZXZlcnQiLCJieXRlcyIsImxlbmd0aCIsInNsaWNlIiwiZGVjb2RlIiwic2lnbmF0dXJlIiwibmFtZSIsImFyZ3MiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb2RlIiwiTnVtYmVyIiwiZ2V0IiwidHJhbnNhY3Rpb24iLCJ0byIsImZyb20iLCJBYmlDb2RlciIsImdldENvZGVyIiwicGFyYW0iLCJpc0FycmF5IiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiaXNUdXBsZSIsImNvbXBvbmVudHMiLCJtYXAiLCJjIiwiYmFzZVR5cGUiLCJtYXRjaCIsInR5cGUiLCJzaXplIiwicGFyc2VJbnQiLCJnZXREZWZhdWx0VmFsdWUiLCJ0eXBlcyIsImNvZGVycyIsImNvZGVyIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwidmFsdWVzIiwid3JpdGVyIiwibG9vc2UiLCJkZWZhdWx0QWJpQ29kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n * @_ignore:\n */ const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    #names;\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(...args) {\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray() {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject() {\n        return this.#names.reduce((accum, name, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n            return accum;\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = this.#names.indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            Padding.slice(bytes.length % WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    constructor(name, type, localName, dynamic){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */ class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor(){\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)(this.#data);\n    }\n    get length() {\n        return this.#dataLength;\n    }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value)=>{\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */ class Reader {\n    #data;\n    #offset;\n    constructor(data, allowLoose){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(data);\n        this.#offset = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(this.#data);\n    }\n    get dataLength() {\n        return this.#data.length;\n    }\n    get consumed() {\n        return this.#offset;\n    }\n    get bytes() {\n        return new Uint8Array(this.#data);\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n} //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXlKO0FBQ3pKOztDQUVDLEdBQ00sTUFBTVUsV0FBVyxHQUFHO0FBQzNCLE1BQU1DLFVBQVUsSUFBSUMsV0FBV0Y7QUFDL0IscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxNQUFNRyxpQkFBaUI7SUFBQztDQUFPO0FBQy9CLE1BQU1DLFNBQVMsQ0FBQztBQUNoQixTQUFTQyxXQUFXQyxJQUFJLEVBQUVDLEtBQUs7SUFDM0IsTUFBTUMsVUFBVSxJQUFJQyxNQUFNLENBQUMsdURBQXVELEVBQUVILEtBQUssQ0FBQztJQUMxRkUsUUFBUUQsS0FBSyxHQUFHQTtJQUNoQixNQUFNQztBQUNWO0FBQ0E7Ozs7OztDQU1DLEdBQ00sTUFBTUUsZUFBZUM7SUFDeEIsQ0FBQ0MsS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREMsWUFBWSxHQUFHQyxJQUFJLENBQUU7UUFDakIsb0RBQW9EO1FBQ3BELHVEQUF1RDtRQUN2RCx3REFBd0Q7UUFDeEQsdURBQXVEO1FBQ3ZELGtEQUFrRDtRQUNsRCwyRUFBMkU7UUFDM0UsTUFBTUMsUUFBUUQsSUFBSSxDQUFDLEVBQUU7UUFDckIsSUFBSUUsUUFBUUYsSUFBSSxDQUFDLEVBQUU7UUFDbkIsSUFBSUYsUUFBUSxDQUFDRSxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRUcsS0FBSztRQUNqQyxJQUFJQyxPQUFPO1FBQ1gsSUFBSUgsVUFBVVgsUUFBUTtZQUNsQlksUUFBUUY7WUFDUkYsUUFBUSxFQUFFO1lBQ1ZNLE9BQU87UUFDWDtRQUNBLHlEQUF5RDtRQUN6RCxrQ0FBa0M7UUFDbEMsS0FBSyxDQUFDRixNQUFNRyxNQUFNO1FBQ2xCSCxNQUFNSSxPQUFPLENBQUMsQ0FBQ0MsTUFBTUM7WUFBWSxJQUFJLENBQUNBLE1BQU0sR0FBR0Q7UUFBTTtRQUNyRCx1QkFBdUI7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QUFhO0lBQ2JRLFVBQVU5RSxNQUFNLEVBQUV5RSxLQUFLLEVBQUU7UUFDckIsSUFBSXZCLFFBQVEsSUFBSSxDQUFDLENBQUNzQixTQUFTLENBQUMsR0FBR3hFLFFBQVEsQ0FBQyxDQUFDeUU7UUFDekMsSUFBSSxDQUFDLENBQUNyQixNQUFNLElBQUlGLE1BQU1sRCxNQUFNO1FBQzVCLG9EQUFvRDtRQUNwRCxPQUFPa0QsTUFBTXBELEtBQUssQ0FBQyxHQUFHRTtJQUMxQjtJQUNBLHdCQUF3QjtJQUN4QitFLFlBQVk7UUFDUixPQUFPdEcseURBQVFBLENBQUMsSUFBSSxDQUFDcUcsU0FBUyxDQUFDakc7SUFDbkM7SUFDQW1HLFlBQVk7UUFDUixPQUFPdEcseURBQVFBLENBQUMsSUFBSSxDQUFDb0csU0FBUyxDQUFDakc7SUFDbkM7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanM/Y2VmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBjb25jYXQsIGdldEJ5dGVzQ29weSwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCB0b0JlQXJyYXksIHRvQmlnSW50LCB0b051bWJlciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmRTaXplID0gMzI7XG5jb25zdCBQYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5leHBvcnQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgICNuYW1lcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIC8vIFRvIHByb3Blcmx5IHN1Yi1jbGFzcyBBcnJheSBzbyB0aGUgb3RoZXIgYnVpbHQtaW5cbiAgICAgICAgLy8gZnVuY3Rpb25zIHdvcmssIHRoZSBjb25zdHJ1Y3RvciBoYXMgdG8gYmVoYXZlIGZhaXJseVxuICAgICAgICAvLyB3ZWxsLiBTbywgaW4gdGhlIGV2ZW50IHdlIGFyZSBjcmVhdGVkIHZpYSBmcm9tSXRlbXMoKVxuICAgICAgICAvLyB3ZSBidWlsZCB0aGUgcmVhZC1vbmx5IFJlc3VsdCBvYmplY3Qgd2Ugd2FudCwgYnV0IG9uXG4gICAgICAgIC8vIGFueSBvdGhlciBpbnB1dCwgd2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGNvbnN0cnVjdG9yKGd1YXJkOiBhbnksIGl0ZW1zOiBBcnJheTxhbnk+LCBrZXlzPzogQXJyYXk8bnVsbCB8IHN0cmluZz4pO1xuICAgICAgICBjb25zdCBndWFyZCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBpdGVtcyA9IGFyZ3NbMV07XG4gICAgICAgIGxldCBuYW1lcyA9IChhcmdzWzJdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBsZXQgd3JhcCA9IHRydWU7XG4gICAgICAgIGlmIChndWFyZCAhPT0gX2d1YXJkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGFyZ3M7XG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgd3JhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGp1c3QgcGFzcyBpbiAuLi5pdGVtcyBzaW5jZSBhbiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBpcyBhIHNwZWNpYWwgY2FzZSBpbiB0aGUgc3VwZXIuXG4gICAgICAgIHN1cGVyKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7IHRoaXNbaW5kZXhdID0gaXRlbTsgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBrZXlzXG4gICAgICAgIGNvbnN0IG5hbWVDb3VudHMgPSBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtLnNldChuYW1lLCAoYWNjdW0uZ2V0KG5hbWUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIChuZXcgTWFwKCkpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBrZXkgdGhhdHMgbm90IHVuaXF1ZVxuICAgICAgICB0aGlzLiNuYW1lcyA9IE9iamVjdC5mcmVlemUoaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgbmFtZUNvdW50cy5nZXQobmFtZSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmICghd3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgd3JhcHBlZCBSZXN1bHQgaXMgaW1tdXRhYmxlXG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIC8vIFByb3h5IGluZGljZXMgYW5kIG5hbWVzIHNvIHdlIGNhbiB0cmFwIGRlZmVycmVkIGVycm9yc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleCBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXROdW1iZXIocHJvcCwgXCIlaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9ucyB3b3JrIHdpdGggcHJpdmF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRWYWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSAhPSBudWxsLCBcInZhbHVlIGF0IGluZGV4ICR7IGluZGV4IH0gdW5uYW1lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvT2JqZWN0KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWVzIGZvciBuYW1lcyB0aGF0IGRvbid0IGNvbmZsaWN0XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5nZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKHRoaXMuI25hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBmaWx0ZXIoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHRoaXMuI25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBtYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGZvciAlJW5hbWUlJS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcbiAgICAgKiAgYSBtZXRob2Qgb24gYSBbW1Jlc3VsdF1dIG9yIGl0cyBzdXBlcmNsYXNzIEFycmF5LCBvciBhbnlcbiAgICAgKiAgSmF2YVNjcmlwdCBrZXl3b3JkLCB0aGlzIGVuc3VyZXMgYWxsIG5hbWVkIHZhbHVlcyBhcmUgc3RpbGxcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhbHVlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNuYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbUmVzdWx0XV0gZm9yICUlaXRlbXMlJSB3aXRoIGVhY2ggZW50cnlcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JdGVtcyhpdGVtcywga2V5cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gV29yZFNpemUpIHtcbiAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgLy8gVGhlIGNvZGVyIG5hbWU6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlLCBhcnJheSwgZXRjLlxuICAgIG5hbWU7XG4gICAgLy8gVGhlIGZ1bGx5IGV4cGFuZGVkIHR5cGUsIGluY2x1ZGluZyBjb21wb3NpdGUgdHlwZXM6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlKGFkZHJlc3MsYnl0ZXMpLCB1aW50MjU2WzNdWzRdW10sICBldGMuXG4gICAgdHlwZTtcbiAgICAvLyBUaGUgbG9jYWxOYW1lIGJvdW5kIGluIHRoZSBzaWduYXR1cmUsIGluIHRoaXMgZXhhbXBsZSBpdCBpcyBcImJhelwiOlxuICAgIC8vICAgLSB0dXBsZShhZGRyZXNzIGZvbywgdWludCBiYXIpIGJhelxuICAgIGxvY2FsTmFtZTtcbiAgICAvLyBXaGV0aGVyIHRoaXMgdHlwZSBpcyBkeW5hbWljOlxuICAgIC8vICAtIER5bmFtaWM6IGJ5dGVzLCBzdHJpbmcsIGFkZHJlc3NbXSwgdHVwbGUoYm9vbGVhbltdKSwgZXRjLlxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcbiAgICBkeW5hbWljO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRCeXRlc0NvcHkod3JpdGVyLmRhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbTsgcGFkIG9uIHRoZSByaWdodCB0byAqbmVhcmVzdCogV29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhbGxvd0xvb3NlOiAhIWFsbG93TG9vc2UgfSk7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNwZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIFdvcmRTaXplKSAqIFdvcmRTaXplO1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCA+IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuI29mZnNldCArIGxlbmd0aCA8PSB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFsaWduZWRMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGdldEJ5dGVzQ29weSh0aGlzLiNkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLiNkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0LCB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgc3ViLXJlYWRlciB3aXRoIHRoZSBzYW1lIHVuZGVybHlpbmcgZGF0YSwgYnV0IG9mZnNldFxuICAgIHN1YlJlYWRlcihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UpO1xuICAgIH1cbiAgICAvLyBSZWFkIGJ5dGVzXG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnSW50KHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJjb25jYXQiLCJnZXRCeXRlc0NvcHkiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwidG9CaWdJbnQiLCJ0b051bWJlciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiV29yZFNpemUiLCJQYWRkaW5nIiwiVWludDhBcnJheSIsInBhc3NQcm9wZXJ0aWVzIiwiX2d1YXJkIiwidGhyb3dFcnJvciIsIm5hbWUiLCJlcnJvciIsIndyYXBwZWQiLCJFcnJvciIsIlJlc3VsdCIsIkFycmF5IiwibmFtZXMiLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJndWFyZCIsIml0ZW1zIiwic2xpY2UiLCJ3cmFwIiwibGVuZ3RoIiwiZm9yRWFjaCIsIml0ZW0iLCJpbmRleCIsIm5hbWVDb3VudHMiLCJyZWR1Y2UiLCJhY2N1bSIsInNldCIsImdldCIsIk1hcCIsIk9iamVjdCIsImZyZWV6ZSIsIm1hcCIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiaW5kZXhPZiIsIlJlZmxlY3QiLCJ2YWx1ZSIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJnZXRWYWx1ZSIsInRvQXJyYXkiLCJyZXN1bHQiLCJwdXNoIiwidG9PYmplY3QiLCJvcGVyYXRpb24iLCJzdGFydCIsImVuZCIsImkiLCJmaWx0ZXIiLCJjYWxsYmFjayIsInRoaXNBcmciLCJjYWxsIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImZyb21JdGVtcyIsImtleXMiLCJjaGVja1Jlc3VsdEVycm9ycyIsImVycm9ycyIsImNoZWNrRXJyb3JzIiwicGF0aCIsIm9iamVjdCIsImlzQXJyYXkiLCJrZXkiLCJjaGlsZFBhdGgiLCJieXRlcyIsImJ1ZmZlciIsIm9mZnNldCIsIkNvZGVyIiwidHlwZSIsImxvY2FsTmFtZSIsImR5bmFtaWMiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJXcml0ZXIiLCJkYXRhIiwiZGF0YUxlbmd0aCIsIndyaXRlRGF0YSIsImFwcGVuZFdyaXRlciIsIndyaXRlciIsIndyaXRlQnl0ZXMiLCJwYWRkaW5nT2Zmc2V0Iiwid3JpdGVWYWx1ZSIsIndyaXRlVXBkYXRhYmxlVmFsdWUiLCJSZWFkZXIiLCJhbGxvd0xvb3NlIiwiY29uc3VtZWQiLCJwZWVrQnl0ZXMiLCJsb29zZSIsImFsaWduZWRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsInN1YlJlYWRlciIsInJlYWRCeXRlcyIsInJlYWRWYWx1ZSIsInJlYWRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ0w7QUFDWDtBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUkscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsV0FBVyxXQUFXQSxXQUFXO0lBQzNDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsSUFBSUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN0QyxJQUFJO1lBQ0FDLFFBQVFYLDZEQUFVQSxDQUFDVztRQUN2QixFQUNBLE9BQU9FLE9BQU87WUFDVixPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxNQUFNRSxPQUFPLEVBQUVMO1FBQzNDO1FBQ0EsT0FBT0QsT0FBT08sVUFBVSxDQUFDTDtJQUM3QjtJQUNBTSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPbEIsNkRBQVVBLENBQUNDLHdEQUFPQSxDQUFDaUIsT0FBT0MsU0FBUyxJQUFJO0lBQ2xEO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2FkZHJlc3MuanM/Y2E4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uLy4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IHRvQmVIZXggfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcihlcnJvci5tZXNzYWdlLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModG9CZUhleChyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsInRvQmVIZXgiLCJUeXBlZCIsIkNvZGVyIiwiQWRkcmVzc0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwiZXJyb3IiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7Ozs7Q0FJQyxHQUNNLE1BQU1DLHVCQUF1QkQscURBQUtBO0lBRXJDRSxZQUFZQyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBLE1BQU1DLElBQUksRUFBRUQsTUFBTUUsSUFBSSxFQUFFLEtBQUtGLE1BQU1HLE9BQU87UUFDaEQsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FJLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxZQUFZO0lBQ2xDO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDUCxLQUFLLENBQUNLLE1BQU0sQ0FBQ0MsUUFBUUM7SUFDckM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1EsTUFBTSxDQUFDQztJQUM3QjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanM/ZDRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBDbG9uZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gZXhpc3RpbmcgQ29kZXIsIGJ1dCB3aXRob3V0IGEgbG9jYWxOYW1lXG4gKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJBbm9ueW1vdXNDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXIiLCJuYW1lIiwidHlwZSIsImR5bmFtaWMiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anonymous.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */ class ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_4__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RztBQUMxRTtBQUNrQztBQUN0QjtBQUNoRDs7Q0FFQyxHQUNNLFNBQVNXLEtBQUtDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNO0lBQ3ZDLElBQUlDLGNBQWMsRUFBRTtJQUNwQixJQUFJQyxNQUFNQyxPQUFPLENBQUNILFNBQVM7UUFDdkJDLGNBQWNEO0lBQ2xCLE9BQ0ssSUFBSUEsVUFBVSxPQUFRQSxXQUFZLFVBQVU7UUFDN0MsSUFBSUksU0FBUyxDQUFDO1FBQ2RILGNBQWNGLE9BQU9NLEdBQUcsQ0FBQyxDQUFDQztZQUN0QixNQUFNQyxPQUFPRCxNQUFNRSxTQUFTO1lBQzVCcEIsdURBQU1BLENBQUNtQixNQUFNLHlEQUF5RCxvQkFBb0I7Z0JBQUVFLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVKO2dCQUFNO2dCQUFHSyxPQUFPWDtZQUFPO1lBQy9JWix1REFBTUEsQ0FBQyxDQUFDZ0IsTUFBTSxDQUFDRyxLQUFLLEVBQUUsMkRBQTJELG9CQUFvQjtnQkFBRUUsVUFBVTtnQkFBVUMsTUFBTTtvQkFBRUo7Z0JBQU07Z0JBQUdLLE9BQU9YO1lBQU87WUFDMUpJLE1BQU0sQ0FBQ0csS0FBSyxHQUFHO1lBQ2YsT0FBT1AsTUFBTSxDQUFDTyxLQUFLO1FBQ3ZCO0lBQ0osT0FDSztRQUNEbEIsK0RBQWNBLENBQUMsT0FBTyx1QkFBdUIsU0FBU1c7SUFDMUQ7SUFDQVgsK0RBQWNBLENBQUNVLE9BQU9hLE1BQU0sS0FBS1gsWUFBWVcsTUFBTSxFQUFFLCtCQUErQixTQUFTWjtJQUM3RixJQUFJYSxlQUFlLElBQUlsQixzREFBTUE7SUFDN0IsSUFBSW1CLGdCQUFnQixJQUFJbkIsc0RBQU1BO0lBQzlCLElBQUlvQixjQUFjLEVBQUU7SUFDcEJoQixPQUFPaUIsT0FBTyxDQUFDLENBQUNWLE9BQU9XO1FBQ25CLElBQUlO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RCxRQUFRekQsd0RBQVFBLElBQUlrQyxPQUFPeUIsVUFBVSxFQUFFLDRCQUE0QixrQkFBa0I7Z0JBQUVDLFFBQVExQixPQUFPMkIsS0FBSztnQkFBRXZCLFFBQVFtQixRQUFRekQsd0RBQVFBO2dCQUFFa0IsUUFBUWdCLE9BQU95QixVQUFVO1lBQUM7UUFDNUs7UUFDQSxJQUFJdEQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJZ0QsSUFBSSxHQUFHQSxJQUFJSSxPQUFPSixJQUFLO1lBQzVCaEQsT0FBT3dCLElBQUksQ0FBQyxJQUFJM0IseURBQWNBLENBQUMsSUFBSSxDQUFDVSxLQUFLO1FBQzdDO1FBQ0EsT0FBT3FCLE9BQU9DLFFBQVE3QjtJQUMxQjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcz9hOGJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGlzRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydEFyZ3VtZW50Q291bnQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgUmVzdWx0LCBXb3JkU2l6ZSwgV3JpdGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFub255bW91c0NvZGVyIH0gZnJvbSBcIi4vYW5vbnltb3VzLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggbWlzc2luZyBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgYXNzZXJ0KCF1bmlxdWVbbmFtZV0sIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogXCJ2YWx1ZXNcIiwgaW5mbzogeyBjb2RlciB9LCB2YWx1ZTogdmFsdWVzIH0pO1xuICAgICAgICAgICAgdW5pcXVlW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvZGVycy5sZW5ndGggPT09IGFycmF5VmFsdWVzLmxlbmd0aCwgXCJ0eXBlcy92YWx1ZSBsZW5ndGggbWlzbWF0Y2hcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIGxldCBzdGF0aWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICAvLyBBIHJlYWRlciBhbmNob3JlZCB0byB0aGlzIGJhc2VcbiAgICBsZXQgYmFzZVJlYWRlciA9IHJlYWRlci5zdWJSZWFkZXIoMCk7XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgbGV0IG9mZnNldFJlYWRlciA9IGJhc2VSZWFkZXIuc3ViUmVhZGVyKG9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkJVRkZFUl9PVkVSUlVOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmVzdGlnYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAga2V5cy5wdXNoKGNvZGVyLmxvY2FsTmFtZSB8fCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5Q29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgbGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyLCBsZW5ndGggfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgLy8gVmVyaWZpZXMgdGhlIGNoaWxkIGNvZGVyIGlzIHZhbGlkIChldmVuIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljIG9yIDAtbGVuZ3RoKVxuICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGQgPSB0aGlzLmNvZGVyLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWZhdWx0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRJbmRleCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyAqcm91Z2hseSogZW5vdWdoIGRhdGEgdG8gZW5zdXJlXG4gICAgICAgICAgICAvLyBzdHJheSByYW5kb20gZGF0YSBpcyBub3QgYmVpbmcgcmVhZCBhcyBhIGxlbmd0aC4gRWFjaFxuICAgICAgICAgICAgLy8gc2xvdCByZXF1aXJlcyBhdCBsZWFzdCAzMiBieXRlcyBmb3IgdGhlaXIgdmFsdWUgKG9yIDMyXG4gICAgICAgICAgICAvLyBieXRlcyBhcyBhIGxpbmsgdG8gdGhlIGRhdGEpLiBUaGlzIGNvdWxkIHVzZSBhIG11Y2hcbiAgICAgICAgICAgIC8vIHRpZ2h0ZXIgYm91bmQsIGJ1dCB3ZSBhcmUgZXJyb3Jpbmcgb24gdGhlIHNpZGUgb2Ygc2FmZXR5LlxuICAgICAgICAgICAgYXNzZXJ0KGNvdW50ICogV29yZFNpemUgPD0gcmVhZGVyLmRhdGFMZW5ndGgsIFwiaW5zdWZmaWNpZW50IGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwgeyBidWZmZXI6IHJlYWRlci5ieXRlcywgb2Zmc2V0OiBjb3VudCAqIFdvcmRTaXplLCBsZW5ndGg6IHJlYWRlci5kYXRhTGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCBjb2RlcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiaXNFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0QXJndW1lbnRDb3VudCIsIlR5cGVkIiwiQ29kZXIiLCJSZXN1bHQiLCJXb3JkU2l6ZSIsIldyaXRlciIsIkFub255bW91c0NvZGVyIiwicGFjayIsIndyaXRlciIsImNvZGVycyIsInZhbHVlcyIsImFycmF5VmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidW5pcXVlIiwibWFwIiwiY29kZXIiLCJuYW1lIiwibG9jYWxOYW1lIiwiYXJndW1lbnQiLCJpbmZvIiwidmFsdWUiLCJsZW5ndGgiLCJzdGF0aWNXcml0ZXIiLCJkeW5hbWljV3JpdGVyIiwidXBkYXRlRnVuY3MiLCJmb3JFYWNoIiwiaW5kZXgiLCJkeW5hbWljIiwiZHluYW1pY09mZnNldCIsImVuY29kZSIsInVwZGF0ZUZ1bmMiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwicHVzaCIsImJhc2VPZmZzZXQiLCJmdW5jIiwiYXBwZW5kV3JpdGVyIiwidW5wYWNrIiwicmVhZGVyIiwia2V5cyIsImJhc2VSZWFkZXIiLCJzdWJSZWFkZXIiLCJvZmZzZXQiLCJyZWFkSW5kZXgiLCJvZmZzZXRSZWFkZXIiLCJkZWNvZGUiLCJlcnJvciIsImJhc2VUeXBlIiwidHlwZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiZnJvbUl0ZW1zIiwiQXJyYXlDb2RlciIsImNvbnN0cnVjdG9yIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoaWxkIiwicmVzdWx0IiwiaSIsIl92YWx1ZSIsImRlcmVmZXJlbmNlIiwiX3Rocm93RXJyb3IiLCJjb3VudCIsIndyaXRlVmFsdWUiLCJkYXRhTGVuZ3RoIiwiYnVmZmVyIiwiYnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUUscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxRQUFRQSxXQUFXO0lBQ3JDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN4QyxPQUFPRCxPQUFPSSxVQUFVLENBQUNGLFFBQVEsSUFBSTtJQUN6QztJQUNBRyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQ0EsT0FBT0MsU0FBUztJQUM3QjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzPzg2YzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYm9vbFwiKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAhIXJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCJdLCJuYW1lcyI6WyJUeXBlZCIsIkNvZGVyIiwiQm9vbGVhbkNvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2pCO0FBQzVDOztDQUVDLEdBQ00sTUFBTUcsMEJBQTBCRCxxREFBS0E7SUFDeENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsTUFBTUEsTUFBTUMsV0FBVztJQUNqQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCQSxRQUFRViw2REFBWUEsQ0FBQ1U7UUFDckIsSUFBSUMsU0FBU0YsT0FBT0csVUFBVSxDQUFDRixNQUFNQyxNQUFNO1FBQzNDQSxVQUFVRixPQUFPSSxVQUFVLENBQUNIO1FBQzVCLE9BQU9DO0lBQ1g7SUFDQUcsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT0EsT0FBT0MsU0FBUyxDQUFDRCxPQUFPRSxTQUFTLElBQUk7SUFDaEQ7QUFDSjtBQUNBOztDQUVDLEdBQ00sTUFBTUMsbUJBQW1CZjtJQUM1QkMsWUFBWUUsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxTQUFTQTtJQUNuQjtJQUNBUSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPZCx3REFBT0EsQ0FBQyxLQUFLLENBQUNhLE9BQU9DO0lBQ2hDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2J5dGVzLmpzP2YzNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRCeXRlc0NvcHkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleGxpZnkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiQ29kZXIiLCJEeW5hbWljQnl0ZXNDb2RlciIsImNvbnN0cnVjdG9yIiwidHlwZSIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwibGVuZ3RoIiwid3JpdGVWYWx1ZSIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiLCJyZWFkSW5kZXgiLCJCeXRlc0NvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */ class FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(reader.readBytes(this.size));\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUMzQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUssd0JBQXdCRCxxREFBS0E7SUFFdENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLElBQUlDLE9BQU8sVUFBVUMsT0FBT0g7UUFDNUIsS0FBSyxDQUFDRSxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCUixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVPO1FBQUssR0FBRztZQUFFQSxNQUFNO1FBQVM7SUFDdEQ7SUFDQUksZUFBZTtRQUNYLE9BQU8scUVBQXVFQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQ0wsSUFBSSxHQUFHO0lBQy9HO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLE9BQU9mLDZEQUFZQSxDQUFDRSw0Q0FBS0EsQ0FBQ2MsV0FBVyxDQUFDRixRQUFRLElBQUksQ0FBQ0csSUFBSTtRQUMzRCxJQUFJRixLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDWixJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDYSxXQUFXLENBQUMseUJBQXlCTDtRQUM5QztRQUNBLE9BQU9ELE9BQU9PLFVBQVUsQ0FBQ0w7SUFDN0I7SUFDQU0sT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT3JCLHdEQUFPQSxDQUFDcUIsT0FBT0MsU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7SUFDN0M7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/NmVlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUgfSwgeyBzaXplOiBcIm51bWJlclwiIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gZ2V0Qnl0ZXNDb3B5KFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgdGhpcy50eXBlKSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwiVHlwZWQiLCJDb2RlciIsIkZpeGVkQnl0ZXNDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsImxvY2FsTmFtZSIsIm5hbWUiLCJTdHJpbmciLCJkZWZhdWx0VmFsdWUiLCJzdWJzdHJpbmciLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkYXRhIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibGVuZ3RoIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDLE1BQU1DLFFBQVEsSUFBSUMsV0FBVyxFQUFFO0FBQy9COztDQUVDLEdBQ00sTUFBTUMsa0JBQWtCSCxxREFBS0E7SUFDaENJLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxJQUFJQSxXQUFXO0lBQ2pDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7UUFDbEIsSUFBSUEsU0FBUyxNQUFNO1lBQ2YsSUFBSSxDQUFDQyxXQUFXLENBQUMsWUFBWUQ7UUFDakM7UUFDQSxPQUFPRCxPQUFPRyxVQUFVLENBQUNWO0lBQzdCO0lBQ0FXLE9BQU9DLE1BQU0sRUFBRTtRQUNYQSxPQUFPQyxTQUFTLENBQUM7UUFDakIsT0FBTztJQUNYO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL251bGwuanM/YjIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKEVtcHR5KTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJDb2RlciIsIkVtcHR5IiwiVWludDhBcnJheSIsIk51bGxDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJfdGhyb3dFcnJvciIsIndyaXRlQnl0ZXMiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        } else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkY7QUFDdkQ7QUFDa0I7QUFDdEQsTUFBTVEsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLGlCQUFpQkYsT0FBTztBQUM5Qjs7Q0FFQyxHQUNNLE1BQU1HLG9CQUFvQk4scURBQUtBO0lBR2xDTyxZQUFZQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQ2pDLE1BQU1DLE9BQVEsQ0FBQ0YsU0FBUyxRQUFRLE1BQUssSUFBTUQsT0FBTztRQUNsRCxLQUFLLENBQUNHLE1BQU1BLE1BQU1ELFdBQVc7UUFDN0JoQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVjO1lBQU1DO1FBQU8sR0FBRztZQUFFRCxNQUFNO1lBQVVDLFFBQVE7UUFBVTtJQUNqRjtJQUNBRyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLFFBQVFwQiwwREFBU0EsQ0FBQ0csNENBQUtBLENBQUNrQixXQUFXLENBQUNGLFFBQVEsSUFBSSxDQUFDRyxJQUFJO1FBQ3pELHFDQUFxQztRQUNyQyxJQUFJQyxlQUFldEIscURBQUlBLENBQUNRLGdCQUFnQkosd0RBQVFBLEdBQUc7UUFDbkQsSUFBSSxJQUFJLENBQUNRLE1BQU0sRUFBRTtZQUNiLElBQUlXLFNBQVN2QixxREFBSUEsQ0FBQ3NCLGNBQWMsSUFBSyxDQUFDWCxJQUFJLEdBQUcsSUFBSztZQUNsRCxJQUFJUSxRQUFRSSxVQUFVSixRQUFRLENBQUVJLENBQUFBLFNBQVNoQixJQUFHLEdBQUk7Z0JBQzVDLElBQUksQ0FBQ2lCLFdBQVcsQ0FBQyx1QkFBdUJOO1lBQzVDO1lBQ0FDLFFBQVFsQix1REFBTUEsQ0FBQ2tCLE9BQU8sSUFBSWYsd0RBQVFBO1FBQ3RDLE9BQ0ssSUFBSWUsUUFBUWQsUUFBUWMsUUFBUW5CLHFEQUFJQSxDQUFDc0IsY0FBYyxJQUFJLENBQUNYLElBQUksR0FBRyxJQUFJO1lBQ2hFLElBQUksQ0FBQ2EsV0FBVyxDQUFDLHVCQUF1Qk47UUFDNUM7UUFDQSxPQUFPRCxPQUFPUSxVQUFVLENBQUNOO0lBQzdCO0lBQ0FPLE9BQU9DLE1BQU0sRUFBRTtRQUNYLElBQUlSLFFBQVFuQixxREFBSUEsQ0FBQzJCLE9BQU9DLFNBQVMsSUFBSSxJQUFJLENBQUNqQixJQUFJLEdBQUc7UUFDakQsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNiTyxRQUFRckIseURBQVFBLENBQUNxQixPQUFPLElBQUksQ0FBQ1IsSUFBSSxHQUFHO1FBQ3hDO1FBQ0EsT0FBT1E7SUFDWDtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanM/NzE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBmcm9tVHdvcywgZ2V0QmlnSW50LCBtYXNrLCB0b1R3b3MgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciwgV29yZFNpemUgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBOdW1iZXJDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIHNpZ25lZDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBzaWduZWQsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gKChzaWduZWQgPyBcImludFwiIDogXCJ1aW50XCIpICsgKHNpemUgKiA4KSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgc2l6ZSwgc2lnbmVkIH0sIHsgc2l6ZTogXCJudW1iZXJcIiwgc2lnbmVkOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBtYXNrKEJOX01BWF9VSU5UMjU2LCBXb3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBtYXNrKG1heFVpbnRWYWx1ZSwgKHRoaXMuc2l6ZSAqIDgpIC0gMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBib3VuZHMgfHwgdmFsdWUgPCAtKGJvdW5kcyArIEJOXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdG9Ud29zKHZhbHVlLCA4ICogV29yZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgQk5fMCB8fCB2YWx1ZSA+IG1hc2sobWF4VWludFZhbHVlLCB0aGlzLnNpemUgKiA4KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1hc2socmVhZGVyLnJlYWRWYWx1ZSgpLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZyb21Ud29zKHZhbHVlLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZnJvbVR3b3MiLCJnZXRCaWdJbnQiLCJtYXNrIiwidG9Ud29zIiwiVHlwZWQiLCJDb2RlciIsIldvcmRTaXplIiwiQk5fMCIsIkJpZ0ludCIsIkJOXzEiLCJCTl9NQVhfVUlOVDI1NiIsIk51bWJlckNvZGVyIiwiY29uc3RydWN0b3IiLCJzaXplIiwic2lnbmVkIiwibG9jYWxOYW1lIiwibmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibWF4VWludFZhbHVlIiwiYm91bmRzIiwiX3Rocm93RXJyb3IiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */ class StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUM1QjtBQUNXO0FBQy9DOztDQUVDLEdBQ00sTUFBTUksb0JBQW9CRCx3REFBaUJBO0lBQzlDRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFVBQVVBO0lBQ3BCO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsT0FBTyxLQUFLLENBQUNGLE9BQU9DLFFBQVFULDJEQUFXQSxDQUFDRSw0Q0FBS0EsQ0FBQ1MsV0FBVyxDQUFDRCxRQUFRO0lBQ3RFO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9aLDREQUFZQSxDQUFDLEtBQUssQ0FBQ1csT0FBT0M7SUFDckM7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvc3RyaW5nLmpzP2ZiNmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCIuLi8uLi91dGlscy91dGY4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgRHluYW1pY0J5dGVzQ29kZXIgfSBmcm9tIFwiLi9ieXRlcy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcInN0cmluZ1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIikpKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwiVHlwZWQiLCJEeW5hbWljQnl0ZXNDb2RlciIsIlN0cmluZ0NvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2RDtBQUN6QjtBQUNRO0FBQ0Y7QUFDMUM7O0NBRUMsR0FDTSxNQUFNSyxtQkFBbUJILHFEQUFLQTtJQUVqQ0ksWUFBWUMsTUFBTSxFQUFFQyxTQUFTLENBQUU7UUFDM0IsSUFBSUMsVUFBVTtRQUNkLE1BQU1DLFFBQVEsRUFBRTtRQUNoQkgsT0FBT0ksT0FBTyxDQUFDLENBQUNDO1lBQ1osSUFBSUEsTUFBTUgsT0FBTyxFQUFFO2dCQUNmQSxVQUFVO1lBQ2Q7WUFDQUMsTUFBTUcsSUFBSSxDQUFDRCxNQUFNRSxJQUFJO1FBQ3pCO1FBQ0EsTUFBTUEsT0FBUSxXQUFXSixNQUFNSyxJQUFJLENBQUMsT0FBTztRQUMzQyxLQUFLLENBQUMsU0FBU0QsTUFBTU4sV0FBV0M7UUFDaENULHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRU8sUUFBUVMsT0FBT0MsTUFBTSxDQUFDVixPQUFPVyxLQUFLO1FBQUk7SUFDbkU7SUFDQUMsZUFBZTtRQUNYLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNiLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDO1lBQ2pCUSxPQUFPUCxJQUFJLENBQUNELE1BQU1PLFlBQVk7UUFDbEM7UUFDQSw0REFBNEQ7UUFDNUQsTUFBTUUsY0FBYyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsTUFBTSxDQUFDLENBQUNDLE9BQU9YO1lBQzNDLE1BQU1ZLE9BQU9aLE1BQU1KLFNBQVM7WUFDNUIsSUFBSWdCLE1BQU07Z0JBQ04sSUFBSSxDQUFDRCxLQUFLLENBQUNDLEtBQUssRUFBRTtvQkFDZEQsS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2xCO2dCQUNBRCxLQUFLLENBQUNDLEtBQUs7WUFDZjtZQUNBLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO1FBQ0osbUJBQW1CO1FBQ25CLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDLE9BQU9hO1lBQ3hCLElBQUlELE9BQU9aLE1BQU1KLFNBQVM7WUFDMUIsSUFBSSxDQUFDZ0IsUUFBUUgsV0FBVyxDQUFDRyxLQUFLLEtBQUssR0FBRztnQkFDbEM7WUFDSjtZQUNBLElBQUlBLFNBQVMsVUFBVTtnQkFDbkJBLE9BQU87WUFDWDtZQUNBLElBQUlKLE1BQU0sQ0FBQ0ksS0FBSyxJQUFJLE1BQU07Z0JBQ3RCO1lBQ0o7WUFDQUosTUFBTSxDQUFDSSxLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssTUFBTTtRQUNoQztRQUNBLE9BQU9ULE9BQU9DLE1BQU0sQ0FBQ0c7SUFDekI7SUFDQU0sT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUTVCLDRDQUFLQSxDQUFDNkIsV0FBVyxDQUFDRixRQUFRO1FBQ3hDLE9BQU96QiwrQ0FBSUEsQ0FBQ3dCLFFBQVEsSUFBSSxDQUFDcEIsTUFBTSxFQUFFc0I7SUFDckM7SUFDQUUsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTzVCLGlEQUFNQSxDQUFDNEIsUUFBUSxJQUFJLENBQUN6QixNQUFNO0lBQ3JDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3R1cGxlLmpzPzNhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXkuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb2RlcnMsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIHN1cGVyKFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGNvZGVyczogT2JqZWN0LmZyZWV6ZShjb2RlcnMuc2xpY2UoKSkgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChjb2Rlci5kZWZhdWx0VmFsdWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBvbmx5IG91dHB1dCBuYW1lZCBwcm9wZXJ0aWVzIGZvciB1bmlxdWVseSBuYW1lZCBjb2RlcnNcbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB0aGlzLmNvZGVycy5yZWR1Y2UoKGFjY3VtLCBjb2RlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gQWRkIG5hbWVkIHZhbHVlc1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInR1cGxlXCIpO1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHVucGFjayhyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIlR5cGVkIiwiQ29kZXIiLCJwYWNrIiwidW5wYWNrIiwiVHVwbGVDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXJzIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsInR5cGVzIiwiZm9yRWFjaCIsImNvZGVyIiwicHVzaCIsInR5cGUiLCJqb2luIiwiT2JqZWN0IiwiZnJlZXplIiwic2xpY2UiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZXMiLCJ1bmlxdWVOYW1lcyIsInJlZHVjZSIsImFjY3VtIiwibmFtZSIsImluZGV4IiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/fragments.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ \n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() {\n        return this.#offset;\n    }\n    get length() {\n        return this.#tokens.length - this.#offset;\n    }\n    constructor(tokens){\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() {\n        return new TokenString(this.#tokens);\n    }\n    reset() {\n        this.#offset = 0;\n    }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t)=>{\n            return Object.freeze(Object.assign({}, t, {\n                match: t.match - from,\n                linkBack: t.linkBack - from,\n                linkNext: t.linkNext - from\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while(this.#offset < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = this.#offset; i < this.#tokens.length; i++){\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        } else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index)=>{\n                childType.#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            } else {\n                if (value == null || typeof value !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param)=>{\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index)=>{\n                components[index].#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push(async function() {\n                setValue(await result);\n            }());\n        } else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        this.#walkAsync(promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = `tuple(${comps.map((c)=>c.format()).join(\",\")})`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            anonymous\n        });\n    }\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            `constructor${joinParams(format, this.inputs)}`\n        ];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable\n        });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNpSDtBQUM1RTs7QUFFdEMscUNBQXFDO0FBQ3JDLFNBQVNPLE9BQU9DLEtBQUs7SUFDakIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkYsTUFBTUcsT0FBTyxDQUFDLENBQUNDLElBQU1ILE9BQU9JLEdBQUcsQ0FBQ0Q7SUFDaEMsT0FBT0UsT0FBT0MsTUFBTSxDQUFDTjtBQUN6QjtBQUNBLE1BQU1PLGlCQUFpQjtBQUN2QixNQUFNQyxnQkFBZ0JWLE9BQU9TLGVBQWVFLEtBQUssQ0FBQztBQUNsRCxzQkFBc0I7QUFDdEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxVQUFVYixPQUFPWSxTQUFTRCxLQUFLLENBQUM7QUFDdEMsTUFBTUcsV0FBVztBQUNqQixNQUFNQyxVQUFVZixPQUFPYyxTQUFTSCxLQUFLLENBQUM7QUFDdEMsTUFBTUssZUFBZTtBQUNyQixNQUFNQyxjQUFjakIsT0FBT2dCLGFBQWFMLEtBQUssQ0FBQztBQUM5QyxNQUFNTyxXQUFXO0FBQ2pCLGVBQWU7QUFDZixNQUFNQyxZQUFZO0lBQUNMO0lBQVVFO0lBQWNFO0lBQVVOO0NBQVMsQ0FBQ1EsSUFBSSxDQUFDO0FBQ3BFLE1BQU1DLFdBQVdyQixPQUFPbUIsVUFBVVIsS0FBSyxDQUFDO0FBQ3hDLDBCQUEwQjtBQUMxQixNQUFNVyxlQUFlO0lBQ2pCLEtBQUs7SUFBYyxLQUFLO0lBQ3hCLEtBQUs7SUFBZ0IsS0FBSztJQUMxQixLQUFLO0lBQVMsS0FBSztBQUN2QjtBQUNBLDJDQUEyQztBQUMzQyxNQUFNQyx3QkFBd0IsSUFBSUMsT0FBTztBQUN6QyxNQUFNQyxvQkFBb0IsSUFBSUQsT0FBTztBQUNyQyxNQUFNRSxnQkFBZ0IsSUFBSUYsT0FBTztBQUNqQyxrQ0FBa0M7QUFDbEMsTUFBTUcsVUFBVSxJQUFJSCxPQUFP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L2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcz83MWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBhc3NlcnQsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG47XG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cbmZ1bmN0aW9uIHNldGlmeShpdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xufVxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlXCI7XG5jb25zdCBLd1Zpc2liRGVwbG95ID0gc2V0aWZ5KF9rd1Zpc2liRGVwbG95LnNwbGl0KFwiIFwiKSk7XG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXdcIjtcbmNvbnN0IEt3VmlzaWIgPSBzZXRpZnkoX2t3VmlzaWIuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3TW9kaWZpZXJzID0gXCJjYWxsZGF0YSBtZW1vcnkgc3RvcmFnZSBwYXlhYmxlIGluZGV4ZWRcIjtcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcbi8vIEFsbCBLZXl3b3Jkc1xuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbi8vIFNpbmdsZSBjaGFyYWN0ZXIgdG9rZW5zXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxuICAgIFwiW1wiOiBcIk9QRU5fQlJBQ0tFVFwiLCBcIl1cIjogXCJDTE9TRV9CUkFDS0VUXCIsXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxufTtcbi8vIFBhcnNlciByZWdleGVzIHRvIGNvbnN1bWUgdGhlIG5leHQgdG9rZW5cbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XG5jb25zdCByZWdleElkUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKVwiKTtcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcbmNvbnN0IHJlZ2V4VHlwZSA9IG5ldyBSZWdFeHAoXCJeKGFkZHJlc3N8Ym9vbHxieXRlcyhbMC05XSopfHN0cmluZ3x1P2ludChbMC05XSopKSRcIik7XG5jbGFzcyBUb2tlblN0cmluZyB7XG4gICAgI29mZnNldDtcbiAgICAjdG9rZW5zO1xuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XG4gICAgI3N1YlRva2VuU3RyaW5nKGZyb20gPSAwLCB0byA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAodC5tYXRjaCAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYWxsb3dlZDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJLRVlXT1JEXCIgfHwgIWFsbG93ZWQuaGFzKHRvcC50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcFR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke3R5cGV9OyBnb3QgJHtKU09OLnN0cmluZ2lmeSh0aGlzLnBlZWsoKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyBhIFwiKFwiIFRPS0VOUyBcIilcIlxuICAgIHBvcFBhcmVuKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIHRvcC5tYXRjaCArIDEpO1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSBpdGVtcyB3aXRoaW4gXCIoXCIgSVRFTTEgXCIsXCIgSVRFTTIgXCIsXCIgLi4uIFwiKVwiXG4gICAgcG9wUGFyYW1zKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKHRvcC50eXBlICE9PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHN0YXJ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy4jb2Zmc2V0IDwgdG9wLm1hdGNoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgbGluayA9IHRoaXMucGVlaygpLmxpbmtOZXh0O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgbGluaykpO1xuICAgICAgICAgICAgdGhpcy4jb2Zmc2V0ID0gbGluaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNvZmZzZXQgPSB0b3AubWF0Y2ggKyAxO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB0b3AgVG9rZW4sIHRocm93aW5nIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy4jb2Zmc2V0ID49IHRoaXMuI3Rva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm91dC1vZi1ib3VuZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3Rva2Vuc1t0aGlzLiNvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHZhbHVlLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYGFsbG93ZWRgXG4gICAgcGVla0tleXdvcmQoYWxsb3dlZCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWtUeXBlKFwiS0VZV09SRFwiKTtcbiAgICAgICAgcmV0dXJuICh0b3AgIT0gbnVsbCAmJiBhbGxvd2VkLmhhcyh0b3ApKSA/IHRvcCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYFxuICAgIHBlZWtUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgcmV0dXJuICh0b3AudHlwZSA9PT0gdHlwZSkgPyB0b3AudGV4dCA6IG51bGw7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdG9rZW47IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI29mZnNldDsgaSA8IHRoaXMuI3Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLiN0b2tlbnNbaV07XG4gICAgICAgICAgICB0b2tlbnMucHVzaChgJHt0b2tlbi50eXBlfToke3Rva2VuLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGA8VG9rZW5TdHJpbmcgJHt0b2tlbnMuam9pbihcIiBcIil9PmA7XG4gICAgfVxufVxuZnVuY3Rpb24gbGV4KHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkodGV4dFtvZmZzZXRdKSA6IFwiJEVPSVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdG9rZW4gJHt0b2tlbn0gYXQgJHtvZmZzZXR9OiAke21lc3NhZ2V9YCk7XG4gICAgfTtcbiAgICBsZXQgYnJhY2tldHMgPSBbXTtcbiAgICBsZXQgY29tbWFzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIFN0cmlwIG9mZiBhbnkgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBjdXIubWF0Y2gocmVnZXhXaGl0ZXNwYWNlUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHsgZGVwdGg6IGJyYWNrZXRzLmxlbmd0aCwgbGlua0JhY2s6IC0xLCBsaW5rTmV4dDogLTEsIG1hdGNoOiAtMSwgdHlwZTogXCJcIiwgdGV4dDogXCJcIiwgb2Zmc2V0LCB2YWx1ZTogLTEgfTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBsZXQgdHlwZSA9IChTaW1wbGVUb2tlbnNbY3VyWzBdXSB8fCBcIlwiKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IGN1clswXTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIkNMT1NFX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJubyBtYXRjaGluZyBvcGVuIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoID0gYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5tYXRjaF0pLm1hdGNoID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdG9rZW4uZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ09NTUFcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiT1BFTl9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJCUkFDS0VUXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNMT1NFX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQ0xPU0VfQlJBQ0tFVFxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlID09PSBcIk5VTUJFUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHZhbHVlICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudmFsdWUgPSBnZXROdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwiQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3BlbmluZyBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkudGV4dCArPSBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleElkUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoS2V5d29yZHMuaGFzKHRva2VuLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiS0VZV09SRFwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnRleHQubWF0Y2gocmVnZXhUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIlRZUEVcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIklEXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IGN1ci5tYXRjaChyZWdleE51bWJlclByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiTlVNQkVSXCI7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdG9rZW4udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW4gJHtKU09OLnN0cmluZ2lmeShjdXJbMF0pfSBhdCBwb3NpdGlvbiAke29mZnNldH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0b2tlbnMubWFwKCh0KSA9PiBPYmplY3QuZnJlZXplKHQpKSk7XG59XG4vLyBDaGVjayBvbmx5IG9uZSBvZiBgYWxsb3dlZGAgaXMgaW4gYHNldGBcbmZ1bmN0aW9uIGFsbG93U2luZ2xlKHNldCwgYWxsb3dlZCkge1xuICAgIGxldCBpbmNsdWRlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFsbG93ZWQua2V5cygpKSB7XG4gICAgICAgIGlmIChzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGVkLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5jbHVkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0aW5nIHR5cGVzOiAke2luY2x1ZGVkLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG59XG4vLyBGdW5jdGlvbnMgdG8gcHJvY2VzcyBhIFNvbGlkaXR5IFNpZ25hdHVyZSBUb2tlblN0cmluZyBmcm9tIGxlZnQtdG8tcmlnaHQgZm9yLi4uXG4vLyAuLi50aGUgbmFtZSB3aXRoIGFuIG9wdGlvbmFsIHR5cGUsIHJldHVybmluZyB0aGUgbmFtZVxuZnVuY3Rpb24gY29uc3VtZU5hbWUodHlwZSwgdG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrS2V5d29yZChLd1R5cGVzKSkge1xuICAgICAgICBjb25zdCBrZXl3b3JkID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgIGlmIChrZXl3b3JkICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX0sIGdvdCAke2tleXdvcmR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucy5wb3BUeXBlKFwiSURcIik7XG59XG4vLyAuLi5hbGwga2V5d29yZHMgbWF0Y2hpbmcgYWxsb3dlZCwgcmV0dXJuaW5nIHRoZSBrZXl3b3Jkc1xuZnVuY3Rpb24gY29uc3VtZUtleXdvcmRzKHRva2VucywgYWxsb3dlZCkge1xuICAgIGNvbnN0IGtleXdvcmRzID0gbmV3IFNldCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICBpZiAoa2V5d29yZCA9PSBudWxsIHx8IChhbGxvd2VkICYmICFhbGxvd2VkLmhhcyhrZXl3b3JkKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKGtleXdvcmRzLmhhcyhrZXl3b3JkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUga2V5d29yZHM6ICR7SlNPTi5zdHJpbmdpZnkoa2V5d29yZCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5d29yZHMuYWRkKGtleXdvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShrZXl3b3Jkcyk7XG59XG4vLyAuLi5hbGwgdmlzaWJpbGl0eSBrZXl3b3JkcywgcmV0dXJuaW5nIHRoZSBjb2FsZXNjZWQgbXV0YWJpbGl0eVxuZnVuY3Rpb24gY29uc3VtZU11dGFiaWxpdHkodG9rZW5zKSB7XG4gICAgbGV0IG1vZGlmaWVycyA9IGNvbnN1bWVLZXl3b3Jkcyh0b2tlbnMsIEt3VmlzaWIpO1xuICAgIC8vIERldGVjdCBjb25mbGljdGluZyBtb2RpZmllcnNcbiAgICBhbGxvd1NpbmdsZShtb2RpZmllcnMsIHNldGlmeShcImNvbnN0YW50IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwicHVyZSB2aWV3IHBheWFibGUgbm9ucGF5YWJsZVwiLnNwbGl0KFwiIFwiKSkpO1xuICAgIC8vIFByb2Nlc3MgbXV0YWJpbGl0eSBzdGF0ZXNcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInZpZXdcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInB1cmVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicHVyZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcInBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicGF5YWJsZVwiO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcIm5vbnBheWFibGVcIikpIHtcbiAgICAgICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGxlZ2FjeSBgY29uc3RhbnRgIGxhc3RcbiAgICBpZiAobW9kaWZpZXJzLmhhcyhcImNvbnN0YW50XCIpKSB7XG4gICAgICAgIHJldHVybiBcInZpZXdcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibm9ucGF5YWJsZVwiO1xufVxuLy8gLi4uYSBwYXJhbWV0ZXIgbGlzdCwgcmV0dXJuaW5nIHRoZSBQYXJhbVR5cGUgbGlzdFxuZnVuY3Rpb24gY29uc3VtZVBhcmFtcyh0b2tlbnMsIGFsbG93SW5kZXhlZCkge1xuICAgIHJldHVybiB0b2tlbnMucG9wUGFyYW1zKCkubWFwKCh0KSA9PiBQYXJhbVR5cGUuZnJvbSh0LCBhbGxvd0luZGV4ZWQpKTtcbn1cbi8vIC4uLmEgZ2FzIGxpbWl0LCByZXR1cm5pbmcgYSBCaWdOdW1iZXIgb3IgbnVsbCBpZiBub25lXG5mdW5jdGlvbiBjb25zdW1lR2FzKHRva2Vucykge1xuICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJBVFwiKSkge1xuICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbnMucGVla1R5cGUoXCJOVU1CRVJcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCaWdJbnQodG9rZW5zLnBvcCgpLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ2FzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVFb2kodG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuczogJHt0b2tlbnMudG9TdHJpbmcoKX1gKTtcbiAgICB9XG59XG5jb25zdCByZWdleEFycmF5VHlwZSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5mdW5jdGlvbiB2ZXJpZnlCYXNpY1R5cGUodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChyZWdleFR5cGUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgaWYgKHR5cGUgPT09IFwidWludFwiKSB7XG4gICAgICAgIHJldHVybiBcInVpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW50MjU2XCI7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAvLyBieXRlc1hYXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIC8vIGludFhYIG9yIHVpbnRYWFxuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBNYWtlIHRoZSBGcmFnbWVudCBjb25zdHJ1Y3RvcnMgZWZmZWN0aXZlbHkgcHJpdmF0ZVxuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX2ludGVybmFsXCIpO1xuY29uc3QgUGFyYW1UeXBlSW50ZXJuYWwgPSBcIl9QYXJhbVR5cGVJbnRlcm5hbFwiO1xuY29uc3QgRXJyb3JGcmFnbWVudEludGVybmFsID0gXCJfRXJyb3JJbnRlcm5hbFwiO1xuY29uc3QgRXZlbnRGcmFnbWVudEludGVybmFsID0gXCJfRXZlbnRJbnRlcm5hbFwiO1xuY29uc3QgQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsID0gXCJfQ29uc3RydWN0b3JJbnRlcm5hbFwiO1xuY29uc3QgRmFsbGJhY2tGcmFnbWVudEludGVybmFsID0gXCJfRmFsbGJhY2tJbnRlcm5hbFwiO1xuY29uc3QgRnVuY3Rpb25GcmFnbWVudEludGVybmFsID0gXCJfRnVuY3Rpb25JbnRlcm5hbFwiO1xuY29uc3QgU3RydWN0RnJhZ21lbnRJbnRlcm5hbCA9IFwiX1N0cnVjdEludGVybmFsXCI7XG4vKipcbiAqICBFYWNoIGlucHV0IGFuZCBvdXRwdXQgb2YgYSBbW0ZyYWdtZW50XV0gaXMgYW4gQXJyYXkgb2YgKipQYXJhbVR5cGUqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhcmFtVHlwZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2NhbCBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgKG9yIGBgXCJcImBgIGlmIHVuYm91bmQpXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlKGFkZHJlc3MpXCJgYCxcbiAgICAgKiAgYGBcInVpbnQyNTZbM11bXVwiYGApXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgdHlwZSAoZS5nLiBgYFwiYWRkcmVzc1wiYGAsIGBgXCJ0dXBsZVwiYGAsIGBgXCJhcnJheVwiYGApXG4gICAgICovXG4gICAgYmFzZVR5cGU7XG4gICAgLyoqXG4gICAgICogIFRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaXMgaW5kZXhlZC5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWluZGV4YWJsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGluZGV4ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wb25lbnRzIGZvciB0aGUgdHVwbGUuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi10dXBsZSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGNvbXBvbmVudHM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcnJheSBsZW5ndGgsIG9yIGBgLTFgYCBmb3IgZHluYW1pYy1sZW5ndGhlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiAgRm9yIG5vbi1hcnJheSB0eXBlcyB0aGlzIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFycmF5TGVuZ3RoO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiBlYWNoIGNoaWxkIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlDaGlsZHJlbjtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJQYXJhbVR5cGVcIik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogUGFyYW1UeXBlSW50ZXJuYWwgfSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzID0gT2JqZWN0LmZyZWV6ZShjb21wb25lbnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJyYXlMZW5ndGggIT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wb25lbnRzLCBhcnJheUxlbmd0aCwgYXJyYXlDaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsXG4gICAgICpcbiAgICAgKiAgYGBzaWdoYXNoXCIgPT4gXCIodWludDI1NixhZGRyZXNzKVwiYGBcbiAgICAgKlxuICAgICAqICBgYFwibWluaW1hbFwiID0+IFwidHVwbGUodWludDI1NixhZGRyZXNzKSBpbmRleGVkXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJmdWxsXCIgPT4gXCJ0dXBsZSh1aW50MjU2IGZvbywgYWRkcmVzcyBiYXIpIGluZGV4ZWQgYmF6XCJgYFxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZSB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSh0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50eXBlICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubWFwKChjKSA9PiBKU09OLnBhcnNlKGMuZm9ybWF0KGZvcm1hdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAvLyBBcnJheVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmFycmF5Q2hpbGRyZW4uZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICByZXN1bHQgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKFwiICsgdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gY29tcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJmdWxsXCIgJiYgdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gQXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbYXJyYXlDaGlsZHJlbl1dXG4gICAgICogIGFuZCBbW2FycmF5TGVuZ3RoXV0gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhIFR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2NvbXBvbmVudHNdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc1R1cGxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYW4gSW5kZXhhYmxlIHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2luZGV4ZWRdXVxuICAgICAqICBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0luZGV4YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4ZWQgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgY2FsbGluZyAlJXByb2Nlc3MlJVxuICAgICAqICBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICovXG4gICAgd2Fsayh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IChfdGhpcy5hcnJheUNoaWxkcmVuLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGkpID0+IChfdGhpcy5jb21wb25lbnRzW2ldLndhbGsodiwgcHJvY2VzcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsIHNldFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5hcnJheUNoaWxkcmVuO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFR5cGUuI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mICh2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcG9uZW50cy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW0ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBvYmplY3QgdmFsdWUgd2l0aCB1bm5hbWVkIGNvbXBvbmVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW0ubmFtZSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgY29tcG9uZW50ICR7cGFyYW0ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2luZGV4XS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jIGZ1bmN0aW9uICgpIHsgc2V0VmFsdWUoYXdhaXQgcmVzdWx0KTsgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXYWxrcyB0aGUgKipQYXJhbVR5cGUqKiB3aXRoICUldmFsdWUlJSwgYXN5bmNocm9ub3VzbHkgY2FsbGluZ1xuICAgICAqICAlJXByb2Nlc3MlJSBvbiBlYWNoIHR5cGUsIGRlc3RydWN0aW5nIHRoZSAlJXZhbHVlJSUgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgdXNlZCB0byByZXNvbHZlIEVOUyBuYWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXG4gICAgICogIGBgXCJhZGRyZXNzXCJgYCB0eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxuICAgICAgICAgICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnBvcFR5cGUoXCJUWVBFXCIpKTtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQXJyYXlcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAob2JqLmxlbmd0aCAmJiBvYmoucGVla1R5cGUoXCJCUkFDS0VUXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCA9IGJyYWNrZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qga2V5d29yZHMgPSBjb25zdW1lS2V5d29yZHMob2JqLCBLd01vZGlmaWVycyk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVmdG92ZXIgdG9rZW5zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IG9iai5pbmRleGVkO1xuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xuICAgICAgICAgICAgaW5kZXhlZCA9ICEhaW5kZXhlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xuICAgICAgICBsZXQgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheVR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XG4gICAgICAgICAgICBjb25zdCBhcnJheUNoaWxkcmVuID0gUGFyYW1UeXBlLmZyb20oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInR1cGxlXCIgfHwgdHlwZS5zdGFydHNXaXRoKFwidHVwbGUoXCIgLyogZml4OiApICovKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCIoXCIgLyogZml4OiApICovKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHVzZSBsZXhlciB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai50eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXG4gICAgICovXG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBpbnB1dHM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIEpTT04uLi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBIdW1hbi1yZWFkYWJsZSBBQkkgKGFscmVhZHkgbGV4ZWQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gSlNPTiBBQklcbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50XG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luUGFyYW1zKGZvcm1hdCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEVycm9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBDdXN0b20gRXJyb3Igc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXJyb3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhpcyBldmVudCBpcyBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgYW5vbnltb3VzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFub255bW91cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFdmVudCB0b3BpYyBoYXNoLlxuICAgICAqL1xuICAgIGdldCB0b3BpY0hhc2goKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV2ZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcGljSGFzaChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFdmVudEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJldmVudFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHAsIHRydWUpKSA6IFtdLCAhIW9iai5hbm9ueW1vdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIGNvbnN0cnVjdG9yIGNhbiByZWNlaXZlIGFuIGVuZG93bWVudC5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBhc3NlcnQoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xuICAgICAgICBpZiAodGhpcy5wYXlhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU11dGFiaWxpdHkgPSAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3R5cGV9KCkke3RoaXMucGF5YWJsZSA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGYWxsYmFja0ZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGYWxsYmFja0ZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjaygpIFtwYXlhYmxlXVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBwYXlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLm91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2VsZWN0b3IgZm9yIGEgZnVuY3Rpb24gd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJhc3NlcnQiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0QXJndW1lbnQiLCJpZCIsInNldGlmeSIsIml0ZW1zIiwicmVzdWx0IiwiU2V0IiwiZm9yRWFjaCIsImsiLCJhZGQiLCJPYmplY3QiLCJmcmVlemUiLCJfa3dWaXNpYkRlcGxveSIsIkt3VmlzaWJEZXBsb3kiLCJzcGxpdCIsIl9rd1Zpc2liIiwiS3dWaXNpYiIsIl9rd1R5cGVzIiwiS3dUeXBlcyIsIl9rd01vZGlmaWVycyIsIkt3TW9kaWZpZXJzIiwiX2t3T3RoZXIiLCJfa2V5d29yZHMiLCJqb2luIiwiS2V5d29yZHMiLCJTaW1wbGVUb2tlbnMiLCJyZWdleFdoaXRlc3BhY2VQcmVmaXgiLCJSZWdFeHAiLCJyZWdleE51bWJlclByZWZpeCIsInJlZ2V4SWRQcmVmaXgiLCJyZWdleElkIiwicmVnZXhUeXBlIiwiVG9rZW5TdHJpbmciLCJvZmZzZXQiLCJ0b2tlbnMiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsInNsaWNlIiwiY2xvbmUiLCJyZXNldCIsInN1YlRva2VuU3RyaW5nIiwiZnJvbSIsInRvIiwibWFwIiwidCIsImFzc2lnbiIsIm1hdGNoIiwibGlua0JhY2siLCJsaW5rTmV4dCIsInBvcEtleXdvcmQiLCJhbGxvd2VkIiwidG9wIiwicGVlayIsInR5cGUiLCJoYXMiLCJ0ZXh0IiwiRXJyb3IiLCJwb3AiLCJwb3BUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInBvcFBhcmVuIiwicG9wUGFyYW1zIiwibGluayIsInB1c2giLCJwZWVrS2V5d29yZCIsInBlZWtUeXBlIiwidG9TdHJpbmciLCJpIiwidG9rZW4iLCJsZXgiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsImJyYWNrZXRzIiwiY29tbWFzIiwiY3VyIiwic3Vic3RyaW5nIiwiZGVwdGgiLCJ2YWx1ZSIsInN1ZmZpeCIsImFsbG93U2luZ2xlIiwic2V0IiwiaW5jbHVkZWQiLCJrZXkiLCJrZXlzIiwiY29uc3VtZU5hbWUiLCJrZXl3b3JkIiwiY29uc3VtZUtleXdvcmRzIiwia2V5d29yZHMiLCJjb25zdW1lTXV0YWJpbGl0eSIsIm1vZGlmaWVycyIsImNvbnN1bWVQYXJhbXMiLCJhbGxvd0luZGV4ZWQiLCJQYXJhbVR5cGUiLCJjb25zdW1lR2FzIiwiY29uc3VtZUVvaSIsInJlZ2V4QXJyYXlUeXBlIiwidmVyaWZ5QmFzaWNUeXBlIiwicGFyc2VJbnQiLCJzaXplIiwiX2d1YXJkIiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmb3IiLCJQYXJhbVR5cGVJbnRlcm5hbCIsIkVycm9yRnJhZ21lbnRJbnRlcm5hbCIsIkV2ZW50RnJhZ21lbnRJbnRlcm5hbCIsIkNvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCIsIkZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCIsIkZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCIsIlN0cnVjdEZyYWdtZW50SW50ZXJuYWwiLCJndWFyZCIsIm5hbWUiLCJiYXNlVHlwZSIsImluZGV4ZWQiLCJjb21wb25lbnRzIiwiYXJyYXlMZW5ndGgiLCJhcnJheUNoaWxkcmVuIiwiZGVmaW5lUHJvcGVydHkiLCJmb3JtYXQiLCJpc0FycmF5IiwicGFyc2UiLCJTdHJpbmciLCJpc1R1cGxlIiwiYyIsImNvbXAiLCJpc0luZGV4YWJsZSIsIndhbGsiLCJwcm9jZXNzIiwiQXJyYXkiLCJfdGhpcyIsInYiLCJ3YWxrQXN5bmMiLCJwcm9taXNlcyIsInNldFZhbHVlIiwiY2hpbGRUeXBlIiwiaW5kZXgiLCJwYXJhbSIsInRoZW4iLCJQcm9taXNlIiwiYWxsIiwib2JqIiwiaXNQYXJhbVR5cGUiLCJlcnJvciIsImNvbXBzIiwiYnJhY2tldCIsImFycmF5TWF0Y2giLCJzdGFydHNXaXRoIiwidHVwbGUiLCJGcmFnbWVudCIsImlucHV0cyIsImUiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGYWxsYmFja0ZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIlN0cnVjdEZyYWdtZW50Iiwib3BlcmF0aW9uIiwiaXNDb25zdHJ1Y3RvciIsImlzRnJhZ21lbnQiLCJpc0Vycm9yIiwiaXNFdmVudCIsImlzRnVuY3Rpb24iLCJpc1N0cnVjdCIsIk5hbWVkRnJhZ21lbnQiLCJqb2luUGFyYW1zIiwicGFyYW1zIiwicCIsInNlbGVjdG9yIiwiaW5wdXQiLCJhbm9ueW1vdXMiLCJ0b3BpY0hhc2giLCJnZXRUb3BpY0hhc2giLCJmcmFnbWVudCIsInBheWFibGUiLCJnYXMiLCJzdGF0ZU11dGFiaWxpdHkiLCJ1bmRlZmluZWQiLCJlcnJvck9iaiIsInRvcElzVmFsaWQiLCJtdXRhYmlsaXR5Iiwib3V0cHV0cyIsImNvbnN0YW50IiwibyIsImdldFNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/interface.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abi-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ \n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = values.length > 0 ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#functions.get(name), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()){\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for(let i = matching.length - 1; i >= 0; i--){\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#events.get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#errors.get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n} //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDOEM7QUFDVDtBQUN3SjtBQUNwSjtBQUM2QjtBQUNtRDtBQUN2RjtBQUNFO0FBQ3JDOzs7Q0FHQyxHQUNNLE1BQU15QjtJQXFCVDs7S0FFQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxDQUFFO1FBQy9CLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNQztZQUFXSDtZQUFPQztRQUN0QztJQUNKO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUk7SUF5QlQ7O0tBRUMsR0FDRFAsWUFBWUMsUUFBUSxFQUFFTyxRQUFRLEVBQUVMLElBQUksRUFBRU0sS0FBSyxDQUFFO1FBQ3pDLE1BQU1MLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztZQUFVQztRQUMvQztJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQztJQXFCVDs7S0FFQyxHQUNEVixZQUFZQyxRQUFRLEVBQUVPLFFBQVEsRUFBRUwsSUFBSSxDQUFFO1FBQ2xDLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztRQUNyQztJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1HO0lBU1Q7Ozs7S0FJQyxHQUNELE9BQU9DLFVBQVVILEtBQUssRUFBRTtRQUNwQixPQUFPLENB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QUFXcEQsSUFBSSxFQUFFO1FBQ2IsTUFBTXFELFVBQVU5Syx3REFBT0EsQ0FBQ3lIO1FBQ3hCLE1BQU1yRyxXQUFXLElBQUksQ0FBQ2lHLFFBQVEsQ0FBQ3pILDBEQUFTQSxDQUFDa0wsU0FBUyxHQUFHO1FBQ3JELElBQUksQ0FBQzFKLFVBQVU7WUFDWCxPQUFPO1FBQ1g7UUFDQSxNQUFNRSxPQUFPLElBQUksQ0FBQyxDQUFDeUIsUUFBUSxDQUFDMkUsTUFBTSxDQUFDdEcsU0FBU2dCLE1BQU0sRUFBRXhDLDBEQUFTQSxDQUFDa0wsU0FBUztRQUN2RSxPQUFPLElBQUlqSixpQkFBaUJULFVBQVVBLFNBQVNPLFFBQVEsRUFBRUw7SUFDN0Q7SUFDQTs7Ozs7S0FLQyxHQUNELE9BQU9pQyxLQUFLM0IsS0FBSyxFQUFFO1FBQ2YsMkNBQTJDO1FBQzNDLElBQUlBLGlCQUFpQmUsV0FBVztZQUM1QixPQUFPZjtRQUNYO1FBQ0EsT0FBTztRQUNQLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLE9BQU8sSUFBSWUsVUFBVUosS0FBS1csS0FBSyxDQUFDdEI7UUFDcEM7UUFDQSxxRUFBcUU7UUFDckUsSUFBSSxPQUFRQSxNQUFNSCxNQUFNLEtBQU0sWUFBWTtZQUN0QyxPQUFPLElBQUlrQixVQUFVZixNQUFNSCxNQUFNLENBQUM7UUFDdEM7UUFDQSxxQkFBcUI7UUFDckIsT0FBTyxJQUFJa0IsVUFBVWY7SUFDekI7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9pbnRlcmZhY2UuanM/ZTU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgSW50ZXJmYWNlIGNsYXNzIGlzIGEgbG93LWxldmVsIGNsYXNzIHRoYXQgYWNjZXB0cyBhblxuICogIEFCSSBhbmQgcHJvdmlkZXMgYWxsIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25hbGl0eSB0byBlbmNvZGVcbiAqICBhbmQgZGVjb2RlIHBhcmFtYXRlcnMgdG8gYW5kIHJlc3VsdHMgZnJvbSBtZXRob2RzLCBldmVudHNcbiAqICBhbmQgZXJyb3JzLlxuICpcbiAqICBJdCBhbHNvIHByb3ZpZGVzIHNldmVyYWwgY29udmVuaWVuY2UgbWV0aG9kcyB0byBhdXRvbWF0aWNhbGx5XG4gKiAgc2VhcmNoIGFuZCBmaW5kIG1hdGNoaW5nIHRyYW5zYWN0aW9ucyBhbmQgZXZlbnRzIHRvIHBhcnNlIHRoZW0uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpOkludGVyZmFjZXMgIFtpbnRlcmZhY2VzXVxuICovXG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFTbGljZSwgZ2V0QmlnSW50LCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB6ZXJvUGFkQnl0ZXMsIHplcm9QYWRWYWx1ZSwgaXNIZXhTdHJpbmcsIGRlZmluZVByb3BlcnRpZXMsIGFzc2VydEFyZ3VtZW50LCB0b0JlSGV4LCBhc3NlcnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFiaUNvZGVyIH0gZnJvbSBcIi4vYWJpLWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFcnJvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgUGFyYW1UeXBlIH0gZnJvbSBcIi4vZnJhZ21lbnRzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuL3R5cGVkLmpzXCI7XG5leHBvcnQgeyBjaGVja1Jlc3VsdEVycm9ycywgUmVzdWx0IH07XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZUxvZ11dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYSBMb2cgdG8gaXRzIGV2ZW50XG4gKiAgZm9yIHBhcnNpbmcsIGEgKipMb2dEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgTG9nRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoZSBgYHRvcGljMGBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvcGljIGhhc2ggZm9yIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICB0b3BpYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgRXZlbnQgd2l0aCBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgdG9waWMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBzaWduYXR1cmUsIHRvcGljLCBhcmdzXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlVHJhbnNhY3Rpb25dXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoXG4gKiAgYSB0cmFuc2FjdGlvbiBkYXRhIHRvIGl0cyBmdW5jdGlvbiBmb3IgcGFyc2luZyxcbiAqICBhICoqVHJhbnNhY3Rpb25EZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBGdW5jdGlvbiBzaWduYXR1cmUgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmFsdWVgYCAoaW4gd2VpKSBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3IsIHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlRXJyb3JdXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGFuXG4gKiAgZXJyb3IgZm9yIGEgY2FsbCByZXN1bHQgZm9yIHBhcnNpbmcsIGFuICoqRXJyb3JEZXNjcmlwdGlvbioqIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBFcnJvciB3aXRoIGBgcmV2ZXJ0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXJyb3Igc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbGVjdG9yIGZvciB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgc2VsZWN0b3I7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCBzZWxlY3RvciwgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIGFyZ3MsIHNpZ25hdHVyZSwgc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipJbmRleGVkKiogaXMgdXNlZCBhcyBhIHZhbHVlIHdoZW4gYSB2YWx1ZSB0aGF0IGRvZXMgbm90XG4gKiAgZml0IHdpdGhpbiBhIHRvcGljIChpLmUuIG5vdCBhIGZpeGVkLWxlbmd0aCwgMzItYnl0ZSB0eXBlKS4gSXRcbiAqICBpcyB0aGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUsIGFuZCB1c2VkIGZvciB0eXBlcyBzdWNoIGFzXG4gKiAgYXJyYXlzLCB0dXBsZXMsIGJ5dGVzIGFuZCBzdHJpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSBsb2dnZWQuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX2lzSW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJXZhbHVlJSUgaXMgYW4gKipJbmRleGVkKiouXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgZm9yIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc2gpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGhhc2gsIF9pc0luZGV4ZWQ6IHRydWUgfSk7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xMy9jb250cm9sLXN0cnVjdHVyZXMuaHRtbD9oaWdobGlnaHQ9cGFuaWMjcGFuaWMtdmlhLWFzc2VydC1hbmQtZXJyb3ItdmlhLXJlcXVpcmVcbmNvbnN0IFBhbmljUmVhc29ucyA9IHtcbiAgICBcIjBcIjogXCJnZW5lcmljIHBhbmljXCIsXG4gICAgXCIxXCI6IFwiYXNzZXJ0KGZhbHNlKVwiLFxuICAgIFwiMTdcIjogXCJhcml0aG1ldGljIG92ZXJmbG93XCIsXG4gICAgXCIxOFwiOiBcImRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIsXG4gICAgXCIzM1wiOiBcImVudW0gb3ZlcmZsb3dcIixcbiAgICBcIjM0XCI6IFwiaW52YWxpZCBlbmNvZGVkIHN0b3JhZ2UgYnl0ZSBhcnJheSBhY2Nlc3NlZFwiLFxuICAgIFwiNDlcIjogXCJvdXQtb2YtYm91bmRzIGFycmF5IGFjY2VzczsgcG9wcGluZyBvbiBhbiBlbXB0eSBhcnJheVwiLFxuICAgIFwiNTBcIjogXCJvdXQtb2YtYm91bmRzIGFjY2VzcyBvZiBhbiBhcnJheSBvciBieXRlc05cIixcbiAgICBcIjY1XCI6IFwib3V0IG9mIG1lbW9yeVwiLFxuICAgIFwiODFcIjogXCJ1bmluaXRpYWxpemVkIGZ1bmN0aW9uXCIsXG59O1xuY29uc3QgQnVpbHRpbkVycm9ycyA9IHtcbiAgICBcIjB4MDhjMzc5YTBcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiRXJyb3Ioc3RyaW5nKVwiLFxuICAgICAgICBuYW1lOiBcIkVycm9yXCIsXG4gICAgICAgIGlucHV0czogW1wic3RyaW5nXCJdLFxuICAgICAgICByZWFzb246IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpfWA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiMHg0ZTQ4N2I3MVwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxuICAgICAgICBuYW1lOiBcIlBhbmljXCIsXG4gICAgICAgIGlucHV0czogW1widWludDI1NlwiXSxcbiAgICAgICAgcmVhc29uOiAoY29kZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwidW5rbm93biBwYW5pYyBjb2RlXCI7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSAwICYmIGNvZGUgPD0gMHhmZiAmJiBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXSkge1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHBhbmljIGNvZGUgMHgke2NvZGUudG9TdHJpbmcoMTYpfSAoJHtyZWFzb259KWA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiAgQW4gSW50ZXJmYWNlIGFic3RyYWN0cyBtYW55IG9mIHRoZSBsb3ctbGV2ZWwgZGV0YWlscyBmb3JcbiAqICBlbmNvZGluZyBhbmQgZGVjb2RpbmcgdGhlIGRhdGEgb24gdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogIEFuIEFCSSBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZW5jb2RlIGRhdGEgdG8gc2VuZCB0b1xuICogIGEgQ29udHJhY3QsIGhvdyB0byBkZWNvZGUgdGhlIHJlc3VsdHMgYW5kIGV2ZW50cyBhbmQgaG93IHRvXG4gKiAgaW50ZXJwcmV0IHJldmVydCBlcnJvcnMuXG4gKlxuICogIFRoZSBBQkkgY2FuIGJlIHNwZWNpZmllZCBieSBbYW55IHN1cHBvcnRlZCBmb3JtYXRdKEludGVyZmFjZUFiaSkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIENvbnRyYWN0IEFCSSBtZW1iZXJzIChpLmUuIG1ldGhvZHMsIGV2ZW50cywgZXJyb3JzLCBldGMpLlxuICAgICAqL1xuICAgIGZyYWdtZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGRlcGxveTtcbiAgICAvKipcbiAgICAgKiAgVGhlIEZhbGxiYWNrIG1ldGhvZCwgaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBJZiByZWNlaXZpbmcgZXRoZXIgaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHJlY2VpdmU7XG4gICAgI2Vycm9ycztcbiAgICAjZXZlbnRzO1xuICAgICNmdW5jdGlvbnM7XG4gICAgLy8gICAgI3N0cnVjdHM6IE1hcDxzdHJpbmcsIFN0cnVjdEZyYWdtZW50PjtcbiAgICAjYWJpQ29kZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBJbnRlcmZhY2UgZm9yIHRoZSAlJWZyYWdtZW50cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICBsZXQgYWJpID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50cykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFiaSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Vycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAgICAgICAgdGhpcy4jc3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZnJhZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIGFiaSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFncy5wdXNoKEZyYWdtZW50LmZyb20oYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRVwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIGFuIGludGVyZmFjZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIG9yIGZyb20gYSBzeW1saW5rZWQgY29weVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGZyYWdtZW50c1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJpZCIsImNvbmNhdCIsImRhdGFTbGljZSIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsInplcm9QYWRCeXRlcyIsInplcm9QYWRWYWx1ZSIsImlzSGV4U3RyaW5nIiwiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydEFyZ3VtZW50IiwidG9CZUhleCIsImFzc2VydCIsIkFiaUNvZGVyIiwiY2hlY2tSZXN1bHRFcnJvcnMiLCJSZXN1bHQiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJQYXJhbVR5cGUiLCJUeXBlZCIsIkxvZ0Rlc2NyaXB0aW9uIiwiY29uc3RydWN0b3IiLCJmcmFnbWVudCIsInRvcGljIiwiYXJncyIsIm5hbWUiLCJzaWduYXR1cmUiLCJmb3JtYXQiLCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIiwic2VsZWN0b3IiLCJ2YWx1ZSIsIkVycm9yRGVzY3JpcHRpb24iLCJJbmRleGVkIiwiaXNJbmRleGVkIiwiX2lzSW5kZXhlZCIsImhhc2giLCJQYW5pY1JlYXNvbnMiLCJCdWlsdGluRXJyb3JzIiwiaW5wdXRzIiwicmVhc29uIiwibWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb2RlIiwidG9TdHJpbmciLCJJbnRlcmZhY2UiLCJlcnJvcnMiLCJldmVudHMiLCJmdW5jdGlvbnMiLCJhYmlDb2RlciIsImZyYWdtZW50cyIsImFiaSIsInBhcnNlIiwiTWFwIiwiZnJhZ3MiLCJhIiwicHVzaCIsImZyb20iLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJPYmplY3QiLCJmcmVlemUiLCJmYWxsYmFjayIsInJlY2VpdmUiLCJnZXRBYmlDb2RlciIsImZvckVhY2giLCJpbmRleCIsImJ1Y2tldCIsInR5cGUiLCJkZXBsb3kiLCJsZW5ndGgiLCJwYXlhYmxlIiwiaGFzIiwic2V0IiwibWluaW1hbCIsIm1hcCIsImYiLCJmb3JtYXRKc29uIiwiaiIsImRlZmF1bHRBYmlDb2RlciIsImdldEZ1bmN0aW9uIiwia2V5IiwidmFsdWVzIiwiZm9yY2VVbmlxdWUiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJtYXRjaGluZyIsInNwbGl0IiwibGFzdFZhbHVlIiwidmFsdWVMZW5ndGgiLCJhbGxvd09wdGlvbnMiLCJpc1R5cGVkIiwiaSIsInNwbGljZSIsImJhc2VUeXBlIiwibGFzdEFyZyIsIkFycmF5IiwiaXNBcnJheSIsIm1hdGNoU3RyIiwibSIsImpvaW4iLCJyZXN1bHQiLCJnZXQiLCJnZXRGdW5jdGlvbk5hbWUiLCJoYXNGdW5jdGlvbiIsImZvckVhY2hGdW5jdGlvbiIsImNhbGxiYWNrIiwibmFtZXMiLCJrZXlzIiwic29ydCIsImIiLCJsb2NhbGVDb21wYXJlIiwiZ2V0RXZlbnQiLCJldmVudFRvcGljIiwidG9waWNIYXNoIiwiZ2V0RXZlbnROYW1lIiwiaGFzRXZlbnQiLCJmb3JFYWNoRXZlbnQiLCJnZXRFcnJvciIsImZvckVhY2hFcnJvciIsIl9kZWNvZGVQYXJhbXMiLCJwYXJhbXMiLCJkYXRhIiwiZGVjb2RlIiwiX2VuY29kZVBhcmFtcyIsImVuY29kZSIsImVuY29kZURlcGxveSIsImRlY29kZUVycm9yUmVzdWx0IiwiZW5jb2RlRXJyb3JSZXN1bHQiLCJkZWNvZGVGdW5jdGlvbkRhdGEiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJkZWNvZGVGdW5jdGlvblJlc3VsdCIsImJ5dGVzIiwib3V0cHV0cyIsImluZm8iLCJtZXRob2QiLCJtYWtlRXJyb3IiLCJfZGF0YSIsInR4IiwiZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24iLCJjdXN0b21QcmVmaXgiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJlZiIsInJldmVydCIsImUiLCJwYXJzZWQiLCJwYXJzZVRyYW5zYWN0aW9uIiwiaW52b2NhdGlvbiIsImVuY29kZUZ1bmN0aW9uUmVzdWx0IiwiZW5jb2RlRmlsdGVyVG9waWNzIiwiY291bnQiLCJleHBlY3RlZENvdW50IiwidG9waWNzIiwiYW5vbnltb3VzIiwiZW5jb2RlVG9waWMiLCJwYXJhbSIsIm1hdGNoIiwiaW5kZXhlZCIsInBvcCIsImVuY29kZUV2ZW50TG9nIiwiZGF0YVR5cGVzIiwiZGF0YVZhbHVlcyIsIkVycm9yIiwiZGVjb2RlRXZlbnRMb2ciLCJub25JbmRleGVkIiwiZHluYW1pYyIsInJlc3VsdEluZGV4ZWQiLCJyZXN1bHROb25JbmRleGVkIiwibm9uSW5kZXhlZEluZGV4IiwiaW5kZXhlZEluZGV4IiwiZnJvbUl0ZW1zIiwicGFyc2VDYWxsUmVzdWx0IiwicGFyc2VMb2ciLCJwYXJzZUVycm9yIiwiaGV4RGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/typed.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/typed.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ \nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    #options;\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v)=>v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n} //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDbUU7QUFDcEUsTUFBTUUsU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsUUFBUSxHQUFHO1FBQ1hDLFNBQVM7UUFDVEQsU0FBUyxDQUFDO0lBQ2Q7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBTyxJQUFJRSxNQUFNTCxRQUFRLENBQUMsRUFBRUksU0FBUyxLQUFLLElBQUksR0FBRyxFQUFFRCxNQUFNLENBQUMsRUFBRUQsT0FBTztRQUFFRTtRQUFRRDtJQUFNO0FBQ3ZGO0FBQ0EsU0FBU0csRUFBRUosS0FBSyxFQUFFSyxJQUFJO0lBQ2xCLHdDQUF3QztJQUN4QyxPQUFPLElBQUlGLE1BQU1MLFFBQVEsQ0FBQyxLQUFLLEVBQUUsT0FBU08sT0FBTyxHQUFHLENBQUMsRUFBRUwsT0FBTztRQUFFSztJQUFLO0FBQ3pFO0FBQ0EsTUFBTUMsZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQ2hDOztDQUVDLEdBQ00sTUFBTUw7SUFTVCxDQUFDTSxPQUFPLENBQUM7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRVosS0FBSyxFQUFFUyxPQUFPLENBQUU7UUFDckMsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVO1FBQ2Q7UUFDQWIsOERBQWFBLENBQUNFLFFBQVFhLE9BQU87UUFDN0JkLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVM7WUFBY007WUFBTVo7UUFBTTtRQUNuRCxJQUFJLENBQUMsQ0FBQ1MsT0FBTyxHQUFHQTtRQUNoQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDSSxNQUFNO0lBQ2Y7SUFDQTs7S0FFQyxHQUNEQSxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxTQUFTO1lB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QkFDckIsTUFBTSxJQUFJRSxNQUFNLENBQUMsdUJBQXVCLEVBQUVGLEtBQUssTUFBTSxFQUFFWixNQUFNWSxJQUFJLENBQUMsQ0FBQztZQUN2RTtZQUNBLE9BQU9aLE1BQU1BLEtBQUs7UUFDdEI7UUFDQSxPQUFPQTtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvdHlwZWQuanM/MmRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIFR5cGVkIG9iamVjdCBhbGxvd3MgYSB2YWx1ZSB0byBoYXZlIGl0cyB0eXBlIGV4cGxpY2l0bHlcbiAqICBzcGVjaWZpZWQuXG4gKlxuICogIEZvciBleGFtcGxlLCBpbiBTb2xpZGl0eSwgdGhlIHZhbHVlIGBgNDVgYCBjb3VsZCByZXByZXNlbnQgYVxuICogIGBgdWludDhgYCBvciBhIGBgdWludDI1NmBgLiBUaGUgdmFsdWUgYGAweDEyMzRgYCBjb3VsZCByZXByZXNlbnRcbiAqICBhIGBgYnl0ZXMyYGAgb3IgYGBieXRlc2BgLlxuICpcbiAqICBTaW5jZSBKYXZhU2NyaXB0IGhhcyBubyBtZWFuaW5nZnVsIHdheSB0byBleHBsaWNpdGx5IGluZm9ybSBhbnlcbiAqICBBUElzIHdoaWNoIHdoYXQgdGhlIHR5cGUgaXMsIHRoaXMgYWxsb3dzIHRyYW5zcGFyZW50IGludGVyb3BlcmF0aW9uXG4gKiAgd2l0aCBTb2xkaXR5LlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9hYmk6VHlwZWQgVmFsdWVzXG4gKi9cbmltcG9ydCB7IGFzc2VydFByaXZhdGUsIGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IF9nYXVyZCA9IHt9O1xuZnVuY3Rpb24gbih2YWx1ZSwgd2lkdGgpIHtcbiAgICBsZXQgc2lnbmVkID0gZmFsc2U7XG4gICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICB3aWR0aCAqPSAtMTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIHJhbmdlIGlzIHZhbGlkIGZvciB2YWx1ZVxuICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBgJHtzaWduZWQgPyBcIlwiIDogXCJ1XCJ9aW50JHt3aWR0aH1gLCB2YWx1ZSwgeyBzaWduZWQsIHdpZHRoIH0pO1xufVxuZnVuY3Rpb24gYih2YWx1ZSwgc2l6ZSkge1xuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYGJ5dGVzJHsoc2l6ZSkgPyBzaXplIDogXCJcIn1gLCB2YWx1ZSwgeyBzaXplIH0pO1xufVxuY29uc3QgX3R5cGVkU3ltYm9sID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfdHlwZWRcIik7XG4vKipcbiAqICBUaGUgKipUeXBlZCoqIGNsYXNzIHRvIHdyYXAgdmFsdWVzIHByb3ZpZGluZyBleHBsaWNpdCB0eXBlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3R5cGVkU3ltYm9sO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShfZ2F1cmQsIGdhdXJkLCBcIlR5cGVkXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgX3R5cGVkU3ltYm9sLCB0eXBlLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWx1ZSBpcyB2YWxpZFxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9ybWF0IHRoZSB0eXBlIGFzIGEgSHVtYW4tUmVhZGFibGUgdHlwZS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJkeW5hbWljQXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYHR1cGxlKCR7dGhpcy52YWx1ZS5tYXAoKHYpID0+IHYuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIHR5cGUuXG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5pbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1pblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBudW1lcmljIHR5cGVzLlxuICAgICAqL1xuICAgIG1heFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZEJpZ0ludF1dLlxuICAgICAqL1xuICAgIGlzQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy50eXBlLm1hdGNoKC9edT9pbnRbMC05XSskLykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkRGF0YV1dLlxuICAgICAqL1xuICAgIGlzRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRTdHJpbmddXS5cbiAgICAgKi9cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IFwic3RyaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHVwbGUgbmFtZSwgaWYgdGhpcyBpcyBhIHR1cGxlLiBUaHJvd3Mgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCB0dXBsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGEgdHVwbGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGlzIHR5cGUgYXMgYW4gYXJyYXlcbiAgICAvLyAtIGBudWxsYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyB1bmZvcmNlZCwgaXQgY291bGQgYmUgZHluYW1pY1xuICAgIC8vIC0gYC0xYCBpbmRpY2F0ZXMgdGhlIGxlbmd0aCBpcyBkeW5hbWljXG4gICAgLy8gLSBhbnkgb3RoZXIgdmFsdWUgaW5kaWNhdGVzIGl0IGlzIGEgc3RhdGljIGFycmF5IGFuZCBpcyBpdHMgbGVuZ3RoXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdHlwZSBvciBgYC0xYGAgaWYgaXQgaXMgZHluYW1pYy5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIHR5cGUgaXMgbm90IGFuIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBhcnJheUxlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlR5cGVkKiogb2YgJSV0eXBlJSUgd2l0aCB0aGUgJSV2YWx1ZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCB0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OCh2KSB7IHJldHVybiBuKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYodikgeyByZXR1cm4gbih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNCh2KSB7IHJldHVybiBuKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDMyKHYpIHsgcmV0dXJuIG4odiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDAodikgeyByZXR1cm4gbih2LCA0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0OCh2KSB7IHJldHVybiBuKHYsIDQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDU2KHYpIHsgcmV0dXJuIG4odiwgNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NjQodikgeyByZXR1cm4gbih2LCA2NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ3Mih2KSB7IHJldHVybiBuKHYsIDcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgwKHYpIHsgcmV0dXJuIG4odiwgODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODgodikgeyByZXR1cm4gbih2LCA4OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ5Nih2KSB7IHJldHVybiBuKHYsIDk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMDQodikgeyByZXR1cm4gbih2LCAxMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDExMih2KSB7IHJldHVybiBuKHYsIDExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTIwKHYpIHsgcmV0dXJuIG4odiwgMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjgodikgeyByZXR1cm4gbih2LCAxMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEzNih2KSB7IHJldHVybiBuKHYsIDEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNTIodikgeyByZXR1cm4gbih2LCAxNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2MCh2KSB7IHJldHVybiBuKHYsIDE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTY4KHYpIHsgcmV0dXJuIG4odiwgMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNzYodikgeyByZXR1cm4gbih2LCAxNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE4NCh2KSB7IHJldHVybiBuKHYsIDE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTkyKHYpIHsgcmV0dXJuIG4odiwgMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDAodikgeyByZXR1cm4gbih2LCAyMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwOCh2KSB7IHJldHVybiBuKHYsIDIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjE2KHYpIHsgcmV0dXJuIG4odiwgMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMjQodikgeyByZXR1cm4gbih2LCAyMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIzMih2KSB7IHJldHVybiBuKHYsIDIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQwKHYpIHsgcmV0dXJuIG4odiwgMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDgodikgeyByZXR1cm4gbih2LCAyNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI1Nih2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgodikgeyByZXR1cm4gbih2LCAtOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYodikgeyByZXR1cm4gbih2LCAtMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0KHYpIHsgcmV0dXJuIG4odiwgLTI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQzMih2KSB7IHJldHVybiBuKHYsIC0zMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDAodikgeyByZXR1cm4gbih2LCAtNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQ4KHYpIHsgcmV0dXJuIG4odiwgLTQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ1Nih2KSB7IHJldHVybiBuKHYsIC01Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NjQodikgeyByZXR1cm4gbih2LCAtNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDcyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDcyKHYpIHsgcmV0dXJuIG4odiwgLTcyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4MCh2KSB7IHJldHVybiBuKHYsIC04MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODgodikgeyByZXR1cm4gbih2LCAtODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDk2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDk2KHYpIHsgcmV0dXJuIG4odiwgLTk2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTA0KHYpIHsgcmV0dXJuIG4odiwgLTEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDExMih2KSB7IHJldHVybiBuKHYsIC0xMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjAodikgeyByZXR1cm4gbih2LCAtMTIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTI4KHYpIHsgcmV0dXJuIG4odiwgLTEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEzNih2KSB7IHJldHVybiBuKHYsIC0xMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE0NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNDQodikgeyByZXR1cm4gbih2LCAtMTQ0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNTIodikgeyByZXR1cm4gbih2LCAtMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTYwKHYpIHsgcmV0dXJuIG4odiwgLTE2MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2OCh2KSB7IHJldHVybiBuKHYsIC0xNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNzYodikgeyByZXR1cm4gbih2LCAtMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxODRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTg0KHYpIHsgcmV0dXJuIG4odiwgLTE4NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTkyKHYpIHsgcmV0dXJuIG4odiwgLTE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjAwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwMCh2KSB7IHJldHVybiBuKHYsIC0yMDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDgodikgeyByZXR1cm4gbih2LCAtMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjE2KHYpIHsgcmV0dXJuIG4odiwgLTIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIyNCh2KSB7IHJldHVybiBuKHYsIC0yMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMzIodikgeyByZXR1cm4gbih2LCAtMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQwKHYpIHsgcmV0dXJuIG4odiwgLTI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0OCh2KSB7IHJldHVybiBuKHYsIC0yNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNTYodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMSh2KSB7IHJldHVybiBiKHYsIDEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIodikgeyByZXR1cm4gYih2LCAyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzKHYpIHsgcmV0dXJuIGIodiwgMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNCh2KSB7IHJldHVybiBiKHYsIDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczUodikgeyByZXR1cm4gYih2LCA1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM2KHYpIHsgcmV0dXJuIGIodiwgNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNyh2KSB7IHJldHVybiBiKHYsIDcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczgodikgeyByZXR1cm4gYih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM5KHYpIHsgcmV0dXJuIGIodiwgOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEwKHYpIHsgcmV0dXJuIGIodiwgMTApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMSh2KSB7IHJldHVybiBiKHYsIDExKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTIodikgeyByZXR1cm4gYih2LCAxMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEzKHYpIHsgcmV0dXJuIGIodiwgMTMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNCh2KSB7IHJldHVybiBiKHYsIDE0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTUodikgeyByZXR1cm4gYih2LCAxNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE2KHYpIHsgcmV0dXJuIGIodiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNyh2KSB7IHJldHVybiBiKHYsIDE3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTgodikgeyByZXR1cm4gYih2LCAxOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE5KHYpIHsgcmV0dXJuIGIodiwgMTkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMCh2KSB7IHJldHVybiBiKHYsIDIwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjEodikgeyByZXR1cm4gYih2LCAyMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIyKHYpIHsgcmV0dXJuIGIodiwgMjIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMyh2KSB7IHJldHVybiBiKHYsIDIzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjQodikgeyByZXR1cm4gYih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI1KHYpIHsgcmV0dXJuIGIodiwgMjUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNih2KSB7IHJldHVybiBiKHYsIDI2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjcodikgeyByZXR1cm4gYih2LCAyNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI4KHYpIHsgcmV0dXJuIGIodiwgMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOSh2KSB7IHJldHVybiBiKHYsIDI5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzAodikgeyByZXR1cm4gYih2LCAzMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMxKHYpIHsgcmV0dXJuIGIodiwgMzEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMih2KSB7IHJldHVybiBiKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhZGRyZXNzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGFkZHJlc3ModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhZGRyZXNzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJvb2xgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm9vbCh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJvb2xcIiwgISF2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImJ5dGVzXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHN0cmluZ2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmcodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJzdHJpbmdcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYXJyYXlgYCB0eXBlIGZvciAlJXYlJSwgYWxsb3dpbmcgJSVkeW5hbWljJSUgbGVuZ3RoLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcnJheSh2LCBkeW5hbWljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFycmF5XCIsIHYsIGR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdHVwbGVgYCB0eXBlIGZvciAlJXYlJSwgd2l0aCB0aGUgb3B0aW9uYWwgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIHR1cGxlKHYsIG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwidHVwbGVcIiwgdiwgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBvdmVycmlkZXModikge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJvdmVycmlkZXNcIiwgT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIG9ubHkgaWYgJSV2YWx1ZSUlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWVcbiAgICAgICAgICAgICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBcIl90eXBlZFN5bWJvbFwiIGluIHZhbHVlXG4gICAgICAgICAgICAmJiB2YWx1ZS5fdHlwZWRTeW1ib2wgPT09IF90eXBlZFN5bWJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0aGUgdmFsdWUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UsIHZhbGlkYXRlcyB0aGUgdW5kZXJseWluZyB2YWx1ZVxuICAgICAqICBhbmQgcmV0dXJucyBpdCwgb3RoZXJ3aXNlIHJldHVybnMgdmFsdWUgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyB1c2VmdWwgZm9yIGZ1bmN0aW9ucyB0aGF0IHdpdGggdG8gYWNjZXB0IGVpdGhlciBhIFtbVHlwZWRdXVxuICAgICAqICBvYmplY3Qgb3IgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXJlZmVyZW5jZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGU6IGV4cGVjZXRkICR7dHlwZX0sIGdvdCAke3ZhbHVlLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRQcml2YXRlIiwiZGVmaW5lUHJvcGVydGllcyIsIl9nYXVyZCIsIm4iLCJ2YWx1ZSIsIndpZHRoIiwic2lnbmVkIiwiVHlwZWQiLCJiIiwic2l6ZSIsIl90eXBlZFN5bWJvbCIsIlN5bWJvbCIsImZvciIsIm9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsImdhdXJkIiwidHlwZSIsImZvcm1hdCIsIkVycm9yIiwibWFwIiwidiIsImpvaW4iLCJkZWZhdWx0VmFsdWUiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNCaWdJbnQiLCJtYXRjaCIsImlzRGF0YSIsInN0YXJ0c1dpdGgiLCJpc1N0cmluZyIsInR1cGxlTmFtZSIsIlR5cGVFcnJvciIsImFycmF5TGVuZ3RoIiwibGVuZ3RoIiwiZnJvbSIsInVpbnQ4IiwidWludDE2IiwidWludDI0IiwidWludDMyIiwidWludDQwIiwidWludDQ4IiwidWludDU2IiwidWludDY0IiwidWludDcyIiwidWludDgwIiwidWludDg4IiwidWludDk2IiwidWludDEwNCIsInVpbnQxMTIiLCJ1aW50MTIwIiwidWludDEyOCIsInVpbnQxMzYiLCJ1aW50MTQ0IiwidWludDE1MiIsInVpbnQxNjAiLCJ1aW50MTY4IiwidWludDE3NiIsInVpbnQxODQiLCJ1aW50MTkyIiwidWludDIwMCIsInVpbnQyMDgiLCJ1aW50MjE2IiwidWludDIyNCIsInVpbnQyMzIiLCJ1aW50MjQwIiwidWludDI0OCIsInVpbnQyNTYiLCJ1aW50IiwiaW50OCIsImludDE2IiwiaW50MjQiLCJpbnQzMiIsImludDQwIiwiaW50NDgiLCJpbnQ1NiIsImludDY0IiwiaW50NzIiLCJpbnQ4MCIsImludDg4IiwiaW50OTYiLCJpbnQxMDQiLCJpbnQxMTIiLCJpbnQxMjAiLCJpbnQxMjgiLCJpbnQxMzYiLCJpbnQxNDQiLCJpbnQxNTIiLCJpbnQxNjAiLCJpbnQxNjgiLCJpbnQxNzYiLCJpbnQxODQiLCJpbnQxOTIiLCJpbnQyMDAiLCJpbnQyMDgiLCJpbnQyMTYiLCJpbnQyMjQiLCJpbnQyMzIiLCJpbnQyNDAiLCJpbnQyNDgiLCJpbnQyNTYiLCJpbnQiLCJieXRlczEiLCJieXRlczIiLCJieXRlczMiLCJieXRlczQiLCJieXRlczUiLCJieXRlczYiLCJieXRlczciLCJieXRlczgiLCJieXRlczkiLCJieXRlczEwIiwiYnl0ZXMxMSIsImJ5dGVzMTIiLCJieXRlczEzIiwiYnl0ZXMxNCIsImJ5dGVzMTUiLCJieXRlczE2IiwiYnl0ZXMxNyIsImJ5dGVzMTgiLCJieXRlczE5IiwiYnl0ZXMyMCIsImJ5dGVzMjEiLCJieXRlczIyIiwiYnl0ZXMyMyIsImJ5dGVzMjQiLCJieXRlczI1IiwiYnl0ZXMyNiIsImJ5dGVzMjciLCJieXRlczI4IiwiYnl0ZXMyOSIsImJ5dGVzMzAiLCJieXRlczMxIiwiYnl0ZXMzMiIsImFkZHJlc3MiLCJib29sIiwiYnl0ZXMiLCJzdHJpbmciLCJhcnJheSIsImR5bmFtaWMiLCJ0dXBsZSIsIm5hbWUiLCJvdmVycmlkZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJpc1R5cGVkIiwiZGVyZWZlcmVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/address.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/address.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ2M7QUFDN0QsTUFBTUcsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLFNBQVNFLG1CQUFtQkMsT0FBTztJQUMvQixzQ0FBc0M7SUFDdEMsMkVBQTJFO0lBQzNFLE9BQU87SUFDUEEsVUFBVUEsUUFBUUMsV0FBVztJQUM3QixNQUFNQyxRQUFRRixRQUFRRyxTQUFTLENBQUMsR0FBR0MsS0FBSyxDQUFDO0lBQ3pDLE1BQU1DLFdBQVcsSUFBSUMsV0FBVztJQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCRixRQUFRLENBQUNFLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxFQUFFLENBQUNDLFVBQVUsQ0FBQztJQUN0QztJQUNBLE1BQU1DLFNBQVNmLHlEQUFRQSxDQUFDRCwyREFBU0EsQ0FBQ1k7SUFDbEMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1FBQzVCLElBQUksTUFBTyxDQUFDQSxLQUFLLEVBQUUsSUFBSSxLQUFNLEdBQUc7WUFDNUJMLEtBQUssQ0FBQ0ssRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0csV0FBVztRQUNuQztRQUNBLElBQUksQ0FBQ0QsTUFBTSxDQUFDRixLQUFLLEVBQUUsR0FBRyxJQUFHLEtBQU0sR0FBRztZQUM5QkwsS0FBSyxDQUFDSyxJQUFJLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxJQUFJLEVBQUUsQ0FBQ0csV0FBVztRQUMzQztJQUNKO0lBQ0EsT0FBTyxPQUFPUixNQUFNUyxJQUFJLENBQUM7QUFDN0I7QUFDQSx1RUFBdUU7QUFDdkUsc0JBQXNCO0FBQ3RCLE1BQU1DLGFBQWEsQ0FBQztBQUNwQixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO0lBQ3pCSyxV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ZWhDLE9BQU87SUFDbEMsMkVBQTJFO0lBQzNFLElBQUlpQyxTQUFTcEMsT0FBTytCLFdBQVc1QixVQUFVK0IsUUFBUSxDQUFDLElBQUlyQixXQUFXO0lBQ2pFLE1BQU91QixPQUFPZCxNQUFNLEdBQUcsR0FBSTtRQUN2QmMsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT2pCLGFBQWEsU0FBU2lCLFVBQVVBO0FBQ2xELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzP2ExOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMzYgPSBCaWdJbnQoMzYpO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvLyAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgIC8vICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAvLyAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGdldEJ5dGVzKGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG4vLyBpLmUuIE1hdGguZmxvb3IoTWF0aC5sb2cxMChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuY29uc3Qgc2FmZURpZ2l0cyA9IDE1O1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmNvbnN0IEJhc2UzNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiW2ldO1xuICAgICAgICByZXN1bHRba2V5XSA9IEJpZ0ludChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5mdW5jdGlvbiBmcm9tQmFzZTM2KHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXN1bHQgPSBCTl8wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogQk5fMzYgKyBCYXNlMzZbdmFsdWVbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5vcm1hbGl6ZWQgYW5kIGNoZWNrc3VtZWQgYWRkcmVzcyBmb3IgJSVhZGRyZXNzJSUuXG4gKiAgVGhpcyBhY2NlcHRzIG5vbi1jaGVja3N1bSBhZGRyZXNzZXMsIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmRcbiAqICBbW2dldEljYXBBZGRyZXNzXV0gZm9ybWF0cy5cbiAqXG4gKiAgVGhlIGNoZWNrc3VtIGluIEV0aGVyZXVtIHVzZXMgdGhlIGNhcGl0YWxpemF0aW9uICh1cHBlci1jYXNlXG4gKiAgdnMgbG93ZXItY2FzZSkgb2YgdGhlIGNoYXJhY3RlcnMgd2l0aGluIGFuIGFkZHJlc3MgdG8gZW5jb2RlXG4gKiAgaXRzIGNoZWNrc3VtLCB3aGljaCBvZmZlcnMsIG9uIGF2ZXJhZ2UsIGEgY2hlY2tzdW0gb2YgMTUtYml0cy5cbiAqXG4gKiAgSWYgJSVhZGRyZXNzJSUgY29udGFpbnMgYm90aCB1cHBlci1jYXNlIGFuZCBsb3dlci1jYXNlLCBpdCBpc1xuICogIGFzc3VtZWQgdG8gYWxyZWFkeSBiZSBhIGNoZWNrc3VtIGFkZHJlc3MgYW5kIGl0cyBjaGVja3N1bSBpc1xuICogIHZhbGlkYXRlZCwgYW5kIGlmIHRoZSBhZGRyZXNzIGZhaWxzIGl0cyBleHBlY3RlZCBjaGVja3N1bSBhblxuICogIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAgSWYgeW91IHdpc2ggdGhlIGNoZWNrc3VtIG9mICUlYWRkcmVzcyUlIHRvIGJlIGlnbm9yZSwgaXQgc2hvdWxkXG4gKiAgYmUgY29udmVydGVkIHRvIGxvd2VyLWNhc2UgKGkuZS4gYGAudG9Mb3dlcmNhc2UoKWBgKSBiZWZvcmVcbiAqICBiZWluZyBwYXNzZWQgaW4uIFRoaXMgc2hvdWxkIGJlIGEgdmVyeSByYXJlIHNpdHVhdGlvbiB0aG91Z2gsXG4gKiAgdGhhdCB5b3Ugd2lzaCB0byBieXBhc3MgdGhlIHNhZmVnYXVyZHMgaW4gcGxhY2UgdG8gcHJvdGVjdFxuICogIGFnYWluc3QgYW4gYWRkcmVzcyB0aGF0IGhhcyBiZWVuIGluY29ycmVjdGx5IGNvcGllZCBmcm9tIGFub3RoZXJcbiAqICBzb3VyY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQWRkcyB0aGUgY2hlY2tzdW0gKHZpYSB1cHBlci1jYXNpbmcgc3BlY2lmaWMgbGV0dGVycylcbiAqICAgIGdldEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb252ZXJ0cyBJQ0FQIGFkZHJlc3MgYW5kIGFkZHMgY2hlY2tzdW1cbiAqICAgIGdldEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW4gYWRkcmVzcyBjb250YWlucyBtaXhlZCBjYXNlLFxuICogICAgLy8gYnV0IHRoZSBjaGVja3N1bSBmYWlsc1xuICogICAgZ2V0QWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKGFkZHJlc3MpID09PSBcInN0cmluZ1wiLCBcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKCFhZGRyZXNzLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudCghYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSB8fCByZXN1bHQgPT09IGFkZHJlc3MsIFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBhc3NlcnRBcmd1bWVudChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSA9PT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpLCBcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZyb21CYXNlMzYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xufVxuLyoqXG4gKiAgVGhlIFtJQ0FQIEFkZHJlc3MgZm9ybWF0XShsaW5rLWljYXApIGZvcm1hdCBpcyBhbiBlYXJseSBjaGVja3N1bVxuICogIGZvcm1hdCB3aGljaCBhdHRlbXB0cyB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIGJhbmtpbmdcbiAqICBpbmR1c3RyeSBbSUJBTiBmb3JtYXRdKGxpbmstd2lraS1pYmFuKSBmb3IgYmFuayBhY2NvdW50cy5cbiAqXG4gKiAgSXQgaXMgbm8gbG9uZ2VyIGNvbW1vbiBvciBhIHJlY29tbWVuZGVkIGZvcm1hdC5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgSUNBUCBjaGVja3N1bSBpcyB3cm9uZ1xuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszN1wiKTtcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldCBiYXNlMzYgPSBCaWdJbnQoZ2V0QWRkcmVzcyhhZGRyZXNzKSkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJnZXRCeXRlcyIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJpZ0ludCIsIkJOXzM2IiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwiY2hhcnMiLCJzdWJzdHJpbmciLCJzcGxpdCIsImV4cGFuZGVkIiwiVWludDhBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiaGFzaGVkIiwidG9VcHBlckNhc2UiLCJqb2luIiwiaWJhbkxvb2t1cCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNhZmVEaWdpdHMiLCJpYmFuQ2hlY2tzdW0iLCJtYXAiLCJjIiwibGVuZ3RoIiwiYmxvY2siLCJwYXJzZUludCIsImNoZWNrc3VtIiwiQmFzZTM2IiwicmVzdWx0Iiwia2V5IiwiZnJvbUJhc2UzNiIsInZhbHVlIiwiZ2V0QWRkcmVzcyIsIm1hdGNoIiwic3RhcnRzV2l0aCIsInRvU3RyaW5nIiwiZ2V0SWNhcEFkZHJlc3MiLCJiYXNlMzYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/checks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/checks.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n} //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDakI7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNHLGNBQWNDLEtBQUs7SUFDL0IsT0FBUUEsU0FBUyxPQUFRQSxNQUFNRixVQUFVLEtBQU07QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sU0FBU0csVUFBVUQsS0FBSztJQUMzQixJQUFJO1FBQ0FGLHVEQUFVQSxDQUFDRTtRQUNYLE9BQU87SUFDWCxFQUNBLE9BQU9FLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQSxlQUFlQyxhQUFhQyxNQUFNLEVBQUVDLE9BQU87SUFDdkMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixJQUFJQyxVQUFVLFFBQVFBLFdBQVcsOENBQThDO1FBQzNFVix1REFBTUEsQ0FBQyxPQUFRUSxXQUFZLFVBQVUscUJBQXFCLHFCQUFxQjtZQUFFSixPQUFPSTtRQUFPO1FBQy9GUCwrREFBY0EsQ0FBQyxPQUFPLGlFQUFpRSxVQUFVTztJQUNyRztJQUNBLE9BQU9OLHVEQUFVQSxDQUFDUTtBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxTQUFTQyxlQUFlSCxNQUFNLEVBQUVJLFFBQVE7SUFDM0MsSUFBSSxPQUFRSixXQUFZLFVBQVU7UUFDOUIsSUFBSUEsT0FBT0ssS0FBSyxDQUFDLHNCQUFzQjtZQUNuQyxPQUFPWCx1REFBVUEsQ0FBQ007UUFDdEI7UUFDQVIsdURBQU1BLENBQUNZLFlBQVksTUFBTSxzQ0FBc0MseUJBQXlCO1lBQUVFLFdBQVc7UUFBYztRQUNuSCxPQUFPUCxhQUFhQyxRQUFRSSxTQUFTRyxXQUFXLENBQUNQO0lBQ3JELE9BQ0ssSUFBSUwsY0FBY0ssU0FBUztRQUM1QixPQUFPRCxhQUFhQyxRQUFRQSxPQUFPTixVQUFVO0lBQ2pELE9BQ0ssSUFBSU0sVUFBVSxPQUFRQSxPQUFPUSxJQUFJLEtBQU0sWUFBWTtRQUNwRCxPQUFPVCxhQUFhQyxRQUFRQTtJQUNoQztJQUNBUCwrREFBY0EsQ0FBQyxPQUFPLGlDQUFpQyxVQUFVTztBQUNyRSxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvY2hlY2tzLmpzPzg0NzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuL2FkZHJlc3MuanNcIjtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlXG4gKiAgW1tBZGRyZXNzYWJsZV1dIGludGVyZmFjZS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBXYWxsZXRzIGFuZCBBYnN0cmFjdFNpZ25lciBzdWItY2xhc3Nlc1xuICogICAgaXNBZGRyZXNzYWJsZShXYWxsZXQuY3JlYXRlUmFuZG9tKCkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udHJhY3RzXG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBbIF0sIHByb3ZpZGVyKVxuICogICAgaXNBZGRyZXNzYWJsZShjb250cmFjdClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzc2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZ2V0QWRkcmVzcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBWYWxpZCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBWYWxpZCBJQ0FQIGFkZHJlc3NcbiAqICAgIGlzQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM2XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gSW52YWxpZCBJQ0FQIGNoZWNrc3VtXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBOb3QgYW4gYWRkcmVzcyAoYW4gRU5TIG5hbWUgcmVxdWlyZXMgYSBwcm92aWRlZCBhbmQgYW5cbiAqICAgIC8vIGFzeW5jaHJvbm91cyBBUEkgdG8gYWNjZXNzKVxuICogICAgaXNBZGRyZXNzKFwicmljbW9vLmV0aFwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHByb21pc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIiwgXCJ1bmNvbmZpZ3VyZWQgbmFtZVwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHsgdmFsdWU6IHRhcmdldCB9KTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBBZGRyZXNzTGlrZSB2YWx1ZTsgZGlkIG5vdCByZXNvbHZlIHRvIGEgdmFsdWUgYWRkcmVzc1wiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYW4gYWRkcmVzcyBmb3IgdGhlICUldGFyZ2V0JSUsIHdoaWNoIG1heSBiZSBhbnlcbiAqICBzdXBwb3J0ZWQgYWRkcmVzcyB0eXBlLCBhbiBbW0FkZHJlc3NhYmxlXV0gb3IgYSBQcm9taXNlIHdoaWNoXG4gKiAgcmVzb2x2ZXMgdG8gYW4gYWRkcmVzcy5cbiAqXG4gKiAgSWYgYW4gRU5TIG5hbWUgaXMgcHJvdmlkZWQsIGJ1dCB0aGF0IG5hbWUgaGFzIG5vdCBiZWVuIGNvcnJlY3RseVxuICogIGNvbmZpZ3VyZWQgYSBbW1VuY29uZmlndXJlZE5hbWVFcnJvcl1dIGlzIHRocm93bi5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBhZGRyID0gXCIweDZCMTc1NDc0RTg5MDk0QzQ0RGE5OGI5NTRFZWRlQUM0OTUyNzFkMEZcIlxuICpcbiAqICAgIC8vIEFkZHJlc3NlcyBhcmUgcmV0dXJuIHN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGFkZHIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3MgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhQcm9taXNlLnJlc29sdmUoYWRkcikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRU5TIG5hbWVzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQWRkcmVzc2FibGUgb2JqZWN0cyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGFkZHIsIFsgXSlcbiAqICAgIHJlc29sdmVBZGRyZXNzKGNvbnRyYWN0LCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBVbmNvbmZpZ3VyZWQgRU5TIG5hbWVzIHJlamVjdFxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiLCBwcm92aWRlcilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyByZXF1aXJlIGEgTmFtZVJlc29sdmVyIG9iamVjdCBwYXNzZWQgaW5cbiAqICAgIC8vIChub3RpY2UgdGhlIHByb3ZpZGVyIHdhcyBvbWl0dGVkKVxuICogICAgcmVzb2x2ZUFkZHJlc3MoXCJub3RoaW5nLWhlcmUucmljbW9vLmV0aFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoKC9eMHhbMC05YS1mXXs0MH0kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChyZXNvbHZlciAhPSBudWxsLCBcIkVOUyByZXNvbHV0aW9uIHJlcXVpcmVzIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FkZHJlc3NhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldC5nZXRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mICh0YXJnZXQudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgYWRkcmVzc2FibGUgdmFsdWVcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcy5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRBZGRyZXNzIiwiaXNBZGRyZXNzYWJsZSIsInZhbHVlIiwiaXNBZGRyZXNzIiwiZXJyb3IiLCJjaGVja0FkZHJlc3MiLCJ0YXJnZXQiLCJwcm9taXNlIiwicmVzdWx0IiwicmVzb2x2ZUFkZHJlc3MiLCJyZXNvbHZlciIsIm1hdGNoIiwib3BlcmF0aW9uIiwicmVzb2x2ZU5hbWUiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/contract-address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getCreateAddress: () => (/* binding */ getCreateAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */ function getCreateAddress(tx) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.from);\n    const nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.encodeRlp)([\n        from,\n        nonceHex\n    ])), 12));\n}\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */ function getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(_from);\n    const salt = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.dataSlice)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        from,\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=contract-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ3VEO0FBQzVEO0FBQzFDLHNHQUFzRztBQUN0Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTUSxpQkFBaUJDLEVBQUU7SUFDL0IsTUFBTUMsT0FBT0gsdURBQVVBLENBQUNFLEdBQUdDLElBQUk7SUFDL0IsTUFBTUMsUUFBUVIsMERBQVNBLENBQUNNLEdBQUdFLEtBQUssRUFBRTtJQUNsQyxJQUFJQyxXQUFXRCxNQUFNRSxRQUFRLENBQUM7SUFDOUIsSUFBSUQsYUFBYSxLQUFLO1FBQ2xCQSxXQUFXO0lBQ2YsT0FDSyxJQUFJQSxTQUFTRSxNQUFNLEdBQUcsR0FBRztRQUMxQkYsV0FBVyxRQUFRQTtJQUN2QixPQUNLO1FBQ0RBLFdBQVcsT0FBT0E7SUFDdEI7SUFDQSxPQUFPTCx1REFBVUEsQ0FBQ0wsMERBQVNBLENBQUNGLDJEQUFTQSxDQUFDSywwREFBU0EsQ0FBQztRQUFDSztRQUFNRTtLQUFTLElBQUk7QUFDeEU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNHLGtCQUFrQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGFBQWE7SUFDekQsTUFBTVIsT0FBT0gsdURBQVVBLENBQUNTO0lBQ3hCLE1BQU1HLE9BQU9mLHlEQUFRQSxDQUFDYSxPQUFPO0lBQzdCLE1BQU1HLGVBQWVoQix5REFBUUEsQ0FBQ2MsZUFBZTtJQUM3Q1osK0RBQWNBLENBQUNhLEtBQUtMLE1BQU0sS0FBSyxJQUFJLHlCQUF5QixRQUFRRztJQUNwRVgsK0RBQWNBLENBQUNjLGFBQWFOLE1BQU0sS0FBSyxJQUFJLGlDQUFpQyxnQkFBZ0JJO0lBQzVGLE9BQU9YLHVEQUFVQSxDQUFDTCwwREFBU0EsQ0FBQ0YsMkRBQVNBLENBQUNDLHVEQUFNQSxDQUFDO1FBQUM7UUFBUVM7UUFBTVM7UUFBTUM7S0FBYSxJQUFJO0FBQ3ZGLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzP2MwYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhU2xpY2UsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGVuY29kZVJscCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBhIGBgQ1JFQVRFYGAgZm9yICUldHglJS5cbiAqXG4gKiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGFuIEVPQSB3aGVuIHNlbmRpbmcgYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uIChpLmUuXG4gKiAgd2hlbiB0aGUgYGB0b2BgIGFkZHJlc3MgaXMgYGBudWxsYGApLlxuICpcbiAqICBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcyBhIGNvbnRyYWN0IHdpbGwgYmVcbiAqICBkZXBsb3llZCB0byBieSBhIGNvbnRyYWN0LCBieSB1c2luZyB0aGUgY29udHJhY3QncyBhZGRyZXNzIGFzIHRoZVxuICogIGBgdG9gYCBhbmQgdGhlIGNvbnRyYWN0J3Mgbm9uY2UuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBmcm9tID0gXCIweDhiYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIjtcbiAqICAgIG5vbmNlID0gNTtcbiAqXG4gKiAgICBnZXRDcmVhdGVBZGRyZXNzKHsgZnJvbSwgbm9uY2UgfSk7XG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGVBZGRyZXNzKHR4KSB7XG4gICAgY29uc3QgZnJvbSA9IGdldEFkZHJlc3ModHguZnJvbSk7XG4gICAgY29uc3Qgbm9uY2UgPSBnZXRCaWdJbnQodHgubm9uY2UsIFwidHgubm9uY2VcIik7XG4gICAgbGV0IG5vbmNlSGV4ID0gbm9uY2UudG9TdHJpbmcoMTYpO1xuICAgIGlmIChub25jZUhleCA9PT0gXCIwXCIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vbmNlSGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgbm9uY2VIZXggPSBcIjB4MFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIiArIG5vbmNlSGV4O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhkYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZVJscChbZnJvbSwgbm9uY2VIZXhdKSksIDEyKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhfZnJvbSwgX3NhbHQsIF9pbml0Q29kZUhhc2gpIHtcbiAgICBjb25zdCBmcm9tID0gZ2V0QWRkcmVzcyhfZnJvbSk7XG4gICAgY29uc3Qgc2FsdCA9IGdldEJ5dGVzKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gZ2V0Qnl0ZXMoX2luaXRDb2RlSGFzaCwgXCJpbml0Q29kZUhhc2hcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQoc2FsdC5sZW5ndGggPT09IDMyLCBcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgX3NhbHQpO1xuICAgIGFzc2VydEFyZ3VtZW50KGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGRhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiY29uY2F0IiwiZGF0YVNsaWNlIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJlbmNvZGVSbHAiLCJhc3NlcnRBcmd1bWVudCIsImdldEFkZHJlc3MiLCJnZXRDcmVhdGVBZGRyZXNzIiwidHgiLCJmcm9tIiwibm9uY2UiLCJub25jZUhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZ2V0Q3JlYXRlMkFkZHJlc3MiLCJfZnJvbSIsIl9zYWx0IiwiX2luaXRDb2RlSGFzaCIsInNhbHQiLCJpbml0Q29kZUhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/addresses.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroAddress: () => (/* binding */ ZeroAddress)\n/* harmony export */ });\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */ const ZeroAddress = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BLGNBQWMsNkNBQTZDLENBQ3hFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9hZGRyZXNzZXMuanM/MjMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBhZGRyZXNzLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbIlplcm9BZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/constants/hashes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZeroHash: () => (/* binding */ ZeroHash)\n/* harmony export */ });\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */ const ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29uc3RhbnRzL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNNLE1BQU1BLFdBQVcscUVBQXFFLENBQzdGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnN0YW50cy9oYXNoZXMuanM/OTdkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBoYXNoLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydCBjb25zdCBaZXJvSGFzaCA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbIlplcm9IYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/contract.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wrappers.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    constructor(contract, fragment, args){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function(...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function(...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function(...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function(...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args)=>{\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function(...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once })=>{\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof target === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_8__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            filters\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n} //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNpQjtBQUNwRSxzRUFBc0U7QUFDdEUseUJBQXlCO0FBQ21DO0FBQ2lHO0FBQ2pCO0FBQzVJLE1BQU1vQixPQUFPQyxPQUFPO0FBQ3BCLFNBQVNDLFFBQVFDLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxZQUFZRixLQUFLO0lBQ3RCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUcsV0FBVyxLQUFNO0FBQ3BEO0FBQ0EsU0FBU0MsV0FBV0osS0FBSztJQUNyQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1LLFdBQVcsS0FBTTtBQUNwRDtBQUNBLFNBQVNDLFFBQVFOLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNTyxlQUFlLEtBQU07QUFDeEQ7QUFDQSxTQUFTQyxZQUFZUixLQUFLO0lBQ3RCLElBQUlBLFNBQVMsTUFBTTtRQUNmLElBQUlJLFdBQVdKLFFBQVE7WUFDbkIsT0FBT0E7UUFDWDtRQUNBLElBQUlBLE1BQU1TLFFBQVEsRUFBRTtZQUNoQixPQUFPVCxNQUFNUyxRQUFRO1FBQ3pCO0lBQ0o7SUFDQSxPQUFPQztBQUNYO0FBQ0EsTUFBTUM7SUFDRixDQUFDQyxNQUFNLENBQUM7SUFFUkMsWUFBWUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksQ0FBRTtRQUNsQ2pDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWdDO1FBQVM7UUFDbEMsSUFBSUEsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSwwREFBMEQ7UUFDMUQsTUFBTUMsU0FBU0MsVUFBVVAsU0FBU00sTUFBTSxFQUFFO1FBQzFDLE1BQU1FLFdBQVdsQixXQUFXZ0IsVUFB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QUFFa0IsUUFBUSxFQUFFO1FBQ2xDLE9BQU8sTUFBTSxJQUFJLENBQUNZLEdBQUcsQ0FBQzlCLE9BQU9rQjtJQUNqQztJQUNBOztLQUVDLEdBQ0QsT0FBT21FLFdBQVd6QyxHQUFHLEVBQUU7UUFDbkIsTUFBTTBDLHVCQUF1QjVDO1lBQ3pCbEksWUFBWXlHLE9BQU8sRUFBRWxHLFNBQVMsSUFBSSxDQUFFO2dCQUNoQyxLQUFLLENBQUNrRyxTQUFTMkIsS0FBSzdIO1lBQ3hCO1FBQ0o7UUFDQSxPQUFPdUs7SUFDWDtJQUVBOztLQUVDLEdBQ0QsT0FBTzNJLEtBQUtnRyxNQUFNLEVBQUVDLEdBQUcsRUFBRTdILE1BQU0sRUFBRTtRQUM3QixJQUFJQSxVQUFVLE1BQU07WUFDaEJBLFNBQVM7UUFDYjtRQUNBLE1BQU1OLFdBQVcsSUFBSSxJQUFJLENBQUNrSSxRQUFRQyxLQUFLN0g7UUFDdkMsT0FBT047SUFDWDtBQUNKO0FBQ0EsU0FBUzhLO0lBQ0wsT0FBTzdDO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLE1BQU04QyxpQkFBaUJEO0FBQzlCLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanM/MjY2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UsIFR5cGVkIH0gZnJvbSBcIi4uL2FiaS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaXNBZGRyZXNzYWJsZSwgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgY29weVJlcXVlc3QsIExvZyB9IGZyb20gXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaXNDYWxsRXhjZXB0aW9uLCBpc0hleFN0cmluZywgcmVzb2x2ZVByb3BlcnRpZXMsIGlzRXJyb3IsIG1ha2VFcnJvciwgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3RFdmVudFBheWxvYWQsIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlLCBFdmVudExvZywgVW5kZWNvZGVkRXZlbnRMb2cgfSBmcm9tIFwiLi93cmFwcGVycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGNhbkNhbGwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5Fc3RpbWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblNlbmQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNhblJlc29sdmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xuICAgICNmaWx0ZXI7XG4gICAgZnJhZ21lbnQ7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmcmFnbWVudCB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoZnJhZ21lbnQuaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzcyh2LCByZXNvbHZlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZpbHRlcjtcbiAgICB9XG59XG4vLyBBID0gQXJndW1lbnRzIHBhc3NlZCBpbiBhcyBhIHR1cGxlXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcbi8vIEQgPSBUaGUgdHlwZSB0aGUgZGVmYXVsdCBjYWxsIHdpbGwgcmV0dXJuIChpLmUuIFIgZm9yIHZpZXcvcHVyZSxcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XG5mdW5jdGlvbiBnZXRSdW5uZXIodmFsdWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlPdmVycmlkZXMoYXJnLCBhbGxvd2VkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBvdmVycmlkZXMgcGFzc2VkIGluIGFyZSBhIHZhbGlkIG92ZXJyaWRlcyBvYmplY3RcbiAgICBjb25zdCBfb3ZlcnJpZGVzID0gVHlwZWQuZGVyZWZlcmVuY2UoYXJnLCBcIm92ZXJyaWRlc1wiKTtcbiAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKF9vdmVycmlkZXMpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgb3ZlcnJpZGVzIHBhcmFtZXRlclwiLCBcIm92ZXJyaWRlc1wiLCBhcmcpO1xuICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSAod2UnbGwgZGVlcC1pZnkgYW55dGhpbmcgbmVlZGVkIGR1cmluZyBub3JtYWxpemluZylcbiAgICBjb25zdCBvdmVycmlkZXMgPSBjb3B5UmVxdWVzdChfb3ZlcnJpZGVzKTtcbiAgICBhc3NlcnRBcmd1bWVudChvdmVycmlkZXMudG8gPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcInRvXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIHRvXCIsIFwib3ZlcnJpZGVzLnRvXCIsIG92ZXJyaWRlcy50byk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLmRhdGEgPT0gbnVsbCB8fCAoYWxsb3dlZCB8fCBbXSkuaW5kZXhPZihcImRhdGFcIikgPj0gMCwgXCJjYW5ub3Qgb3ZlcnJpZGUgZGF0YVwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIG92ZXJyaWRlcy5kYXRhKTtcbiAgICAvLyBSZXNvbHZlIGFueSBmcm9tXG4gICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgIG92ZXJyaWRlcy5mcm9tID0gb3ZlcnJpZGVzLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvdmVycmlkZXM7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBcmdzKF9ydW5uZXIsIGlucHV0cywgYXJncykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlc2NlbmQgaW50byBhcmdzIGFuZCByZXNvbHZlIGFueSBhZGRyZXNzZXNcbiAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoX3J1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICBjb25zdCByZXNvbHZlciA9IGNhblJlc29sdmUocnVubmVyKSA/IHJ1bm5lciA6IG51bGw7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyYW0ud2Fsa0FzeW5jKGFyZ3NbaW5kZXhdLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzKHZhbHVlLCByZXNvbHZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEZhbGxiYWNrKGNvbnRyYWN0KSB7XG4gICAgY29uc3QgcG9wdWxhdGVUcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IHR4ID0gKGF3YWl0IGNvcHlPdmVycmlkZXMob3ZlcnJpZGVzLCBbXCJkYXRhXCJdKSk7XG4gICAgICAgIHR4LnRvID0gYXdhaXQgY29udHJhY3QuZ2V0QWRkcmVzcygpO1xuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgdHguZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gY29udHJhY3QuaW50ZXJmYWNlO1xuICAgICAgICBjb25zdCBub1ZhbHVlID0gKGdldEJpZ0ludCgodHgudmFsdWUgfHwgQk5fMCksIFwib3ZlcnJpZGVzLnZhbHVlXCIpID09PSBCTl8wKTtcbiAgICAgICAgY29uc3Qgbm9EYXRhID0gKCh0eC5kYXRhIHx8IFwiMHhcIikgPT09IFwiMHhcIik7XG4gICAgICAgIGlmIChpZmFjZS5mYWxsYmFjayAmJiAhaWZhY2UuZmFsbGJhY2sucGF5YWJsZSAmJiBpZmFjZS5yZWNlaXZlICYmICFub0RhdGEgJiYgIW5vVmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZSBvciBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzXCIsIG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgcGF5YWJsZSBjb250cmFjdHMgdG8gc2V0IG5vbi16ZXJvIHZhbHVlXG4gICAgICAgIGNvbnN0IHBheWFibGUgPSBpZmFjZS5yZWNlaXZlIHx8IChpZmFjZS5mYWxsYmFjayAmJiBpZmFjZS5mYWxsYmFjay5wYXlhYmxlKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocGF5YWJsZSB8fCBub1ZhbHVlLCBcImNhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZhbGxiYWNrXCIsIFwib3ZlcnJpZGVzLnZhbHVlXCIsIHR4LnZhbHVlKTtcbiAgICAgICAgLy8gT25seSBhbGxvdyBmYWxsYmFjayBjb250cmFjdHMgdG8gc2V0IG5vbi1lbXB0eSBkYXRhXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImNhbGxcIik7XG4gICAgICAgIGFzc2VydChjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250cmFjdC5pbnRlcmZhY2UubWFrZUVycm9yKGVycm9yLmRhdGEsIHR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZW5kID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkVzdGltYXRlKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgZ2FzIGVzdGltYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIiB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5lc3RpbWF0ZUdhcyhhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKG92ZXJyaWRlcykpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKG92ZXJyaWRlcykgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZChvdmVycmlkZXMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGxcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkTWV0aG9kKGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyhvdmVycmlkZXMuZnJvbSwgZ2V0UmVzb2x2ZXIoY29udHJhY3QucnVubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlcm5hbCBlcnJvcjogZnJhZ21lbnQgaW5wdXRzIGRvZXNuJ3QgbWF0Y2ggYXJndW1lbnRzOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBhd2FpdCByZXNvbHZlQXJncyhjb250cmFjdC5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgYXNzZXJ0KGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgLy8gbWVhbmluZ2Z1bCBlcnJvclxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsUmVzdWx0ID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIG5hbWU6IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbk5hbWUoa2V5KSxcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCwgX2tleToga2V5LFxuICAgICAgICBnZXRGcmFnbWVudCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGwsIHN0YXRpY0NhbGxSZXN1bHQsXG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb24oa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRXZlbnQoY29udHJhY3QsIGtleSkge1xuICAgIGNvbnN0IGdldEZyYWdtZW50ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5LCBhcmdzKTtcbiAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFRvcGljRmlsdGVyKGNvbnRyYWN0LCBnZXRGcmFnbWVudCguLi5hcmdzKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnROYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnRcbiAgICB9KTtcbiAgICAvLyBPbmx5IHdvcmtzIG9uIG5vbi1hbWJpZ3VvdXMga2V5cyAocmVmaW5lZCBmcmFnbWVudCBpcyBhbHdheXMgbm9uLWFtYmlndW91cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0aG9kLCBcImZyYWdtZW50XCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXkpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG4vLyBUaGUgY29tYmluYXRpb24gb2YgVHlwZVNjcnlwZSwgUHJpdmF0ZSBGaWVsZHMgYW5kIFByb3hpZXMgbWFrZXNcbi8vIHRoZSB3b3JsZCBnbyBib29tOyBzbyB3ZSBoaWRlIHZhcmlhYmxlcyB3aXRoIHNvbWUgdHJpY2tlcnkga2VlcGluZ1xuLy8gYSBzeW1ib2wgYXR0YWNoZWQgdG8gZWFjaCBCYXNlQ29udHJhY3Qgd2hpY2ggaXRzIHN1Yi1jbGFzcyAoZXZlblxuLy8gdmlhIGEgUHJveHkpIGNhbiByZWFjaCBhbmQgdXNlIHRvIGxvb2sgdXAgaXRzIGludGVybmFsIHZhbHVlcy5cbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNJbnRlcm5hbF9jb250cmFjdFwiKTtcbmNvbnN0IGludGVybmFsVmFsdWVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHNldEludGVybmFsKGNvbnRyYWN0LCB2YWx1ZXMpIHtcbiAgICBpbnRlcm5hbFZhbHVlcy5zZXQoY29udHJhY3RbaW50ZXJuYWxdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWwoY29udHJhY3QpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZXMuZ2V0KGNvbnRyYWN0W2ludGVybmFsXSk7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAoXCJnZXRUb3BpY0ZpbHRlclwiIGluIHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mICh2YWx1ZS5nZXRUb3BpY0ZpbHRlcikgPT09IFwiZnVuY3Rpb25cIikgJiYgdmFsdWUuZnJhZ21lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpIHtcbiAgICBsZXQgdG9waWNzO1xuICAgIGxldCBmcmFnbWVudCA9IG51bGw7XG4gICAgLy8gQ29udmVydCBuYW1lZCBldmVudHMgdG8gdG9waWNIYXNoIGFuZCBnZXQgdGhlIGZyYWdtZW50IGZvclxuICAgIC8vIGV2ZW50cyB3aGljaCBuZWVkIGRlY29uc3RydWN0aW5nLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBjb25zdCB0b3BpY0hhc2hpZnkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobmFtZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJ1bmtub3duIGZyYWdtZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFycmF5IG9mIFRvcGljcyBhbmQgTmFtZXM7IGUuZy4gYFsgXCIweDEyMzQuLi44OWFiXCIsIFwiVHJhbnNmZXIoYWRkcmVzcylcIiBdYFxuICAgICAgICB0b3BpY3MgPSBldmVudC5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubWFwKHRvcGljSGFzaGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9waWNIYXNoaWZ5KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIHRvcGljcyA9IFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGV2ZW50LCAzMikpIHtcbiAgICAgICAgICAgIC8vIFRvcGljIEhhc2hcbiAgICAgICAgICAgIHRvcGljcyA9IFtldmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOYW1lIG9yIFNpZ25hdHVyZTsgZS5nLiBgXCJUcmFuc2ZlclwiLCBgXCJUcmFuc2ZlcihhZGRyZXNzKVwiYFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmZXJyZWQoZXZlbnQpKSB7XG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxuICAgICAgICBmcmFnbWVudCA9IGV2ZW50LmZyYWdtZW50O1xuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVua25vd24gZXZlbnQgbmFtZVwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljcyBhbmQgc29ydCBUb3BpY1NldHNcbiAgICB0b3BpY3MgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20obmV3IFNldCh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSkudmFsdWVzKCkpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHRhZyA9IHRvcGljcy5tYXAoKHQpID0+IHtcbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4geyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhc1N1Yihjb250cmFjdCwgZXZlbnQpIHtcbiAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICByZXR1cm4gc3Vicy5nZXQoKGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSkudGFnKSB8fCBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3ViKGNvbnRyYWN0LCBvcGVyYXRpb24sIGV2ZW50KSB7XG4gICAgLy8gTWFrZSBzdXJlIG91ciBydW5uZXIgY2FuIGFjdHVhbGx5IHN1YnNjcmliZSB0byBldmVudHNcbiAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKGNvbnRyYWN0LnJ1bm5lcik7XG4gICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHN1YnNjcmliaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCk7XG4gICAgY29uc3QgeyBhZGRyLCBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgbGV0IHN1YiA9IHN1YnMuZ2V0KHRhZyk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IChhZGRyID8gYWRkciA6IGNvbnRyYWN0KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmcmFnbWVudCBpcyBudWxsLCB3ZSBkbyBub3QgZGVjb25zdHJ1Y3QgdGhlIGFyZ3MgdG8gZW1pdFxuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZm91bmRGcmFnbWVudCA9IGZvdW5kRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGZyYWdtZW50ID8gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcykgOiBbXTtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RFdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgX2ZvdW5kRnJhZ21lbnQsIGxvZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0KGNvbnRyYWN0LCBldmVudCwgW10sIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQpO1xuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICBzdWIgPSB7IHRhZywgbGlzdGVuZXJzOiBbXSwgc3RhcnQsIHN0b3AgfTtcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cbi8vIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nIChub3RlIHRoaXMgY2Fubm90IHRocm93IGFuZCBqdXN0IGFkZHMgdGhlXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmFzeW5jIGZ1bmN0aW9uIF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICAgICAgICBpZiAocGF5bG9hZEZ1bmMpIHtcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgIH0pO1xuICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgPiAwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcbiAgICBsYXN0RW1pdCA9IHJlc3VsdFByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG59XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRhcmdldCB0byBjb25uZWN0IHRvLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIGFuIGFkZHJlc3MsIEVOUyBuYW1lIG9yIGFueSBbW0FkZHJlc3NhYmxlXV0sIHN1Y2ggYXNcbiAgICAgKiAgYW5vdGhlciBjb250cmFjdC4gVG8gZ2V0IHRoZSByZXNvdmxlZCBhZGRyZXNzLCB1c2UgdGhlIGBgZ2V0QWRkcmVzc2BgXG4gICAgICogIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHJ1bm5lci4gVGhpcyBpcyBnZW5lcmFsbHkgYSBbW1Byb3ZpZGVyXV0gb3IgYVxuICAgICAqICBbW1NpZ25lcl1dLCB3aGljaCBkaWN0YXRlcyB3aGF0IG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSAqKkNvbnRyYWN0KiogY29ubmVjdGVkIHRvIGEgW1tQcm92aWRlcl1dIG1heVxuICAgICAqICBvbmx5IGV4ZWN1dGUgcmVhZC1vbmx5IG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIEV2ZW50cyBhdmFpbGFibGUgb24gdGhpcyBjb250cmFjdC5cbiAgICAgKi9cbiAgICBmaWx0ZXJzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBbaW50ZXJuYWxdO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmFsbGJhY2sgb3IgcmVjZWl2ZSBmdW5jdGlvbiBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgY29udHJhY3QgY29ubmVjdGVkIHRvICUldGFyZ2V0JSUgd2l0aCB0aGUgJSVhYmklJSBhbmRcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gYSAlJXJ1bm5lciUlIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBiZWhhbGZcbiAgICAgKiAgb2YuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhYmksIHJ1bm5lciwgX2RlcGxveVR4KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCBpc0FkZHJlc3NhYmxlKHRhcmdldCksIFwiaW52YWxpZCB2YWx1ZSBmb3IgQ29udHJhY3QgdGFyZ2V0XCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IEludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyB0YXJnZXQsIHJ1bm5lciwgaW50ZXJmYWNlOiBpZmFjZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiB7fSB9KTtcbiAgICAgICAgbGV0IGFkZHJQcm9taXNlO1xuICAgICAgICBsZXQgYWRkciA9IG51bGw7XG4gICAgICAgIGxldCBkZXBsb3lUeCA9IG51bGw7XG4gICAgICAgIGlmIChfZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIocnVubmVyKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGUgcHJvdmlkZXIgY2FuIGJlIG51bGw7IG1ha2UgYSBjdXN0b20gZHVtbXkgcHJvdmlkZXIgdGhhdCB3aWxsIHRocm93IGFcbiAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgICAgIGRlcGxveVR4ID0gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIF9kZXBsb3lUeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRhcmdldCBhcyB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGFkZHIgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZ2V0UnVubmVyKHJ1bm5lciwgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblJlc29sdmUocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IG5hbWUgcmVzb2x1dGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkclByb21pc2UgPSByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWFrZUVycm9yKFwiYW4gRU5TIG5hbWUgdXNlZCBmb3IgYSBjb250cmFjdCB0YXJnZXQgbXVzdCBiZSBjb3JyZWN0bHkgY29uZmlndXJlZFwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3VyIHByaXZhdGUgdmFsdWVzXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFcnJvcihlcnJvciwgXCJJTlZBTElEX0FSR1VNRU5UXCIpIHx8IGVycm9yLmFyZ3VtZW50ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSB8fCB0aGlzLmludGVyZmFjZS5oYXNFdmVudChTdHJpbmcocHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGZpbHRlcnMgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0RnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuaW50ZXJmYWNlLmhhc0Z1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBDb250cmFjdCBpbnN0YW5jZSB3aXRoIHRoZSBzYW1lIHRhcmdldCBhbmQgQUJJLCBidXRcbiAgICAgKiAgYSBkaWZmZXJlbnQgJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0aGlzLnRhcmdldCwgdGhpcy5pbnRlcmZhY2UsIHJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBBQkkgYW5kIHJ1bm5lciwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUldGFyZ2V0JSUuXG4gICAgICovXG4gICAgYXR0YWNoKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VDb250cmFjdCh0YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHJlc29sdmVkIGFkZHJlc3Mgb2YgdGhpcyBDb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gYXdhaXQgZ2V0SW50ZXJuYWwodGhpcykuYWRkclByb21pc2U7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkZXBsb3llZCBieXRlY29kZSBvciBudWxsIGlmIG5vIGJ5dGVjb2RlIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlcGxveWVkQ29kZSgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRDb2RlXCIgfSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwcm92aWRlci5nZXRDb2RlKGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoaXMgQ29udHJhY3Qgb25jZSB0aGUgYnl0ZWNvZGUgaGFzIGJlZW4gZGVwbG95ZWQsIG9yXG4gICAgICogIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBkZXBsb3llZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yRGVwbG95bWVudCgpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZGVwbG95ZW1lbnQgdHJhbnNhY3Rpb247IGp1c3QgdXNlIHRoYXQgKHRocm93cyBpZiBkZXBsb3llbWVudCBmYWlscylcbiAgICAgICAgY29uc3QgZGVwbG95VHggPSB0aGlzLmRlcGxveW1lbnRUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAoZGVwbG95VHgpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveVR4LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLmdldERlcGxveWVkQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIHN1YnNjcmliZSB0byBhIHByb3ZpZGVyIGV2ZW50XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIGV2ZW50IG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLypcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXG4gICAgLy8gICAgICAgIHY2IHJlbGVhc2VcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XG5cbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxuICAgICAqICBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xuICAgICAgICBpZiAoZnJvbUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhZGRyLCBhZGRyUHJvbWlzZSB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MsIGZyb21CbG9jaywgdG9CbG9jayB9O1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBoYXZlIGEgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlGaWx0ZXJcIiB9KTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcikpLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmRGcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGZvdW5kRnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kRnJhZ21lbnQgPSB0aGlzLmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5kZWNvZGVkRXZlbnRMb2cobG9nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWRkIGFuIGV2ZW50ICUlbGlzdGVuZXIlJSBmb3IgdGhlICUlZXZlbnQlJS5cbiAgICAgKi9cbiAgICBhc3luYyBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25cIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIHN1Yi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUsIGJ1dCByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICogIGFmdGVyIGl0IGlzIGZpcmVkIG9uY2UuXG4gICAgICovXG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgZ2V0U3ViKHRoaXMsIFwib25jZVwiLCBldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbWl0IGFuICUlZXZlbnQlJSBjYWxsaW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCAlJWFyZ3MlJS5cbiAgICAgKlxuICAgICAqICBSZXNvbHZlcyB0byBgYHRydWVgYCBpZiBhbnkgbGlzdGVuZXJzIHdlcmUgY2FsbGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGVtaXQodGhpcywgZXZlbnQsIGFyZ3MsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgb2YgJSVldmVudCUlIG9yIHRoZSB0b3RhbCBudW1iZXJcbiAgICAgKiAgb2YgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgbGlzdGVuZXJzIHN1YnNjcmliZWQgdG8gJSVldmVudCUlIG9yIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiAgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBsaXN0ZW5lcnMgfSBvZiBzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGxpc3RlbmVycy5tYXAoKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIHRoZSAlJWxpc3RlbmVyJSUgZnJvbSB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlXG4gICAgICogIGFsbCBsaXN0ZW5lcnMgaWYgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgZm9yICUlZXZlbnQlJSBvciByZW1vdmUgYWxsIGxpc3RlbmVycyBpZlxuICAgICAqICB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5zdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3VicyB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFnLCBzdG9wIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICBzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvbl0uXG4gICAgICovXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGlhcyBmb3IgW29mZl0uXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IENsYXNzIGZvciB0aGUgJSVhYmklJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRDbGFzcyhhYmkpIHtcbiAgICAgICAgY2xhc3MgQ3VzdG9tQ29udHJhY3QgZXh0ZW5kcyBCYXNlQ29udHJhY3Qge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoYWRkcmVzcywgcnVubmVyID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKGFkZHJlc3MsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ3VzdG9tQ29udHJhY3Q7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEJhc2VDb250cmFjdCB3aXRoIGEgc3BlY2lmaWVkIEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0YXJnZXQsIGFiaSwgcnVubmVyKSB7XG4gICAgICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyB0aGlzKHRhcmdldCwgYWJpLCBydW5uZXIpO1xuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX0NvbnRyYWN0QmFzZSgpIHtcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xufVxuLyoqXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBfQ29udHJhY3RCYXNlKCkge1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QuanMubWFwIl0sIm5hbWVzIjpbIkludGVyZmFjZSIsIlR5cGVkIiwiaXNBZGRyZXNzYWJsZSIsInJlc29sdmVBZGRyZXNzIiwiY29weVJlcXVlc3QiLCJMb2ciLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiaXNDYWxsRXhjZXB0aW9uIiwiaXNIZXhTdHJpbmciLCJyZXNvbHZlUHJvcGVydGllcyIsImlzRXJyb3IiLCJtYWtlRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwiRXZlbnRMb2ciLCJVbmRlY29kZWRFdmVudExvZyIsIkJOXzAiLCJCaWdJbnQiLCJjYW5DYWxsIiwidmFsdWUiLCJjYWxsIiwiY2FuRXN0aW1hdGUiLCJlc3RpbWF0ZUdhcyIsImNhblJlc29sdmUiLCJyZXNvbHZlTmFtZSIsImNhblNlbmQiLCJzZW5kVHJhbnNhY3Rpb24iLCJnZXRSZXNvbHZlciIsInByb3ZpZGVyIiwidW5kZWZpbmVkIiwiUHJlcGFyZWRUb3BpY0ZpbHRlciIsImZpbHRlciIsImNvbnN0cnVjdG9yIiwiY29udHJhY3QiLCJmcmFnbWVudCIsImFyZ3MiLCJpbnB1dHMiLCJsZW5ndGgiLCJFcnJvciIsInJ1bm5lciIsImdldFJ1bm5lciIsInJlc29sdmVyIiwicmVzb2x2ZWRBcmdzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInBhcmFtIiwiaW5kZXgiLCJhcmciLCJ3YWxrQXN5bmMiLCJ0eXBlIiwiQXJyYXkiLCJpc0FycmF5IiwidiIsImludGVyZmFjZSIsImVuY29kZUZpbHRlclRvcGljcyIsImdldFRvcGljRmlsdGVyIiwiZmVhdHVyZSIsImdldFByb3ZpZGVyIiwiY29weU92ZXJyaWRlcyIsImFsbG93ZWQiLCJfb3ZlcnJpZGVzIiwiZGVyZWZlcmVuY2UiLCJvdmVycmlkZXMiLCJ0byIsImluZGV4T2YiLCJkYXRhIiwiZnJvbSIsInJlc29sdmVBcmdzIiwiX3J1bm5lciIsImJ1aWxkV3JhcHBlZEZhbGxiYWNrIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsInR4IiwiZ2V0QWRkcmVzcyIsImlmYWNlIiwibm9WYWx1ZSIsIm5vRGF0YSIsImZhbGxiYWNrIiwicGF5YWJsZSIsInJlY2VpdmUiLCJzdGF0aWNDYWxsIiwib3BlcmF0aW9uIiwiZXJyb3IiLCJzZW5kIiwibWV0aG9kIiwiX2NvbnRyYWN0IiwiYnVpbGRXcmFwcGVkTWV0aG9kIiwia2V5IiwiZ2V0RnJhZ21lbnQiLCJnZXRGdW5jdGlvbiIsImluZm8iLCJwb3AiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJyZXN1bHQiLCJzdGF0aWNDYWxsUmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJjb25zdGFudCIsIm5hbWUiLCJnZXRGdW5jdGlvbk5hbWUiLCJfa2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYnVpbGRXcmFwcGVkRXZlbnQiLCJnZXRFdmVudCIsImdldEV2ZW50TmFtZSIsImludGVybmFsIiwiU3ltYm9sIiwiZm9yIiwiaW50ZXJuYWxWYWx1ZXMiLCJXZWFrTWFwIiwic2V0SW50ZXJuYWwiLCJ2YWx1ZXMiLCJzZXQiLCJnZXRJbnRlcm5hbCIsImlzRGVmZXJyZWQiLCJnZXRTdWJJbmZvIiwiZXZlbnQiLCJ0b3BpY3MiLCJ0b3BpY0hhc2hpZnkiLCJ0b3BpY0hhc2giLCJlIiwidCIsIml0ZW1zIiwiU2V0IiwidG9Mb3dlckNhc2UiLCJzb3J0IiwidGFnIiwiam9pbiIsImhhc1N1YiIsInN1YnMiLCJnZXRTdWIiLCJhZGRyIiwic3ViIiwiYWRkcmVzcyIsImxpc3RlbmVyIiwibG9nIiwiZm91bmRGcmFnbWVudCIsIl9mb3VuZEZyYWdtZW50IiwiZGVjb2RlRXZlbnRMb2ciLCJlbWl0Iiwic3RhcnRpbmciLCJzdGFydCIsInB1c2giLCJvbiIsInN0b3AiLCJzdGFydGVkIiwib2ZmIiwibGlzdGVuZXJzIiwibGFzdEVtaXQiLCJyZXNvbHZlIiwiX2VtaXQiLCJwYXlsb2FkRnVuYyIsImNvdW50Iiwib25jZSIsInBhc3NBcmdzIiwiZGVsZXRlIiwicmVzdWx0UHJvbWlzZSIsInBhc3NQcm9wZXJ0aWVzIiwiQmFzZUNvbnRyYWN0IiwidGFyZ2V0IiwiYWJpIiwiX2RlcGxveVR4IiwiYWRkclByb21pc2UiLCJkZXBsb3lUeCIsIk1hcCIsInRoZW4iLCJmaWx0ZXJzIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiYXJndW1lbnQiLCJoYXMiLCJoYXNFdmVudCIsIlN0cmluZyIsImhhc0Z1bmN0aW9uIiwiY29ubmVjdCIsImF0dGFjaCIsImdldERlcGxveWVkQ29kZSIsImNvZGUiLCJnZXRDb2RlIiwid2FpdEZvckRlcGxveW1lbnQiLCJkZXBsb3ltZW50VHJhbnNhY3Rpb24iLCJ3YWl0IiwicmVqZWN0IiwiY2hlY2tDb2RlIiwiZm9ybWF0IiwiZnVuYyIsInF1ZXJ5VHJhbnNhY3Rpb24iLCJoYXNoIiwicXVlcnlGaWx0ZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiZ2V0TG9ncyIsImxpc3RlbmVyQ291bnQiLCJ0b3RhbCIsImNvbmNhdCIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJidWlsZENsYXNzIiwiQ3VzdG9tQ29udHJhY3QiLCJfQ29udHJhY3RCYXNlIiwiQ29udHJhY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/factory.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/factory.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _contract_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contract.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n\n\n\n\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */ class ContractFactory {\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */ constructor(abi, bytecode, runner){\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_0__.Interface.from(abi);\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(bytecode));\n        } else {\n            if (typeof bytecode === \"object\") {\n                bytecode = bytecode.object;\n            }\n            if (!bytecode.startsWith(\"0x\")) {\n                bytecode = \"0x\" + bytecode;\n            }\n            bytecode = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(bytecode));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            bytecode,\n            interface: iface,\n            runner: runner || null\n        });\n    }\n    attach(target) {\n        return new _contract_js__WEBPACK_IMPORTED_MODULE_3__.BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */ async getDeployTransaction(...args) {\n        let overrides = {};\n        const fragment = this.interface.deploy;\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await (0,_contract_js__WEBPACK_IMPORTED_MODULE_3__.copyOverrides)(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n        const resolvedArgs = await (0,_contract_js__WEBPACK_IMPORTED_MODULE_3__.resolveArgs)(this.runner, fragment.inputs, args);\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            this.bytecode,\n            this.interface.encodeDeploy(resolvedArgs)\n        ]);\n        return Object.assign({}, overrides, {\n            data\n        });\n    }\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resovle to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */ async deploy(...args) {\n        const tx = await this.getDeployTransaction(...args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.runner && typeof this.runner.sendTransaction === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_5__.getCreateAddress)(sentTx);\n        return new _contract_js__WEBPACK_IMPORTED_MODULE_3__.BaseContract(address, this.interface, this.runner, sentTx);\n    }\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */ connect(runner) {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */ static fromSolidity(output, runner) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n        if (typeof output === \"string\") {\n            output = JSON.parse(output);\n        }\n        const abi = output.abi;\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        } else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n        return new this(abi, bytecode, runner);\n    }\n} //# sourceMappingURL=factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvZmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRDO0FBQ1c7QUFDaUQ7QUFDL0I7QUFDekUsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0Qzs7Q0FFQyxHQUNNLE1BQU1XO0lBYVQ7Ozs7OztLQU1DLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLENBQUU7UUFDL0IsTUFBTUMsUUFBUWhCLG9EQUFTQSxDQUFDaUIsSUFBSSxDQUFDSjtRQUM3Qix3RUFBd0U7UUFDeEUsSUFBSUMsb0JBQW9CSSxZQUFZO1lBQ2hDSixXQUFXVCx3REFBT0EsQ0FBQ0QseURBQVFBLENBQUNVO1FBQ2hDLE9BQ0s7WUFDRCxJQUFJLE9BQVFBLGFBQWMsVUFBVTtnQkFDaENBLFdBQVdBLFNBQVNLLE1BQU07WUFDOUI7WUFDQSxJQUFJLENBQUNMLFNBQVNNLFVBQVUsQ0FBQyxPQUFPO2dCQUM1Qk4sV0FBVyxPQUFPQTtZQUN0QjtZQUNBQSxXQUFXVCx3REFBT0EsQ0FBQ0QseURBQVFBLENBQUNVO1FBQ2hDO1FBQ0FYLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJXO1lBQVVPLFdBQVdMO1lBQU9ELFFBQVNBLFVBQVU7UUFDbkQ7SUFDSjtJQUNBTyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLElBQUlmLHNEQUFZQSxDQUFDZSxRQUFRLElBQUksQ0FBQ0YsU0FBUyxFQUFFLElBQUksQ0FBQ04sTUFBTTtJQUMvRDtJQUNBOzs7S0FHQyxHQUNELE1BQU1TLHFCQUFxQixHQUFHQyxJQUFJLEVBQUU7UUFDaEMsSUFBSUMsWUFBWSxDQUFDO1FBQ2pCLE1BQU1DLFdBQVcsSUFBSSxDQUFDTixTQUFTLENBQUNPLE1BQU07UUFDdEMsSUFBSUQsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUcsTUFBTUwsS0FBS0ssTUFBTSxFQUFFO1lBQzVDSixZQUFZLE1BQU1qQiwyREFBYUEsQ0FBQ2dCLEtBQUtNLEdBQUc7UUFDNUM7UUFDQSxJQUFJSixTQUFTRSxNQUFNLENBQUNDLE1BQU0sS0FBS0wsS0FBS0ssTUFBTSxFQUFFO1lBQ3hDLE1BQU0sSUFBSUUsTUFBTTtRQUNwQjtRQUNBLE1BQU1DLGVBQWUsTUFBTXZCLHlEQUFXQSxDQUFDLElBQUksQ0FBQ0ssTUFBTSxFQUFFWSxTQUFTRSxNQUFNLEVBQUVKO1FBQ3JFLE1BQU1TLE9BQU9oQyx1REFBTUEsQ0FBQztZQUFDLElBQUksQ0FBQ1ksUUFBUTtZQUFFLElBQUksQ0FBQ08sU0FBUyxDQUFDYyxZQUFZLENBQUNGO1NBQWM7UUFDOUUsT0FBT0csT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1gsV0FBVztZQUFFUTtRQUFLO0lBQy9DO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE1BQU1OLE9BQU8sR0FBR0gsSUFBSSxFQUFFO1FBQ2xCLE1BQU1hLEtBQUssTUFBTSxJQUFJLENBQUNkLG9CQUFvQixJQUFJQztRQUM5Q25CLHVEQUFNQSxDQUFDLElBQUksQ0FBQ1MsTUFBTSxJQUFJLE9BQVEsSUFBSSxDQUFDQSxNQUFNLENBQUN3QixlQUFlLEtBQU0sWUFBWSx3REFBd0QseUJBQXlCO1lBQ3hKQyxXQUFXO1FBQ2Y7UUFDQSxNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDMUIsTUFBTSxDQUFDd0IsZUFBZSxDQUFDRDtRQUNqRCxNQUFNSSxVQUFVekMsbUVBQWdCQSxDQUFDd0M7UUFDakMsT0FBTyxJQUFJakMsc0RBQVlBLENBQUNrQyxTQUFTLElBQUksQ0FBQ3JCLFNBQVMsRUFBRSxJQUFJLENBQUNOLE1BQU0sRUFBRTBCO0lBQ2xFO0lBQ0E7OztLQUdDLEdBQ0RFLFFBQVE1QixNQUFNLEVBQUU7UUFDWixPQUFPLElBQUlKLGdCQUFnQixJQUFJLENBQUNVLFNBQVMsRUFBRSxJQUFJLENBQUNQLFFBQVEsRUFBRUM7SUFDOUQ7SUFDQTs7S0FFQyxHQUNELE9BQU82QixhQUFhQyxNQUFNLEVBQUU5QixNQUFNLEVBQUU7UUFDaENSLCtEQUFjQSxDQUFDc0MsVUFBVSxNQUFNLHVCQUF1QixVQUFVQTtRQUNoRSxJQUFJLE9BQVFBLFdBQVksVUFBVTtZQUM5QkEsU0FBU0MsS0FBS0MsS0FBSyxDQUFDRjtRQUN4QjtRQUNBLE1BQU1oQyxNQUFNZ0MsT0FBT2hDLEdBQUc7UUFDdEIsSUFBSUMsV0FBVztRQUNmLElBQUkrQixPQUFPL0IsUUFBUSxFQUFFO1lBQ2pCQSxXQUFXK0IsT0FBTy9CLFFBQVE7UUFDOUIsT0FDSyxJQUFJK0IsT0FBT0csR0FBRyxJQUFJSCxPQUFPRyxHQUFHLENBQUNsQyxRQUFRLEVBQUU7WUFDeENBLFdBQVcrQixPQUFPRyxHQUFHLENBQUNsQyxRQUFRO1FBQ2xDO1FBQ0EsT0FBTyxJQUFJLElBQUksQ0FBQ0QsS0FBS0MsVUFBVUM7SUFDbkM7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L2ZhY3RvcnkuanM/M2YzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRlcmZhY2UgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRDcmVhdGVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXMsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhc2VDb250cmFjdCwgY29weU92ZXJyaWRlcywgcmVzb2x2ZUFyZ3MgfSBmcm9tIFwiLi9jb250cmFjdC5qc1wiO1xuLy8gQSA9IEFyZ3VtZW50cyB0byB0aGUgY29uc3RydWN0b3Jcbi8vIEkgPSBJbnRlcmZhY2Ugb2YgZGVwbG95ZWQgY29udHJhY3RzXG4vKipcbiAqICBBICoqQ29udHJhY3RGYWN0b3J5KiogaXMgdXNlZCB0byBkZXBsb3kgYSBDb250cmFjdCB0byB0aGUgYmxvY2tjaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgZGVwbG95bWVudCBieXRlY29kZS4gT2Z0ZW4gY2FsbGVkIHRoZSBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBieXRlY29kZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0UnVubmVyIHRvIGRlcGxveSB0aGUgQ29udHJhY3QgYXMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoICUlYWJpJSUgYW5kICUlYnl0ZWNvZGUlJSxcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gJSVydW5uZXIlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVieXRlY29kZSUlIG1heSBiZSB0aGUgYGBieXRlY29kZWBgIHByb3BlcnR5IHdpdGhpbiB0aGVcbiAgICAgKiAgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWJpLCBieXRlY29kZSwgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gSW50ZXJmYWNlLmZyb20oYWJpKTtcbiAgICAgICAgLy8gRGVyZWZlcmVuY2UgU29saWRpdHkgYnl0ZWNvZGUgb2JqZWN0cyBhbmQgYWxsb3cgYSBtaXNzaW5nIGAweGAtcHJlZml4XG4gICAgICAgIGlmIChieXRlY29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gaGV4bGlmeShnZXRCeXRlcyhieXRlY29kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYnl0ZWNvZGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgYnl0ZWNvZGUgPSBieXRlY29kZS5vYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJ5dGVjb2RlLnN0YXJ0c1dpdGgoXCIweFwiKSkge1xuICAgICAgICAgICAgICAgIGJ5dGVjb2RlID0gXCIweFwiICsgYnl0ZWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlY29kZSA9IGhleGxpZnkoZ2V0Qnl0ZXMoYnl0ZWNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlLCBpbnRlcmZhY2U6IGlmYWNlLCBydW5uZXI6IChydW5uZXIgfHwgbnVsbClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRvIGRlcGxveSB0aGUgY29udHJhY3QsIHBhc3NpbmcgJSVhcmdzJSVcbiAgICAgKiAgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZGVwbG95O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCBjb3B5T3ZlcnJpZGVzKGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgcmVzb2x2ZUFyZ3ModGhpcy5ydW5uZXIsIGZyYWdtZW50LmlucHV0cywgYXJncyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb25jYXQoW3RoaXMuYnl0ZWNvZGUsIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShyZXNvbHZlZEFyZ3MpXSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBDb250cmFjdCBkZXBsb3llZCBieSBwYXNzaW5nICUlYXJncyUlIGludG8gdGhlXG4gICAgICogIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXNvdmxlIHRvIHRoZSBDb250cmFjdCBiZWZvcmUgaXQgaGFzIGJlZW4gZGVwbG95ZWQgdG8gdGhlXG4gICAgICogIG5ldHdvcmssIHNvIHRoZSBbW0Jhc2VDb250cmFjdC13YWl0Rm9yRGVwbG95bWVudF1dIHNob3VsZCBiZSB1c2VkIGJlZm9yZVxuICAgICAqICBzZW5kaW5nIGFueSB0cmFuc2FjdGlvbnMgdG8gaXQuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICBhc3NlcnQodGhpcy5ydW5uZXIgJiYgdHlwZW9mICh0aGlzLnJ1bm5lci5zZW5kVHJhbnNhY3Rpb24pID09PSBcImZ1bmN0aW9uXCIsIFwiZmFjdG9yeSBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlbnRUeCA9IGF3YWl0IHRoaXMucnVubmVyLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRDcmVhdGVBZGRyZXNzKHNlbnRUeCk7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZUNvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnJ1bm5lciwgc2VudFR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBieXRlY29kZSxcbiAgICAgKiAgYnV0IGNvbm5lY3RlZCB0byAlJXJ1bm5lciUlLlxuICAgICAqL1xuICAgIGNvbm5lY3QocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RGYWN0b3J5KHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQ29udHJhY3RGYWN0b3J5KiogZnJvbSB0aGUgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Tb2xpZGl0eShvdXRwdXQsIHJ1bm5lcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChvdXRwdXQgIT0gbnVsbCwgXCJiYWQgY29tcGlsZXIgb3V0cHV0XCIsIFwib3V0cHV0XCIsIG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgKG91dHB1dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYmkgPSBvdXRwdXQuYWJpO1xuICAgICAgICBsZXQgYnl0ZWNvZGUgPSBcIlwiO1xuICAgICAgICBpZiAob3V0cHV0LmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IG91dHB1dC5ieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdXRwdXQuZXZtICYmIG91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gb3V0cHV0LmV2bS5ieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYWJpLCBieXRlY29kZSwgcnVubmVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6WyJJbnRlcmZhY2UiLCJnZXRDcmVhdGVBZGRyZXNzIiwiY29uY2F0IiwiZGVmaW5lUHJvcGVydGllcyIsImdldEJ5dGVzIiwiaGV4bGlmeSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiQmFzZUNvbnRyYWN0IiwiY29weU92ZXJyaWRlcyIsInJlc29sdmVBcmdzIiwiQ29udHJhY3RGYWN0b3J5IiwiY29uc3RydWN0b3IiLCJhYmkiLCJieXRlY29kZSIsInJ1bm5lciIsImlmYWNlIiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJvYmplY3QiLCJzdGFydHNXaXRoIiwiaW50ZXJmYWNlIiwiYXR0YWNoIiwidGFyZ2V0IiwiZ2V0RGVwbG95VHJhbnNhY3Rpb24iLCJhcmdzIiwib3ZlcnJpZGVzIiwiZnJhZ21lbnQiLCJkZXBsb3kiLCJpbnB1dHMiLCJsZW5ndGgiLCJwb3AiLCJFcnJvciIsInJlc29sdmVkQXJncyIsImRhdGEiLCJlbmNvZGVEZXBsb3kiLCJPYmplY3QiLCJhc3NpZ24iLCJ0eCIsInNlbmRUcmFuc2FjdGlvbiIsIm9wZXJhdGlvbiIsInNlbnRUeCIsImFkZHJlc3MiLCJjb25uZWN0IiwiZnJvbVNvbGlkaXR5Iiwib3V0cHV0IiwiSlNPTiIsInBhcnNlIiwiZXZtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            error\n        });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms) {\n        const receipt = await super.wait(confirms);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.EventPayload {\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            log\n        });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n} //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsc0VBQXNFO0FBQ3RFLHlCQUF5QjtBQUMrRDtBQUNyQjtBQUNuRTs7Q0FFQyxHQUNNLE1BQU1LLGlCQUFpQkwsdURBQUdBO0lBYTdCOztLQUVDLEdBQ0RNLFlBQVlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDOUIsS0FBSyxDQUFDRixLQUFLQSxJQUFJRyxRQUFRO1FBQ3ZCLE1BQU1DLE9BQU9ILE1BQU1JLGNBQWMsQ0FBQ0gsVUFBVUYsSUFBSU0sSUFBSSxFQUFFTixJQUFJTyxNQUFNO1FBQ2hFWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1lBQVVNLFdBQVdQO1FBQU07SUFDOUQ7SUFDQTs7S0FFQyxHQUNELElBQUlRLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQUU7SUFDN0M7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFBRSxPQUFPLElBQUksQ0FBQ1QsUUFBUSxDQUFDVSxNQUFNO0lBQUk7QUFDMUQ7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLDBCQUEwQnBCLHVEQUFHQTtJQUt0Qzs7S0FFQyxHQUNETSxZQUFZQyxHQUFHLEVBQUVjLEtBQUssQ0FBRTtRQUNwQixLQUFLLENBQUNkLEtBQUtBLElBQUlHLFFBQVE7UUFDdkJQLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWtCO1FBQU07SUFDbkM7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG1DQUFtQ3JCLHNFQUFrQkE7SUFDOUQsQ0FBQ08sS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREYsWUFBWUUsS0FBSyxFQUFFRSxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBQ1YsSUFBSSxDQUFDLENBQUNGLEtBQUssR0FBR0E7SUFDbEI7SUFDQTs7O0tBR0MsR0FDRCxJQUFJZ0IsT0FBTztRQUNQLE9BQU8sS0FBSyxDQUFDQSxLQUFLQyxHQUFHLENBQUMsQ0FBQ2xCO1lBQ25CLE1BQU1FLFdBQVdGLElBQUlPLE1BQU0sQ0FBQ1ksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDbEIsS0FBSyxDQUFDbUIsUUFBUSxDQUFDcEIsSUFBSU8sTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUMzRSxJQUFJTCxVQUFVO2dCQUNWLElBQUk7b0JBQ0EsT0FBTyxJQUFJSixTQUFTRSxLQUFLLElBQUksQ0FBQyxDQUFDQyxLQUFLLEVBQUVDO2dCQUMxQyxFQUNBLE9BQU9ZLE9BQU87b0JBQ1YsT0FBTyxJQUFJRCxrQkFBa0JiLEtBQUtjO2dCQUN0QztZQUNKO1lBQ0EsT0FBT2Q7UUFDWDtJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNcUIsb0NBQW9DMUIsdUVBQW1CQTtJQUNoRSxDQUFDTSxLQUFLLENBQUM7SUFDUDs7S0FFQyxHQUNERixZQUFZRSxLQUFLLEVBQUVFLFFBQVEsRUFBRWEsRUFBRSxDQUFFO1FBQzdCLEtBQUssQ0FBQ0EsSUFBSWI7UUFDVixJQUFJLENBQUMsQ0FBQ0YsS0FBSyxHQUFHQTtJQUNsQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTXFCLEtBQUtDLFFBQVEsRUFBRTtRQUNqQixNQUFNQyxVQUFVLE1BQU0sS0FBSyxDQUFDRixLQUFLQztRQUNqQyxJQUFJQyxXQUFXLE1BQU07WUFDakIsT0FBTztRQUNYO1FBQ0EsT0FBTyxJQUFJVCwyQkFBMkIsSUFBSSxDQUFDLENBQUNkLEtBQUssRUFBRSxJQUFJLENBQUNFLFFBQVEsRUFBRXFCO0lBQ3RFO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQyxvQ0FBb0M1Qix5REFBWUE7SUFLekQ7O0tBRUMsR0FDREUsWUFBWTJCLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUU1QixHQUFHLENBQUU7UUFDekMsS0FBSyxDQUFDMEIsVUFBVUMsVUFBVUM7UUFDMUJoQyxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVJO1FBQUk7SUFDakM7SUFDQTs7S0FFQyxHQUNELE1BQU02QixXQUFXO1FBQ2IsT0FBTyxNQUFNLElBQUksQ0FBQzdCLEdBQUcsQ0FBQzZCLFFBQVE7SUFDbEM7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGlCQUFpQjtRQUNuQixPQUFPLE1BQU0sSUFBSSxDQUFDOUIsR0FBRyxDQUFDOEIsY0FBYztJQUN4QztJQUNBOztLQUVDLEdBQ0QsTUFBTUMsd0JBQXdCO1FBQzFCLE9BQU8sTUFBTSxJQUFJLENBQUMvQixHQUFHLENBQUMrQixxQkFBcUI7SUFDL0M7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLDZCQUE2QlA7SUFDdEM7O0tBRUMsR0FDRDFCLFlBQVkyQixRQUFRLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFMUIsUUFBUSxFQUFFK0IsSUFBSSxDQUFFO1FBQ3BELEtBQUssQ0FBQ1AsVUFBVUMsVUFBVUMsUUFBUSxJQUFJOUIsU0FBU21DLE1BQU1QLFNBQVNsQixTQUFTLEVBQUVOO1FBQ3pFLE1BQU1FLE9BQU9zQixTQUFTbEIsU0FBUyxDQUFDSCxjQUFjLENBQUNILFVBQVUsSUFBSSxDQUFDRixHQUFHLENBQUNNLElBQUksRUFBRSxJQUFJLENBQUNOLEdBQUcsQ0FBQ08sTUFBTTtRQUN2RlgsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFUTtZQUFNRjtRQUFTO0lBQzVDO0lBQ0E7O0tBRUMsR0FDRCxJQUFJTyxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNQLFFBQVEsQ0FBQ1EsSUFBSTtJQUM3QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUMsaUJBQWlCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDVCxRQUFRLENBQUNVLE1BQU07SUFDL0I7QUFDSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L3dyYXBwZXJzLmpzP2UwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpOyB9XG59XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxuICAgICAqL1xuICAgIGVycm9yO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGxvZ3MgZm9yIGFueSBbW0xvZ11dIHdoaWNoIGhhcyBhIG1hdGNoaW5nIGV2ZW50IGluIHRoZVxuICAgICAqICBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2c7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UqKiB3aWxsIHJldHVybiBhXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoY29uZmlybXMpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2lmYWNlLCB0aGlzLnByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2cgd2l0aCBubyBtYXRjaGluZyBldmVudHMuXG4gICAgICovXG4gICAgbG9nO1xuICAgIC8qKlxuICAgICAqICBAX2V2ZW50OlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBsb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RFdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgaXMga25vd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEV2ZW50UGF5bG9hZCBleHRlbmRzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBmcmFnbWVudCwgX2xvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgdGhpcy5sb2cuZGF0YSwgdGhpcy5sb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwcGVycy5qcy5tYXAiXSwibmFtZXMiOlsiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJFdmVudExvZyIsImNvbnN0cnVjdG9yIiwibG9nIiwiaWZhY2UiLCJmcmFnbWVudCIsInByb3ZpZGVyIiwiYXJncyIsImRlY29kZUV2ZW50TG9nIiwiZGF0YSIsInRvcGljcyIsImludGVyZmFjZSIsImV2ZW50TmFtZSIsIm5hbWUiLCJldmVudFNpZ25hdHVyZSIsImZvcm1hdCIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiZXJyb3IiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsInR4IiwibG9ncyIsIm1hcCIsImxlbmd0aCIsImdldEV2ZW50IiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwid2FpdCIsImNvbmZpcm1zIiwicmVjZWlwdCIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsImNvbnRyYWN0IiwibGlzdGVuZXIiLCJmaWx0ZXIiLCJnZXRCbG9jayIsImdldFRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJfbG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ \n\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBQytDO0FBQ007QUFDdEQsSUFBSUcsU0FBUztBQUNiLE1BQU1DLGFBQWEsU0FBVUMsSUFBSTtJQUM3QixPQUFPTCw4REFBVUEsQ0FBQ0s7QUFDdEI7QUFDQSxJQUFJQyxjQUFjRjtBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBU0csVUFBVUMsS0FBSztJQUMzQixNQUFNSCxPQUFPSix5REFBUUEsQ0FBQ08sT0FBTztJQUM3QixPQUFPTix3REFBT0EsQ0FBQ0ksWUFBWUQ7QUFDL0I7QUFDQUUsVUFBVUUsQ0FBQyxHQUFHTDtBQUNkRyxVQUFVRyxJQUFJLEdBQUc7SUFBY1AsU0FBUztBQUFNO0FBQzlDSSxVQUFVSSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUMvQixJQUFJVCxRQUFRO1FBQ1IsTUFBTSxJQUFJVSxVQUFVO0lBQ3hCO0lBQ0FQLGNBQWNNO0FBQ2xCO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1IsWUFDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9jcnlwdG8va2VjY2FrLmpzPzEzODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQ3J5cHRvZ3JhcGhpYyBoYXNoaW5nIGZ1bmN0aW9uc1xuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnMgW2Fib3V0LWNyeXB0by1oYXNoaW5nXVxuICovXG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhM1wiO1xuaW1wb3J0IHsgZ2V0Qnl0ZXMsIGhleGxpZnkgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9rZWNjYWsyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBrZWNjYWtfMjU2KGRhdGEpO1xufTtcbmxldCBfX2tlY2NhazI1NiA9IF9rZWNjYWsyNTY7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIEtFQ0NBSzI1NiBoYXNoIG9mICUlZGF0YSUlLlxuICpcbiAqICBUaGUgJSVkYXRhJSUgKiptdXN0KiogYmUgYSBkYXRhIHJlcHJlc2VudGF0aW9uLCB0byBjb21wdXRlIHRoZVxuICogIGhhc2ggb2YgVVRGLTggZGF0YSB1c2UgdGhlIFtbaWRdXSBmdW5jdGlvbi5cbiAqXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICogIEBleGFtcGxlOlxuICogICAga2VjY2FrMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBrZWNjYWsyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFN0cmluZ3MgYXJlIGFzc3VtZWQgdG8gYmUgRGF0YUhleFN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqICAgIC8vIHRocm93LiBUbyBoYXNoIFVURi04IGRhdGEsIHNlZSB0aGUgbm90ZSBhYm92ZS5cbiAqICAgIGtlY2NhazI1NihcIkhlbGxvIFdvcmxkXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiBoZXhsaWZ5KF9fa2VjY2FrMjU2KGRhdGEpKTtcbn1cbmtlY2NhazI1Ni5fID0gX2tlY2NhazI1NjtcbmtlY2NhazI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xua2VjY2FrMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZWNjYWsyNTYgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2tlY2NhazI1NiA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShrZWNjYWsyNTYpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2VjY2FrLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWtfMjU2IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibG9ja2VkIiwiX2tlY2NhazI1NiIsImRhdGEiLCJfX2tlY2NhazI1NiIsImtlY2NhazI1NiIsIl9kYXRhIiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJUeXBlRXJyb3IiLCJPYmplY3QiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signature: () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */ class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */ get r() {\n        return this.#r;\n    }\n    set r(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */ get s() {\n        return this.#s;\n    }\n    set s(_value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(_value);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */ get v() {\n        return this.#v;\n    }\n    set v(value) {\n        const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(value, \"value\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get networkV() {\n        return this.#networkV;\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */ get yParity() {\n        return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */ get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */ get compactSerialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.yParityAndS\n        ]);\n    }\n    /**\n     *  The serialized representation.\n     */ get serialized() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            this.r,\n            this.s,\n            this.yParity ? \"0x1c\" : \"0x1b\"\n        ]);\n    }\n    /**\n     *  @private\n     */ constructor(guard, r, s, v){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */ clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */ toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: networkV != null ? networkV.toString() : null,\n            r: this.r,\n            s: this.s,\n            v: this.v\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */ static getChainId(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if (bv == BN_27 || bv == BN_28) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */ static getChainIdV(chainId, v) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */ static getNormalizedV(v) {\n        const bv = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */ static from(sig) {\n        function assertError(check, message) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, _constants_index_js__WEBPACK_IMPORTED_MODULE_3__.ZeroHash, 27);\n        }\n        if (typeof sig === \"string\") {\n            const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = s[0] & 0x80 ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = function(s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        }(sig.s, sig.yParityAndS);\n        assertError(((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = function(_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_v);\n                return {\n                    networkV: v >= BN_35 ? v : undefined,\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return {\n                    v: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n                };\n            }\n            if (yParity != null) {\n                switch((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(yParity, \"sig.yParity\")){\n                    case 0:\n                        return {\n                            v: 27\n                        };\n                    case 1:\n                        return {\n                            v: 28\n                        };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n} //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNvSDtBQUNySyxZQUFZO0FBQ1osTUFBTVksT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsUUFBUUgsT0FBTztBQUNyQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLFFBQVFMLE9BQU87QUFDckIsTUFBTU0sU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLFVBQVVDLEtBQUs7SUFDcEIsT0FBT1osNkRBQVlBLENBQUNGLDBEQUFTQSxDQUFDYyxRQUFRO0FBQzFDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQztJQUNULENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLENBQUMsQ0FBQztJQUNILENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7OztLQUtDLEdBQ0QsSUFBSUgsSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFBRTtJQUMxQixJQUFJQSxFQUFFRixLQUFLLEVBQUU7UUFDVFgsK0RBQWNBLENBQUNSLDJEQUFVQSxDQUFDbUIsV0FBVyxJQUFJLGFBQWEsU0FBU0E7UUFDL0QsSUFBSSxDQUFDLENBQUNFLENBQUMsR0FBR2pCLHdEQUFPQSxDQUFDZTtJQUN0QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUcsSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFBRTtJQUMxQixJQUFJQSxFQUFFRyxNQUFNLEVBQUU7UUFDVmpCLCtEQUFjQSxDQUFDUiwyREFBVUEsQ0FBQ3lCLFlBQVksSUFBSSxhQUFhLFNBQVNBO1FBQ2hFLE1BQU1OLFFBQVFmLHdEQUFPQSxDQUFDcUI7UUFDdEJqQiwrREFBY0EsQ0FBQ2tCLFNBQVNQLE1BQU1RLFNBQVMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxt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Q3RDLE1BQU0yQixTQUFTLElBQUlyQyxVQUFVSCxRQUFRSSxHQUFHQyxHQUFHQztRQUMzQyxJQUFJQyxVQUFVO1lBQ1ZpQyxPQUFPLENBQUNqQyxRQUFRLEdBQUdBO1FBQ3ZCO1FBQ0Esb0VBQW9FO1FBQ3BFd0IsWUFBWUQsSUFBSWpCLE9BQU8sSUFBSSxRQUFRM0IsMERBQVNBLENBQUM0QyxJQUFJakIsT0FBTyxFQUFFLG1CQUFtQjJCLE9BQU8zQixPQUFPLEVBQUU7UUFDN0ZrQixZQUFZRCxJQUFJaEIsV0FBVyxJQUFJLFFBQVFnQixJQUFJaEIsV0FBVyxLQUFLMEIsT0FBTzFCLFdBQVcsRUFBRTtRQUMvRSxPQUFPMEI7SUFDWDtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25hdHVyZS5qcz9jMDE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFplcm9IYXNoIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXROdW1iZXIsIGhleGxpZnksIHRvQmVBcnJheSwgaXNIZXhTdHJpbmcsIHplcm9QYWRWYWx1ZSwgYXNzZXJ0QXJndW1lbnQsIGFzc2VydFByaXZhdGUgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8vIENvbnN0YW50c1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgQk5fMjcgPSBCaWdJbnQoMjcpO1xuY29uc3QgQk5fMjggPSBCaWdJbnQoMjgpO1xuY29uc3QgQk5fMzUgPSBCaWdJbnQoMzUpO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0b1VpbnQyNTYodmFsdWUpIHtcbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHRvQmVBcnJheSh2YWx1ZSksIDMyKTtcbn1cbi8qKlxuICogIEEgU2lnbmF0dXJlICBAVE9ET1xuICpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86U2lnbmluZ1xuICovXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAjcjtcbiAgICAjcztcbiAgICAjdjtcbiAgICAjbmV0d29ya1Y7XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHJgYCB2YWx1ZSBmb3IgYSBzaWduYXV0cmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyByZXByZXNlbnRzIHRoZSBgYHhgYCBjb29yZGluYXRlIG9mIGEgXCJyZWZlcmVuY2VcIiBvclxuICAgICAqICBjaGFsbGVuZ2UgcG9pbnQsIGZyb20gd2hpY2ggdGhlIGBgeWBgIGNhbiBiZSBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBnZXQgcigpIHsgcmV0dXJuIHRoaXMuI3I7IH1cbiAgICBzZXQgcih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKHZhbHVlKSA9PT0gMzIsIFwiaW52YWxpZCByXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB0aGlzLiNyID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGBzYGAgdmFsdWUgZm9yIGEgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBzKCkgeyByZXR1cm4gdGhpcy4jczsgfVxuICAgIHNldCBzKF92YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKF92YWx1ZSkgPT09IDMyLCBcImludmFsaWQgc1wiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShfdmFsdWUpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMCwgMykpIDwgOCwgXCJub24tY2Fub25pY2FsIHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxuICAgICAqICB2YWx1ZXMgdG8gdXNlLlxuICAgICAqXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcbiAgICAgKiAgcHVycG9zZXMuXG4gICAgICovXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XG4gICAgc2V0IHYodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdiA9IGdldE51bWJlcih2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodiA9PT0gMjcgfHwgdiA9PT0gMjgsIFwiaW52YWxpZCB2XCIsIFwidlwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEVJUC0xNTUgYGB2YGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMuIEZvciBub24tbGVnYWN5XG4gICAgICogIHRyYW5zYWN0aW9ucywgdGhpcyB2YWx1ZSBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbmV0d29ya1YoKSB7IHJldHVybiB0aGlzLiNuZXR3b3JrVjsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgZm9yIEVJUC0xNTUgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBsZWdhY3lDaGFpbklkKCkge1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5nZXRDaGFpbklkKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgeVBhcml0eWBgIGZvciB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogIFNlZSBgYHZgYCBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyB0aGlzIHZhbHVlIGlzIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52ID09PSAyNykgPyAwIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgYHlQYXJpdHlgYFxuICAgICAqICBhbmQgYGBzYGAgY29tcGFjdGVkIGludG8gYSBzaW5nbGUgYGBieXRlczMyYGAuXG4gICAgICovXG4gICAgZ2V0IHlQYXJpdHlBbmRTKCkge1xuICAgICAgICAvLyBUaGUgRUlQLTIwOTggY29tcGFjdCByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCB5UGFyaXR5QW5kUyA9IGdldEJ5dGVzKHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnlQYXJpdHkpIHtcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoeVBhcml0eUFuZFMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IGNvbXBhY3RTZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMueVBhcml0eUFuZFNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gY29uY2F0KFt0aGlzLnIsIHRoaXMucywgKHRoaXMueVBhcml0eSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJTaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMuI3IgPSByO1xuICAgICAgICB0aGlzLiNzID0gcztcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgICAgIHRoaXMuI25ldHdvcmtWID0gbnVsbDtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gYFNpZ25hdHVyZSB7IHI6IFwiJHt0aGlzLnJ9XCIsIHM6IFwiJHt0aGlzLnN9XCIsIHlQYXJpdHk6ICR7dGhpcy55UGFyaXR5fSwgbmV0d29ya1Y6ICR7dGhpcy5uZXR3b3JrVn0gfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IGlkZW50aWNhbCBbW1NpZ25hdHVyZV1dLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCB0aGlzLnIsIHRoaXMucywgdGhpcy52KTtcbiAgICAgICAgaWYgKHRoaXMubmV0d29ya1YpIHtcbiAgICAgICAgICAgIGNsb25lLiNuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBgSlNPTi5zdHJpbmdpZnlgYC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtWID0gdGhpcy5uZXR3b3JrVjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcInNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgbmV0d29ya1Y6ICgobmV0d29ya1YgIT0gbnVsbCkgPyBuZXR3b3JrVi50b1N0cmluZygpIDogbnVsbCksXG4gICAgICAgICAgICByOiB0aGlzLnIsIHM6IHRoaXMucywgdjogdGhpcy52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgY2hhaW4gSUQgZnJvbSB0aGUgYGB2YGAgaW4gYSBsZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWQoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDaGFpbklkKHYpIHtcbiAgICAgICAgY29uc3QgYnYgPSBnZXRCaWdJbnQodiwgXCJ2XCIpO1xuICAgICAgICAvLyBUaGUgdiBpcyBub3QgYW4gRUlQLTE1NSB2LCBzbyBpdCBpcyB0aGUgdW5zcGVjaWZpZWQgY2hhaW4gSURcbiAgICAgICAgaWYgKChidiA9PSBCTl8yNykgfHwgKGJ2ID09IEJOXzI4KSkge1xuICAgICAgICAgICAgcmV0dXJuIEJOXzA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFkIHZhbHVlIGZvciBhbiBFSVAtMTU1IHZcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCBFSVAtMTU1IHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBMZWdhY3kgdHJhbnNhY3Rpb25zIHdoaWNoIHVzZSBbW2xpbmstZWlwLTE1NV1dIGhpamFjayB0aGUgYGB2YGBcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xuICAgICAgICByZXR1cm4gKGdldEJpZ0ludChjaGFpbklkKSAqIEJOXzIpICsgQmlnSW50KDM1ICsgdiAtIDI3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIG5vcm1hbGl6ZWQgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIGZyb20gYSBgYHlQYXJpcnR5YGAsXG4gICAgICogIGEgbGVnYWN5IHRyYW5zYWN0aW9uIGBgdmBgIG9yIGEgbGVnYWN5IFtbbGluay1laXAtMTU1XV0gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgLy8gVGhlIHZhbHVlcyAwIGFuZCAxIGltcGx5IHYgaXMgYWN0dWFsbHkgeVBhcml0eVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigwKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBub24tRUlQLTE1NTkgdHJhbnNhY3Rpb24gKGkuZS4gMjcgb3IgMjgpXG4gICAgICogICAgU2lnbmF0dXJlLmdldE5vcm1hbGl6ZWRWKDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIExlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9uIChpLmUuID49IDM1KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig0NilcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBJbnZhbGlkIHZhbHVlcyB0aHJvd1xuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVig1KVxuICAgICAqICAgIC8vX2Vycm9yOlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXROb3JtYWxpemVkVih2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gZ2V0QmlnSW50KHYpO1xuICAgICAgICBpZiAoYnYgPT09IEJOXzAgfHwgYnYgPT09IEJOXzI3KSB7XG4gICAgICAgICAgICByZXR1cm4gMjc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ2ID09PSBCTl8xIHx8IGJ2ID09PSBCTl8yOCkge1xuICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxuICAgICAgICByZXR1cm4gKGJ2ICYgQk5fMSkgPyAyNyA6IDI4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1NpZ25hdHVyZV1dLlxuICAgICAqXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxuICAgICAqICB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBcInNpZ25hdHVyZVwiLCBzaWcpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHNpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIFplcm9IYXNoLCBaZXJvSGFzaCwgMjcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHNpZykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoc2lnLCBcInNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gKHNbMF0gJiAweDgwKSA/IDI4IDogMjc7XG4gICAgICAgICAgICAgICAgc1swXSAmPSAweDdmO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKHNbMF0gJiAweDgwKSA9PT0gMCwgXCJub24tY2Fub25pY2FsIHNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVihieXRlc1s2NF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgaGV4bGlmeShzKSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJpbnZhbGlkIHJhdyBzaWduYXR1cmUgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWcuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgclxuICAgICAgICBjb25zdCBfciA9IHNpZy5yO1xuICAgICAgICBhc3NlcnRFcnJvcihfciAhPSBudWxsLCBcIm1pc3NpbmcgclwiKTtcbiAgICAgICAgY29uc3QgciA9IHRvVWludDI1Nihfcik7XG4gICAgICAgIC8vIEdldCBzOyBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh3ZSBjaGVjayBjb25zaXN0ZW5jeSBiZWxvdylcbiAgICAgICAgY29uc3QgcyA9IChmdW5jdGlvbiAocywgeVBhcml0eUFuZFMpIHtcbiAgICAgICAgICAgIGlmIChzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VaW50MjU2KHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyh5UGFyaXR5QW5kUyk7XG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRFcnJvcihmYWxzZSwgXCJtaXNzaW5nIHNcIik7XG4gICAgICAgIH0pKHNpZy5zLCBzaWcueVBhcml0eUFuZFMpO1xuICAgICAgICBhc3NlcnRFcnJvcigoZ2V0Qnl0ZXMocylbMF0gJiAweDgwKSA9PSAwLCBcIm5vbi1jYW5vbmljYWwgc1wiKTtcbiAgICAgICAgLy8gR2V0IHY7IGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHdlIGNoZWNrIGNvbnNpc3RlbmN5IGJlbG93KVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtWLCB2IH0gPSAoZnVuY3Rpb24gKF92LCB5UGFyaXR5QW5kUywgeVBhcml0eSkge1xuICAgICAgICAgICAgaWYgKF92ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0QmlnSW50KF92KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihpc0hleFN0cmluZyh5UGFyaXR5QW5kUywgMzIpLCBcImludmFsaWQgeVBhcml0eUFuZFNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdjogKChnZXRCeXRlcyh5UGFyaXR5QW5kUylbMF0gJiAweDgwKSA/IDI4IDogMjcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeVBhcml0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChnZXROdW1iZXIoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHsgdjogMjggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCBnZXROdW1iZXIoc2lnLnlQYXJpdHksIFwic2lnLnlQYXJpdHlcIikgPT09IHJlc3VsdC55UGFyaXR5LCBcInlQYXJpdHkgbWlzbWF0Y2hcIik7XG4gICAgICAgIGFzc2VydEVycm9yKHNpZy55UGFyaXR5QW5kUyA9PSBudWxsIHx8IHNpZy55UGFyaXR5QW5kUyA9PT0gcmVzdWx0LnlQYXJpdHlBbmRTLCBcInlQYXJpdHlBbmRTIG1pc21hdGNoXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiWmVyb0hhc2giLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydFByaXZhdGUiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJfZ3VhcmQiLCJ0b1VpbnQyNTYiLCJ2YWx1ZSIsIlNpZ25hdHVyZSIsInIiLCJzIiwidiIsIm5ldHdvcmtWIiwiX3ZhbHVlIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJsZWdhY3lDaGFpbklkIiwiZ2V0Q2hhaW5JZCIsInlQYXJpdHkiLCJ5UGFyaXR5QW5kUyIsImNvbXBhY3RTZXJpYWxpemVkIiwic2VyaWFsaXplZCIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJTeW1ib2wiLCJmb3IiLCJjbG9uZSIsInRvSlNPTiIsIl90eXBlIiwidG9TdHJpbmciLCJidiIsImdldENoYWluSWRWIiwiY2hhaW5JZCIsImdldE5vcm1hbGl6ZWRWIiwiZnJvbSIsInNpZyIsImFzc2VydEVycm9yIiwiY2hlY2siLCJtZXNzYWdlIiwiYnl0ZXMiLCJsZW5ndGgiLCJzbGljZSIsIl9yIiwiX3YiLCJ1bmRlZmluZWQiLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/signing-key.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _signature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signature.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */ \n\n\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */ class SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */ constructor(privateKey){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */ get privateKey() {\n        return this.#privateKey;\n    }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */ get publicKey() {\n        return SigningKey.computePublicKey(this.#privateKey);\n    }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */ get compressedPublicKey() {\n        return SigningKey.computePublicKey(this.#privateKey, true);\n    }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */ sign(digest) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.sign((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.r, 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.toBeHex)(sig.s, 32),\n            v: sig.recovery ? 0x1c : 0x1b\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */ computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(this.#privateKey), (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */ static computePublicKey(key, compressed) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */ static recoverPublicKey(digest, signature) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = _signature_js__WEBPACK_IMPORTED_MODULE_3__.Signature.from(signature);\n        let secpSig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromCompact((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n            sig.r,\n            sig.s\n        ])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(digest));\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(pubKey != null, \"invalid signautre for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */ static addPoints(p0, p1, compressed) {\n        const pub0 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n} //# sourceMappingURL=signing-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDbUQ7QUFDNkQ7QUFDdEU7QUFDM0M7OztDQUdDLEdBQ00sTUFBTVM7SUFDVCxDQUFDQyxVQUFVLENBQUM7SUFDWjs7S0FFQyxHQUNEQyxZQUFZRCxVQUFVLENBQUU7UUFDcEJILCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ1EsZ0JBQWdCLElBQUksdUJBQXVCLGNBQWM7UUFDbkYsSUFBSSxDQUFDLENBQUNBLFVBQVUsR0FBR0wsd0RBQU9BLENBQUNLO0lBQy9CO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsVUFBVTtJQUFFO0lBQzVDOzs7OztLQUtDLEdBQ0QsSUFBSUUsWUFBWTtRQUFFLE9BQU9ILFdBQVdJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDSCxVQUFVO0lBQUc7SUFDeEU7Ozs7OztLQU1DLEdBQ0QsSUFBSUksc0JBQXNCO1FBQUUsT0FBT0wsV0FBV0ksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUNILFVBQVUsRUFBRTtJQUFPO0lBQ3hGOztLQUVDLEdBQ0RLLEtBQUtDLE1BQU0sRUFBRTtRQUNUVCwrREFBY0EsQ0FBQ0wsMkRBQVVBLENBQUNjLFlBQVksSUFBSSx5QkFBeUIsVUFBVUE7UUFDN0UsTUFBTUMsTUFBTWpCLDhEQUFTQSxDQUFDZSxJQUFJLENBQUNYLDZEQUFZQSxDQUFDWSxTQUFTWiw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sVUFBVSxHQUFHO1lBQzdFUSxNQUFNO1FBQ1Y7UUFDQSxPQUFPVixvREFBU0EsQ0FBQ1csSUFBSSxDQUFDO1lBQ2xCQyxHQUFHZCx3REFBT0EsQ0FBQ1csSUFBSUcsQ0FBQyxFQUFFO1lBQ2xCQyxHQUFHZix3REFBT0EsQ0FBQ1csSUFBSUksQ0FBQyxFQUFFO1lBQ2xCQyxHQUFJTCxJQUFJTSxRQUFRLEdBQUcsT0FBTztRQUM5QjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEQyxvQkFBb0JDLEtBQUssRUFBRTtRQUN2QixNQUFNQyxTQUFTakIsV0FBV0ksZ0JBQWdCLENBQUNZO1FBQzNDLE9BQU9wQix3REFBT0EsQ0FBQ0wsOERBQVNBLENBQUMyQixlQUFlLENBQUN2Qiw2REFBWUEsQ0FBQyxJQUFJLENBQUMsQ0FBQ00sVUFBVSxHQUFHUCx5REFBUUEsQ0FBQ3VCLFNBQVM7SUFDL0Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBd0JDLEdBQ0QsT0FBT2IsaUJBQWlCZSxHQUFHLEVBQUVDLFVBQVUsRUFBRTtRQUNyQyxJQUFJQyxRQUFRM0IseURBQVFBLENBQUN5QixLQUFLO1FBQzFCLGNBQWM7UUFDZCxJQUFJRSxNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNTCxTQUFTMUIsOERBQVNBLENBQUNnQyxZQUFZLENBQUNGLE9BQU8sQ0FBQyxDQUFDRDtZQUMvQyxPQUFPeEIsd0RBQU9BLENBQUNxQjtRQUNuQjtRQUNBLHdEQUF3RDtRQUN4RCxJQUFJSSxNQUFNQyxNQUFNLEtBQUssSUFBSTtZQUNyQixNQUFNRSxNQUFNLElBQUlDLFdBQVc7WUFDM0JELEdBQUcsQ0FBQyxFQUFFLEdBQUc7WUFDVEEsSUFBSUUsR0FBRyxDQUFDTCxPQUFPO1lBQ2ZBLFFBQVFHO1FBQ1o7UUFDQSxNQUFNRyxRQUFRcEMsOERBQVNBLENBQUNxQyxlQUFlLENBQUNDLE9BQU8sQ0FBQ1I7UUFDaEQsT0FBT3pCLHdEQUFPQSxDQUFDK0IsTUFBTUcsVUFBVSxDQUFDVjtJQUNwQztJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztLQWlCQyxHQUNELE9BQU9XLGlCQUFpQnhCLE1BQU0sRUFBRXlCLFNBQVMsRUFBRTtRQUN2Q2xDLCtEQUFjQSxDQUFDTCwyREFBVUEsQ0FBQ2MsWUFBWSxJQUFJLHlCQUF5QixVQUFVQTtRQUM3RSxNQUFNQyxNQUFNVCxvREFBU0EsQ0FBQ1csSUFBSSxDQUFDc0I7UUFDM0IsSUFBSUMsVUFBVTFDLDhEQUFTQSxDQUFDUSxTQUFTLENBQUNtQyxXQUFXLENBQUN2Qyw2REFBWUEsQ0FBQ0gsdURBQU1BLENBQUM7WUFBQ2dCLElBQUlHLENBQUM7WUFBRUgsSUFBSUksQ0FBQztTQUFDO1FBQ2hGcUIsVUFBVUEsUUFBUUUsY0FBYyxDQUFDM0IsSUFBSTRCLE9BQU87UUFDNUMsTUFBTW5CLFNBQVNnQixRQUFRRixnQkFBZ0IsQ0FBQ3BDLDZEQUFZQSxDQUFDWTtRQUNyRFQsK0RBQWNBLENBQUNtQixVQUFVLE1BQU0sZ0NBQWdDLGFBQWFlO1FBQzVFLE9BQU8sT0FBT2YsT0FBT29CLEtBQUssQ0FBQztJQUMvQjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE9BQU9DLFVBQVVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFcEIsVUFBVSxFQUFFO1FBQ2pDLE1BQU1xQixPQUFPbEQsOERBQVNBLENBQUNxQyxlQUFlLENBQUNDLE9BQU8sQ0FBQzdCLFdBQVdJLGdCQUFnQixDQUFDbUMsSUFBSUcsU0FBUyxDQUFDO1FBQ3pGLE1BQU1DLE9BQU9wRCw4REFBU0EsQ0FBQ3FDLGVBQWUsQ0FBQ0MsT0FBTyxDQUFDN0IsV0FBV0ksZ0JBQWdCLENBQUNvQyxJQUFJRSxTQUFTLENBQUM7UUFDekYsT0FBTyxPQUFPRCxLQUFLRyxHQUFHLENBQUNELE1BQU1OLEtBQUssQ0FBQyxDQUFDLENBQUNqQjtJQUN6QztBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL3NpZ25pbmcta2V5LmpzPzQ4ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWRkIGRldGFpbHMgYWJvdXQgc2lnbmluZyBoZXJlLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86U2lnbmluZyAgW2Fib3V0LXNpZ25pbmddXG4gKi9cbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY29uY2F0LCBkYXRhTGVuZ3RoLCBnZXRCeXRlcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5LCB0b0JlSGV4LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4vc2lnbmF0dXJlLmpzXCI7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgICNwcml2YXRlS2V5O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqU2lnbmluZ0tleSoqIGZvciAlJXByaXZhdGVLZXklJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGRhdGFMZW5ndGgocHJpdmF0ZUtleSkgPT09IDMyLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jcHJpdmF0ZUtleSA9IGhleGxpZnkocHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkuXG4gICAgICovXG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7IHJldHVybiB0aGlzLiNwcml2YXRlS2V5OyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgMHgwNGBgIGFuZCBiZSAxMzJcbiAgICAgKiBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAxMzAgaGV4YWRlY2ltYWwgbmliYmxlcykuXG4gICAgICovXG4gICAgZ2V0IHB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5KTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBhbHdheXMgYmVnaW4gd2l0aCBlaXRoZXIgdGhlIHByZWZpeCBgYDB4MDJgYCBvciBgYDB4MDNgYFxuICAgICAqICBhbmQgYmUgNjggY2hhcmFjdGVycyBsb25nICh0aGUgYGAweGBgIHByZWZpeCBhbmQgMzMgaGV4YWRlY2ltYWxcbiAgICAgKiAgbmliYmxlcylcbiAgICAgKi9cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHsgcmV0dXJuIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleSh0aGlzLiNwcml2YXRlS2V5LCB0cnVlKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkICUlZGlnZXN0JSUuXG4gICAgICovXG4gICAgc2lnbihkaWdlc3QpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZGF0YUxlbmd0aChkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24oZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCksIGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6IHRvQmVIZXgoc2lnLnIsIDMyKSxcbiAgICAgICAgICAgIHM6IHRvQmVIZXgoc2lnLnMsIDMyKSxcbiAgICAgICAgICAgIHY6IChzaWcucmVjb3ZlcnkgPyAweDFjIDogMHgxYilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBbW2xpbmstd2lraS1lY2RoXV0gc2hhcmVkIHNlY3JldCBiZXR3ZWVuIHRoaXNcbiAgICAgKiAgcHJpdmF0ZSBrZXkgYW5kIHRoZSAlJW90aGVyJSUga2V5LlxuICAgICAqXG4gICAgICogIFRoZSAlJW90aGVyJSUga2V5IG1heSBiZSBhbnkgdHlwZSBvZiBrZXksIGEgcmF3IHB1YmxpYyBrZXksXG4gICAgICogIGEgY29tcHJlc3NlZC91bmNvbXByZXNzZWQgcHViaWMga2V5IG9yIGFwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqICBCZXN0IHByYWN0aWNlIGlzIHVzdWFsbHkgdG8gdXNlIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIG9uIHRoZVxuICAgICAqICByZXR1cm5lZCB2YWx1ZSBiZWZvcmUgdXNpbmcgaXQgYXMgYSBzeW1ldHJpYyBzZWNyZXQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbjEgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTFcIikpXG4gICAgICogICAgc2lnbjIgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0LTJcIikpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhhdCBwcml2QS5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkIpLi4uXG4gICAgICogICAgc2lnbjEuY29tcHV0ZVNoYXJlZFNlY3JldChzaWduMi5wdWJsaWNLZXkpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gcHJpdkIuY29tcHV0ZVNoYXJlZFNlY3JldChwdWJBKS5cbiAgICAgKiAgICBzaWduMi5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24xLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICovXG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcikge1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkob3RoZXIpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KGdldEJ5dGVzQ29weSh0aGlzLiNwcml2YXRlS2V5KSwgZ2V0Qnl0ZXMocHViS2V5KSwgZmFsc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yICUla2V5JSUsIG9wdGlvbmFsbHkgJSVjb21wcmVzc2VkJSUuXG4gICAgICpcbiAgICAgKiAgVGhlICUla2V5JSUgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSwgYVxuICAgICAqICBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJsaWMga2V5IG9yIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIHNpZ24gPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKTtcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHJpdmF0ZUtleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5LCB0cnVlKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHNpZ24ucHVibGljS2V5LCBmYWxzZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgQ29tcHJlc3NlZCBhIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIHRydWUpO1xuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gZ2V0Qnl0ZXMoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShwdWJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJhdyBwdWJsaWMga2V5OyB1c2UgdW5jb21wcmVzc2VkIGtleSB3aXRoIDB4MDQgcHJlZml4XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICBjb25zdCBwdWIgPSBuZXcgVWludDhBcnJheSg2NSk7XG4gICAgICAgICAgICBwdWJbMF0gPSAweDA0O1xuICAgICAgICAgICAgcHViLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICBieXRlcyA9IHB1YjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChieXRlcyk7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHBvaW50LnRvUmF3Qnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcHVibGljIGtleSBmb3IgdGhlIHByaXZhdGUga2V5IHdoaWNoIHByb2R1Y2VkIHRoZVxuICAgICAqICAlJXNpZ25hdHVyZSUlIGZvciB0aGUgZ2l2ZW4gJSVkaWdlc3QlJS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBrZXkgPSBuZXcgU2lnbmluZ0tleShpZChcInNvbWUtc2VjcmV0XCIpKVxuICAgICAqICAgIGRpZ2VzdCA9IGlkKFwiaGVsbG8gd29ybGRcIilcbiAgICAgKiAgICBzaWcgPSBrZXkuc2lnbihkaWdlc3QpXG4gICAgICpcbiAgICAgKiAgICAvLyBOb3RpY2UgdGhlIHNpZ25lciBwdWJsaWMga2V5Li4uXG4gICAgICogICAga2V5LnB1YmxpY0tleVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIC4uLmlzIGVxdWFsIHRvIHRoZSByZWNvdmVyZWQgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkucmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhTGVuZ3RoKGRpZ2VzdCkgPT09IDMyLCBcImludmFsaWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBzaWcgPSBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpO1xuICAgICAgICBsZXQgc2VjcFNpZyA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbUNvbXBhY3QoZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoZ2V0Qnl0ZXNDb3B5KGRpZ2VzdCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwdWJLZXkgIT0gbnVsbCwgXCJpbnZhbGlkIHNpZ25hdXRyZSBmb3IgZGlnZXN0XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWJLZXkudG9IZXgoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcG9pbnQgcmVzdWx0aW5nIGZyb20gYWRkaW5nIHRoZSBlbGxpcGljIGN1cnZlIHBvaW50c1xuICAgICAqICAlJXAwJSUgYW5kICUlcDElJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBhIGNvbW1vbiBmdW5jdGlvbiBtb3N0IGRldmVsb3BlcnMgc2hvdWxkIHJlcXVpcmUsIGJ1dFxuICAgICAqICBjYW4gYmUgdXNlZnVsIGZvciBjZXJ0YWluIHByaXZhY3ktc3BlY2lmaWMgdGVjaG5pcXVlcy5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgaXQgaXMgdXNlZCBieSBbW0hETm9kZVdhbGxldF1dIHRvIGNvbXB1dGUgY2hpbGRcbiAgICAgKiAgYWRkcmVzc2VzIGZyb20gcGFyZW50IHB1YmxpYyBrZXlzIGFuZCBjaGFpbiBjb2Rlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUG9pbnRzKHAwLCBwMSwgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBwdWIwID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMCkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgY29uc3QgcHViMSA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocDEpLnN1YnN0cmluZygyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwdWIwLmFkZChwdWIxKS50b0hleCghIWNvbXByZXNzZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCJdLCJuYW1lcyI6WyJzZWNwMjU2azEiLCJjb25jYXQiLCJkYXRhTGVuZ3RoIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJoZXhsaWZ5IiwidG9CZUhleCIsImFzc2VydEFyZ3VtZW50IiwiU2lnbmF0dXJlIiwiU2lnbmluZ0tleSIsInByaXZhdGVLZXkiLCJjb25zdHJ1Y3RvciIsInB1YmxpY0tleSIsImNvbXB1dGVQdWJsaWNLZXkiLCJjb21wcmVzc2VkUHVibGljS2V5Iiwic2lnbiIsImRpZ2VzdCIsInNpZyIsImxvd1MiLCJmcm9tIiwiciIsInMiLCJ2IiwicmVjb3ZlcnkiLCJjb21wdXRlU2hhcmVkU2VjcmV0Iiwib3RoZXIiLCJwdWJLZXkiLCJnZXRTaGFyZWRTZWNyZXQiLCJrZXkiLCJjb21wcmVzc2VkIiwiYnl0ZXMiLCJsZW5ndGgiLCJnZXRQdWJsaWNLZXkiLCJwdWIiLCJVaW50OEFycmF5Iiwic2V0IiwicG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJmcm9tSGV4IiwidG9SYXdCeXRlcyIsInJlY292ZXJQdWJsaWNLZXkiLCJzaWduYXR1cmUiLCJzZWNwU2lnIiwiZnJvbUNvbXBhY3QiLCJhZGRSZWNvdmVyeUJpdCIsInlQYXJpdHkiLCJ0b0hleCIsImFkZFBvaW50cyIsInAwIiwicDEiLCJwdWIwIiwic3Vic3RyaW5nIiwicHViMSIsImFkZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/id.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/id.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDQztBQUNoRDs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0UsR0FBR0MsS0FBSztJQUNwQixPQUFPSCwyREFBU0EsQ0FBQ0MsNERBQVdBLENBQUNFO0FBQ2pDLEVBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcz81NDUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vKipcbiAqICBBIHNpbXBsZSBoYXNoaW5nIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIFVURi04IHN0cmluZ3MgdG9cbiAqICBjb21wdXRlIGFuIDMyLWJ5dGUgaWRlbnRpZmllci5cbiAqXG4gKiAgVGhpcyBzaW1wbHkgY29tcHV0ZXMgdGhlIFtVVEYtOCBieXRlc10odG9VdGY4Qnl0ZXMpIGFuZCBjb21wdXRlc1xuICogIHRoZSBbW2tlY2NhazI1Nl1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGlkKFwiaGVsbG8gd29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtlY2NhazI1Nih0b1V0ZjhCeXRlcyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIl0sIm5hbWVzIjpbImtlY2NhazI1NiIsInRvVXRmOEJ5dGVzIiwiaWQiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/namehash.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n\n\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */ function ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */ function isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */ function namehash(name) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)([\n            result,\n            (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_3__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(result);\n}\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */ function dnsEncode(name) {\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.concat)(ensNameSplit(name).map((comp)=>{\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0M7QUFDa0M7QUFDMUI7QUFDdkQsTUFBTU0sUUFBUSxJQUFJQyxXQUFXO0FBQzdCRCxNQUFNRSxJQUFJLENBQUM7QUFDWCxTQUFTQyxlQUFlQyxJQUFJO0lBQ3hCUCwrREFBY0EsQ0FBQ08sS0FBS0MsTUFBTSxLQUFLLEdBQUcscUNBQXFDLFFBQVFEO0lBQy9FLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRSxhQUFhQyxJQUFJO0lBQ3RCLE1BQU1DLFFBQVFWLDREQUFXQSxDQUFDVyxhQUFhRjtJQUN2QyxNQUFNRyxRQUFRLEVBQUU7SUFDaEIsSUFBSUgsS0FBS0YsTUFBTSxLQUFLLEdBQUc7UUFDbkIsT0FBT0s7SUFDWDtJQUNBLElBQUlDLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosTUFBTUgsTUFBTSxFQUFFTyxJQUFLO1FBQ25DLE1BQU1DLElBQUlMLEtBQUssQ0FBQ0ksRUFBRTtRQUNsQiw4Q0FBOEM7UUFDOUMsSUFBSUMsTUFBTSxNQUFNO1lBQ1pILE1BQU1JLElBQUksQ0FBQ1gsZUFBZUssTUFBTU8sS0FBSyxDQUFDSixNQUFNQztZQUM1Q0QsT0FBT0MsSUFBSTtRQUNmO0lBQ0o7SUFDQSxxREFBcUQ7SUFDckRmLCtEQUFjQSxDQUFDYyxPQUFPSCxNQUFNSCxNQUFNLEVBQUUscUNBQXFDLFFBQVFFO0lBQ2pGRyxNQUFNSSxJQUFJLENBQUNYLGVBQWVLLE1BQU1PLEtBQUssQ0FBQ0o7SUFDdEMsT0FBT0Q7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU0QsYUFBYUYsSUFBSTtJQUM3QixJQUFJO1FBQ0EsSUFBSUEsS0FBS0YsTUFBTSxLQUFLLEdBQUc7WUFDbkIsTUFBTSxJQUFJVyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT2pCLHFFQUFhQSxDQUFDUTtJQUN6QixFQUNBLE9BQU9VLE9BQU87UUFDVnBCLCtEQUFjQSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRW9CLE1BQU1DLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRWDtJQUN6RTtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxTQUFTWSxZQUFZWixJQUFJO0lBQzVCLElBQUk7UUFDQSxPQUFRRCxhQUFhQyxNQUFNRixNQUFNLEtBQUs7SUFDMUMsRUFDQSxPQUFPWSxPQUFPLENBQUU7SUFDaEIsT0FBTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRyxTQUFTYixJQUFJO0lBQ3pCViwrREFBY0EsQ0FBQyxPQUFRVSxTQUFVLFVBQVUsa0NBQWtDLFFBQVFBO0lBQ3JGViwrREFBY0EsQ0FBQ1UsS0FBS0YsTUFBTSxFQUFFLENBQUMsOEJBQThCLENBQUMsRUFBRSxRQUFRRTtJQUN0RSxJQUFJYyxTQUFTckI7SUFDYixNQUFNVSxRQUFRSixhQUFhQztJQUMzQixNQUFPRyxNQUFNTCxNQUFNLENBQUU7UUFDakJnQixTQUFTM0IsMkRBQVNBLENBQUNDLHVEQUFNQSxDQUFDO1lBQUMwQjtZQUFRM0IsMkRBQVNBLENBQUVnQixNQUFNWSxHQUFHO1NBQUs7SUFDaEU7SUFDQSxPQUFPMUIsd0RBQU9BLENBQUN5QjtBQUNuQjtBQUNBOzs7OztDQUtDLEdBQ00sU0FBU0UsVUFBVWhCLElBQUk7SUFDMUIsT0FBT1gsd0RBQU9BLENBQUNELHVEQUFNQSxDQUFDVyxhQUFhQyxNQUFNaUIsR0FBRyxDQUFDLENBQUNwQjtRQUMxQyx3REFBd0Q7UUFDeEQsSUFBSUEsS0FBS0MsTUFBTSxHQUFHLElBQUk7WUFDbEIsTUFBTSxJQUFJVyxNQUFNO1FBQ3BCO1FBQ0EsTUFBTVIsUUFBUSxJQUFJUCxXQUFXRyxLQUFLQyxNQUFNLEdBQUc7UUFDM0NHLE1BQU1pQixHQUFHLENBQUNyQixNQUFNO1FBQ2hCSSxLQUFLLENBQUMsRUFBRSxHQUFHQSxNQUFNSCxNQUFNLEdBQUc7UUFDMUIsT0FBT0c7SUFDWCxPQUFPO0FBQ1gsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL25hbWVoYXNoLmpzP2U1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5LCBhc3NlcnRBcmd1bWVudCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZVwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGFzc2VydEFyZ3VtZW50KGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zTm9ybWFsaXplKG5hbWUpKTtcbiAgICBjb25zdCBjb21wcyA9IFtdO1xuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29tcHM7XG4gICAgfVxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBieXRlc1tpXTtcbiAgICAgICAgLy8gQSBzZXBhcmF0b3IgKGkuZS4gXCIuXCIpOyBjb3B5IHRoaXMgY29tcG9uZW50XG4gICAgICAgIGlmIChkID09PSAweDJlKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QsIGkpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlcmUgd2FzIGEgc3RyYXkgc2VwYXJhdG9yIGF0IHRoZSBlbmQgb2YgdGhlIG5hbWVcbiAgICBhc3NlcnRBcmd1bWVudChsYXN0IDwgYnl0ZXMubGVuZ3RoLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIEVOUyAlJW5hbWUlJSBub3JtYWxpemVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IGxhYmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEVOUyBuYW1lICgke2Vycm9yLm1lc3NhZ2V9KWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlbmFtZSUlIGlzIGEgdmFsaWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGFzc2VydEFyZ3VtZW50KG5hbWUubGVuZ3RoLCBgaW52YWxpZCBFTlMgbmFtZSAoZW1wdHkgbGFiZWwpYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KChjb21wcy5wb3AoKSkpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRE5TIGVuY29kZWQgJSVuYW1lJSUuXG4gKlxuICogIFRoaXMgaXMgdXNlZCBmb3IgdmFyaW91cyBwYXJ0cyBvZiBFTlMgbmFtZSByZXNvbHV0aW9uLCBzdWNoXG4gKiAgYXMgdGhlIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSkge1xuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XG4gICAgICAgIC8vIEROUyBkb2VzIG5vdCBhbGxvdyBjb21wb25lbnRzIG92ZXIgNjMgYnl0ZXMgaW4gbGVuZ3RoXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEROUyBlbmNvZGVkIGVudHJ5OyBsZW5ndGggZXhjZWVkcyA2MyBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVoYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJjb25jYXQiLCJoZXhsaWZ5IiwiYXNzZXJ0QXJndW1lbnQiLCJ0b1V0ZjhCeXRlcyIsImVuc19ub3JtYWxpemUiLCJaZXJvcyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiY2hlY2tDb21wb25lbnQiLCJjb21wIiwibGVuZ3RoIiwiZW5zTmFtZVNwbGl0IiwibmFtZSIsImJ5dGVzIiwiZW5zTm9ybWFsaXplIiwiY29tcHMiLCJsYXN0IiwiaSIsImQiLCJwdXNoIiwic2xpY2UiLCJFcnJvciIsImVycm9yIiwibWVzc2FnZSIsImlzVmFsaWROYW1lIiwibmFtZWhhc2giLCJyZXN1bHQiLCJwb3AiLCJkbnNFbmNvZGUiLCJtYXAiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/typed-data.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder),\n/* harmony export */   verifyTypedData: () => (/* binding */ verifyTypedData)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _id_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./id.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\n\n\n\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n}\nconst hexTrue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_1, 32);\nconst hexFalse = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value) {\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"domain.chainId\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toQuantity)(value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value, \"domain.salt\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n            return function(_value) {\n                const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toBeHex)(signed ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function(value) {\n                const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.zeroPadValue)((0,_address_index_js__WEBPACK_IMPORTED_MODULE_3__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */ class TypedDataEncoder {\n    #types;\n    /**\n     *  The types.\n     */ get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */ constructor(types){\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        Object.keys(types).forEach((type)=>{\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        for(const name in types){\n            const uniqueNames = new Set();\n            for (const field of types[name]){\n                // Check each field has a unique name\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n)=>parents.get(n).length === 0);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.defineProperties)(this, {\n            primaryType: primaryTypes[0]\n        });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            found.add(type);\n            for (const child of links.get(type)){\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found){\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes){\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */ getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value)=>{\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256);\n                }\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id_js__WEBPACK_IMPORTED_MODULE_5__.id)(this.#fullTypes.get(type));\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)(values);\n            };\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */ encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */ encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */ hashStruct(name, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */ encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */ hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */ _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n            return value.map((v)=>this._visit(match[1], v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */ visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */ static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */ static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */ static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */ static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static encode(domain, types, value) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static hash(domain, types, value) {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_4__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */ static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for(const key in domain){\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && !(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for(const name in ensCache){\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return {\n            domain,\n            value\n        };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */ static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = Object.assign({}, types);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */ function verifyTypedData(domain, types, value, signature) {\n    return (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_7__.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSwyRkFBMkY7QUFDMUM7QUFDRjtBQUNVO0FBQ2dIO0FBQzVJO0FBQzdCLE1BQU1nQixVQUFVLElBQUlDLFdBQVc7QUFDL0JELFFBQVFFLElBQUksQ0FBQztBQUNiLE1BQU1DLFFBQVFDLE9BQU8sQ0FBQztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLE9BQU9GLE9BQU87QUFDcEIsTUFBTUcsaUJBQWlCSCxPQUFPOzs7QUFHOUIsU0FBU0ksWUFBWUMsS0FBSztJQUN0QixNQUFNQyxRQUFRcEIseURBQVFBLENBQUNtQjtJQUN2QixNQUFNRSxZQUFZRCxNQUFNRSxNQUFNLEdBQUc7SUFDakMsSUFBSUQsV0FBVztRQUNYLE9BQU94Qix1REFBTUEsQ0FBQztZQUFDdUI7WUFBT1YsUUFBUWEsS0FBSyxDQUFDRjtTQUFXO0lBQ25EO0lBQ0EsT0FBT3BCLHdEQUFPQSxDQUFDbUI7QUFDbkI7QUFDQSxNQUFNSSxVQUFVcEIsd0RBQU9BLENBQUNZLE1BQU07QUFDOUIsTUFBTVMsV0FBV3JCLHdEQUFPQSxDQUFDVyxNQUFNO0FBQy9CLE1BQU1XLG1CQUFtQjtJQUNyQkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsbUJBQW1CO0lBQ25CQyxNQUFNO0FBQ1Y7QUFDQSxNQUFNQyxtQkFBbUI7SUFDckI7SUFBUTtJQUFXO0lBQVc7SUFBcUI7Q0FDdEQ7QUFDRCxTQUFTQyxZQUFZQyxHQUFHO0lBQ3BCLE9BQU8sU0FBVWYsS0FBSztRQUNsQlgsK0RBQWNBLENBQUMsT0FBUVcsVUFBVyxVQUFVLENBQUMseUJBQXlCLEVBQUVnQixLQUFLQyxTQUFTLENBQUNGLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFQSxJQUFJLENBQUMsRUFBRWY7UUFDaEgsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTWtC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REFBY0EsQ0FBQyxPQUFPLG9CQUFvQixRQUFRb0M7WUFDdEQ7UUFDSjtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNtRixnQkFBZ0JoQixNQUFNLEVBQUV0RCxLQUFLLEVBQUV0QyxLQUFLLEVBQUU2RyxTQUFTO0lBQzNELE9BQU9wSSxxRUFBY0EsQ0FBQzRELGlCQUFpQjhDLElBQUksQ0FBQ1MsUUFBUXRELE9BQU90QyxRQUFRNkc7QUFDdkUsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9oYXNoL3R5cGVkLWRhdGEuanM/MjFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGVmaW5lUHJvcGVydGllcywgZ2V0QmlnSW50LCBnZXRCeXRlcywgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIG1hc2ssIHRvQmVIZXgsIHRvUXVhbnRpdHksIHRvVHdvcywgemVyb1BhZFZhbHVlLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi9pZC5qc1wiO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IEJOX18xID0gQmlnSW50KC0xKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG47XG47XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gdG9CZUhleChCTl8xLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IHRvQmVIZXgoQk5fMCwgMzIpO1xuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcbiAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IFwiYWRkcmVzc1wiLFxuICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG59O1xuY29uc3QgZG9tYWluRmllbGROYW1lcyA9IFtcbiAgICBcIm5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwiY2hhaW5JZFwiLCBcInZlcmlmeWluZ0NvbnRyYWN0XCIsIFwic2FsdFwiXG5dO1xuZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwiZG9tYWluLmNoYWluSWRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IDAsIFwiaW52YWxpZCBjaGFpbiBJRFwiLCBcImRvbWFpbi5jaGFpbklkXCIsIF92YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1F1YW50aXR5KHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBkb21haW4gdmFsdWUgXCJ2ZXJpZnlpbmdDb250cmFjdFwiYCwgXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2FsdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUsIFwiZG9tYWluLnNhbHRcIik7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14odT8paW50KFxcZCopJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQod2lkdGggJSA4ID09PSAwICYmIHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDI1NiAmJiAobWF0Y2hbMl0gPT0gbnVsbCB8fCBtYXRjaFsyXSA9PT0gU3RyaW5nKHdpZHRoKSksIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gbWFzayhCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/ICgoYm91bmRzVXBwZXIgKyBCTl8xKSAqIEJOX18xKSA6IEJOXzA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSBib3VuZHNMb3dlciAmJiB2YWx1ZSA8PSBib3VuZHNVcHBlciwgYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9CZUhleChzaWduZWQgPyB0b1R3b3ModmFsdWUsIDI1NikgOiB2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBieXRlc1hYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHdpZHRoICE9PSAwICYmIHdpZHRoIDw9IDMyICYmIG1hdGNoWzFdID09PSBTdHJpbmcod2lkdGgpLCBcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGJ5dGVzLmxlbmd0aCA9PT0gd2lkdGgsIGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZFZhbHVlKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuLyoqXG4gKiAgQSAqKlR5cGVkRGF0YUVuY29kZSoqIHByZXBhcmVzIGFuZCBlbmNvZGVzIFtbbGluay1laXAtNzEyXV0gcGF5bG9hZHNcbiAqICBmb3Igc2lnbmVkIHR5cGVkIGRhdGEuXG4gKlxuICogIFRoaXMgaXMgdXNlZnVsIGZvciB0aG9zZSB0aGF0IHdpc2ggdG8gY29tcHV0ZSB2YXJpb3VzIGNvbXBvbmVudHMgb2YgYVxuICogIHR5cGVkIGRhdGEgaGFzaCwgcHJpbWFyeSB0eXBlcywgb3Igc3ViLWNvbXBvbmVudHMsIGJ1dCBnZW5lcmFsbHkgdGhlXG4gKiAgaGlnaGVyIGxldmVsIFtbU2lnbmVyLXNpZ25UeXBlZERhdGFdXSBpcyBtb3JlIHVzZWZ1bC5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJpbWFyeSB0eXBlIGZvciB0aGUgc3RydWN0dXJlZCBbW3R5cGVzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBkZXJpdmVkIGF1dG9tYXRpY2FsbHkgZnJvbSB0aGUgW1t0eXBlc11dLCBzaW5jZSBub1xuICAgICAqICByZWN1cnNpb24gaXMgcG9zc2libGUsIG9uY2UgdGhlIERBRyBmb3IgdGhlIHR5cGVzIGlzIGNvbnN0dXJjdGVkXG4gICAgICogIGludGVybmFsbHksIHRoZSBwcmltYXJ5IHR5cGUgbXVzdCBiZSB0aGUgb25seSByZW1haW5pbmcgdHlwZSB3aXRoXG4gICAgICogIG5vIHBhcmVudCBub2Rlcy5cbiAgICAgKi9cbiAgICBwcmltYXJ5VHlwZTtcbiAgICAjdHlwZXM7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZXMoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuI3R5cGVzKTtcbiAgICB9XG4gICAgI2Z1bGxUeXBlcztcbiAgICAjZW5jb2RlckNhY2hlO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipUeXBlZERhdGFFbmNvZGVyKiogZm9yICUldHlwZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHBlcmZvcm1zIGFsbCBuZWNlc3NhcnkgY2hlY2tpbmcgdGhhdCB0eXBlcyBhcmUgdmFsaWQgYW5kXG4gICAgICogIGRvIG5vdCB2aW9sYXRlIHRoZSBbW2xpbmstZWlwLTcxMl1dIHN0cnVjdHVyYWwgY29uc3RyYWludHMgYXNcbiAgICAgKiAgd2VsbCBhcyBjb21wdXRlcyB0aGUgW1twcmltYXJ5VHlwZV1dLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGVzKSB7XG4gICAgICAgIHRoaXMuI3R5cGVzID0gSlNPTi5zdHJpbmdpZnkodHlwZXMpO1xuICAgICAgICB0aGlzLiNmdWxsVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcbiAgICAgICAgY29uc3QgbGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0cyB0byBzdHJ1Y3RzIHdoaWNoIGNvbnRhaW4gdGhlbSBhcyBhIGNoaWxkXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxpbmtzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICAgICAgc3VidHlwZXMuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghdW5pcXVlTmFtZXMuaGFzKGZpZWxkLm5hbWUpLCBgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSAoZmllbGQudHlwZS5tYXRjaCgvXihbXlxceDViXSopKFxceDVifCQpLykpWzFdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYmFzZVR5cGUgIT09IG5hbWUsIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHBhcmVudHMuaGFzKGJhc2VUeXBlKSwgYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHMuZ2V0KGJhc2VUeXBlKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzLmdldChuYW1lKS5hZGQoYmFzZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IEFycmF5LmZyb20ocGFyZW50cy5rZXlzKCkpLmZpbHRlcigobikgPT4gKHBhcmVudHMuZ2V0KG4pLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoICE9PSAwLCBcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAxLCBgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHByaW1hcnlUeXBlOiBwcmltYXJ5VHlwZXNbMF0gfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZvdW5kLmhhcyh0eXBlKSwgYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodHlwZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpbmtzLmdldCh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50cy5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ0eXBlIG9mIGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzLmdldChzdWJ0eXBlKS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHNldF0gb2Ygc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuZnJvbShzZXQpO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy4jZnVsbFR5cGVzLnNldChuYW1lLCBlbmNvZGVUeXBlKG5hbWUsIHR5cGVzW25hbWVdKSArIHN0Lm1hcCgodCkgPT4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSkpLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm50aGUgZW5jb2RlciBmb3IgdGhlIHNwZWNpZmljICUldHlwZSUlLlxuICAgICAqL1xuICAgIGdldEVuY29kZXIodHlwZSkge1xuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuI2VuY29kZXJDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuI2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUuc2V0KHR5cGUsIGVuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH1cbiAgICAjZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3ViRW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghbWF0Y2hbM10gfHwgcGFyc2VJbnQobWF0Y2hbM10pID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke3BhcnNlSW50KG1hdGNoWzNdKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHN1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoa2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nihjb25jYXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVHlwZSA9IGlkKHRoaXMuI2Z1bGxUeXBlcy5nZXQodHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbCB0eXBlIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVsbFR5cGVzLmdldChuYW1lKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgaGFzaCBvZiAlJXZhbHVlJSUgZm9yIHRoZSB0eXBlIG9mICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbGVkIGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSBbW3R5cGVzXV0uXG4gICAgICovXG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KCFtYXRjaFszXSB8fCBwYXJzZUludChtYXRjaFszXSkgPT09IHZhbHVlLmxlbmd0aCwgYGFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7cGFyc2VJbnQobWF0Y2hbM10pfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQobWF0Y2hbMV0sIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXG4gICAgICogIGNvbXBvbmVudCB3aXRoaW4gJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcbiAgICAgKiAgbWF5IGJlIGRlc2lyZWQgb24gZWFjaCBjb21wb25lbnQsIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgICAqL1xuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHByaW1hcnkgdHlwZSBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaGVkIHN0cnVjdCBmb3IgJSV2YWx1ZSUlIHVzaW5nICUldHlwZXMlJSBhbmQgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkb21haW4gaGFzaCBmb3IgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlLCBgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaCBvZiB0aGUgZnVsbHkgZW5jb2RlZCBbW2xpbmstZWlwLTcxMl1dICUldmFsdWUlJSBmb3IgJSV0eXBlcyUlIHdpdGggJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXG4gICAgICogJSV0eXBlcyUlIGFuZCB0aGUgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgZG9tYWluKTtcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSBhd2FpdCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIEpTT04tZW5jb2RlZCBwYXlsb2FkIGV4cGVjdGVkIGJ5IG5vZGVzIHdoaWNoIGltcGxlbWVudFxuICAgICAqICB0aGUgSlNPTi1SUEMgW1tsaW5rLWVpcC03MTJdXSBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGVzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoZ2V0Qnl0ZXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogIENvbXB1dGUgdGhlIGFkZHJlc3MgdXNlZCB0byBzaWduIHRoZSB0eXBlZCBkYXRhIGZvciB0aGUgJSVzaWduYXR1cmUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwicmVjb3ZlckFkZHJlc3MiLCJjb25jYXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJtYXNrIiwidG9CZUhleCIsInRvUXVhbnRpdHkiLCJ0b1R3b3MiLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnRBcmd1bWVudCIsImlkIiwicGFkZGluZyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiQk5fXzEiLCJCaWdJbnQiLCJCTl8wIiwiQk5fMSIsIkJOX01BWF9VSU5UMjU2IiwiaGV4UGFkUmlnaHQiLCJ2YWx1ZSIsImJ5dGVzIiwicGFkT2Zmc2V0IiwibGVuZ3RoIiwic2xpY2UiLCJoZXhUcnVlIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsInZlcnNpb24iLCJjaGFpbklkIiwidmVyaWZ5aW5nQ29udHJhY3QiLCJzYWx0IiwiZG9tYWluRmllbGROYW1lcyIsImNoZWNrU3RyaW5nIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRvbWFpbkNoZWNrcyIsIl92YWx1ZSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJ0b0xvd2VyQ2FzZSIsImVycm9yIiwiZ2V0QmFzZUVuY29kZXIiLCJ0eXBlIiwibWF0Y2giLCJzaWduZWQiLCJ3aWR0aCIsInBhcnNlSW50IiwiU3RyaW5nIiwiYm91bmRzVXBwZXIiLCJib3VuZHNMb3dlciIsImVuY29kZVR5cGUiLCJmaWVsZHMiLCJtYXAiLCJqb2luIiwiVHlwZWREYXRhRW5jb2RlciIsInR5cGVzIiwicGFyc2UiLCJmdWxsVHlwZXMiLCJlbmNvZGVyQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzZXQiLCJTZXQiLCJ1bmlxdWVOYW1lcyIsImZpZWxkIiwiaGFzIiwiYWRkIiwiYmFzZVR5cGUiLCJlbmNvZGVyIiwiZ2V0IiwicHVzaCIsInByaW1hcnlUeXBlcyIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIm4iLCJ0IiwicHJpbWFyeVR5cGUiLCJjaGVja0NpcmN1bGFyIiwiZm91bmQiLCJjaGlsZCIsInN1YnR5cGUiLCJkZWxldGUiLCJzdCIsInNvcnQiLCJnZXRFbmNvZGVyIiwic3ViRW5jb2RlciIsInJlc3VsdCIsImVuY29kZWRUeXBlIiwidmFsdWVzIiwidW5zaGlmdCIsImVuY29kZURhdGEiLCJoYXNoU3RydWN0IiwiZW5jb2RlIiwiaGFzaCIsIl92aXNpdCIsImNhbGxiYWNrIiwidiIsInJlZHVjZSIsImFjY3VtIiwidmlzaXQiLCJnZXRQcmltYXJ5VHlwZSIsImhhc2hEb21haW4iLCJkb21haW4iLCJkb21haW5GaWVsZHMiLCJhIiwiYiIsImluZGV4T2YiLCJFSVA3MTJEb21haW4iLCJyZXNvbHZlTmFtZXMiLCJyZXNvbHZlTmFtZSIsImFzc2lnbiIsImVuc0NhY2hlIiwiZ2V0UGF5bG9hZCIsImRvbWFpblZhbHVlcyIsImRvbWFpblR5cGVzIiwidHlwZXNXaXRoRG9tYWluIiwibWVzc2FnZSIsInRvU3RyaW5nIiwidmVyaWZ5VHlwZWREYXRhIiwic2lnbmF0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractProvider: () => (/* binding */ AbstractProvider),\n/* harmony export */   UnmanagedSubscriber: () => (/* binding */ UnmanagedSubscriber)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ens-resolver.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\");\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/format.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */ // @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v)=>{\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof v === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof v === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key)=>{\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */ class UnmanagedSubscriber {\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    start() {}\n    stop() {}\n    pause(dropWhilePaused) {}\n    resume() {}\n}\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from(new Set(items).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = {\n            topics: _event\n        };\n    }\n    if (typeof _event === \"string\") {\n        switch(_event){\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\":\n                {\n                    return {\n                        type: _event,\n                        tag: _event\n                    };\n                }\n        }\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n                hash\n            }),\n            hash\n        };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n        };\n    }\n    if (_event.address || _event.topics) {\n        const event = _event;\n        const filter = {\n            topics: (event.topics || []).map((t)=>{\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t)=>t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            })\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr)=>{\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async ()=>{\n                        addresses.push(await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a)=>a.toLowerCase()));\n        }\n        return {\n            filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n        };\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */ class AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */ constructor(_network, options){\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = _network_js__WEBPACK_IMPORTED_MODULE_4__.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(()=>{\n                this.emit(\"network\", network, null);\n            }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() {\n        return this.#options.pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */ get provider() {\n        return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */ get disableCcipRead() {\n        return this.#disableCcipRead;\n    }\n    set disableCcipRead(value) {\n        this.#disableCcipRead = !!value;\n    }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(()=>{\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */ async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for(let i = 0; i < urls.length; i++){\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                    data,\n                    sender\n                };\n            }\n            this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request,\n                index: i,\n                urls\n            });\n            let errorMessage = \"unknown error\";\n            const resp = await request.send();\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadFetchResult\",\n                        request,\n                        result\n                    });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result\n                });\n            } catch (error) {}\n            // 4xx indicates the result is not present; stop\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                    url,\n                    errorMessage\n                }\n            });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx,\n            info: {\n                urls,\n                errorMessages\n            }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */ _wrapBlock(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Block((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */ _wrapLog(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.Log((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */ _wrapTransactionReceipt(value, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionReceipt((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */ _wrapTransactionResponse(tx, network) {\n        return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.TransactionResponse((0,_format_js__WEBPACK_IMPORTED_MODULE_7__.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */ _detectNetwork() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */ async _perform(req) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#perform({\n            method: \"getBlockNumber\"\n        }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */ _getAddress(address) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */ _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag)) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n        }\n        if (typeof blockTag === \"bigint\") {\n            blockTag = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof blockTag === \"number\") {\n            if (blockTag >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b)=>(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toQuantity)(b + blockTag));\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */ _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t)=>{\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t)=>t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock)=>{\n            let address = undefined;\n            switch(_address.length){\n                case 0:\n                    break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address){\n                    address.push(this._getAddress(addr));\n                }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a)=>typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n            return Promise.all([\n                Promise.all(address),\n                fromBlock,\n                toBlock\n            ]).then((result)=>{\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resovles to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */ _getTransactionRequest(_request) {\n        const request = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(_request);\n        const promises = [];\n        [\n            \"to\",\n            \"from\"\n        ].forEach((key)=>{\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push(async function() {\n                    request[key] = await addr;\n                }());\n            } else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push(async function() {\n                    request.blockTag = await blockTag;\n                }());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return async function() {\n                await Promise.all(promises);\n                return request;\n            }();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = this._detectNetwork().then((network)=>{\n                this.emit(\"network\", network, null);\n                return network;\n            }, (error)=>{\n                // Reset the networkPromise on failure, so we will try again\n                if (this.#networkPromise === detectNetwork) {\n                    this.#networkPromise = null;\n                }\n                throw error;\n            });\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async ()=>{\n            const { _block, gasPrice, priorityFee } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: (async ()=>{\n                    try {\n                        const value = await this.#perform({\n                            method: \"getGasPrice\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })(),\n                priorityFee: (async ()=>{\n                    try {\n                        const value = await this.#perform({\n                            method: \"getPriorityFee\"\n                        });\n                        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(value, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })()\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt(\"1000000000\");\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n            }\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new _utils_index_js__WEBPACK_IMPORTED_MODULE_5__.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new _provider_js__WEBPACK_IMPORTED_MODULE_6__.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#perform({\n            method: \"estimateGas\",\n            transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n                blockTag,\n                enableCcipRead: true\n            })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0,_provider_js__WEBPACK_IMPORTED_MODULE_6__.copyRequest)(tx);\n        try {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this._perform({\n                method: \"call\",\n                transaction,\n                blockTag\n            }));\n        } catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(error.data, 4));\n                } catch (error) {\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\",\n                        transaction,\n                        info: {\n                            data\n                        }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\",\n                    transaction,\n                    info: {\n                        data: error.data,\n                        errorArgs: ccipArgs.errorArgs\n                    }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)([\n                        ccipArgs.selector,\n                        encodeBytes([\n                            ccipResult,\n                            ccipArgs.extraData\n                        ])\n                    ])\n                };\n                this.emit(\"debug\", {\n                    action: \"sendCcipReadCall\",\n                    transaction: tx\n                });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallResult\",\n                        transaction: Object.assign({}, tx),\n                        result\n                    });\n                    return result;\n                } catch (error) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallError\",\n                        transaction: Object.assign({}, tx),\n                        error\n                    });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n            [address, blockTag] = await Promise.all([\n                address,\n                blockTag\n            ]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, {\n            address,\n            blockTag\n        })));\n    }\n    async getBalance(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(await this.#getAccountValue({\n            method: \"getBalance\"\n        }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)(await this.#getAccountValue({\n            method: \"getTransactionCount\"\n        }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getCode\"\n        }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getBigInt)(_position, \"position\");\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(await this.#getAccountValue({\n            method: \"getStorage\",\n            position\n        }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_9__.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\",\n                blockHash: block,\n                includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof blockTag !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\",\n            blockTag,\n            includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransaction\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransactionReceipt\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({\n                method: \"getTransaction\",\n                hash\n            });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({\n                method: \"getTransactionResult\",\n                hash\n            })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getLogs\",\n                filter\n            })\n        });\n        return params.map((p)=>this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_11__.getAddress)(address);\n        const node = (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_12__.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await _ens_resolver_js__WEBPACK_IMPORTED_MODULE_10__.EnsResolver.getEnsAddress(this);\n            const ensContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === _constants_index_js__WEBPACK_IMPORTED_MODULE_14__.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_13__.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = _confirms != null ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject)=>{\n            let timer = null;\n            const listener = async (blockNumber)=>{\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            };\n            if (timeout != null) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"timeout\", \"TIMEOUT\", {\n                        reason: \"timeout\"\n                    }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */ _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */ _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = ()=>{\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, {\n                timer: null,\n                func,\n                time: timeout\n            });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, {\n                timer,\n                func,\n                time: getTime()\n            });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */ _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()){\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                {\n                    const subscriber = new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockSubscriber(this);\n                    subscriber.pollingInterval = this.pollingInterval;\n                    return subscriber;\n                }\n            case \"safe\":\n            case \"finalized\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_15__.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */ _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()){\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({\n                orphan: \"drop-log\",\n                log: emitArgs[0]\n            }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = {\n                subscriber,\n                tag,\n                addressableMap,\n                nameMap,\n                started: false,\n                listeners: []\n            };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once })=>{\n            const payload = new _utils_index_js__WEBPACK_IMPORTED_MODULE_16__.EventPayload(this, once ? null : listener, event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch (error) {}\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return count > 0;\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        } else {\n            for (const [tag, { started, subscriber }] of this.#subs){\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */ get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */ destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()){\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */ get paused() {\n        return this.#pausedState != null;\n    }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */ pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s)=>s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()){\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */ resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s)=>s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()){\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_17__.toUtf8String)(bytes);\n        }\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, start, start + 32));\n        const length = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset, offset + 32));\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(result, offset + 32, offset + 32 + length);\n    } catch (error) {}\n    return null;\n}\nfunction numPad(value) {\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(empty);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\",\n        urls: [],\n        calldata: \"\",\n        selector: \"\",\n        extraData: \"\",\n        errorArgs: []\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 0, 32);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 0, 12) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 32, 64));\n        const urlsLength = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getNumber)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, urlsOffset + 32);\n        for(let u = 0; u < urlsLength; u++){\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 100, 128) === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k)=>result[k]);\n    return result;\n} //# sourceMappingURL=abstract-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ0QsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQiw0RUFBNEU7QUFDNUUsNEVBQTRFO0FBQzVFLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQ1Y7QUFDYjtBQUNKO0FBQ0o7QUFDVTtBQUNxTztBQUMzTztBQUMwRDtBQUNuRTtBQUNtRTtBQUNpRTtBQUMzSyxZQUFZO0FBQ1osTUFBTTJDLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMscUJBQXFCO0FBQzNCLFNBQVNDLFVBQVVDLEtBQUs7SUFDcEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVILEtBQUs7SUFDekIsT0FBT0csU0FBUyxNQUFNQyxLQUFLQyxTQUFTLENBQUNMLE9BQU8sQ0FBQ00sR0FBR0M7UUFDNUMsSUFBSUEsS0FBSyxNQUFNO1lBQ1gsT0FBTztRQUNYO1FBQ0EsSUFBSSxPQUFRQSxNQUFPLFVBQVU7WUFDekIsT0FBTyxDQUFDLE9BQU8sRUFBRUEsRUFBRUMsUUFBUSxHQUFHLENBQUM7UUFDbkM7UUFDQSxJQUFJLE9BQVFELE1BQU8sVUFBVTtZQUN6QixPQUFPQSxFQUFFRSxXQUFXO1FBQ3hCO1FBQ0EsbUJBQW1CO1FBQ25CLElBQUksT0FBUUYsTUFBTyxZQUFZLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0osSUFBSTtZQUM5QyxNQUFNSyxPQUFPQyxPQUFPRCxJQUFJLENBQUNMO1lBQ3pCSyxLQUFLRSxJQUFJO1lBQ1QsT0FBT0YsS0FBS0csTUFBTSxDQUFDLENBQUNDLE9BQU9DO2dCQUN2QkQsS0FBSyxDQUFDQyxJQUFJLEdBQUdWLENBQUMsQ0FBQ1UsSUFBSTtnQkFDbkIsT0FBT0Q7WUFDWCxHQUFHLENB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Q3JKLHVEQUFNQSxDQUFDVCwwREFBU0EsQ0FBQzJJLE1BQU0sS0FBSyxTQUFTM0ksMERBQVNBLENBQUM2VCxPQUFPLEdBQUcsS0FBSyw0Q0FBNEMsa0JBQWtCO1FBQ3hIL0osUUFBUTtJQUNaO0lBQ0FMLE9BQU84RCxRQUFRLEdBQUd2TiwwREFBU0EsQ0FBQzJJLE1BQU0sSUFBSTtJQUN0Qyw2REFBNkQ7SUFDN0QsSUFBSTtRQUNBLE1BQU04RSxZQUFZeUYsWUFBWXZLLE1BQU07UUFDcEMsSUFBSThFLGFBQWEsTUFBTTtZQUNuQixNQUFNLElBQUk5SSxNQUFNO1FBQ3BCO1FBQ0E4RSxPQUFPZ0UsU0FBUyxHQUFHQTtJQUN2QixFQUNBLE9BQU83RCxPQUFPO1FBQ1ZuSix1REFBTUEsQ0FBQyxPQUFPLG9DQUFvQyxrQkFBa0I7WUFDaEVxSixRQUFRO1FBQ1o7SUFDSjtJQUNBTCxPQUFPNEQsU0FBUyxHQUFHLDBDQUEwQzZHLEtBQUssQ0FBQyxLQUFLOU8sR0FBRyxDQUFDLENBQUN2QyxJQUFNNEcsTUFBTSxDQUFDNUcsRUFBRTtJQUM1RixPQUFPNEc7QUFDWCxFQUNBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlci5qcz8xZWE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBhdmFpbGFibGUgcHJvdmlkZXJzIHNob3VsZCBzdWZmaWNlIGZvciBtb3N0IGRldmVsb3BlcnMgcHVycG9zZXMsXG4gKiAgYnV0IHRoZSBbW0Fic3RyYWN0UHJvdmlkZXJdXSBjbGFzcyBoYXMgbWFueSBmZWF0dXJlcyB3aGljaCBlbmFibGVcbiAqICBzdWItY2xhc3NpbmcgaXQgZm9yIHNwZWNpZmljIHB1cnBvc2VzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6IFN1YmNsYXNzaW5nIFByb3ZpZGVyICBbYWJzdHJhY3QtcHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPXG4vLyBFdmVudCBjb2FsZXNjZW5jZVxuLy8gICBXaGVuIHdlIHJlZ2lzdGVyIGFuIGV2ZW50IHdpdGggYW4gYXN5bmMgdmFsdWUgKGUuZy4gYWRkcmVzcyBpcyBhIFNpZ25lclxuLy8gICBvciBFTlMgbmFtZSksIHdlIG5lZWQgdG8gYWRkIGl0IGltbWVpZGF0ZWx5IGZvciB0aGUgRXZlbnQgQVBJLCBidXQgYWxzb1xuLy8gICBuZWVkIHRpbWUgdG8gcmVzb2x2ZSB0aGUgYWRkcmVzcy4gVXBvbiByZXNvbHZpbmcgdGhlIGFkZHJlc3MsIHdlIG5lZWQgdG9cbi8vICAgbWlncmF0ZSB0aGUgbGlzdGVuZXIgdG8gdGhlIHN0YXRpYyBldmVudC4gV2UgYWxzbyBuZWVkIHRvIG1haW50YWluIGEgbWFwXG4vLyAgIG9mIFNpZ25lci9FTlMgbmFtZSB0byBhZGRyZXNzIHNvIHdlIGNhbiBzeW5jIHJlc3BvbmQgdG8gbGlzdGVuZXJDb3VudC5cbmltcG9ydCB7IGdldEFkZHJlc3MsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IFplcm9BZGRyZXNzIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29udHJhY3QgfSBmcm9tIFwiLi4vY29udHJhY3QvaW5kZXguanNcIjtcbmltcG9ydCB7IG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRhdGFMZW5ndGgsIGRhdGFTbGljZSwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIGdldEJpZ0ludCwgZ2V0Qnl0ZXMsIGdldE51bWJlciwgaXNDYWxsRXhjZXB0aW9uLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgdG9CZUFycmF5LCB0b1F1YW50aXR5LCBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQsIHJlc29sdmVQcm9wZXJ0aWVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1Jlc29sdmVyIH0gZnJvbSBcIi4vZW5zLXJlc29sdmVyLmpzXCI7XG5pbXBvcnQgeyBmb3JtYXRCbG9jaywgZm9ybWF0TG9nLCBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQsIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBjb3B5UmVxdWVzdCwgQmxvY2ssIEZlZURhdGEsIExvZywgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2FjdGlvblJlc3BvbnNlIH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIsIFBvbGxpbmdCbG9ja1RhZ1N1YnNjcmliZXIsIFBvbGxpbmdFdmVudFN1YnNjcmliZXIsIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyLCBQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyIH0gZnJvbSBcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCI7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBNQVhfQ0NJUF9SRURJUkVDVFMgPSAxMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhZyhwcmVmaXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIFwiOlwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrLCB2KSA9PiB7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGBiaWdpbnQ6JHt2LnRvU3RyaW5nKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IG9iamVjdCBrZXlzXG4gICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModik7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW2tleV0gPSB2W2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuLyoqXG4gKiAgQW4gKipVbm1hbmFnZWRTdWJzY3JpYmVyKiogaXMgdXNlZnVsIGZvciBldmVudHMgd2hpY2ggZG8gbm90IHJlcXVpcmVcbiAqICBhbnkgYWRkaXRpb25hbCBtYW5hZ2VtZW50LCBzdWNoIGFzIGBgXCJkZWJ1Z1wiYGAgd2hpY2ggb25seSByZXF1aXJlc1xuICogIGVtaXQgaW4gc3luY2hyb25vdXMgZXZlbnQgbG9vcCB0cmlnZ2VyZWQgY2FsbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgZm9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7IH1cbiAgICBzdGFydCgpIHsgfVxuICAgIHN0b3AoKSB7IH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgfVxuICAgIHJlc3VtZSgpIHsgfVxufVxuZnVuY3Rpb24gY29weSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjb25jaXNpZnkoaXRlbXMpIHtcbiAgICBpdGVtcyA9IEFycmF5LmZyb20oKG5ldyBTZXQoaXRlbXMpKS52YWx1ZXMoKSk7XG4gICAgaXRlbXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbihfZXZlbnQsIHByb3ZpZGVyKSB7XG4gICAgaWYgKF9ldmVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnRcIik7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpYyBhcnJheSBpbmZvIGFuIEV2ZW50RmlsdGVyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2V2ZW50KSkge1xuICAgICAgICBfZXZlbnQgPSB7IHRvcGljczogX2V2ZW50IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKF9ldmVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3dpdGNoIChfZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcInNhZmVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IF9ldmVudCwgdGFnOiBfZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoX2V2ZW50LCAzMikpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IF9ldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRyYW5zYWN0aW9uXCIsIHRhZzogZ2V0VGFnKFwidHhcIiwgeyBoYXNoIH0pLCBoYXNoIH07XG4gICAgfVxuICAgIGlmIChfZXZlbnQub3JwaGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICAvLyBAVE9ETzogU2hvdWxkIGxvd2VyY2FzZSBhbmQgd2hhdG5vdCB0aGluZ3MgaGVyZSBpbnN0ZWFkIG9mIGNvcHkuLi5cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvcnBoYW5cIiwgdGFnOiBnZXRUYWcoXCJvcnBoYW5cIiwgZXZlbnQpLCBmaWx0ZXI6IGNvcHkoZXZlbnQpIH07XG4gICAgfVxuICAgIGlmICgoX2V2ZW50LmFkZHJlc3MgfHwgX2V2ZW50LnRvcGljcykpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIHRvcGljczogKChldmVudC50b3BpY3MgfHwgW10pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRBZGRyZXNzID0gKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYWRkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhd2FpdCByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBldmVudC5hZGRyZXNzLmZvckVhY2goYWRkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRBZGRyZXNzKGV2ZW50LmFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gY29uY2lzaWZ5KGFkZHJlc3Nlcy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpbHRlciwgdGFnOiBnZXRUYWcoXCJldmVudFwiLCBmaWx0ZXIpLCB0eXBlOiBcImV2ZW50XCIgfTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5rbm93biBQcm92aWRlckV2ZW50XCIsIFwiZXZlbnRcIiwgX2V2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjYWNoZVRpbWVvdXQ6IDI1MCxcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IDQwMDBcbn07XG4vKipcbiAqICBBbiAqKkFic3RyYWN0UHJvdmlkZXIqKiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgZm9yIG90aGVyIHN1Yi1jbGFzc2VzIHRvXG4gKiAgaW1wbGVtZW50IHRoZSBbW1Byb3ZpZGVyXV0gQVBJIGJ5IG5vcm1hbGl6aW5nIGlucHV0IGFyZ3VtZW50cyBhbmRcbiAqICBmb3JtYXR0aW5nIG91dHB1dCByZXN1bHRzIGFzIHdlbGwgYXMgdHJhY2tpbmcgZXZlbnRzIGZvciBjb25zaXN0ZW50XG4gKiAgYmVoYXZpb3VyIG9uIGFuIGV2ZW50dWFsbHktY29uc2lzdGVudCBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI3N1YnM7XG4gICAgI3BsdWdpbnM7XG4gICAgLy8gbnVsbD11bnBhdXNlZCwgdHJ1ZT1wYXVzZWQrZHJvcFdoaWxlUGF1c2VkLCBmYWxzZT1wYXVzZWRcbiAgICAjcGF1c2VkU3RhdGU7XG4gICAgI2Rlc3Ryb3llZDtcbiAgICAjbmV0d29ya1Byb21pc2U7XG4gICAgI2FueU5ldHdvcms7XG4gICAgI3BlcmZvcm1DYWNoZTtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgbnVtYmVyIGlmIHJ1bm5pbmcgYW4gZXZlbnQgb3IgLTEgaWYgbm8gXCJibG9ja1wiIGV2ZW50XG4gICAgI2xhc3RCbG9ja051bWJlcjtcbiAgICAjbmV4dFRpbWVyO1xuICAgICN0aW1lcnM7XG4gICAgI2Rpc2FibGVDY2lwUmVhZDtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQWJzdHJhY3RQcm92aWRlcioqIGNvbm5lY3RlZCB0byAlJW5ldHdvcmslJSwgb3JcbiAgICAgKiAgdXNlIHRoZSB2YXJpb3VzIG5ldHdvcmsgZGV0ZWN0aW9uIGNhcGFiaWxpdGllcyB0byBkaXNjb3ZlciB0aGVcbiAgICAgKiAgW1tOZXR3b3JrXV0gaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChfbmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX25ldHdvcmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBOZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICAgICAgdGhpcy4jYW55TmV0d29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdEJsb2NrTnVtYmVyID0gLTE7XG4gICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV4dFRpbWVyID0gMTtcbiAgICAgICAgdGhpcy4jdGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI29wdGlvbnMucG9sbGluZ0ludGVydmFsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0aGlzYGAsIHRvIGFsbG93IGFuICoqQWJzdHJhY3RQcm92aWRlcioqIHRvIGltcGxlbWVudFxuICAgICAqICB0aGUgW1tDb250cmFjdFJ1bm5lcl1dIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBnZXQgcHJvdmlkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYWxsIHRoZSByZWdpc3RlcmVkIHBsdWctaW5zLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyBwbHVnLWluLlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY29ubmVjdCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IGEgcGx1Z2luIGJ5IG5hbWUuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByZXZlbnQgYW55IENDSVAtcmVhZCBvcGVyYXRpb24sIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciByZXF1ZXN0ZWRcbiAgICAgKiAgaW4gYSBbW2NhbGxdXSB1c2luZyBgYGVuYWJsZUNjaXBSZWFkYGAuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVDY2lwUmVhZCgpIHsgcmV0dXJuIHRoaXMuI2Rpc2FibGVDY2lwUmVhZDsgfVxuICAgIHNldCBkaXNhYmxlQ2NpcFJlYWQodmFsdWUpIHsgdGhpcy4jZGlzYWJsZUNjaXBSZWFkID0gISF2YWx1ZTsgfVxuICAgIC8vIFNoYXJlcyBtdWx0aXBsZSBpZGVudGljYWwgcmVxdWVzdHMgbWFkZSBkdXJpbmcgdGhlIHNhbWUgMjUwbXNcbiAgICBhc3luYyAjcGVyZm9ybShyZXEpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuI29wdGlvbnMuY2FjaGVUaW1lb3V0O1xuICAgICAgICAvLyBDYWNoaW5nIGRpc2FibGVkXG4gICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSB0YWdcbiAgICAgICAgY29uc3QgdGFnID0gZ2V0VGFnKHJlcS5tZXRob2QsIHJlcSk7XG4gICAgICAgIGxldCBwZXJmb3JtID0gdGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXBlcmZvcm0pIHtcbiAgICAgICAgICAgIHBlcmZvcm0gPSB0aGlzLl9wZXJmb3JtKHJlcSk7XG4gICAgICAgICAgICB0aGlzLiNwZXJmb3JtQ2FjaGUuc2V0KHRhZywgcGVyZm9ybSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jcGVyZm9ybUNhY2hlLmdldCh0YWcpID09PSBwZXJmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5kZWxldGUodGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcGVyZm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBkYXRhIGZvciBleGVjdXRpbmcgdGhlIENDSVAtcmVhZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDY2lwUmVhZCB8fCB1cmxzLmxlbmd0aCA9PT0gMCB8fCB0eC50byA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAvLyBVUkwgZXhwYW5zaW9uXG4gICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgIC8vY29uc3QganNvbjogc3RyaW5nIHwgbnVsbCA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGw6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgLy9jb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgdmFsdWUuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChocmVmKTtcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJvZHkgPSB7IGRhdGEsIHNlbmRlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkRmV0Y2hSZXF1ZXN0XCIsIHJlcXVlc3QsIGluZGV4OiBpLCB1cmxzIH0pO1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwLmJvZHlKc29uO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaFJlc3VsdFwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHJlc3VsdC5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRGZXRjaEVycm9yXCIsIHJlcXVlc3QsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgIGFzc2VydChyZXNwLnN0YXR1c0NvZGUgPCA0MDAgfHwgcmVzcC5zdGF0dXNDb2RlID49IDUwMCwgYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7IHJlYXNvbjogXCI0MDRfTUlTU0lOR19SRVNPVVJDRVwiLCB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJsLCBlcnJvck1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2VzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oXCIsIFwiKX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCI1MDBfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJscywgZXJyb3JNZXNzYWdlcyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgYmxvY2sgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBfd3JhcEJsb2NrKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2soZm9ybWF0QmxvY2sodmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIGxvZyBiZWZvcmVcbiAgICAgKiAgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuIGFsdGVybmF0ZVxuICAgICAqICBzdWItY2xhc3Mgb2YgW1tMb2ddXS5cbiAgICAgKi9cbiAgICBfd3JhcExvZyh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IExvZyhmb3JtYXRMb2codmFsdWUpLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFByb3ZpZGVzIHRoZSBvcHBvcnR1bml0eSBmb3IgYSBzdWItY2xhc3MgdG8gd3JhcCBhIHRyYW5zYWN0aW9uXG4gICAgICogIHJlY2VpcHQgYmVmb3JlIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhblxuICAgICAqICBhbHRlcm5hdGUgc3ViLWNsYXNzIG9mIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlY2VpcHQoZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZShmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHR4KSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgTmV0d29yaywgZm9yY2luZyBhIG5ldHdvcmsgZGV0ZWN0aW9uIHVzaW5nIHdoYXRldmVyXG4gICAgICogIHRlY2huaXF1ZSB0aGUgc3ViLWNsYXNzIHJlcXVpcmVzLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMuXG4gICAgICovXG4gICAgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgc2hvdWxkIHVzZSB0aGlzIHRvIHBlcmZvcm0gYWxsIGJ1aWx0LWluIG9wZXJhdGlvbnMuIEFsbFxuICAgICAqICBtZXRob2RzIHNhbml0aXplcyBhbmQgbm9ybWFsaXplcyB0aGUgdmFsdWVzIHBhc3NlZCBpbnRvIHRoaXMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcy5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgdW5zdXBwb3J0ZWQgbWV0aG9kOiAke3JlcS5tZXRob2R9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgaW5mbzogcmVxXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTdGF0ZVxuICAgIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGdldE51bWJlcihhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldEJsb2NrTnVtYmVyXCIgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gdGhlIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLCByZXNvbHZpbmcgRU5TXG4gICAgICogIG5hbWVzIGFuZCBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0cyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYW5cbiAgICAgKiAgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyhhZGRyZXNzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSB2YWxpZCBibG9jayB0YWcgZm9yICUlYmxvY2tUYWclJSwgcmVzb2x2aW5nXG4gICAgICogIG5lZ2F0aXZlIHZhbHVlcyBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZCBibG9jayB0YWcuXG4gICAgICovXG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGJsb2NrVGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiZWFybGllc3RcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJmaW5hbGl6ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1F1YW50aXR5KGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gZ2V0TnVtYmVyKGJsb2NrVGFnLCBcImJsb2NrVGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFnID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eShibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbGFzdEJsb2NrTnVtYmVyID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9RdWFudGl0eSh0aGlzLiNsYXN0QmxvY2tOdW1iZXIgKyBibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oKGIpID0+IHRvUXVhbnRpdHkoYiArIGJsb2NrVGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBibG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb2x2ZXMgdG8gYSBmaWx0ZXIgZm9yICUlZmlsdGVyJSUsIHJlc29sdmluZyBhbnkgRU5TXG4gICAgICogIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBvYmplY3QgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGEgdmFsaWRcbiAgICAgKiAgZmlsdGVyLlxuICAgICAqL1xuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9waWNzXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IChmaWx0ZXIudG9waWNzIHx8IFtdKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gKFwiYmxvY2tIYXNoXCIgaW4gZmlsdGVyKSA/IGZpbHRlci5ibG9ja0hhc2ggOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoX2FkZHJlc3MsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2FkZHJlc3NbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9hZGRyZXNzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQmxvY2sgIT0gbnVsbCB8fCB0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWx0ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZnJvbUJsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IHRvQmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmJsb2NrSGFzaCA9IGJsb2NrSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZHJlc3NlcyBjb3VsZCBiZSBhc3luYyAoRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlcylcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBbXTtcbiAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgb2YgZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRoaXMuX2dldEFkZHJlc3MoYWRkcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyb21CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwiZnJvbUJsb2NrXCIgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9CbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFwidG9CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgdG9CbG9jayA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcy5maWx0ZXIoKGEpID0+ICh0eXBlb2YgKGEpICE9PSBcInN0cmluZ1wiKSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAoZnJvbUJsb2NrICE9IG51bGwgJiYgdHlwZW9mIChmcm9tQmxvY2spICE9PSBcInN0cmluZ1wiKSB8fFxuICAgICAgICAgICAgKHRvQmxvY2sgIT0gbnVsbCAmJiB0eXBlb2YgKHRvQmxvY2spICE9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtQcm9taXNlLmFsbChhZGRyZXNzKSwgZnJvbUJsb2NrLCB0b0Jsb2NrXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShhZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvdmxlcyB0byBhIHRyYW5zYWN0aW9uIGZvciAlJXJlcXVlc3QlJSwgcmVzb2x2aW5nXG4gICAgICogIGFueSBFTlMgbmFtZXMgb3IgW1tBZGRyZXNzYWJsZV1dIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3JlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNvcHlSZXF1ZXN0KF9yZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgW1widG9cIiwgXCJmcm9tXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Rba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkciA9IHJlc29sdmVBZGRyZXNzKHJlcXVlc3Rba2V5XSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0W2tleV0gPSBhd2FpdCBhZGRyOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rba2V5XSA9IGFkZHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVxdWVzdC5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKHJlcXVlc3QuYmxvY2tUYWcpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3QuYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZzsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJsb2NrVGFnID0gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgbmV0d29yayB3YXMgc2V0IGFuZCB0aGlzIGlzIG91ciBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGN1cnJlbnQgbmV0d29yayAoc2hhcmVkIHdpdGggYWxsIGNhbGxzKVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0TmV0d29yayA9IHRoaXMuX2RldGVjdE5ldHdvcmsoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBuZXR3b3JrUHJvbWlzZSBvbiBmYWlsdXJlLCBzbyB3ZSB3aWxsIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBgbmV0d29yayBjaGFuZ2VkOiAke2V4cGVjdGVkLmNoYWluSWR9ID0+ICR7YWN0dWFsLmNoYWluSWR9IGAsIFwiTkVUV09SS19FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBlY3RlZC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVEYXRhKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGdldEZlZURhdGFGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBfYmxvY2ssIGdhc1ByaWNlLCBwcmlvcml0eUZlZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIF9ibG9jazogdGhpcy4jZ2V0QmxvY2soXCJsYXRlc3RcIiwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiAoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRHYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSwgXCIlcmVzcG9uc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkoKSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWU6ICgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFByaW9yaXR5RmVlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QmlnSW50KHZhbHVlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChwcmlvcml0eUZlZSAhPSBudWxsKSA/IHByaW9yaXR5RmVlIDogQmlnSW50KFwiMTAwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2suYmFzZUZlZVBlckdhcyAqIEJOXzIpICsgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IEZldGNoUmVxdWVzdChwbHVnaW4udXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwbHVnaW4ucHJvY2Vzc0Z1bmMoZ2V0RmVlRGF0YUZ1bmMsIHRoaXMsIHJlcSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZlZURhdGEoZmVlRGF0YS5nYXNQcmljZSwgZmVlRGF0YS5tYXhGZWVQZXJHYXMsIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRGZWVEYXRhRnVuYygpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyhfdHgpIHtcbiAgICAgICAgbGV0IHR4ID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF90eCk7XG4gICAgICAgIGlmIChpc1Byb21pc2UodHgpKSB7XG4gICAgICAgICAgICB0eCA9IGF3YWl0IHR4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCaWdJbnQoYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIiwgdHJhbnNhY3Rpb246IHR4XG4gICAgICAgIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgI2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0KSB7XG4gICAgICAgIGFzc2VydChhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNhbGxcIiwgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENDSVAgUmVhZCBPZmZjaGFpbkxvb2t1cFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVDY2lwUmVhZCAmJiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgZGF0YVNsaWNlKGVycm9yLmRhdGEsIDAsIDQpID09PSBcIjB4NTU2ZjE4MzBcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3ModHJhbnNhY3Rpb24udG8sIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBDQ0lQIFJlYWQgQXJndW1lbnRzXG4gICAgICAgICAgICAgICAgbGV0IGNjaXBBcmdzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNjaXBBcmdzID0gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhU2xpY2UoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJCQURfREFUQVwiLCB0cmFuc2FjdGlvbiwgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBBcmdzLnNlbmRlci50b0xvd2VyQ2FzZSgpID09PSB0eFNlbmRlci50b0xvd2VyQ2FzZSgpLCBcIkNDSVAgUmVhZCBzZW5kZXIgbWlzbWF0Y2hcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGludm9jYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldmVydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogY2NpcEFyZ3MuZXJyb3JBcmdzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjY2lwUmVzdWx0ID0gYXdhaXQgdGhpcy5jY2lwUmVhZEZldGNoKHRyYW5zYWN0aW9uLCBjY2lwQXJncy5jYWxsZGF0YSwgY2NpcEFyZ3MudXJscyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNvbmNhdChbY2NpcEFyZ3Muc2VsZWN0b3IsIGVuY29kZUJ5dGVzKFtjY2lwUmVzdWx0LCBjY2lwQXJncy5leHRyYURhdGFdKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kQ2NpcFJlYWRDYWxsXCIsIHRyYW5zYWN0aW9uOiB0eCB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjYWxsKHR4LCBibG9ja1RhZywgYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsUmVzdWx0XCIsIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCksIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVDY2lwUmVhZENhbGxFcnJvclwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrTmV0d29yayhwcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgdmFsdWU6IHByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChfdHgpIHtcbiAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tUYWcgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0QmlnSW50KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRCYWxhbmNlXCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIgfSwgYWRkcmVzcywgYmxvY2tUYWcpLCBcIiVyZXNwb25zZVwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q29kZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldEJpZ0ludChfcG9zaXRpb24sIFwicG9zaXRpb25cIik7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGF3YWl0IHRoaXMuI2dldEFjY291bnRWYWx1ZSh7IG1ldGhvZDogXCJnZXRTdG9yYWdlXCIsIHBvc2l0aW9uIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIC8vIFdyaXRlXG4gICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNhY3Rpb24oc2lnbmVkVHgpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgaGFzaCwgbmV0d29yayB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFR4KTtcbiAgICAgICAgaWYgKHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPOiB0aGUgcmV0dXJuZWQgaGFzaCBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgbmV0d29yaykucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcik7XG4gICAgfVxuICAgIGFzeW5jICNnZXRCbG9jayhibG9jaywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAvLyBAVE9ETzogQWRkIEN1c3RvbUJsb2NrUGx1Z2luIGNoZWNrXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI2dldEJsb2NrKGJsb2NrLCAhIXByZWZldGNoVHhzKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcEJsb2NrKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNwZXJmb3JtKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uXCIsIGhhc2ggfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHBhcmFtcywgbmV0d29yayk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLCBoYXNoIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEJsb29tLWZpbHRlciBRdWVyaWVzXG4gICAgYXN5bmMgZ2V0TG9ncyhfZmlsdGVyKSB7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB0aGlzLl9nZXRGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIGlmIChpc1Byb21pc2UoZmlsdGVyKSkge1xuICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwicHJvdmlkZXIgY2Fubm90IGNvbm5lY3QgdG8gdGFyZ2V0IG5ldHdvcmtcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9nZXRQcm92aWRlcigpXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IEVuc1Jlc29sdmVyLmZyb21OYW1lKHRoaXMsIG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdmF0YXIobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBDb250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCBlbnNDb250cmFjdC5yZXNvbHZlcihub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlciA9PSBudWxsIHx8IHJlc29sdmVyID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJDb250cmFjdCA9IG5ldyBDb250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCQURfREFUQVwiKSAmJiBlcnJvci52YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgcmVlcnRlZFxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgX2NvbmZpcm1zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyAhPSBudWxsKSA/IF9jb25maXJtcyA6IDE7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoYXN5bmMgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLm9mZihcImJsb2NrXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRUVFXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobWFrZUVycm9yKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIiwgXCJOT1RfSU1QTEVNRU5URURcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIndhaXRGb3JCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2xlYXIgYSB0aW1lciBjcmVhdGVkIHVzaW5nIHRoZSBbW19zZXRUaW1lb3V0XV0gbWV0aG9kLlxuICAgICAqL1xuICAgIF9jbGVhclRpbWVvdXQodGltZXJJZCkge1xuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuI3RpbWVycy5nZXQodGltZXJJZCk7XG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lci50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdGltZXJzLmRlbGV0ZSh0aW1lcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIHRpbWVyIHRoYXQgd2lsbCBleGVjdXRlICUlZnVuYyUlIGFmdGVyIGF0IGxlYXN0ICUldGltZW91dCUlXG4gICAgICogIChpbiBtcykuIElmICUldGltZW91dCUlIGlzIHVuc3BlY2lmaWVkLCB0aGVuICUlZnVuYyUlIHdpbGwgZXhlY3V0ZVxuICAgICAqICBpbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogIFtQYXVzaW5nXShBYnN0cmFjdFByb3ZpZGVyLXBhdXNlZCkgdGhlIHByb3ZpZGVyIHdpbGwgcGF1c2UgYW55XG4gICAgICogIGFzc29jaWF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIF9zZXRUaW1lb3V0KF9mdW5jLCB0aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVySWQgPSB0aGlzLiNuZXh0VGltZXIrKztcbiAgICAgICAgY29uc3QgZnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgICAgICAgICBfZnVuYygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lcjogbnVsbCwgZnVuYywgdGltZTogdGltZW91dCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuI3RpbWVycy5zZXQodGltZXJJZCwgeyB0aW1lciwgZnVuYywgdGltZTogZ2V0VGltZSgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUGVyZm9ybSAlJWZ1bmMlJSBvbiBlYWNoIHN1YnNjcmliZXIuXG4gICAgICovXG4gICAgX2ZvckVhY2hTdWJzY3JpYmVyKGZ1bmMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZnVuYyhzdWIuc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIGN1c3RvbWl6ZSBzdWJzY3JpcHRpb25cbiAgICAgKiAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICBzd2l0Y2ggKHN1Yi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVubWFuYWdlZFN1YnNjcmliZXIoc3ViLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLnBvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyKHRoaXMsIHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ0V2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcih0aGlzLCBzdWIuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwib3JwaGFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV2ZW50OiAke3N1Yi50eXBlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSBbW1N1YnNjcmliZXJdXSBmYWlscyBhbmQgbmVlZHMgdG8gcmVwbGFjZSBpdHNlbGYsIHRoaXNcbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCB0aGlzIGlzIHVzZWQgZm9yIHByb3ZpZGVycyB3aGVuIHVzaW5nIHRoZVxuICAgICAqICBgYGV0aF9nZXRGaWx0ZXJDaGFuZ2VzYGAgbWV0aG9kLCB3aGljaCBjYW4gcmV0dXJuIG51bGwgaWYgc3RhdGVcbiAgICAgKiAgZmlsdGVycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCwgYWxsb3dpbmcgdGhlIFN1YnNjcmliZXJcbiAgICAgKiAgdG8gc3dhcCBpbiBhIFtbUG9sbGluZ0V2ZW50U3Vic2NyaWJlcl1dLlxuICAgICAqL1xuICAgIF9yZWNvdmVyU3Vic2NyaWJlcihvbGRTdWIsIG5ld1N1Yikge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLiNzdWJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN1YnNjcmliZXIgPT09IG9sZFN1Yikge1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyID0gbmV3U3ViO1xuICAgICAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2hhc1N1YihldmVudCwgZW1pdEFyZ3MpIHtcbiAgICAgICAgbGV0IHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsb2cgdGhhdCBpcyByZW1vdmluZyBhbiBleGlzdGluZyBsb2c7IHdlIGFjdHVhbGx5IHdhbnRcbiAgICAgICAgLy8gdG8gZW1pdCBhbiBvcnBoYW4gZXZlbnQgZm9yIHRoZSByZW1vdmVkIGxvZ1xuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBlbWl0QXJncyAmJiBlbWl0QXJncy5sZW5ndGggPiAwICYmIGVtaXRBcmdzWzBdLnJlbW92ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN1YiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbih7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IGVtaXRBcmdzWzBdIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNzdWJzLmdldChzdWIudGFnKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0U3ViKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvbihldmVudCwgdGhpcyk7XG4gICAgICAgIC8vIFByZXZlbnQgdGFtcGVyaW5nIHdpdGggb3VyIHRhZyBpbiBhbnkgc3ViY2xhc3MnIF9nZXRTdWJzY3JpYmVyXG4gICAgICAgIGNvbnN0IHRhZyA9IHN1YnNjcmlwdGlvbi50YWc7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLiNzdWJzLmdldCh0YWcpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHRoaXMuX2dldFN1YnNjcmliZXIoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBzdWIgPSB7IHN1YnNjcmliZXIsIHRhZywgYWRkcmVzc2FibGVNYXAsIG5hbWVNYXAsIHN0YXJ0ZWQ6IGZhbHNlLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLiNzdWJzLnNldCh0YWcsIHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2dldFN1YihldmVudCk7XG4gICAgICAgIHN1Yi5saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHN1Yi5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIucGF1c2UodGhpcy4jcGF1c2VkU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCwgYXJncyk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBzdWJzY3JpcHRpb24gb3IgaWYgYSByZWNlbnQgZW1pdCByZW1vdmVkXG4gICAgICAgIC8vIHRoZSBsYXN0IG9mIHRoZW0gKHdoaWNoIGFsc28gZGVsZXRlZCB0aGUgc3ViKSBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc3ViIHx8IHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBzdWIubGlzdGVuZXJzID0gc3ViLmxpc3RlbmVycy5maWx0ZXIoKHsgbGlzdGVuZXIsIG9uY2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG5ldyBFdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJjYW5ub3QgY2hhbmdlIHBhdXNlIHR5cGU7IHJlc3VtZSBmaXJzdFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdXNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCkpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVyXG4gICAgICAgICAgICBpZiAodGltZXIudGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgbmVlZGVkIGZvciB3aGVuIHdlIGJlY29tZSB1bnBhdXNlZFxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKSAtIHRpbWVyLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc3VtZSB0aGUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvckVhY2hTdWJzY3JpYmVyKChzKSA9PiBzLnJlc3VtZSgpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuI3RpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgLy8gUmVtYWluaW5nIHRpbWUgd2hlbiB3ZSB3ZXJlIHBhdXNlZFxuICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0aW1lci50aW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCB0aW1lIChpbiBjYXVzZSBwYXVzZWQsIHNvIHdlIGNvbiBjb21wdXRlIHJlbWFpbmluZiB0aW1lKVxuICAgICAgICAgICAgdGltZXIudGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lclxuICAgICAgICAgICAgc2V0VGltZW91dCh0aW1lci5mdW5jLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KTtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSk7XG4gICAgICAgIHJldHVybiBkYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQgKyAzMiwgb2Zmc2V0ICsgMzIgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyhkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChyZXN1bHQpO1xufVxuY29uc3QgemVyb3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuZnVuY3Rpb24gcGFyc2VPZmZjaGFpbkxvb2t1cChkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZW5kZXI6IFwiXCIsIHVybHM6IFtdLCBjYWxsZGF0YTogXCJcIiwgc2VsZWN0b3I6IFwiXCIsIGV4dHJhRGF0YTogXCJcIiwgZXJyb3JBcmdzOiBbXVxuICAgIH07XG4gICAgYXNzZXJ0KGRhdGFMZW5ndGgoZGF0YSkgPj0gNSAqIDMyLCBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiaW5zdWZmaWNpZW50IE9mZmNoYWluTG9va3VwIGRhdGFcIlxuICAgIH0pO1xuICAgIGNvbnN0IHNlbmRlciA9IGRhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgYXNzZXJ0KGRhdGFTbGljZShzZW5kZXIsIDAsIDEyKSA9PT0gZGF0YVNsaWNlKHplcm9zLCAwLCAxMiksIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBzZW5kZXJcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbmRlciA9IGRhdGFTbGljZShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gZ2V0TnVtYmVyKGRhdGFTbGljZShkYXRhLCAzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgdXJsc0xlbmd0aCA9IGdldE51bWJlcihkYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSk7XG4gICAgICAgIGNvbnN0IHVybHNEYXRhID0gZGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51cmxzID0gdXJscztcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGRhdGFcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjYWxsYmFja1NlbGVjdG9yIChieXRlczQpXG4gICAgYXNzZXJ0KGRhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkgPT09IGRhdGFTbGljZSh6ZXJvcywgMCwgMjgpLCBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgY2FsbGJhYWNrU2VsZWN0b3JcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VsZWN0b3IgPSBkYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgLy8gR2V0IHRoZSBleHRyYSBkYXRhIHRvIHNlbmQgYmFjayB0byB0aGUgY29udHJhY3QgYXMgY29udGV4dFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgIGlmIChleHRyYURhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWJvcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmV4dHJhRGF0YSA9IGV4dHJhRGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJyZXNvbHZlQWRkcmVzcyIsIlplcm9BZGRyZXNzIiwiQ29udHJhY3QiLCJuYW1laGFzaCIsIlRyYW5zYWN0aW9uIiwiY29uY2F0IiwiZGF0YUxlbmd0aCIsImRhdGFTbGljZSIsImhleGxpZnkiLCJpc0hleFN0cmluZyIsImdldEJpZ0ludCIsImdldEJ5dGVzIiwiZ2V0TnVtYmVyIiwiaXNDYWxsRXhjZXB0aW9uIiwiaXNFcnJvciIsIm1ha2VFcnJvciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiRmV0Y2hSZXF1ZXN0IiwidG9CZUFycmF5IiwidG9RdWFudGl0eSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJyZXNvbHZlUHJvcGVydGllcyIsInRvVXRmOFN0cmluZyIsIkVuc1Jlc29sdmVyIiwiZm9ybWF0QmxvY2siLCJmb3JtYXRMb2ciLCJmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQiLCJmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiTmV0d29yayIsImNvcHlSZXF1ZXN0IiwiQmxvY2siLCJGZWVEYXRhIiwiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsIlBvbGxpbmdCbG9ja1N1YnNjcmliZXIiLCJQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciIsIkJOXzIiLCJCaWdJbnQiLCJNQVhfQ0NJUF9SRURJUkVDVFMiLCJpc1Byb21pc2UiLCJ2YWx1ZSIsInRoZW4iLCJnZXRUYWciLCJwcmVmaXgiLCJKU09OIiwic3RyaW5naWZ5IiwiayIsInYiLCJ0b1N0cmluZyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5cyIsIk9iamVjdCIsInNvcnQiLCJyZWR1Y2UiLCJhY2N1bSIsImtleSIsIlVubWFuYWdlZFN1YnNjcmliZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJzdGFydCIsInN0b3AiLCJwYXVzZSIsImRyb3BXaGlsZVBhdXNlZCIsInJlc3VtZSIsImNvcHkiLCJwYXJzZSIsImNvbmNpc2lmeSIsIml0ZW1zIiwiZnJvbSIsIlNldCIsInZhbHVlcyIsImdldFN1YnNjcmlwdGlvbiIsIl9ldmVudCIsInByb3ZpZGVyIiwiRXJyb3IiLCJ0b3BpY3MiLCJ0eXBlIiwidGFnIiwiaGFzaCIsIm9ycGhhbiIsImV2ZW50IiwiZmlsdGVyIiwiYWRkcmVzcyIsIm1hcCIsInQiLCJhZGRyZXNzZXMiLCJwcm9taXNlcyIsImFkZEFkZHJlc3MiLCJhZGRyIiwicHVzaCIsImZvckVhY2giLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwiYSIsImdldFRpbWUiLCJEYXRlIiwiZGVmYXVsdE9wdGlvbnMiLCJjYWNoZVRpbWVvdXQiLCJwb2xsaW5nSW50ZXJ2YWwiLCJBYnN0cmFjdFByb3ZpZGVyIiwic3VicyIsInBsdWdpbnMiLCJwYXVzZWRTdGF0ZSIsImRlc3Ryb3llZCIsIm5ldHdvcmtQcm9taXNlIiwiYW55TmV0d29yayIsInBlcmZvcm1DYWNoZSIsImxhc3RCbG9ja051bWJlciIsIm5leHRUaW1lciIsInRpbWVycyIsImRpc2FibGVDY2lwUmVhZCIsIm9wdGlvbnMiLCJfbmV0d29yayIsImFzc2lnbiIsIm5ldHdvcmsiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImVtaXQiLCJNYXAiLCJhdHRhY2hQbHVnaW4iLCJwbHVnaW4iLCJnZXQiLCJzZXQiLCJjb25uZWN0IiwiZ2V0UGx1Z2luIiwicGVyZm9ybSIsInJlcSIsInRpbWVvdXQiLCJfcGVyZm9ybSIsIm1ldGhvZCIsImRlbGV0ZSIsImNjaXBSZWFkRmV0Y2giLCJ0eCIsImNhbGxkYXRhIiwidXJscyIsInRvIiwic2VuZGVyIiwiZGF0YSIsImVycm9yTWVzc2FnZXMiLCJpIiwidXJsIiwiaHJlZiIsInJlcGxhY2UiLCJyZXF1ZXN0IiwiaW5kZXhPZiIsImJvZHkiLCJhY3Rpb24iLCJpbmRleCIsImVycm9yTWVzc2FnZSIsInJlc3AiLCJzZW5kIiwicmVzdWx0IiwiYm9keUpzb24iLCJtZXNzYWdlIiwiZXJyb3IiLCJzdGF0dXNDb2RlIiwicmVhc29uIiwidHJhbnNhY3Rpb24iLCJpbmZvIiwibSIsImpvaW4iLCJfd3JhcEJsb2NrIiwiX3dyYXBMb2ciLCJfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCIsIl93cmFwVHJhbnNhY3Rpb25SZXNwb25zZSIsIl9kZXRlY3ROZXR3b3JrIiwib3BlcmF0aW9uIiwiZ2V0QmxvY2tOdW1iZXIiLCJibG9ja051bWJlciIsIl9nZXRBZGRyZXNzIiwiX2dldEJsb2NrVGFnIiwiYmxvY2tUYWciLCJiIiwiX2dldEZpbHRlciIsImJsb2NrSGFzaCIsInVuZGVmaW5lZCIsIl9hZGRyZXNzIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsIl9nZXRUcmFuc2FjdGlvblJlcXVlc3QiLCJfcmVxdWVzdCIsImdldE5ldHdvcmsiLCJkZXRlY3ROZXR3b3JrIiwiY2xvbmUiLCJleHBlY3RlZCIsImFjdHVhbCIsImNoYWluSWQiLCJnZXRGZWVEYXRhIiwiZ2V0RmVlRGF0YUZ1bmMiLCJfYmxvY2siLCJnYXNQcmljZSIsInByaW9yaXR5RmVlIiwiZ2V0QmxvY2siLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImJsb2NrIiwiYmFzZUZlZVBlckdhcyIsImZlZURhdGEiLCJwcm9jZXNzRnVuYyIsImVzdGltYXRlR2FzIiwiX3R4IiwiY2FsbCIsImF0dGVtcHQiLCJlbmFibGVDY2lwUmVhZCIsInR4U2VuZGVyIiwiY2NpcEFyZ3MiLCJwYXJzZU9mZmNoYWluTG9va3VwIiwiaW52b2NhdGlvbiIsInJldmVydCIsInNpZ25hdHVyZSIsImFyZ3MiLCJlcnJvckFyZ3MiLCJjY2lwUmVzdWx0Iiwic2VsZWN0b3IiLCJlbmNvZGVCeXRlcyIsImV4dHJhRGF0YSIsImNoZWNrTmV0d29yayIsInByb21pc2UiLCJnZXRBY2NvdW50VmFsdWUiLCJfYmxvY2tUYWciLCJnZXRCYWxhbmNlIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldENvZGUiLCJnZXRTdG9yYWdlIiwiX3Bvc2l0aW9uIiwicG9zaXRpb24iLCJicm9hZGNhc3RUcmFuc2FjdGlvbiIsInNpZ25lZFR4Iiwic2lnbmVkVHJhbnNhY3Rpb24iLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsInByZWZldGNoVHhzIiwicGFyYW1zIiwiZ2V0VHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJlZmZlY3RpdmVHYXNQcmljZSIsImdldFRyYW5zYWN0aW9uUmVzdWx0IiwiZ2V0TG9ncyIsIl9maWx0ZXIiLCJwIiwiX2dldFByb3ZpZGVyIiwiZ2V0UmVzb2x2ZXIiLCJmcm9tTmFtZSIsImdldEF2YXRhciIsInJlc29sdmVyIiwicmVzb2x2ZU5hbWUiLCJsb29rdXBBZGRyZXNzIiwibm9kZSIsInN1YnN0cmluZyIsImVuc0FkZHIiLCJnZXRFbnNBZGRyZXNzIiwiZW5zQ29udHJhY3QiLCJyZXNvbHZlckNvbnRyYWN0IiwiY2hlY2siLCJ3YWl0Rm9yVHJhbnNhY3Rpb24iLCJfY29uZmlybXMiLCJjb25maXJtcyIsInJlamVjdCIsInRpbWVyIiwibGlzdGVuZXIiLCJyZWNlaXB0IiwiY2xlYXJUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsIm9uY2UiLCJvZmYiLCJ3YWl0Rm9yQmxvY2siLCJfY2xlYXJUaW1lb3V0IiwidGltZXJJZCIsIl9zZXRUaW1lb3V0IiwiX2Z1bmMiLCJmdW5jIiwicGF1c2VkIiwidGltZSIsIl9mb3JFYWNoU3Vic2NyaWJlciIsInN1YiIsInN1YnNjcmliZXIiLCJfZ2V0U3Vic2NyaWJlciIsIl9yZWNvdmVyU3Vic2NyaWJlciIsIm9sZFN1YiIsIm5ld1N1YiIsInN0YXJ0ZWQiLCJoYXNTdWIiLCJlbWl0QXJncyIsInJlbW92ZWQiLCJnZXRTdWIiLCJzdWJzY3JpcHRpb24iLCJhZGRyZXNzYWJsZU1hcCIsIldlYWtNYXAiLCJuYW1lTWFwIiwibGlzdGVuZXJzIiwib24iLCJjb3VudCIsInBheWxvYWQiLCJsaXN0ZW5lckNvdW50IiwidG90YWwiLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiZGVzdHJveSIsInMiLCJfcGFyc2VTdHJpbmciLCJieXRlcyIsIl9wYXJzZUJ5dGVzIiwib2Zmc2V0IiwibnVtUGFkIiwicGFkZGVkIiwiVWludDhBcnJheSIsImJ5dGVzUGFkIiwiTWF0aCIsImNlaWwiLCJlbXB0eSIsImRhdGFzIiwiYnl0ZUNvdW50IiwiemVyb3MiLCJ1cmxzT2Zmc2V0IiwidXJsc0xlbmd0aCIsInVybHNEYXRhIiwidSIsInNwbGl0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/abstract-signer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSigner: () => (/* binding */ AbstractSigner),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */ \n\n\n\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\nasync function populate(signer, tx) {\n    let pop = (0,_provider_js__WEBPACK_IMPORTED_MODULE_1__.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveAddress)(from, signer)\n        ]).then(([address, from])=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n    return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */ class AbstractSigner {\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */ constructor(provider){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            provider: provider || null\n        });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await this.provider.getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getBigInt)(pop.chainId);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        } else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    pop.type = 2;\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    } else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                } else {\n                    // getFeeData has failed us.\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            } else if (pop.type === 2) {\n                // Explicitly using EIP-1559\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(pop);\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = _transaction_index_js__WEBPACK_IMPORTED_MODULE_5__.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */ class VoidSigner extends AbstractSigner {\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */ constructor(address, provider){\n        super(provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            address\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n} //# sourceMappingURL=abstract-signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNvRDtBQUNDO0FBQ3FEO0FBQy9EO0FBQzVDLFNBQVNRLGNBQWNDLE1BQU0sRUFBRUMsU0FBUztJQUNwQyxJQUFJRCxPQUFPRSxRQUFRLEVBQUU7UUFDakIsT0FBT0YsT0FBT0UsUUFBUTtJQUMxQjtJQUNBTix1REFBTUEsQ0FBQyxPQUFPLG9CQUFvQix5QkFBeUI7UUFBRUs7SUFBVTtBQUMzRTtBQUNBLGVBQWVFLFNBQVNILE1BQU0sRUFBRUksRUFBRTtJQUM5QixJQUFJQyxNQUFNUCx5REFBV0EsQ0FBQ007SUFDdEIsSUFBSUMsSUFBSUMsRUFBRSxJQUFJLE1BQU07UUFDaEJELElBQUlDLEVBQUUsR0FBR2YsaUVBQWNBLENBQUNjLElBQUlDLEVBQUUsRUFBRU47SUFDcEM7SUFDQSxJQUFJSyxJQUFJRSxJQUFJLElBQUksTUFBTTtRQUNsQixNQUFNQSxPQUFPRixJQUFJRSxJQUFJO1FBQ3JCRixJQUFJRSxJQUFJLEdBQUdDLFFBQVFDLEdBQUcsQ0FBQztZQUNuQlQsT0FBT1UsVUFBVTtZQUNqQm5CLGlFQUFjQSxDQUFDZ0IsTUFBTVA7U0FDeEIsRUFBRVcsSUFBSSxDQUFDLENBQUMsQ0FBQ0MsU0FBU0wsS0FBSztZQUNwQlYsK0RBQWNBLENBQUNlLFFBQVFDLFdBQVcsT0FBT04sS0FBS00sV0FBVyxJQUFJLDZCQUE2QixXQUFXTjtZQUNyRyxPQUFPSztRQUNYO0lBQ0osT0FDSztRQUNEUCxJQUFJRSxJQUFJLEdBQUdQLE9BQU9VLFVBQVU7SUFDaEM7SUFDQSxPQUFPLE1BQU1mLGtFQUFpQkEsQ0FBQ1U7QUFDbkM7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1TO0lBS1Q7O0tBRUMsR0FDREMsWUFBWWIsUUFBUSxDQUFFO1FBQ2xCVCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lB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QUM3QixPQUFPLEVBQUVWO0lBQ3hDO0lBQ0EsQ0FBQ3lDLGdCQUFnQixDQUFDQyxNQUFNLEVBQUUzQyxTQUFTO1FBQy9CTCx1REFBTUEsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUVnRCxPQUFPLENBQUMsRUFBRSx5QkFBeUI7WUFBRTNDO1FBQVU7SUFDM0Y7SUFDQSxNQUFNdUMsZ0JBQWdCcEMsRUFBRSxFQUFFO1FBQ3RCLElBQUksQ0FBQyxDQUFDdUMsZ0JBQWdCLENBQUMsZ0JBQWdCO0lBQzNDO0lBQ0EsTUFBTUUsWUFBWUMsT0FBTyxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDSCxnQkFBZ0IsQ0FBQyxZQUFZO0lBQ3ZDO0lBQ0EsTUFBTUksY0FBY0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUN0QyxJQUFJLENBQUMsQ0FBQ1AsZ0JBQWdCLENBQUMsY0FBYztJQUN6QztBQUNKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcz85NDRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEdlbmVyYWxseSB0aGUgW1tXYWxsZXRdXSBhbmQgW1tKc29uUnBjU2lnbmVyXV0gYW5kIHRoZWlyIHN1Yi1jbGFzc2VzXG4gKiAgYXJlIHN1ZmZpY2VudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuaW1wb3J0IHsgcmVzb2x2ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgcmVzb2x2ZVByb3BlcnRpZXMsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvcHlSZXF1ZXN0IH0gZnJvbSBcIi4vcHJvdmlkZXIuanNcIjtcbmZ1bmN0aW9uIGNoZWNrUHJvdmlkZXIoc2lnbmVyLCBvcGVyYXRpb24pIHtcbiAgICBpZiAoc2lnbmVyLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBzaWduZXIucHJvdmlkZXI7XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgXCJtaXNzaW5nIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoc2lnbmVyLCB0eCkge1xuICAgIGxldCBwb3AgPSBjb3B5UmVxdWVzdCh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9IHJlc29sdmVBZGRyZXNzKHBvcC50bywgc2lnbmVyKTtcbiAgICB9XG4gICAgaWYgKHBvcC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBvcC5mcm9tO1xuICAgICAgICBwb3AuZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICByZXNvbHZlQWRkcmVzcyhmcm9tLCBzaWduZXIpXG4gICAgICAgIF0pLnRoZW4oKFthZGRyZXNzLCBmcm9tXSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xufVxuLyoqXG4gKiAgQW4gKipBYnN0cmFjdFNpZ25lcioqIGluY2x1ZGVzIG1vc3Qgb2YgdGVoIGZ1bmN0aW9uYWxpdHkgcmVxdWlyZWRcbiAqICB0byBnZXQgYSBbW1NpZ25lcl1dIHdvcmtpbmcgYXMgZXhwZWN0ZWQsIGJ1dCByZXF1aXJlcyBhIGZld1xuICogIFNpZ25lci1zcGVjaWZpYyBtZXRob2RzIGJlIG92ZXJyaWRkZW4uXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBwcm92aWRlcjogKHByb3ZpZGVyIHx8IG51bGwpIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXROb25jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikuZ2V0VHJhbnNhY3Rpb25Db3VudChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZUNhbGwodHgpIHtcbiAgICAgICAgY29uc3QgcG9wID0gYXdhaXQgcG9wdWxhdGUodGhpcywgdHgpO1xuICAgICAgICByZXR1cm4gcG9wO1xuICAgIH1cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gY2hlY2tQcm92aWRlcih0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgaWYgKHBvcC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3Aubm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlKFwicGVuZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMuZXN0aW1hdGVHYXMocG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2hhaW4gSURcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0ICh0aGlzLnByb3ZpZGVyKS5nZXROZXR3b3JrKCk7XG4gICAgICAgIGlmIChwb3AuY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gZ2V0QmlnSW50KHBvcC5jaGFpbklkKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocG9wLnR5cGUgPT09IDIgfHwgcG9wLnR5cGUgPT0gbnVsbCkgJiYgKHBvcC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAwIHx8IHBvcC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBhc3NlcnQoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCB0aGV5IGFyZSB0cnlpbmcgdG8gdXNlIEVJUC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KCFoYXNFaXAxNTU5LCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3AuZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogTWF5YmUgdGhpcyBzaG9sZCBhbGxvdyB0eXBlIDE/XG4gICAgICAgICAgICAgICAgICAgIHBvcC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3AudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0BUT09EOiBEb24ndCBhd2FpdCBhbGwgb3ZlciB0aGUgcGxhY2U7IHNhdmUgdGhlbSB1cCBmb3JcbiAgICAgICAgLy8gdGhlIGVuZCBmb3IgYmV0dGVyIGJhdGNoaW5nXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlUHJvcGVydGllcyhwb3ApO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImVzdGltYXRlR2FzXCIpLmVzdGltYXRlR2FzKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwodHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJjYWxsXCIpLmNhbGwoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBkZWxldGUgcG9wLmZyb207XG4gICAgICAgIGNvbnN0IHR4T2JqID0gVHJhbnNhY3Rpb24uZnJvbShwb3ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuYnJvYWRjYXN0VHJhbnNhY3Rpb24oYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHhPYmopKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVm9pZFNpZ25lcioqIGlzIGEgY2xhc3MgZGVpc2duZWQgdG8gYWxsb3cgYW4gYWRkcmVzcyB0byBiZSB1c2VkXG4gKiAgaW4gYW55IEFQSSB3aGljaCBhY2NlcHRzIGEgU2lnbmVyLCBidXQgZm9yIHdoaWNoIHRoZXJlIGFyZSBub1xuICogIGNyZWRlbnRpYWxzIGF2YWlsYWJsZSB0byBwZXJmb3JtIGFueSBhY3R1YWwgc2lnbmluZy5cbiAqXG4gKiAgVGhpcyBmb3IgZXhhbXBsZSBhbGxvdyBpbXBlcnNvbmF0aW5nIGFuIGFjY291bnQgZm9yIHRoZSBwdXJwb3NlIG9mXG4gKiAgc3RhdGljIGNhbGxzIG9yIGVzdGltYXRpbmcgZ2FzLCBidXQgZG9lcyBub3QgYWxsb3cgc2VuZGluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlZvaWRTaWduZXIqKiB3aXRoICUlYWRkcmVzcyUlIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxuICAgICN0aHJvd1Vuc3VwcG9ydGVkKHN1ZmZpeCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVBZGRyZXNzIiwiVHJhbnNhY3Rpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImNvcHlSZXF1ZXN0IiwiY2hlY2tQcm92aWRlciIsInNpZ25lciIsIm9wZXJhdGlvbiIsInByb3ZpZGVyIiwicG9wdWxhdGUiLCJ0eCIsInBvcCIsInRvIiwiZnJvbSIsIlByb21pc2UiLCJhbGwiLCJnZXRBZGRyZXNzIiwidGhlbiIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsIkFic3RyYWN0U2lnbmVyIiwiY29uc3RydWN0b3IiLCJnZXROb25jZSIsImJsb2NrVGFnIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsInBvcHVsYXRlQ2FsbCIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJub25jZSIsImdhc0xpbWl0IiwiZXN0aW1hdGVHYXMiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJoYXNFaXAxNTU5IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJnYXNQcmljZSIsInR5cGUiLCJmZWVEYXRhIiwiZ2V0RmVlRGF0YSIsImNhbGwiLCJyZXNvbHZlTmFtZSIsIm5hbWUiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0eE9iaiIsImJyb2FkY2FzdFRyYW5zYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwiVm9pZFNpZ25lciIsImNvbm5lY3QiLCJ0aHJvd1Vuc3VwcG9ydGVkIiwic3VmZml4Iiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnblR5cGVkRGF0YSIsImRvbWFpbiIsInR5cGVzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/ens-resolver.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasicMulticoinProviderPlugin: () => (/* binding */ BasicMulticoinProviderPlugin),\n/* harmony export */   EnsResolver: () => (/* binding */ EnsResolver),\n/* harmony export */   MulticoinProviderPlugin: () => (/* binding */ MulticoinProviderPlugin)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/constants/addresses.js\");\n/* harmony import */ var _contract_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contract/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/namehash.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/base58.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */ \n\n\n\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */ class MulticoinProviderPlugin {\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */ constructor(name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            name\n        });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */ supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */ async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */ async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */ class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */ constructor(){\n        super(BasicMulticoinPluginId);\n    }\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */ class EnsResolver {\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            provider,\n            address,\n            name\n        });\n        this.#supports2544 = null;\n        this.#resolver = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\"\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */ async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async ()=>{\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: {\n                    funcName\n                }\n            });\n            params = [\n                (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.dnsEncode)(this.name),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        } catch (error) {\n            if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */ async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            } catch (error) {\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [\n                ethCoinType\n            ]);\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(data, 20)) {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_6__.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins){\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [\n            coinType\n        ]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: {\n                coinType,\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */ async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [\n            key\n        ]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */ async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: {\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */ async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */ async _getAvatar() {\n        const linkage = [\n            {\n                type: \"name\",\n                value: this.name\n            }\n        ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({\n                    type: \"!avatar\",\n                    value: \"\"\n                });\n                return {\n                    url: null,\n                    linkage\n                };\n            }\n            linkage.push({\n                type: \"avatar\",\n                value: avatar\n            });\n            for(let i = 0; i < matchers.length; i++){\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch(scheme){\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({\n                            type: \"url\",\n                            value: avatar\n                        });\n                        return {\n                            linkage,\n                            url: avatar\n                        };\n                    case \"ipfs\":\n                        {\n                            const url = getIpfsLink(avatar);\n                            linkage.push({\n                                type: \"ipfs\",\n                                value: avatar\n                            });\n                            linkage.push({\n                                type: \"url\",\n                                value: url\n                            });\n                            return {\n                                linkage,\n                                url\n                            };\n                        }\n                    case \"erc721\":\n                    case \"erc1155\":\n                        {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                            linkage.push({\n                                type: scheme,\n                                value: avatar\n                            });\n                            // The owner of this name\n                            const owner = await this.getAddress();\n                            if (owner == null) {\n                                linkage.push({\n                                    type: \"!owner\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                linkage.push({\n                                    type: `!${scheme}caip`,\n                                    value: match[2] || \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const tokenId = comps[1];\n                            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(comps[0], [\n                                // ERC-721\n                                \"function tokenURI(uint) view returns (string)\",\n                                \"function ownerOf(uint) view returns (address)\",\n                                // ERC-1155\n                                \"function uri(uint) view returns (string)\",\n                                \"function balanceOf(address, uint256) view returns (uint)\"\n                            ], this.provider);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                const tokenOwner = await contract.ownerOf(tokenId);\n                                if (owner !== tokenOwner) {\n                                    linkage.push({\n                                        type: \"!owner\",\n                                        value: tokenOwner\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"owner\",\n                                    value: tokenOwner\n                                });\n                            } else if (scheme === \"erc1155\") {\n                                const balance = await contract.balanceOf(owner, tokenId);\n                                if (!balance) {\n                                    linkage.push({\n                                        type: \"!balance\",\n                                        value: \"0\"\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"balance\",\n                                    value: balance.toString()\n                                });\n                            }\n                            // Call the token contract for the metadata URL\n                            let metadataUrl = await contract[selector](tokenId);\n                            if (metadataUrl == null || metadataUrl === \"0x\") {\n                                linkage.push({\n                                    type: \"!metadata-url\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata-url-base\",\n                                value: metadataUrl\n                            });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.toBeHex)(tokenId, 32).substring(2));\n                                linkage.push({\n                                    type: \"metadata-url-expanded\",\n                                    value: metadataUrl\n                                });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({\n                                type: \"metadata-url\",\n                                value: metadataUrl\n                            });\n                            // Get the token metadata\n                            let metadata = {};\n                            const response = await new _utils_index_js__WEBPACK_IMPORTED_MODULE_9__.FetchRequest(metadataUrl).send();\n                            response.assertOk();\n                            try {\n                                metadata = response.bodyJson;\n                            } catch (error) {\n                                try {\n                                    linkage.push({\n                                        type: \"!metadata\",\n                                        value: response.bodyText\n                                    });\n                                } catch (error) {\n                                    const bytes = response.body;\n                                    if (bytes) {\n                                        linkage.push({\n                                            type: \"!metadata\",\n                                            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes)\n                                        });\n                                    }\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (!metadata) {\n                                linkage.push({\n                                    type: \"!metadata\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata\",\n                                value: JSON.stringify(metadata)\n                            });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof imageUrl !== \"string\") {\n                                linkage.push({\n                                    type: \"!imageUrl\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                            } else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    linkage.push({\n                                        type: \"!imageUrl-ipfs\",\n                                        value: imageUrl\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"imageUrl-ipfs\",\n                                    value: imageUrl\n                                });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({\n                                type: \"url\",\n                                value: imageUrl\n                            });\n                            return {\n                                linkage,\n                                url: imageUrl\n                            };\n                        }\n                }\n            }\n        } catch (error) {}\n        return {\n            linkage,\n            url: null\n        };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\",\n            info: {\n                network\n            }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new _contract_index_js__WEBPACK_IMPORTED_MODULE_2__.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === _constants_index_js__WEBPACK_IMPORTED_MODULE_4__.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */ static async fromName(provider, name) {\n        let currentName = name;\n        while(true){\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !await resolver.supportsWildcard()) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n} //# sourceMappingURL=ens-resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Vucy1yZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDZ0Q7QUFDRztBQUNKO0FBQ087QUFDMEY7QUFDakoscURBQXFEO0FBQ3JELGlFQUFpRTtBQUNqRSxTQUFTYyxZQUFZQyxJQUFJO0lBQ3JCLElBQUlBLEtBQUtDLEtBQUssQ0FBQyxzQkFBc0I7UUFDakNELE9BQU9BLEtBQUtFLFNBQVMsQ0FBQztJQUMxQixPQUNLLElBQUlGLEtBQUtDLEtBQUssQ0FBQyxnQkFBZ0I7UUFDaENELE9BQU9BLEtBQUtFLFNBQVMsQ0FBQztJQUMxQixPQUNLO1FBQ0ROLCtEQUFjQSxDQUFDLE9BQU8sMkJBQTJCLFFBQVFJO0lBQzdEO0lBQ0EsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLENBQUM7QUFDbEQ7OztBQUdBOztDQUVDLEdBQ00sTUFBTUc7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDZFosaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUFFWTtRQUFLO0lBQ2xDO0lBQ0FDLFFBQVFDLFFBQVEsRUFBRTtRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREMsaUJBQWlCQyxRQUFRLEVBQUU7UUFDdkIsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxjQUFjRCxRQUFRLEVBQUVFLE9BQU8sRUFBRTtRQUNuQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGNBQWNKLFFBQVEsRUFBRUssSUFBSSxFQUFFO1FBQ2hDLE1BQU0sSUFBSUYsTUFBTTtJQUNwQjtBQUNKO0FBQ0EsTUFBTUcseUJBQXlCO0FBQy9COzs7O0NBSUMsR0FDTSxNQUFNQyxxQ0FBcUNiO0lBQzlDOztLQUVDLEdBQ0RDLGFBQWM7UUFDVixLQUFLLENBQUNXO0lBQ1Y7QUFDSjtBQUNBLE1BQU1FLGNB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LElBQUksQ0FBQztRQUN2RDtJQUNKO0FBQ0osRUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzPzQyMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRU5TIGlzIGEgc2VydmljZSB3aGljaCBhbGxvd3MgZWFzeS10by1yZW1lbWJlciBuYW1lcyB0byBtYXAgdG9cbiAqICBuZXR3b3JrIGFkZHJlc3Nlcy5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2Vucy1yZXNvbHZlcjpFTlMgUmVzb2x2ZXIgIFthYm91dC1lbnMtcnNvbHZlcl1cbiAqL1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBaZXJvQWRkcmVzcyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCI7XG5pbXBvcnQgeyBkbnNFbmNvZGUsIG5hbWVoYXNoIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzSGV4U3RyaW5nLCB0b0JlSGV4LCBkZWZpbmVQcm9wZXJ0aWVzLCBlbmNvZGVCYXNlNTgsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIGlzRXJyb3IsIEZldGNoUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIHVzZSB0aGUgZmV0Y2gtZGF0YTppcGZzIGdhdGV3YXlcbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIElQRlMgZm9ybWF0XCIsIFwibGlua1wiLCBsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIGBodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvJHtsaW5rfWA7XG59XG47XG47XG4vKipcbiAqICBBIHByb3ZpZGVyIHBsdWdpbiBzdXBlci1jbGFzcyBmb3IgcHJvY2Vzc2luZyBtdWx0aWNvaW4gYWRkcmVzcyB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk11bHRpY29pblByb3ZpZGVyUGx1aW5nKiogZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvaXZkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUlY29pblR5cGUlJSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgc3VwcG9ydHNDb2luVHlwZShjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvdmxlcyB0byB0aGUgZW5jb2RlZCAlJWFkZHJlc3MlJSBmb3IgJSVjb2luVHlwZSUlLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZUFkZHJlc3MoY29pblR5cGUsIGFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY29pblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc292bGVzIHRvIHRoZSBkZWNvZGVkICUlZGF0YSUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2ljTXVsdGljb2luUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5CYXNpY011bHRpY29pblwiO1xuLyoqXG4gKiAgQSAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKiBwcm92aWRlcyBzZXJ2aWNlIGZvciBjb21tb25cbiAqICBjb2luIHR5cGVzLCB3aGljaCBkbyBub3QgcmVxdWlyZSBhZGRpdGlvbmFsIGxpYnJhcmllcyB0byBlbmNvZGUgb3JcbiAqICBkZWNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIGV4dGVuZHMgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihCYXNpY011bHRpY29pblBsdWdpbklkKTtcbiAgICB9XG59XG5jb25zdCBtYXRjaGVySXBmcyA9IG5ldyBSZWdFeHAoXCJeKGlwZnMpOi9cXC8oLiopJFwiLCBcImlcIik7XG5jb25zdCBtYXRjaGVycyA9IFtcbiAgICBuZXcgUmVnRXhwKFwiXihodHRwcyk6L1xcLyguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihkYXRhKTooLiopJFwiLCBcImlcIiksXG4gICAgbWF0Y2hlcklwZnMsXG4gICAgbmV3IFJlZ0V4cChcIl5laXAxNTU6WzAtOV0rLyhlcmNbMC05XSspOiguKikkXCIsIFwiaVwiKSxcbl07XG4vKipcbiAqICBBIGNvbm5lY3RlZCBvYmplY3QgdG8gYSByZXNvbHZlZCBFTlMgbmFtZSByZXNvbHZlciwgd2hpY2ggY2FuIGJlXG4gKiAgdXNlZCB0byBxdWVyeSBhZGRpdGlvbmFsIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNSZXNvbHZlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSByZXNvbHZlci5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSB0aGlzIHJlc29sdmVyIHdhcyByZXNvbHZlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLy8gRm9yIEVJUC0yNTQ0IG5hbWVzLCB0aGUgYW5jZXN0b3IgdGhhdCBwcm92aWRlZCB0aGUgcmVzb2x2ZXJcbiAgICAjc3VwcG9ydHMyNTQ0O1xuICAgICNyZXNvbHZlcjtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUgfSk7XG4gICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVyID0gbmV3IENvbnRyYWN0KGFkZHJlc3MsIFtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0KSB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmUoYnl0ZXMsIGJ5dGVzKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBhZGRyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyLCB1aW50KSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiB0ZXh0KGJ5dGVzMzIsIHN0cmluZykgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGNvbnRlbnRoYXNoKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYnl0ZXMpXCIsXG4gICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIHJlc29sdmVyIHN1cHBvcnRzIHdpbGRjYXJkIHJlc29sdXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3N1cHBvcnRzMjU0NCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXNvbHZlci5zdXBwb3J0c0ludGVyZmFjZShcIjB4OTA2MWI5MjNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCByZXNvbHZlcnMgbXVzdCB1bmRlcnN0YW5kIHN1cHBvcnRzSW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQgZnV0dXJlIGF0dGVtcHRzIHRyeSBhZ2Fpbi4uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdXBwb3J0czI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzdXBwb3J0czI1NDQ7XG4gICAgfVxuICAgIGFzeW5jICNmZXRjaChmdW5jTmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gdGhpcy4jcmVzb2x2ZXIuaW50ZXJmYWNlO1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVycyBpcyBhbHdheXMgdGhlIG5vZGVoYXNoXG4gICAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWVoYXNoKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0KGZyYWdtZW50LCBcIm1pc3NpbmcgZnJhZ21lbnRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHtcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGZ1bmNOYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGRuc0VuY29kZSh0aGlzLm5hbWUpLFxuICAgICAgICAgICAgICAgIGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcGFyYW1zKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZ1bmNOYW1lID0gXCJyZXNvbHZlKGJ5dGVzLGJ5dGVzKVwiO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgICAgICAgIGVuYWJsZUNjaXBSZWFkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcmVzb2x2ZXJbZnVuY05hbWVdKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdClbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVjb2luVHlwZSUlIG9yIG51bGwgaWYgdGhlXG4gICAgICogIHByb3ZpZGVkICUlY29pblR5cGUlJSBoYXMgbm90IGJlZW4gY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKGNvaW5UeXBlKSB7XG4gICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luVHlwZSA9PT0gNjApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIpXCIpO1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBaZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcbiAgICAgICAgaWYgKGNvaW5UeXBlID49IDAgJiYgY29pblR5cGUgPCAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICBsZXQgZXRoQ29pblR5cGUgPSBjb2luVHlwZSArIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoZGF0YSwgMjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvaW5QbHVnaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnByb3ZpZGVyLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmICghKHBsdWdpbiBpbnN0YW5jZW9mIE11bHRpY29pblByb3ZpZGVyUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvaW5QbHVnaW4gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5QbHVnaW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTZcIilcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwiYWRkcihieXRlczMyLHVpbnQpXCIsIFtjb2luVHlwZV0pO1xuICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBjb2luUGx1Z2luLmRlY29kZUFkZHJlc3MoY29pblR5cGUsIGRhdGEpO1xuICAgICAgICBpZiAoYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIGNvaW4gZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgIGluZm86IHsgY29pblR5cGUsIGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBFSVAtNjM0IHRleHQgcmVjb3JkIGZvciAlJWtleSUlLCBvciBgYG51bGxgYFxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSc29sdmVzIHRvIHRoZSBjb250ZW50LWhhc2ggb3IgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xuICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImNvbnRlbnRoYXNoKGJ5dGVzMzIpXCIpO1xuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiA3MD1EQUctUEIsIDcyPWxpYnAycC1rZXkpXG4gICAgICAgIGNvbnN0IGlwZnMgPSBkYXRhLm1hdGNoKC9eMHgoZTMwMTAxNzB8ZTUwMTAxNzIpKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IChpcGZzWzFdID09PSBcImUzMDEwMTcwXCIpID8gXCJpcGZzXCIgOiBcImlwbnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbNF0sIDE2KTtcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzY2hlbWV9Oi9cXC8ke2VuY29kZUJhc2U1OChcIjB4XCIgKyBpcGZzWzJdKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgY29uc3Qgc3dhcm0gPSBkYXRhLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICBpZiAoc3dhcm0gJiYgc3dhcm1bMV0ubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgcmV0dXJuIGBieno6L1xcLyR7c3dhcm1bMV19YDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcbiAgICAgICAgICAgIGluZm86IHsgZGF0YSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGF2YXRhciB1cmwgb3IgYGBudWxsYGAgaWYgdGhlIGF2YXRhciBpcyBlaXRoZXJcbiAgICAgKiAgdW5jb25maWd1cmVkIG9yIGluY29ycmVjdGx5IGNvbmZpZ3VyZWQgKGUuZy4gcmVmZXJlbmNlcyBhbiBORlRcbiAgICAgKiAgbm90IG93bmVkIGJ5IHRoZSBhZGRyZXNzKS5cbiAgICAgKlxuICAgICAqICBJZiBkaWFnbm9zaW5nIGlzc3VlcyB3aXRoIGNvbmZpZ3VyYXRpb25zLCB0aGUgW1tfZ2V0QXZhdGFyXV1cbiAgICAgKiAgbWV0aG9kIG1heSBiZSB1c2VmdWwuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXZhdGFyKCkge1xuICAgICAgICBjb25zdCBhdmF0YXIgPSBhd2FpdCB0aGlzLl9nZXRBdmF0YXIoKTtcbiAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGVuIHJlc29sdmluZyBhbiBhdmF0YXIsIHRoZXJlIGFyZSBtYW55IHN0ZXBzIGludm9sdmVkLCBzdWNoXG4gICAgICogIGZldGNoaW5nIG1ldGFkYXRhIGFuZCBwb3NzaWJseSB2YWxpZGF0aW5nIG93bmVyc2hpcCBvZiBhblxuICAgICAqICBORlQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZXhhbWluZSBlYWNoIHN0ZXAgYW5kIHRoZSB2YWx1ZSBpdFxuICAgICAqICB3YXMgd29ya2luZyBmcm9tLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRlc3QgZGF0YSBmb3IgcmljbW9vLmV0aFxuICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWF2YXRhclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYXZhdGFyXCIsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpcGZzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldElwZnNMaW5rKGF2YXRhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmMxMTU1XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcInRva2VuVVJJKHVpbnQyNTYpXCIgOiBcInVyaSh1aW50MjU2KVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG93bmVyIG9mIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogYCEke3NjaGVtZX1jYWlwYCwgdmFsdWU6IChtYXRjaFsyXSB8fCBcIlwiKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBjb21wc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbXBzWzBdLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTcyMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdG9rZW5VUkkodWludCkgdmlldyByZXR1cm5zIChzdHJpbmcpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBvd25lck9mKHVpbnQpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gdXJpKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MsIHVpbnQyNTYpIHZpZXcgcmV0dXJucyAodWludClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSBhd2FpdCBjb250cmFjdC5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogdG9rZW5Pd25lciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwib3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbnRyYWN0LmJhbGFuY2VPZihvd25lciwgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWJhbGFuY2VcIiwgdmFsdWU6IFwiMFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIHZhbHVlOiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB0b2tlbiBjb250cmFjdCBmb3IgdGhlIG1ldGFkYXRhIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhVXJsID0gYXdhaXQgY29udHJhY3Rbc2VsZWN0b3JdKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwgfHwgbWV0YWRhdGFVcmwgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhLXVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b0JlSGV4KHRva2VuSWQsIDMyKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWV4cGFuZGVkXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gZ2V0SXBmc0xpbmsobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChuZXcgRmV0Y2hSZXF1ZXN0KG1ldGFkYXRhVXJsKSkuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiByZXNwb25zZS5ib2R5VGV4dCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogaGV4bGlmeShieXRlcykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIW1ldGFkYXRhXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpbWFnZVVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybFwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVVybC5tYXRjaCgvXihodHRwczpcXC9cXC98ZGF0YTopL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlwZnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaW1hZ2VVcmwtaXBmc1wiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmwgPSBnZXRJcGZzTGluayhpbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBudWxsIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBnZXRFbnNBZGRyZXNzKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGVuc1BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRW5zXCIpO1xuICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgYXNzZXJ0KGVuc1BsdWdpbiwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRFbnNBZGRyZXNzXCIsIGluZm86IHsgbmV0d29yayB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5zUGx1Z2luLmFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoZW5zQWRkciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gcmVzb2x2ZXIoYnl0ZXMzMikgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG4gICAgICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgY29udHJhY3QucmVzb2x2ZXIobmFtZWhhc2gobmFtZSksIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMiksXG4gICAgICAgICAgICAvLyBzbyBwcm9iYWJseSBhIGxpbmsgZXJyb3JcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgRU5TIHJlc29sdmVyIGZvciAlJW5hbWUlJSB1c2luZyAlJXByb3ZpZGVyJSUgb3JcbiAgICAgKiAgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tTmFtZShwcm92aWRlciwgbmFtZSkge1xuICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXJkIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLiNnZXRSZXNvbHZlcihwcm92aWRlciwgY3VycmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gRm91bmQgYSByZXNvbHZlciFcbiAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBFbnNSZXNvbHZlcihwcm92aWRlciwgYWRkciwgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKGF3YWl0IHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zLXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiWmVyb0FkZHJlc3MiLCJDb250cmFjdCIsImRuc0VuY29kZSIsIm5hbWVoYXNoIiwiaGV4bGlmeSIsImlzSGV4U3RyaW5nIiwidG9CZUhleCIsImRlZmluZVByb3BlcnRpZXMiLCJlbmNvZGVCYXNlNTgiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImlzRXJyb3IiLCJGZXRjaFJlcXVlc3QiLCJnZXRJcGZzTGluayIsImxpbmsiLCJtYXRjaCIsInN1YnN0cmluZyIsIk11bHRpY29pblByb3ZpZGVyUGx1Z2luIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29ubmVjdCIsInByb2l2ZGVyIiwic3VwcG9ydHNDb2luVHlwZSIsImNvaW5UeXBlIiwiZW5jb2RlQWRkcmVzcyIsImFkZHJlc3MiLCJFcnJvciIsImRlY29kZUFkZHJlc3MiLCJkYXRhIiwiQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCIsIkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJtYXRjaGVySXBmcyIsIlJlZ0V4cCIsIm1hdGNoZXJzIiwiRW5zUmVzb2x2ZXIiLCJzdXBwb3J0czI1NDQiLCJyZXNvbHZlciIsInByb3ZpZGVyIiwic3VwcG9ydHNXaWxkY2FyZCIsInN1cHBvcnRzSW50ZXJmYWNlIiwiZXJyb3IiLCJmZXRjaCIsImZ1bmNOYW1lIiwicGFyYW1zIiwic2xpY2UiLCJpZmFjZSIsImludGVyZmFjZSIsInVuc2hpZnQiLCJmcmFnbWVudCIsImdldEZ1bmN0aW9uIiwiaW5mbyIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInB1c2giLCJlbmFibGVDY2lwUmVhZCIsInJlc3VsdCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiZXRoQ29pblR5cGUiLCJjb2luUGx1Z2luIiwicGx1Z2luIiwicGx1Z2lucyIsIm9wZXJhdGlvbiIsImdldFRleHQiLCJrZXkiLCJnZXRDb250ZW50SGFzaCIsImlwZnMiLCJzY2hlbWUiLCJsZW5ndGgiLCJwYXJzZUludCIsInN3YXJtIiwiZ2V0QXZhdGFyIiwiYXZhdGFyIiwiX2dldEF2YXRhciIsInVybCIsImxpbmthZ2UiLCJ0eXBlIiwidmFsdWUiLCJpIiwidG9Mb3dlckNhc2UiLCJzZWxlY3RvciIsIm93bmVyIiwiY29tcHMiLCJzcGxpdCIsInRva2VuSWQiLCJjb250cmFjdCIsInRva2VuT3duZXIiLCJvd25lck9mIiwiYmFsYW5jZSIsImJhbGFuY2VPZiIsInRvU3RyaW5nIiwibWV0YWRhdGFVcmwiLCJyZXBsYWNlIiwibWV0YWRhdGEiLCJyZXNwb25zZSIsInNlbmQiLCJhc3NlcnRPayIsImJvZHlKc29uIiwiYm9keVRleHQiLCJieXRlcyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1hZ2VVcmwiLCJpbWFnZSIsImdldEVuc0FkZHJlc3MiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImVuc1BsdWdpbiIsImdldFBsdWdpbiIsImdldFJlc29sdmVyIiwiZW5zQWRkciIsImFkZHIiLCJmcm9tTmFtZSIsImN1cnJlbnROYW1lIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/ens-resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allowNull: () => (/* binding */ allowNull),\n/* harmony export */   arrayOf: () => (/* binding */ arrayOf),\n/* harmony export */   formatBlock: () => (/* binding */ formatBlock),\n/* harmony export */   formatBoolean: () => (/* binding */ formatBoolean),\n/* harmony export */   formatData: () => (/* binding */ formatData),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   formatLog: () => (/* binding */ formatLog),\n/* harmony export */   formatReceiptLog: () => (/* binding */ formatReceiptLog),\n/* harmony export */   formatTransactionReceipt: () => (/* binding */ formatTransactionReceipt),\n/* harmony export */   formatTransactionResponse: () => (/* binding */ formatTransactionResponse),\n/* harmony export */   formatUint256: () => (/* binding */ formatUint256),\n/* harmony export */   object: () => (/* binding */ object)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/contract-address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  @_ignore\n */ \n\n\n\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return function(value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    };\n}\nfunction arrayOf(format) {\n    return (array)=>{\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i)=>format(i));\n    };\n}\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return (value)=>{\n        const result = {};\n        for(const key in format){\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]){\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            } catch (error) {\n                const message = error instanceof Error ? error.message : \"not-an-error\";\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", {\n                    value\n                });\n            }\n        }\n        return result;\n    };\n}\nfunction formatBoolean(value) {\n    switch(value){\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nfunction formatData(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nfunction formatHash(value) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nfunction formatUint256(value) {\n    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.zeroPadValue)(value, 32);\n}\nconst _formatLog = object({\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    blockHash: formatHash,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    number: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    timestamp: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    miner: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress),\n    extraData: formatData,\n    baseFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx)=>{\n        if (typeof tx === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nconst _formatReceiptLog = object({\n    transactionIndex: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    transactionHash: formatHash,\n    address: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    blockHash: formatHash\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nconst _formatTransactionReceipt = object({\n    to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    from: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    contractAddress: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    root: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify),\n    gasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n    effectiveGasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n    status: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber),\n    type: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, 0)\n}, {\n    effectiveGasPrice: [\n        \"gasPrice\"\n    ],\n    hash: [\n        \"transactionHash\"\n    ],\n    index: [\n        \"transactionIndex\"\n    ]\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        type: (value)=>{\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value);\n        },\n        accessList: allowNull(_transaction_index_js__WEBPACK_IMPORTED_MODULE_4__.accessListify, null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        transactionIndex: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber, null),\n        //confirmations: allowNull(getNumber, null),\n        from: _address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxPriorityFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        maxFeePerGas: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt),\n        gasLimit: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        to: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        value: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt,\n        nonce: _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber,\n        data: formatData,\n        creates: allowNull(_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress, null),\n        chainId: allowNull(_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt, null)\n    }, {\n        data: [\n            \"input\"\n        ],\n        gasLimit: [\n            \"gas\"\n        ]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_5__.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(value.signature);\n    } else {\n        result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */ // 0x0000... should actually be null\n    if (result.blockHash && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n} //# sourceMappingURL=format.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDa0U7QUFDcEI7QUFDUztBQUM2RDtBQUNySCxNQUFNVyxPQUFPQyxPQUFPO0FBQ2IsU0FBU0MsVUFBVUMsTUFBTSxFQUFFQyxTQUFTO0lBQ3ZDLE9BQVEsU0FBVUMsS0FBSztRQUNuQixJQUFJQSxTQUFTLE1BQU07WUFDZixPQUFPRDtRQUNYO1FBQ0EsT0FBT0QsT0FBT0U7SUFDbEI7QUFDSjtBQUNPLFNBQVNDLFFBQVFILE1BQU07SUFDMUIsT0FBUSxDQUFDSTtRQUNMLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1lBQ3ZCLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLE9BQU9ILE1BQU1JLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxPQUFPUztJQUNuQztBQUNKO0FBQ0EsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSxpREFBaUQ7QUFDMUMsU0FBU0MsT0FBT1YsTUFBTSxFQUFFVyxRQUFRO0lBQ25DLE9BQVEsQ0FBQ1Q7UUFDTCxNQUFNVSxTQUFTLENBQUM7UUFDaEIsSUFBSyxNQUFNQyxPQUFPYixPQUFRO1lBQ3RCLElBQUljLFNBQVNEO1lBQ2IsSUFBSUYsWUFBWUUsT0FBT0YsWUFBWSxDQUFFRyxDQUFBQSxVQUFVWixLQUFJLEdBQUk7Z0JBQ25ELEtBQUssTUFBTWEsVUFBVUosUUFBUSxDQUFDRSxJQUFJLENBQUU7b0JBQ2hDLElBQUlFLFVBQVViLE9BQU87d0JBQ2pCWSxTQUFTQzt3QkFDVDtvQkFDSjtnQkFDSjtZQUNKO1lBQ0EsSUFBSTtnQkFDQSxNQUFNQyxLQUFLaEIsTUFBTSxDQUFDYSxJQUFJLENBQUNYLEtBQUssQ0FBQ1ksT0FBTztnQkFDcEMsSUFBSUUsT0FBT0MsV0FBVztvQkFDbEJMLE1BQU0sQ0FBQ0MsSUFBSSxHQUFHRztnQkFDbEI7WUFD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QUFDQyxhQUFhO1FBQzlDLElBQUlGLFdBQVcsTUFBTTtZQUNqQjVELE9BQU80RCxPQUFPLEdBQUdBO1FBQ3JCO0lBQ0o7SUFDQSx1QkFBdUI7SUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZ0NBLEdBQ0Esb0NBQW9DO0lBQ3BDLElBQUk1RCxPQUFPZ0IsU0FBUyxJQUFJdEMsMERBQVNBLENBQUNzQixPQUFPZ0IsU0FBUyxNQUFNL0IsTUFBTTtRQUMxRGUsT0FBT2dCLFNBQVMsR0FBRztJQUN2QjtJQUNBLE9BQU9oQjtBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL2Zvcm1hdC5qcz83YzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MsIGdldENyZWF0ZUFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGlzSGV4U3RyaW5nLCB6ZXJvUGFkVmFsdWUsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5leHBvcnQgZnVuY3Rpb24gYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPZihmb3JtYXQpIHtcbiAgICByZXR1cm4gKChhcnJheSkgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoaSkgPT4gZm9ybWF0KGkpKTtcbiAgICB9KTtcbn1cbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xuLy8gQW55IEZvcm1hdEZ1bmMgbWF5IHJldHVybiBgdW5kZWZpbmVkYCB0byBoYXZlIHRoZSB2YWx1ZSBvbWl0dGVkXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KGZvcm1hdCwgYWx0TmFtZXMpIHtcbiAgICByZXR1cm4gKCh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybWF0KSB7XG4gICAgICAgICAgICBsZXQgc3JjS2V5ID0ga2V5O1xuICAgICAgICAgICAgaWYgKGFsdE5hbWVzICYmIGtleSBpbiBhbHROYW1lcyAmJiAhKHNyY0tleSBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsdEtleSBvZiBhbHROYW1lc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHRLZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY0tleSA9IGFsdEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudiA9IGZvcm1hdFtrZXldKHZhbHVlW3NyY0tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChudiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBcIm5vdC1hbi1lcnJvclwiO1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCb29sZWFuKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBib29sZWFuOyAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRhKHZhbHVlKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpLCBcImludmFsaWQgZGF0YVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SGFzaCh2YWx1ZSkge1xuICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHZhbHVlLCAzMiksIFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVaW50MjU2KHZhbHVlKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgIH1cbiAgICByZXR1cm4gemVyb1BhZFZhbHVlKHZhbHVlLCAzMik7XG59XG5jb25zdCBfZm9ybWF0TG9nID0gb2JqZWN0KHtcbiAgICBhZGRyZXNzOiBnZXRBZGRyZXNzLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBibG9ja051bWJlcjogZ2V0TnVtYmVyLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByZW1vdmVkOiBhbGxvd051bGwoZm9ybWF0Qm9vbGVhbiwgZmFsc2UpLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgdHJhbnNhY3Rpb25JbmRleDogZ2V0TnVtYmVyLFxufSwge1xuICAgIGluZGV4OiBbXCJsb2dJbmRleFwiXVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TG9nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXG4gICAgcGFyZW50SGFzaDogZm9ybWF0SGFzaCxcbiAgICBudW1iZXI6IGdldE51bWJlcixcbiAgICB0aW1lc3RhbXA6IGdldE51bWJlcixcbiAgICBub25jZTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGRpZmZpY3VsdHk6IGdldEJpZ0ludCxcbiAgICBnYXNMaW1pdDogZ2V0QmlnSW50LFxuICAgIGdhc1VzZWQ6IGdldEJpZ0ludCxcbiAgICBtaW5lcjogYWxsb3dOdWxsKGdldEFkZHJlc3MpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoZ2V0QmlnSW50KVxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0QmxvY2sodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBfZm9ybWF0QmxvY2sodmFsdWUpO1xuICAgIHJlc3VsdC50cmFuc2FjdGlvbnMgPSB2YWx1ZS50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0VHJhbnNhY3Rpb25SZXNwb25zZSh0eCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IF9mb3JtYXRSZWNlaXB0TG9nID0gb2JqZWN0KHtcbiAgICB0cmFuc2FjdGlvbkluZGV4OiBnZXROdW1iZXIsXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgYWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICB0b3BpY3M6IGFycmF5T2YoZm9ybWF0SGFzaCksXG4gICAgZGF0YTogZm9ybWF0RGF0YSxcbiAgICBpbmRleDogZ2V0TnVtYmVyLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJlY2VpcHRMb2codmFsdWUpIHtcbiAgICByZXR1cm4gX2Zvcm1hdFJlY2VpcHRMb2codmFsdWUpO1xufVxuY29uc3QgX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IG9iamVjdCh7XG4gICAgdG86IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICBmcm9tOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgY29udHJhY3RBZGRyZXNzOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgaW5kZXg6IGdldE51bWJlcixcbiAgICByb290OiBhbGxvd051bGwoaGV4bGlmeSksXG4gICAgZ2FzVXNlZDogZ2V0QmlnSW50LFxuICAgIGxvZ3NCbG9vbTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgIGxvZ3M6IGFycmF5T2YoZm9ybWF0UmVjZWlwdExvZyksXG4gICAgYmxvY2tOdW1iZXI6IGdldE51bWJlcixcbiAgICAvL2NvbmZpcm1hdGlvbnM6IGFsbG93TnVsbChnZXROdW1iZXIsIG51bGwpLFxuICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBnZXRCaWdJbnQsXG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgIHN0YXR1czogYWxsb3dOdWxsKGdldE51bWJlciksXG4gICAgdHlwZTogYWxsb3dOdWxsKGdldE51bWJlciwgMClcbn0sIHtcbiAgICBlZmZlY3RpdmVHYXNQcmljZTogW1wiZ2FzUHJpY2VcIl0sXG4gICAgaGFzaDogW1widHJhbnNhY3Rpb25IYXNoXCJdLFxuICAgIGluZGV4OiBbXCJ0cmFuc2FjdGlvbkluZGV4XCJdLFxufSk7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodmFsdWUpIHtcbiAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgLy8gMCBhZGRyZXNzOyBjb3JyZWN0IHRoaXMgdG8gYmUgYSByZWFsIGFkZHJlc3NcbiAgICBpZiAodmFsdWUudG8gJiYgZ2V0QmlnSW50KHZhbHVlLnRvKSA9PT0gQk5fMCkge1xuICAgICAgICB2YWx1ZS50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9iamVjdCh7XG4gICAgICAgIGhhc2g6IGZvcm1hdEhhc2gsXG4gICAgICAgIHR5cGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFsbG93TnVsbChhY2Nlc3NMaXN0aWZ5LCBudWxsKSxcbiAgICAgICAgYmxvY2tIYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCwgbnVsbCksXG4gICAgICAgIGJsb2NrTnVtYmVyOiBhbGxvd051bGwoZ2V0TnVtYmVyLCBudWxsKSxcbiAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGdldEFkZHJlc3MsXG4gICAgICAgIC8vIGVpdGhlciAoZ2FzUHJpY2UpIG9yIChtYXhQcmlvcml0eUZlZVBlckdhcyArIG1heEZlZVBlckdhcykgbXVzdCBiZSBzZXRcbiAgICAgICAgZ2FzUHJpY2U6IGFsbG93TnVsbChnZXRCaWdJbnQpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGdldEJpZ0ludCksXG4gICAgICAgIGdhc0xpbWl0OiBnZXRCaWdJbnQsXG4gICAgICAgIHRvOiBhbGxvd051bGwoZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIHZhbHVlOiBnZXRCaWdJbnQsXG4gICAgICAgIG5vbmNlOiBnZXROdW1iZXIsXG4gICAgICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgICAgIGNyZWF0ZXM6IGFsbG93TnVsbChnZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGdldEJpZ0ludCwgbnVsbClcbiAgICB9LCB7XG4gICAgICAgIGRhdGE6IFtcImlucHV0XCJdLFxuICAgICAgICBnYXNMaW1pdDogW1wiZ2FzXCJdXG4gICAgfSkodmFsdWUpO1xuICAgIC8vIElmIHRvIGFuZCBjcmVhdGVzIGFyZSBlbXB0eSwgcG9wdWxhdGUgdGhlIGNyZWF0ZXMgZnJvbSB0aGUgdmFsdWVcbiAgICBpZiAocmVzdWx0LnRvID09IG51bGwgJiYgcmVzdWx0LmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuY3JlYXRlcyA9IGdldENyZWF0ZUFkZHJlc3MocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICgodmFsdWUudHlwZSA9PT0gMSB8fCB2YWx1ZS50eXBlID09PSAyKSAmJiB2YWx1ZS5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgc2lnbmF0dXJlXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odmFsdWUuc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNvbWUgYmFja2VuZHMgb21pdCBDaGFpbklkIG9uIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIGJ1dCB3ZSBjYW4gY29tcHV0ZSBpdFxuICAgIGlmIChyZXN1bHQuY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSByZXN1bHQuc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAVE9ETzogY2hlY2sgY2hhaW5JRFxuICAgIC8qXG4gICAgaWYgKHZhbHVlLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLmNoYWluSWQ7XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjaGFpbklkID0gdmFsdWUubmV0d29ya0lkO1xuXG4gICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IChyZXN1bHQudiAtIDM1KSAvIDI7XG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHsgY2hhaW5JZCA9IDA7IH1cbiAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHsgY2hhaW5JZCA9IDA7IH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgfVxuICAgICovXG4gICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgZ2V0QmlnSW50KHJlc3VsdC5ibG9ja0hhc2gpID09PSBCTl8wKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsIlNpZ25hdHVyZSIsImFjY2Vzc0xpc3RpZnkiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ6ZXJvUGFkVmFsdWUiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJhbGxvd051bGwiLCJmb3JtYXQiLCJudWxsVmFsdWUiLCJ2YWx1ZSIsImFycmF5T2YiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwibWFwIiwiaSIsIm9iamVjdCIsImFsdE5hbWVzIiwicmVzdWx0Iiwia2V5Iiwic3JjS2V5IiwiYWx0S2V5IiwibnYiLCJ1bmRlZmluZWQiLCJlcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXRCb29sZWFuIiwiSlNPTiIsInN0cmluZ2lmeSIsImZvcm1hdERhdGEiLCJmb3JtYXRIYXNoIiwiZm9ybWF0VWludDI1NiIsIl9mb3JtYXRMb2ciLCJhZGRyZXNzIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJkYXRhIiwiaW5kZXgiLCJyZW1vdmVkIiwidG9waWNzIiwidHJhbnNhY3Rpb25IYXNoIiwidHJhbnNhY3Rpb25JbmRleCIsImZvcm1hdExvZyIsIl9mb3JtYXRCbG9jayIsImhhc2giLCJwYXJlbnRIYXNoIiwibnVtYmVyIiwidGltZXN0YW1wIiwibm9uY2UiLCJkaWZmaWN1bHR5IiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwibWluZXIiLCJleHRyYURhdGEiLCJiYXNlRmVlUGVyR2FzIiwiZm9ybWF0QmxvY2siLCJ0cmFuc2FjdGlvbnMiLCJ0eCIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZm9ybWF0UmVjZWlwdExvZyIsImZvcm1hdFJlY2VpcHRMb2ciLCJfZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwidG8iLCJmcm9tIiwiY29udHJhY3RBZGRyZXNzIiwicm9vdCIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwic3RhdHVzIiwidHlwZSIsImZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCIsImFjY2Vzc0xpc3QiLCJnYXNQcmljZSIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwiY3JlYXRlcyIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJsZWdhY3lDaGFpbklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/format.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/network.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins-network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js\");\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */ \n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/ const Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */ class Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */ constructor(name, chainId){\n        this.#name = name;\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */ toJSON() {\n        return {\n            name: this.name,\n            chainId: String(this.chainId)\n        };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */ get name() {\n        return this.#name;\n    }\n    set name(value) {\n        this.#name = value;\n    }\n    /**\n     *  The network chain ID.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(value, \"chainId\");\n    }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */ matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof other === \"string\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return this.name === other;\n        }\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\n            try {\n                return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other);\n            } catch (error) {}\n            return false;\n        }\n        if (typeof other === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return this.chainId === (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(other.chainId);\n                } catch (error) {}\n                return false;\n            }\n            if (other.name != null) {\n                return this.name === other.name;\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */ getPlugins(basename) {\n        return this.plugins.filter((p)=>p.name.split(\"#\")[0] === basename);\n    }\n    /**\n     *  Create a copy of this Network.\n     */ clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin)=>{\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */ computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin();\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for(let i = 2; i < tx.data.length; i += 2){\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.accessListify)(tx.accessList);\n            for(const addr in accessList){\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */ static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof network === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof network === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof network.clone === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof network === \"object\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network(network.name, network.chainId);\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */ static register(nameOrChainId, networkFunc) {\n        if (typeof nameOrChainId === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while(comps[1].length < decimals){\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request)=>{\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(),\n                fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n            };\n            return feeData;\n        } catch (error) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", {\n                request,\n                response,\n                error\n            });\n        }\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function() {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new _plugins_network_js__WEBPACK_IMPORTED_MODULE_1__.GasCostPlugin());\n            (options.plugins || []).forEach((plugin)=>{\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name)=>{\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, {\n        ensNetwork: 1,\n        altNames: [\n            \"homestead\"\n        ]\n    });\n    registerEth(\"ropsten\", 3, {\n        ensNetwork: 3\n    });\n    registerEth(\"rinkeby\", 4, {\n        ensNetwork: 4\n    });\n    registerEth(\"goerli\", 5, {\n        ensNetwork: 5\n    });\n    registerEth(\"kovan\", 42, {\n        ensNetwork: 42\n    });\n    registerEth(\"sepolia\", 11155111, {\n        ensNetwork: 11155111\n    });\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"base\", 8453, {\n        ensNetwork: 1\n    });\n    registerEth(\"base-goerli\", 84531, {});\n    registerEth(\"base-sepolia\", 84532, {});\n    registerEth(\"bnb\", 56, {\n        ensNetwork: 1\n    });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, {\n        ensNetwork: 1\n    });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\n            \"maticMumbai\",\n            \"maticmum\"\n        ],\n        plugins: [\n            getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: []\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"xdai\", 100, {\n        ensNetwork: 1\n    });\n} //# sourceMappingURL=network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL25ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUN1RDtBQUNjO0FBQ3dCO0FBQzlGOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLEdBQ0EsTUFBTU8sV0FBVyxJQUFJQztBQUNyQjs7O0NBR0MsR0FDTSxNQUFNQztJQUNULENBQUNDLElBQUksQ0FBQztJQUNOLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNUOztLQUVDLEdBQ0RDLFlBQVlILElBQUksRUFBRUMsT0FBTyxDQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDRCxJQUFJLEdBQUdBO1FBQ2IsSUFBSSxDQUFDLENBQUNDLE9BQU8sR0FBR1YsMERBQVNBLENBQUNVO1FBQzFCLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUcsSUFBSUo7SUFDeEI7SUFDQTs7S0FFQyxHQUNETSxTQUFTO1FBQ0wsT0FBTztZQUFFSixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUFFQyxTQUFTSSxPQUFPLElBQUksQ0FBQ0osT0FBTztRQUFFO0lBQzVEO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJRCxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUFFO0lBQ2hDLElBQUlBLEtBQUtNLEtBQUssRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDTixJQUFJLEdBQUdNO0lBQU87SUFDdEM7O0tBRUMsR0FDRCxJQUFJTCxVQUFVO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsT0FBTztJQUFFO0lBQ3RDLElBQUlBLFFBQVFLLEtBQUssRUFBRTtRQUFFLElBQUksQ0FBQyxDQUFDTCxPQUFPLEdBQUdWLDBEQUFTQSxDQUFDZSxPQUFPO0lBQVk7SUFDbEU7Ozs7OztLQU1DLEdBQ0RDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUlBLFNBQVMsTUFBTTtZQUNmLE9BQU87UUFDWDtRQUNBLElBQUksT0FB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bGliLmVzbS9wcm92aWRlcnMvbmV0d29yay5qcz8zODFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgKipOZXR3b3JrKiogZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgcmVxdWlyZWQgdG9cbiAqICBpbnRlcmFjdCB3aXRoIGEgc3BlY2lmaWMgY2hhaW4uXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVyczpOZXR3b3JrcyAgW25ldHdvcmtzXVxuICovXG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEVuc1BsdWdpbiwgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiwgR2FzQ29zdFBsdWdpbiB9IGZyb20gXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiO1xuLyogKiAqICpcbi8vIE5ldHdvcmtzIHdoaWNoIG9wZXJhdGlvbiBhZ2FpbnN0IGFuIEwyIGNhbiB1c2UgdGhpcyBwbHVnaW4gdG9cbi8vIHNwZWNpZnkgaG93IHRvIGFjY2VzcyBMMSwgZm9yIHRoZSBwdXJwb3NlIG9mIHJlc29sdmluZyBFTlMsXG4vLyBmb3IgZXhhbXBsZS5cbmV4cG9ydCBjbGFzcyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSBwcm92aWRlciE6IFByb3ZpZGVyO1xuLy8gQFRPRE86IFJlbmFtZSB0byBDaGFpbkFjY2VzcyBhbmQgYWxsb3cgZm9yIGNvbm5lY3RpbmcgdG8gYW55IGNoYWluXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXI6IFByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLmxheWVyLW9uZS1jb25uZWN0aW9uXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzPExheWVyT25lQ29ubmVjdGlvblBsdWdpbj4odGhpcywgeyBwcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbih0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG59XG4qL1xuY29uc3QgTmV0d29ya3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqICBBICoqTmV0d29yayoqIHByb3ZpZGVzIGFjY2VzcyB0byBhIGNoYWluJ3MgcHJvcGVydGllcyBhbmQgYWxsb3dzXG4gKiAgZm9yIHBsdWctaW5zIHRvIGV4dGVuZCBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29yayB7XG4gICAgI25hbWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3BsdWdpbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrKiogZm9yICUlbmFtZSUlIGFuZCAlJWNoYWluSWQlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjaGFpbklkKSB7XG4gICAgICAgIHRoaXMuI25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KGNoYWluSWQpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIE5ldHdvcmsuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm5hbWUsIGNoYWluSWQ6IFN0cmluZyh0aGlzLmNoYWluSWQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjb21tb24gbmFtZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBjYW5vbmljYWwgbmFtZSwgYXMgbmV0d29ya3MgbWlnaCBoYXZlIG11bHRpcGxlXG4gICAgICogIG5hbWVzLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy4jbmFtZTsgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7IHRoaXMuI25hbWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gZ2V0QmlnSW50KHZhbHVlLCBcImNoYWluSWRcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBtYXRjaGVzIHRoaXMgbmV0d29yay4gQW55IGNoYWluIElEXG4gICAgICogIG11c3QgbWF0Y2gsIGFuZCBpZiBubyBjaGFpbiBJRCBpcyBwcmVzZW50LCB0aGUgbmFtZSBtdXN0IG1hdGNoLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGRvZXMgbm90IGN1cnJlbnRseSBjaGVjayBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLFxuICAgICAqICBzdWNoIGFzIEVOUyBhZGRyZXNzIG9yIHBsdWctaW4gY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICBtYXRjaGVzKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKG90aGVyKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gZ2V0QmlnSW50KG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG90aGVyLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSBnZXRCaWdJbnQob3RoZXIuY2hhaW5JZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiBwbHVnaW5zIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3ICUlcGx1Z2luJSUgdG8gdGhpcyBOZXR3b3JrLiBUaGUgbmV0d29yayBuYW1lXG4gICAgICogIG11c3QgYmUgdW5pcXVlLCBleGNsdWRpbmcgYW55IGZyYWdtZW50LlxuICAgICAqL1xuICAgIGF0dGFjaFBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbnMuZ2V0KHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVwbGFjZSBleGlzdGluZyBwbHVnaW46ICR7cGx1Z2luLm5hbWV9IGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4uY2xvbmUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBwbHVnaW4sIGlmIGFueSwgbWF0Y2hpbmcgJSVuYW1lJSUgZXhhY3RseS4gUGx1Z2luc1xuICAgICAqICB3aXRoIGZyYWdtZW50cyB3aWxsIG5vdCBiZSByZXR1cm5lZCB1bmxlc3MgJSVuYW1lJSUgaW5jbHVkZXNcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyBhIGxpc3Qgb2YgYWxsIHBsdWdpbnMgdGhhdCBtYXRjaCAlJW5hbWUlJSwgd2l0aCBvdHIgd2l0aG91dFxuICAgICAqICBhIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGdldFBsdWdpbnMoYmFzZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBsdWdpbnMuZmlsdGVyKChwKSA9PiAocC5uYW1lLnNwbGl0KFwiI1wiKVswXSA9PT0gYmFzZW5hbWUpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgTmV0d29yay5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgTmV0d29yayh0aGlzLm5hbWUsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgIGNsb25lLmF0dGFjaFBsdWdpbihwbHVnaW4uY2xvbmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBpbnRyaW5zaWMgZ2FzIHJlcXVpcmVkIGZvciBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEEgR2FzQ29zdFBsdWdpbiBjYW4gYmUgYXR0YWNoZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRcbiAgICAgKiAgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbXB1dGVJbnRyaW5zaWNHYXModHgpIHtcbiAgICAgICAgY29uc3QgY29zdHMgPSB0aGlzLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkdhc0Nvc3RcIikgfHwgKG5ldyBHYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICBsZXQgZ2FzID0gY29zdHMudHhCYXNlO1xuICAgICAgICBpZiAodHgudG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4Q3JlYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHR4LmRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZGF0YS5zdWJzdHJpbmcoaSwgaSArIDIpID09PSBcIjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YVplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhEYXRhTm9uemVybztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIGluIGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBnYXMgKz0gY29zdHMudHhBY2Nlc3NMaXN0QWRkcmVzcyArIGNvc3RzLnR4QWNjZXNzTGlzdFN0b3JhZ2VLZXkgKiBhY2Nlc3NMaXN0W2FkZHJdLnN0b3JhZ2VLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBOZXR3b3JrIGZvciB0aGUgJSVuZXR3b3JrJSUgbmFtZSBvciBjaGFpbklkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG5ldHdvcmspIHtcbiAgICAgICAgaW5qZWN0Q29tbW9uTmV0d29ya3MoKTtcbiAgICAgICAgLy8gRGVmYXVsdCBuZXR3b3JrXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oXCJtYWlubmV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbm9uaWNhbCBuYW1lIG9yIGNoYWluIElEXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gQmlnSW50KG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiAobmV0d29yaykgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtGdW5jID0gTmV0d29ya3MuZ2V0KG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmtGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtGdW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29yayhcInVua25vd25cIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb25hYmxlIHdpdGggbmV0d29yay1saWtlIGFiaWxpdGllc1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IG5ldHdvcmsuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZihuZXR3b3JrLm5hbWUpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZihuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXR3b3JraXNoXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKG5ldHdvcmsubmFtZSkgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIChuZXR3b3JrLmNoYWluSWQpID09PSBcIm51bWJlclwiLCBcImludmFsaWQgbmV0d29yayBvYmplY3QgbmFtZSBvciBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbSA9IG5ldyBOZXR3b3JrKChuZXR3b3JrLm5hbWUpLCAobmV0d29yay5jaGFpbklkKSk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5lbnNBZGRyZXNzIHx8IG5ldHdvcmsuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tLmF0dGFjaFBsdWdpbihuZXcgRW5zUGx1Z2luKG5ldHdvcmsuZW5zQWRkcmVzcywgbmV0d29yay5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmICgoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8vICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbigoPGFueT5uZXR3b3JrKS5sYXllck9uZUNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVnaXN0ZXIgJSVuYW1lT3JDaGFpbklkJSUgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcbiAgICAgKiAgYW4gaW5zdGFuY2Ugb2YgYSBOZXR3b3JrIHJlcHJlc2VudGluZyB0aGF0IGNoYWluLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlcihuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lT3JDaGFpbklkKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmFtZU9yQ2hhaW5JZCA9IEJpZ0ludChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZyA9IE5ldHdvcmtzLmdldChuYW1lT3JDaGFpbklkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGNvbmZsaWN0aW5nIG5ldHdvcmsgZm9yICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcubmFtZSl9YCwgXCJuYW1lT3JDaGFpbklkXCIsIG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIE5ldHdvcmtzLnNldChuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYyk7XG4gICAgfVxufVxuLy8gV2UgZG9uJ3Qgd2FudCB0byBicmluZyBpbiBmb3JtYXRVbml0cyBiZWNhdXNlIGl0IGlzIGJhY2tlZCBieVxuLy8gRml4ZWROdW1iZXIgYW5kIHdlIHdhbnQgdG8ga2VlcCBOZXR3b3JrcyB0aW55LiBUaGUgdmFsdWVzXG4vLyBpbmNsdWRlZCBieSB0aGUgR2FzIFN0YXRpb25zIGFyZSBhbHNvIElFRUUgNzU0IHdpdGggbG90cyBvZlxuLy8gcm91bmRpbmcgaXNzdWVzIGFuZCBleGNlZWQgdGhlIHN0cmljdCBjaGVja3MgZm9ybWF0VW5pdHMgaGFzLlxuZnVuY3Rpb24gcGFyc2VVbml0cyhfdmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoX3ZhbHVlKTtcbiAgICBpZiAoIXZhbHVlLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZ3dlaSB2YWx1ZTogJHtfdmFsdWV9YCk7XG4gICAgfVxuICAgIC8vIEJyZWFrIGludG8gWyB3aG9sZSwgZnJhY3Rpb24gXVxuICAgIGNvbnN0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29tcHMucHVzaChcIlwiKTtcbiAgICB9XG4gICAgLy8gTW9yZSB0aGFuIDEgZGVjaW1hbCBwb2ludCBvciB0b28gbWFueSBmcmFjdGlvbmFsIHBvc2l0aW9uc1xuICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBQYWQgdGhlIGZyYWN0aW9uIHRvIDkgZGVjaW1hbHBsYWNlc1xuICAgIHdoaWxlIChjb21wc1sxXS5sZW5ndGggPCBkZWNpbWFscykge1xuICAgICAgICBjb21wc1sxXSArPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gVG9vIG1hbnkgZGVjaW1hbHMgYW5kIHNvbWUgbm9uLXplcm8gZW5kaW5nLCB0YWtlIHRoZSBjZWlsaW5nXG4gICAgaWYgKGNvbXBzWzFdLmxlbmd0aCA+IDkpIHtcbiAgICAgICAgbGV0IGZyYWMgPSBCaWdJbnQoY29tcHNbMV0uc3Vic3RyaW5nKDAsIDkpKTtcbiAgICAgICAgaWYgKCFjb21wc1sxXS5zdWJzdHJpbmcoOSkubWF0Y2goL14wKyQvKSkge1xuICAgICAgICAgICAgZnJhYysrO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBzWzFdID0gZnJhYy50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGNvbXBzWzBdICsgY29tcHNbMV0pO1xufVxuLy8gVXNlZCBieSBQb2x5Z29uIHRvIHVzZSBhIGdhcyBzdGF0aW9uIGZvciBmZWUgZGF0YVxuZnVuY3Rpb24gZ2V0R2FzU3RhdGlvblBsdWdpbih1cmwpIHtcbiAgICByZXR1cm4gbmV3IEZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4odXJsLCBhc3luYyAoZmV0Y2hGZWVEYXRhLCBwcm92aWRlciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50IENsb3VkZmxhcmUgZnJvbSBibG9ja2luZyBvdXIgcmVxdWVzdCBpbiBub2RlLmpzXG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiVXNlci1BZ2VudFwiLCBcImV0aGVyc1wiKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW19yZXNwb25zZSwgX2ZlZURhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpLCBmZXRjaEZlZURhdGEoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IF9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXNwb25zZS5ib2R5SnNvbi5zdGFuZGFyZDtcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IF9mZWVEYXRhLmdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogcGFyc2VVbml0cyhwYXlsb2FkLm1heEZlZSwgOSksXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhQcmlvcml0eUZlZSwgOSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZlZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCB3aXRoIHBvbHlnb24gZ2FzIHN0YXRpb24gKCR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdC51cmwpfSlgLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gU2VlOiBodHRwczovL2NoYWlubGlzdC5vcmdcbmxldCBpbmplY3RlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5qZWN0Q29tbW9uTmV0d29ya3MoKSB7XG4gICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIC8vLyBSZWdpc3RlciBwb3B1bGFyIEV0aGVyZXVtIG5ldHdvcmtzXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJFdGgobmFtZSwgY2hhaW5JZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldyBOZXR3b3JrKG5hbWUsIGNoYWluSWQpO1xuICAgICAgICAgICAgLy8gV2UgdXNlIDAgdG8gZGlzYWJsZSBFTlNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBFbnNQbHVnaW4obnVsbCwgb3B0aW9ucy5lbnNOZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXR3b3JrLmF0dGFjaFBsdWdpbihuZXcgR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgICAgIChvcHRpb25zLnBsdWdpbnMgfHwgW10pLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbmV0d29yayBieSBuYW1lIGFuZCBjaGFpbiBJRFxuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKGNoYWluSWQsIGZ1bmMpO1xuICAgICAgICBpZiAob3B0aW9ucy5hbHROYW1lcykge1xuICAgICAgICAgICAgb3B0aW9ucy5hbHROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgTmV0d29yay5yZWdpc3RlcihuYW1lLCBmdW5jKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRXRoKFwibWFpbm5ldFwiLCAxLCB7IGVuc05ldHdvcms6IDEsIGFsdE5hbWVzOiBbXCJob21lc3RlYWRcIl0gfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJyb3BzdGVuXCIsIDMsIHsgZW5zTmV0d29yazogMyB9KTtcbiAgICByZWdpc3RlckV0aChcInJpbmtlYnlcIiwgNCwgeyBlbnNOZXR3b3JrOiA0IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiZ29lcmxpXCIsIDUsIHsgZW5zTmV0d29yazogNSB9KTtcbiAgICByZWdpc3RlckV0aChcImtvdmFuXCIsIDQyLCB7IGVuc05ldHdvcms6IDQyIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwic2Vwb2xpYVwiLCAxMTE1NTExMSwgeyBlbnNOZXR3b3JrOiAxMTE1NTExMSB9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNcIiwgNjEsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImNsYXNzaWNLb3R0aVwiLCA2LCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJhcmJpdHJ1bVwiLCA0MjE2MSwge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW0tZ29lcmxpXCIsIDQyMTYxMywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZVwiLCA4NDUzLCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJiYXNlLWdvZXJsaVwiLCA4NDUzMSwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYmFzZS1zZXBvbGlhXCIsIDg0NTMyLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJibmJcIiwgNTYsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImJuYnRcIiwgOTcsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhXCIsIDU5MTQ0LCB7IGVuc05ldHdvcms6IDEgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJsaW5lYS1nb2VybGlcIiwgNTkxNDAsIHt9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljXCIsIDEzNywge1xuICAgICAgICBlbnNOZXR3b3JrOiAxLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24ucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm1hdGljLW11bWJhaVwiLCA4MDAwMSwge1xuICAgICAgICBhbHROYW1lczogW1wibWF0aWNNdW1iYWlcIiwgXCJtYXRpY211bVwiXSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0R2FzU3RhdGlvblBsdWdpbihcImh0dHBzOi9cXC9nYXNzdGF0aW9uLXRlc3RuZXQucG9seWdvbi50ZWNobm9sb2d5L3YyXCIpXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcIm9wdGltaXNtXCIsIDEwLCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtdXG4gICAgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJvcHRpbWlzbS1nb2VybGlcIiwgNDIwLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJ4ZGFpXCIsIDEwMCwgeyBlbnNOZXR3b3JrOiAxIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiXSwibmFtZXMiOlsiYWNjZXNzTGlzdGlmeSIsImdldEJpZ0ludCIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiRW5zUGx1Z2luIiwiRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiIsIkdhc0Nvc3RQbHVnaW4iLCJOZXR3b3JrcyIsIk1hcCIsIk5ldHdvcmsiLCJuYW1lIiwiY2hhaW5JZCIsInBsdWdpbnMiLCJjb25zdHJ1Y3RvciIsInRvSlNPTiIsIlN0cmluZyIsInZhbHVlIiwibWF0Y2hlcyIsIm90aGVyIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJhdHRhY2hQbHVnaW4iLCJwbHVnaW4iLCJnZXQiLCJFcnJvciIsInNldCIsImNsb25lIiwiZ2V0UGx1Z2luIiwiZ2V0UGx1Z2lucyIsImJhc2VuYW1lIiwiZmlsdGVyIiwicCIsInNwbGl0IiwiZm9yRWFjaCIsImNvbXB1dGVJbnRyaW5zaWNHYXMiLCJ0eCIsImNvc3RzIiwiZ2FzIiwidHhCYXNlIiwidG8iLCJ0eENyZWF0ZSIsImRhdGEiLCJpIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwidHhEYXRhWmVybyIsInR4RGF0YU5vbnplcm8iLCJhY2Nlc3NMaXN0IiwiYWRkciIsInR4QWNjZXNzTGlzdEFkZHJlc3MiLCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5Iiwic3RvcmFnZUtleXMiLCJuZXR3b3JrIiwiaW5qZWN0Q29tbW9uTmV0d29ya3MiLCJCaWdJbnQiLCJuZXR3b3JrRnVuYyIsImN1c3RvbSIsImVuc0FkZHJlc3MiLCJlbnNOZXR3b3JrIiwicmVnaXN0ZXIiLCJuYW1lT3JDaGFpbklkIiwiZXhpc3RpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2VVbml0cyIsIl92YWx1ZSIsImRlY2ltYWxzIiwibWF0Y2giLCJjb21wcyIsInB1c2giLCJmcmFjIiwidG9TdHJpbmciLCJnZXRHYXNTdGF0aW9uUGx1Z2luIiwidXJsIiwiZmV0Y2hGZWVEYXRhIiwicHJvdmlkZXIiLCJyZXF1ZXN0Iiwic2V0SGVhZGVyIiwicmVzcG9uc2UiLCJfcmVzcG9uc2UiLCJfZmVlRGF0YSIsIlByb21pc2UiLCJhbGwiLCJzZW5kIiwicGF5bG9hZCIsImJvZHlKc29uIiwic3RhbmRhcmQiLCJmZWVEYXRhIiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJHYXMiLCJtYXhGZWUiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlIiwiaW5qZWN0ZWQiLCJyZWdpc3RlckV0aCIsIm9wdGlvbnMiLCJmdW5jIiwiYWx0TmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/plugins-network.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnsPlugin: () => (/* binding */ EnsPlugin),\n/* harmony export */   FeeDataNetworkPlugin: () => (/* binding */ FeeDataNetworkPlugin),\n/* harmony export */   FetchUrlFeeDataNetworkPlugin: () => (/* binding */ FetchUrlFeeDataNetworkPlugin),\n/* harmony export */   GasCostPlugin: () => (/* binding */ GasCostPlugin),\n/* harmony export */   NetworkPlugin: () => (/* binding */ NetworkPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */ class NetworkPlugin {\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */ constructor(name){\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            name\n        });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */ clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */ class GasCostPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */ constructor(effectiveBlock, costs){\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);\n        const props = {\n            effectiveBlock\n        };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof value === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */ class EnsPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */ constructor(address, targetNetwork){\n        super(\"org.ethers.plugins.network.Ens\");\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            address: address || EnsAddress,\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */ class FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */ get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */ constructor(feeDataFunc){\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */ async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */ get url() {\n        return this.#url;\n    }\n    /**\n     *  The callback to use when computing the FeeData.\n     */ get processFunc() {\n        return this.#processFunc;\n    }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */ constructor(url, processFunc){\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() {\n        return this;\n    }\n} /*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/  //# sourceMappingURL=plugins-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQ1A7QUFDbkQsTUFBTUUsYUFBYTtBQUNuQjs7Q0FFQyxHQUNNLE1BQU1DO0lBUVQ7O0tBRUMsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2RMLHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRUs7UUFBSztJQUNsQztJQUNBOztLQUVDLEdBQ0RDLFFBQVE7UUFDSixPQUFPLElBQUlILGNBQWMsSUFBSSxDQUFDRSxJQUFJO0lBQ3RDO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNRSxzQkFBc0JKO0lBZ0MvQjs7OztLQUlDLEdBQ0RDLFlBQVlJLGNBQWMsRUFBRUMsS0FBSyxDQUFFO1FBQy9CLElBQUlELGtCQUFrQixNQUFNO1lBQ3hCQSxpQkFBaUI7UUFDckI7UUFDQSxLQUFLLENBQUMsQ0FBQyxtQ0FBbUMsRUFBR0Esa0JBQWtCLEVBQUcsQ0FBQztRQUNuRSxNQUFNRSxRQUFRO1lBQUVGO1FBQWU7UUFDL0IsU0FBU0csSUFBSU4sSUFBSSxFQUFFTyxPQUFPO1lBQ3RCLElBQUlDLFFBQVEsQ0FBQ0osU0FBUyxDQUFDLEVBQUUsQ0FBQ0osS0FBSztZQUMvQixJQUFJUSxTQUFTLE1BQU07Z0JBQ2ZBLFFBQVFEO1lBQ1o7WUFDQVgsK0RBQWNBLENBQUMsT0FBUVksVUFBVyxVQUFVLENBQUMsa0JBQWtCLEVBQUVSLEtBQUssQ0FBQyxFQUFFLFNBQVNJO1lBQ2xGQyxLQUFLLENBQUNMLEtBQUssR0FBR1E7UUFDbEI7UUFDQUYsSUFBSSxVQUFVO1FBQ2RBLElBQUksWUFBWTtRQUNoQkEsSUFBSSxjQUFjO1FBQ2xCQSxJQUFJLGlCQUFpQjtRQUNyQkEsSUFBSSwwQkFBMEI7UUFDOUJBLElBQUksdUJBQXVCO1FBQzNCWCxzRUFBZ0JBLENBQUMsSUFBSSxFQUFFVTtJQUMzQjtJQUNBSixRQUFRO1FBQ0osT0FBTyxJQUFJQyxjQUFjLElBQUksQ0FBQ0MsY0FBYyxFQUFFLElBQUk7SUFDdEQ7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sTUFBTU0sa0JBQWtCWDtJQVMzQjs7OztLQUlDLEdBQ0RDLFlBQVlXLE9BQU8sRUFBRUMsYUFBYSxDQUFFO1FBQ2hDLEtBQUssQ0FBQztRQUNOaEIsc0VBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmUsU0FBVUEsV0FBV2I7WUFDckJjLGVBQWdCLGlCQUFrQixPQUFRLElBQUlBO1FBQ2xEO0lBQ0o7SUFDQVYsUUFBUTtRQUNKLE9BQU8sSUFBSVEsVUFBVSxJQUFJLENBQUNDLE9BQU8sRUFBRSxJQUFJLENBQUNDLGFBQWE7SUFDekQ7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1DLDZCQUE2QmQ7SUFDdEMsQ0FBQ2UsV0FBVyxDQUFDO0lBQ2I7O0tBRUMsR0FDRCxJQUFJQSxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUM1QjtJQUNBOztLQUVDLEdBQ0RkLFlBQVljLFdBQVcsQ0FBRTtRQUNyQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHQTtJQUN4QjtJQUNBOztLQUVDLEdBQ0QsTUFBTUMsV0FBV0MsUUFBUSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTSxJQUFJLENBQUMsQ0FBQ0YsV0FBVyxDQUFDRTtJQUNuQztJQUNBZCxRQUFRO1FBQ0osT0FBTyxJQUFJVyxxQkFBcUIsSUFBSSxDQUFDLENBQUNDLFdBQVc7SUFDckQ7QUFDSjtBQUNPLE1BQU1HLHFDQUFxQ2xCO0lBQzlDLENBQUNtQixHQUFHLENBQUM7SUFDTCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNELElBQUlELE1BQU07UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxHQUFHO0lBQUU7SUFDOUI7O0tBRUMsR0FDRCxJQUFJQyxjQUFjO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUFFO0lBQzlDOzs7S0FHQyxHQUNEbkIsWUFBWWtCLEdBQUcsRUFBRUMsV0FBVyxDQUFFO1FBQzFCLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQyxDQUFDRCxHQUFHLEdBQUdBO1FBQ1osSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBR0E7SUFDeEI7SUFDQSxxREFBcUQ7SUFDckRqQixRQUFRO1FBQUUsT0FBTyxJQUFJO0lBQUU7QUFDM0IsRUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsSUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzPzQxMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy9wcm9wZXJ0aWVzLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgRW5zQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCI7XG4vKipcbiAqICBBICoqTmV0d29ya1BsdWdpbioqIHByb3ZpZGVzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBvbiBhIFtbTmV0d29ya11dLlxuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gICAgICpcbiAgICAgKiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHJldmVyc2UtZG9tYWluLW5vdGF0aW9uLCB3aGljaCBwZXJtaXRzXG4gICAgICogIHVuaXF1ZSBuYW1lcyB3aXRoIGEga25vd24gYXV0aG9yaXR5IGFzIHdlbGwgYXMgaGllcmFyY2hhbCBlbnRyaWVzLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipOZXR3b3JrUGx1Z2luKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgcGx1Z2luLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtQbHVnaW4odGhpcy5uYW1lKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqR2FzQ29zdFBsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbHRlcm5hdGl2ZSB2YWx1ZXMgd2hlblxuICogIGNvbXB1dGluZyB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEdhc0Nvc3RQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciB0byB0cmVhdCB0aGVzZSB2YWx1ZXMgYXMgdmFsaWQgZnJvbS5cbiAgICAgKlxuICAgICAqICBUaGlzIGFsbG93cyBhIGhhcmRmb3JrIHRvIGhhdmUgdXBkYXRlZCB2YWx1ZXMgaW5jbHVkZWQgYXMgd2VsbCBhc1xuICAgICAqICBtdWx1dGlwbGUgaGFyZGZvcmtzIHRvIGJlIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBlZmZlY3RpdmVCbG9jaztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9ucyBiYXNlIGZlZS5cbiAgICAgKi9cbiAgICB0eEJhc2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZm9yIGNyZWF0aW5nIGEgbmV3IGFjY291bnQuXG4gICAgICovXG4gICAgdHhDcmVhdGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHplcm8tYnl0ZSBpbiB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICB0eERhdGFaZXJvO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBub24temVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YU5vbnplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIHN0b3JhZ2Uga2V5IGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5O1xuICAgIC8qKlxuICAgICAqICBUaGUgZmVlIHBlciBhZGRyZXNzIGluIHRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdC5cbiAgICAgKi9cbiAgICB0eEFjY2Vzc0xpc3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEdhc0Nvc3RQbHVnaW4gZnJvbSAlJWVmZmVjdGl2ZUJsb2NrJSUgdW50aWwgdGhlXG4gICAgICogIGxhdGVzdCBibG9jayBvciBhbm90aGVyIEdhc0Nvc3RQbHVnaW4gc3VwZXJjZWRlcyB0aGF0IGJsb2NrIG51bWJlcixcbiAgICAgKiAgd2l0aCB0aGUgYXNzb2NpYXRlZCAlJWNvc3RzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWZmZWN0aXZlQmxvY2ssIGNvc3RzKSB7XG4gICAgICAgIGlmIChlZmZlY3RpdmVCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBlZmZlY3RpdmVCbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYG9yZy5ldGhlcnMubmV0d29yay5wbHVnaW5zLkdhc0Nvc3QjJHsoZWZmZWN0aXZlQmxvY2sgfHwgMCl9YCk7XG4gICAgICAgIGNvbnN0IHByb3BzID0geyBlZmZlY3RpdmVCbG9jayB9O1xuICAgICAgICBmdW5jdGlvbiBzZXQobmFtZSwgbnVsbGlzaCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gKGNvc3RzIHx8IHt9KVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsaXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIsIGBpbnZhbHVkIHZhbHVlIGZvciAke25hbWV9YCwgXCJjb3N0c1wiLCBjb3N0cyk7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldChcInR4QmFzZVwiLCAyMTAwMCk7XG4gICAgICAgIHNldChcInR4Q3JlYXRlXCIsIDMyMDAwKTtcbiAgICAgICAgc2V0KFwidHhEYXRhWmVyb1wiLCA0KTtcbiAgICAgICAgc2V0KFwidHhEYXRhTm9uemVyb1wiLCAxNik7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXlcIiwgMTkwMCk7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdEFkZHJlc3NcIiwgMjQwMCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcHMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXNDb3N0UGx1Z2luKHRoaXMuZWZmZWN0aXZlQmxvY2ssIHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuICoqRW5zUGx1Z2luKiogYWxsb3dzIGEgW1tOZXR3b3JrXV0gdG8gc3BlY2lmeSB0aGUgRU5TIFJlZ2lzdHJ5XG4gKiAgQ29udHJhY3QgYWRkcmVzcyBhbmQgdGhlIHRhcmdldCBuZXR3b3JrIHRvIHVzZSB3aGVuIHVzaW5nIHRoYXRcbiAqICBjb250cmFjdC5cbiAqXG4gKiAgVmFyaW91cyB0ZXN0bmV0cyBoYXZlIHRoZWlyIG93biBpbnN0YW5jZSBvZiB0aGUgY29udHJhY3QgdG8gdXNlLCBidXRcbiAqICBpbiBnZW5lcmFsLCB0aGUgbWFpbm5ldCBpbnN0YW5jZSBzdXBwb3J0cyBtdWx0aS1jaGFpbiBhZGRyZXNzZXMgYW5kXG4gKiAgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnNQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEVOUyBSZWdpc3RydHkgQ29udHJhY3QgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhhdCB0aGUgRU5TIGNvbnRyYWN0IGxpdmVzIG9uLlxuICAgICAqL1xuICAgIHRhcmdldE5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFbnNQbHVnaW4qKiBjb25uZWN0ZWQgdG8gJSVhZGRyZXNzJSUgb24gdGhlXG4gICAgICogICUldGFyZ2V0TmV0d29yayUlLiBUaGUgZGVmYXVsdCBFTlMgYWRkcmVzcyBhbmQgbWFpbm5ldCBpcyB1c2VkXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHRhcmdldE5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWRkcmVzczogKGFkZHJlc3MgfHwgRW5zQWRkcmVzcyksXG4gICAgICAgICAgICB0YXJnZXROZXR3b3JrOiAoKHRhcmdldE5ldHdvcmsgPT0gbnVsbCkgPyAxIDogdGFyZ2V0TmV0d29yaylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVuc1BsdWdpbih0aGlzLmFkZHJlc3MsIHRoaXMudGFyZ2V0TmV0d29yayk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkZlZURhdGFOZXR3b3JrUGx1Z2luKiogYWxsb3dzIGEgbmV0d29yayB0byBwcm92aWRlIGFuZCBhbHRlcm5hdGVcbiAqICBtZWFucyB0byBzcGVjaWZ5IGl0cyBmZWUgZGF0YS5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgbmV0d29yayB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IFtbbGluay1laXAtMTU1OV1dIG1heVxuICogIGNob29zZSB0byB1c2UgYSBHYXMgU3RhdGlvbiBzaXRlIHRvIGFwcHJveGltYXRlIHRoZSBnYXMgcHJpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICNmZWVEYXRhRnVuYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBkYXRhIGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBnZXQgZmVlRGF0YUZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGZWVEYXRhTmV0d29ya1BsdWdpbioqLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZlZURhdGFGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmVlRGF0YVwiKTtcbiAgICAgICAgdGhpcy4jZmVlRGF0YUZ1bmMgPSBmZWVEYXRhRnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBmZWUgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRGZWVEYXRhKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZWVEYXRhRnVuYyhwcm92aWRlcik7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZlZURhdGFOZXR3b3JrUGx1Z2luKHRoaXMuI2ZlZURhdGFGdW5jKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICN1cmw7XG4gICAgI3Byb2Nlc3NGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgVVJMIHRvIGluaXRpYWxpemUgdGhlIEZldGNoUmVxdWVzdCB3aXRoIGluICUlcHJvY2Vzc0Z1bmMlJS5cbiAgICAgKi9cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjYWxsYmFjayB0byB1c2Ugd2hlbiBjb21wdXRpbmcgdGhlIEZlZURhdGEuXG4gICAgICovXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkgeyByZXR1cm4gdGhpcy4jcHJvY2Vzc0Z1bmM7IH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiB3aGljaCB3aWxsXG4gICAgICogIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIGZlZSBkYXRhIGZvciB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NGdW5jID0gcHJvY2Vzc0Z1bmM7XG4gICAgfVxuICAgIC8vIFdlIGFyZSBpbW11dGFibGUsIHNvIHdlIGNhbiBzZXJ2ZSBhcyBvdXIgb3duIGNsb25lXG4gICAgY2xvbmUoKSB7IHJldHVybiB0aGlzOyB9XG59XG4vKlxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIHJlYWRvbmx5ICNibG9ja0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KSA9PiBCbG9jazxzdHJpbmc+O1xuICAgIHJlYWRvbmx5ICNibG9ja1dpdGhUeHNGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pID0+IEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXG4gICAgY29uc3RydWN0b3IoYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPiwgYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPikge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMubmV0d29yay1wbHVnaW5zLmN1c3RvbS1ibG9ja1wiKTtcbiAgICAgICAgdGhpcy4jYmxvY2tGdW5jID0gYmxvY2tGdW5jO1xuICAgICAgICB0aGlzLiNibG9ja1dpdGhUeHNGdW5jID0gYmxvY2tXaXRoVHhzRnVuYztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9jayhwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxzdHJpbmc+KTogUHJvbWlzZTxCbG9jazxzdHJpbmc+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja0Z1bmMocHJvdmlkZXIsIGJsb2NrKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRCbG9ja2lvbnMocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8VHJhbnNhY3Rpb25SZXNwb25zZVBhcmFtcz4pOiBQcm9taXNlPEJsb2NrPFRyYW5zYWN0aW9uUmVzcG9uc2U+PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgY2xvbmUoKTogQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4odGhpcy4jYmxvY2tGdW5jLCB0aGlzLiNibG9ja1dpdGhUeHNGdW5jKTtcbiAgICB9XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy1uZXR3b3JrLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiYXNzZXJ0QXJndW1lbnQiLCJFbnNBZGRyZXNzIiwiTmV0d29ya1BsdWdpbiIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNsb25lIiwiR2FzQ29zdFBsdWdpbiIsImVmZmVjdGl2ZUJsb2NrIiwiY29zdHMiLCJwcm9wcyIsInNldCIsIm51bGxpc2giLCJ2YWx1ZSIsIkVuc1BsdWdpbiIsImFkZHJlc3MiLCJ0YXJnZXROZXR3b3JrIiwiRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJmZWVEYXRhRnVuYyIsImdldEZlZURhdGEiLCJwcm92aWRlciIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJ1cmwiLCJwcm9jZXNzRnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/plugins-network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-browser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserProvider: () => (/* binding */ BrowserProvider)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n\n\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */ class BrowserProvider extends _provider_jsonrpc_js__WEBPACK_IMPORTED_MODULE_0__.JsonRpcApiPollingProvider {\n    #request;\n    /**\n     *  Connnect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */ constructor(ethereum, network){\n        super(network, {\n            batchMaxCount: 1\n        });\n        this.#request = async (method, params)=>{\n            const payload = {\n                method,\n                params\n            };\n            this.emit(\"debug\", {\n                action: \"sendEip1193Request\",\n                payload\n            });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Result\",\n                    result\n                });\n                return result;\n            } catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Error\",\n                    error\n                });\n                throw error;\n            }\n        };\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [\n                {\n                    id: payload.id,\n                    result\n                }\n            ];\n        } catch (e) {\n            return [\n                {\n                    id: payload.id,\n                    error: {\n                        code: e.code,\n                        data: e.data,\n                        message: e.message\n                    }\n                }\n            ];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into \n        switch(error.error.code || -1){\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */ async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof address === \"number\") {\n            return accounts.length > address;\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a)=>a.toLowerCase() === address).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!await this.hasSigner(address)) {\n            try {\n                //const resp = \n                await this.#request(\"eth_requestAccounts\", []);\n            //console.log(\"RESP\", resp);\n            } catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, {\n                    id: payload.id,\n                    error\n                });\n            }\n        }\n        return await super.getSigner(address);\n    }\n} //# sourceMappingURL=provider-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBQ2U7O0FBRWxFOzs7O0NBSUMsR0FDTSxNQUFNRSx3QkFBd0JELDJFQUF5QkE7SUFDMUQsQ0FBQ0UsT0FBTyxDQUFDO0lBQ1Q7OztLQUdDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLEtBQUssQ0FBQ0EsU0FBUztZQUFFQyxlQUFlO1FBQUU7UUFDbEMsSUFBSSxDQUFDLENBQUNKLE9BQU8sR0FBRyxPQUFPSyxRQUFRQztZQUMzQixNQUFNQyxVQUFVO2dCQUFFRjtnQkFBUUM7WUFBTztZQUNqQyxJQUFJLENBQUNFLElBQUksQ0FBQyxTQUFTO2dCQUFFQyxRQUFRO2dCQUFzQkY7WUFBUTtZQUMzRCxJQUFJO2dCQUNBLE1BQU1HLFNBQVMsTUFBTVIsU0FBU0YsT0FBTyxDQUFDTztnQkFDdEMsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztvQkFBRUMsUUFBUTtvQkFBd0JDO2dCQUFPO2dCQUM1RCxPQUFPQTtZQUNYLEVBQ0EsT0FBT0MsR0FBRztnQkFDTixNQUFNQyxRQUFRLElBQUlDLE1BQU1GLEVBQUVHLE9BQU87Z0JBQ2pDRixNQUFNRyxJQUFJLEdBQUdKLEVBQUVJLElBQUk7Z0JBQ25CSCxNQUFNSSxJQUFJLEdBQUdMLEVBQUVLLElBQUk7Z0JBQ25CSixNQUFNTCxPQUFPLEdBQUdBO2dCQUNoQixJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTO29CQUFFQyxRQUFRO29CQUF1Qkc7Z0JBQU07Z0JBQzFELE1BQU1BO1lBQ1Y7UUFDSjtJQUNKO0lBQ0EsTUFBTUssS0FBS1osTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDdkIsTUFBTSxJQUFJLENBQUNZLE1BQU07UUFDakIsT0FBTyxNQUFNLEtBQUssQ0FBQ0QsS0FBS1osUUFBUUM7SUFDcEM7SUFDQSxNQUFNYSxNQUFNWixPQUFPLEVBQUU7UUFDakJWLCtEQUFjQSxDQUFDLENBQUN1QixNQUFNQyxPQUFPLENBQUNkLFVBQVUsMkNBQTJDLFdBQVdBO1FBQzlGLElBQUk7WUFDQSxNQUFNRyxTQUFTLE1BQU0sSUFBSSxDQUFDLENBQUNWLE9BQU8sQ0FBQ08sUUFBUUYsTUFBTSxFQUFFRSxRQUFRRCxNQUFNLElBQUksRUFBRTtZQUN2RSxPQUFPO2dCQUFDO29CQUFFZ0IsSUFBSWYsUUFBUWUsRUFBRTtvQkFBRVo7Z0JBQU87YUFBRTtRQUN2QyxFQUNBLE9BQU9DLEdBQUc7WUFDTixPQUFPO2dCQUFDO29CQUNBVyxJQUFJZixRQUFRZSxFQUFFO29CQUNkVixPQUFPO3dCQUFFRyxNQUFNSixFQUFFSSxJQUFJO3dCQUFFQyxNQUFNTCxFQUFFSyxJQUFJO3dCQUFFRixTQUFTSCxFQUFFRyxPQUFPO29CQUFDO2dCQUM1RDthQUFFO1FBQ1Y7SUFDSjtJQUNBUyxZQUFZaEIsT0FBTyxFQUFFSyxLQUFLLEVBQUU7UUFDeEJBLFFBQVFZLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDZDtRQUNsQyxrRUFBa0U7UUFDbEUsYUFBYTtRQUNiLE9BQVFBLE1BQU1BLEtBQUssQ0FBQ0csSUFBSSxJQUFJLENBQUM7WUFDekIsS0FBSztnQkFDREgsTUFBTUEsS0FBSyxDQUFDRSxPQUFPLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRUYsTUFBTUEsS0FBSyxDQUFDRSxPQUFPLENBQUMsQ0FBQztnQkFDbEU7WUFDSixLQUFLO2dCQUNERixNQUFNQSxLQUFLLENBQUNFLE9BQU8sR0FBRyxDQUFDLG9CQUFvQixFQUFFRixNQUFNQSxLQUFLLENBQUNFLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRTtRQUNSO1FBQ0EsT0FBTyxLQUFLLENBQUNTLFlBQVloQixTQUFTSztJQUN0QztJQUNBOztLQUVDLEdBQ0QsTUFBTWUsVUFBVUMsT0FBTyxFQUFFO1FBQ3JCLElBQUlBLFdBQVcsTUFBTTtZQUNqQkEsVUFBVTtRQUNkO1FBQ0EsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ1osSUFBSSxDQUFDLGdCQUFnQixFQUFFO1FBQ25ELElBQUksT0FBUVcsWUFBYSxVQUFVO1lBQy9CLE9BQVFDLFNBQVNDLE1BQU0sR0FBR0Y7UUFDOUI7UUFDQUEsVUFBVUEsUUFBUUcsV0FBVztRQUM3QixPQUFPRixTQUFTRyxNQUFNLENBQUMsQ0FBQ0MsSUFBT0EsRUFBRUYsV0FBVyxPQUFPSCxTQUFVRSxNQUFNLEtBQUs7SUFDNUU7SUFDQSxNQUFNSSxVQUFVTixPQUFPLEVBQUU7UUFDckIsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVO1FBQ2Q7UUFDQSxJQUFJLENBQUUsTUFBTSxJQUFJLENBQUNELFNBQVMsQ0FBQ0MsVUFBVztZQUNsQyxJQUFJO2dCQUNBLGVBQWU7Z0JBQ2YsTUFBTSxJQUFJLENBQUMsQ0FBQzVCLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRTtZQUM3Qyw0QkFBNEI7WUFDaEMsRUFDQSxPQUFPWSxPQUFPO2dCQUNWLE1BQU1MLFVBQVVLLE1BQU1MLE9BQU87Z0JBQzdCLE1BQU0sSUFBSSxDQUFDZ0IsV0FBVyxDQUFDaEIsU0FBUztvQkFBRWUsSUFBSWYsUUFBUWUsRUFBRTtvQkFBRVY7Z0JBQU07WUFDNUQ7UUFDSjtRQUNBLE9BQU8sTUFBTSxLQUFLLENBQUNzQixVQUFVTjtJQUNqQztBQUNKLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWJyb3dzZXIuanM/YzZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB9IGZyb20gXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIjtcbjtcbi8qKlxuICogIEEgKipCcm93c2VyUHJvdmlkZXIqKiBpcyBpbnRlbmRlZCB0byB3cmFwIGFuIGluamVjdGVkIHByb3ZpZGVyIHdoaWNoXG4gKiAgYWRoZXJlcyB0byB0aGUgW1tsaW5rLWVpcC0xMTkzXV0gc3RhbmRhcmQsIHdoaWNoIG1vc3QgKGlmIG5vdCBhbGwpXG4gKiAgY3VycmVudGx5IGRvLlxuICovXG5leHBvcnQgY2xhc3MgQnJvd3NlclByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI3JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogIENvbm5uZWN0IHRvIHRoZSAlJWV0aGVyZXVtJSUgcHJvdmlkZXIsIG9wdGlvbmFsbHkgZm9yY2luZyB0aGVcbiAgICAgKiAgJSVuZXR3b3JrJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXRoZXJldW0sIG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIobmV0d29yaywgeyBiYXRjaE1heENvdW50OiAxIH0pO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0ID0gYXN5bmMgKG1ldGhvZCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyBtZXRob2QsIHBhcmFtcyB9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZEVpcDExOTNSZXF1ZXN0XCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV0aGVyZXVtLnJlcXVlc3QocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgIGVycm9yLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFaXAxMTkzRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFBcnJheS5pc0FycmF5KHBheWxvYWQpLCBcIkVJUC0xMTkzIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2ggcmVxdWVzdFwiLCBcInBheWxvYWRcIiwgcGF5bG9hZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXF1ZXN0KHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyB8fCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW3sgaWQ6IHBheWxvYWQuaWQsIHJlc3VsdCB9XTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXlsb2FkLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiBlLmNvZGUsIGRhdGE6IGUuZGF0YSwgbWVzc2FnZTogZS5tZXNzYWdlIH1cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcikge1xuICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgLy8gRUlQLTExOTMgZ2l2ZXMgdXMgc29tZSBtYWNoaW5lLXJlYWRhYmxlIGVycm9yIGNvZGVzLCBzbyByZXdyaXRlXG4gICAgICAgIC8vIHRoZW0gaW50byBcbiAgICAgICAgc3dpdGNoIChlcnJvci5lcnJvci5jb2RlIHx8IC0xKSB7XG4gICAgICAgICAgICBjYXNlIDQwMDE6XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IGBldGhlcnMtdXNlci1kZW5pZWQ6ICR7ZXJyb3IuZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MjAwOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVuc3VwcG9ydGVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYGB0cnVlYGAgaWYgdGhlIHByb3ZpZGVyIG1hbmFnZXMgdGhlICUlYWRkcmVzcyUlLlxuICAgICAqL1xuICAgIGFzeW5jIGhhc1NpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYWNjb3VudHMubGVuZ3RoID4gYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLmZpbHRlcigoYSkgPT4gKGEudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcykpLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5oYXNTaWduZXIoYWRkcmVzcykpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vY29uc3QgcmVzcCA9IFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3JlcXVlc3QoXCJldGhfcmVxdWVzdEFjY291bnRzXCIsIFtdKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTUFwiLCByZXNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBlcnJvci5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgeyBpZDogcGF5bG9hZC5pZCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLmdldFNpZ25lcihhZGRyZXNzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1icm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudCIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJyZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJldGhlcmV1bSIsIm5ldHdvcmsiLCJiYXRjaE1heENvdW50IiwibWV0aG9kIiwicGFyYW1zIiwicGF5bG9hZCIsImVtaXQiLCJhY3Rpb24iLCJyZXN1bHQiLCJlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiZGF0YSIsInNlbmQiLCJfc3RhcnQiLCJfc2VuZCIsIkFycmF5IiwiaXNBcnJheSIsImlkIiwiZ2V0UnBjRXJyb3IiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoYXNTaWduZXIiLCJhZGRyZXNzIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImZpbHRlciIsImEiLCJnZXRTaWduZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider-browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcApiPollingProvider: () => (/* binding */ JsonRpcApiPollingProvider),\n/* harmony export */   JsonRpcApiProvider: () => (/* binding */ JsonRpcApiProvider),\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\");\n/* harmony import */ var _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abstract-provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/abstract-provider.js\");\n/* harmony import */ var _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-signer.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var _network_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./network.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/network.js\");\n/* harmony import */ var _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./subscriber-filterid.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */ // @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\n\n\n\n\n\n\n\n\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof value.getAddress === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(deepCopy);\n    }\n    if (typeof value === \"object\") {\n        return Object.keys(value).reduce((accum, key)=>{\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof value})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: 1 << 20,\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends _abstract_signer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    constructor(provider, address){\n        super(provider);\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            address\n        });\n    }\n    connect(provider) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async ()=>{\n                const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_from, this.provider);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async ()=>{\n                tx.gasLimit = await this.provider.estimateGas({\n                    ...tx,\n                    from: this.address\n                });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async ()=>{\n                tx.to = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [\n            hexTx\n        ]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await new Promise((resolve, reject)=>{\n            const timeouts = [\n                1000,\n                100\n            ];\n            const checkTx = async ()=>{\n                // Try getting the transaction\n                const tx = await this.provider.getTransaction(hash);\n                if (tx != null) {\n                    resolve(tx.replaceableTransaction(blockNumber));\n                    return;\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(()=>{\n                    checkTx();\n                }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        });\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(tx.from, this.provider);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [\n            hexTx\n        ]);\n    }\n    async signMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"personal_sign\", [\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message),\n            this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await _hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, async (value)=>{\n            const address = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_4__.resolveAddress)(value);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(),\n            password,\n            null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = typeof _message === \"string\" ? (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(),\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(message)\n        ]);\n    }\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */ class JsonRpcApiProvider extends _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #pendingDetectNetwork;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no hard in sending it immeidately\n        const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(()=>{\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while(payloads.length){\n                // Create payload batches that satisfy our batch constraints\n                const batch = [\n                    payloads.shift()\n                ];\n                while(payloads.length){\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push(payloads.shift());\n                    const bytes = JSON.stringify(batch.map((p)=>p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(batch.pop());\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async ()=>{\n                    const payload = batch.length === 1 ? batch[0].payload : batch.map((p)=>p.payload);\n                    this.emit(\"debug\", {\n                        action: \"sendRpcPayload\",\n                        payload\n                    });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcResult\",\n                            result\n                        });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch){\n                            if (this.destroyed) {\n                                reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                                    operation: payload.method\n                                }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r)=>r.id === payload.id)[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result,\n                                    info: {\n                                        payload\n                                    }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    } catch (error) {\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcError\",\n                            error\n                        });\n                        for (const { reject } of batch){\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options){\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve)=>{\n                resolve = _resolve;\n            });\n            this.#notReady = {\n                promise,\n                resolve\n            };\n        }\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof staticNetwork === \"boolean\") {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from(network);\n            }\n        } else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */ _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */ get _network() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */ async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, {\n                                type: undefined\n                            })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */ async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) {\n                    return this.#network;\n                }\n            } else {\n                return network;\n            }\n        }\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async ()=>{\n                const result = _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(await this.send(\"eth_chainId\", [])));\n                this.#pendingDetectNetwork = null;\n                return result;\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async ()=>{\n            const payload = {\n                id: this.#nextId++,\n                method: \"eth_chainId\",\n                params: [],\n                jsonrpc: \"2.0\"\n            };\n            this.emit(\"debug\", {\n                action: \"sendRpcPayload\",\n                payload\n            });\n            let result;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            } catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", {\n                    action: \"receiveRpcError\",\n                    error\n                });\n                throw error;\n            }\n            this.emit(\"debug\", {\n                action: \"receiveRpcResult\",\n                result\n            });\n            if (\"result\" in result) {\n                return _network_js__WEBPACK_IMPORTED_MODULE_9__.Network.from((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(result.result));\n            }\n            throw this.getRpcError(payload, result);\n        })();\n        return await this.#pendingDetectNetwork;\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */ _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async ()=>{\n            // Bootstrap the network\n            while(this.#network == null && !this.destroyed){\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                        event: \"initial-network-discovery\",\n                        info: {\n                            error\n                        }\n                    }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */ async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */ _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_12__.PollingEventSubscriber(this, sub.filter);\n            }\n            return new _subscriber_filterid_js__WEBPACK_IMPORTED_MODULE_11__.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new _abstract_provider_js__WEBPACK_IMPORTED_MODULE_8__.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */ get ready() {\n        return this.#notReady == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */ getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.toQuantity)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_10__.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_13__.accessListify)(tx.accessList);\n        }\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */ getRpcRequest(req) {\n        switch(req.method){\n            case \"chainId\":\n                return {\n                    method: \"eth_chainId\",\n                    args: []\n                };\n            case \"getBlockNumber\":\n                return {\n                    method: \"eth_blockNumber\",\n                    args: []\n                };\n            case \"getGasPrice\":\n                return {\n                    method: \"eth_gasPrice\",\n                    args: []\n                };\n            case \"getPriorityFee\":\n                return {\n                    method: \"eth_maxPriorityFeePerGas\",\n                    args: []\n                };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        \"0x\" + req.position.toString(16),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [\n                        req.signedTransaction\n                    ]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [\n                            req.blockTag,\n                            !!req.includeTransactions\n                        ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [\n                            req.blockHash,\n                            !!req.includeTransactions\n                        ]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [\n                        this.getRpcTransaction(req.transaction),\n                        req.blockTag\n                    ]\n                };\n            case \"estimateGas\":\n                {\n                    return {\n                        method: \"eth_estimateGas\",\n                        args: [\n                            this.getRpcTransaction(req.transaction)\n                        ]\n                    };\n                }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return {\n                    method: \"eth_getLogs\",\n                    args: [\n                        req.filter\n                    ]\n                };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */ getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = _abi_index_js__WEBPACK_IMPORTED_MODULE_14__.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n            e.info = {\n                error,\n                payload\n            };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\"\n            };\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: actionMap[method] || \"unknown\",\n                reason: \"rejected\",\n                info: {\n                    payload,\n                    error\n                }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = payload.params[0];\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method,\n                    info: {\n                        transaction,\n                        info: {\n                            error\n                        }\n                    }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method,\n                info: {\n                    error,\n                    payload\n                }\n            });\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n            error,\n            payload\n        });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */ send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: method\n            }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject)=>{\n            this.#payloads.push({\n                resolve,\n                reject,\n                payload: {\n                    method,\n                    params,\n                    id,\n                    jsonrpc: \"2.0\"\n                }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */ async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof address === \"number\") {\n            const accounts = await accountsPromise;\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address);\n        for (const account of accounts){\n            if ((0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a)=>new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads){\n            reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n            }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */ class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options){\n        super(network, options);\n        this.#pollingInterval = 4000;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */ get pollingInterval() {\n        return this.#pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub)=>{\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */ class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options){\n        if (url == null) {\n            url = \"http://localhost:8545\";\n        }\n        super(network, options);\n        if (typeof url === \"string\") {\n            this.#connect = new _utils_index_js__WEBPACK_IMPORTED_MODULE_15__.FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [\n                resp\n            ];\n        }\n        return resp;\n    }\n}\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(/revert/i) && (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_6__.isHexString)(value.data)) {\n        return {\n            message: value.message,\n            data: value.data\n        };\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) {}\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) {}\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n} //# sourceMappingURL=provider-jsonrpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBUztBQUNULHlCQUF5QjtBQUN6Qix5UUFBeVE7QUFDOU47QUFDc0I7QUFDYjtBQUNJO0FBQzJIO0FBQ3BHO0FBQ3pCO0FBQ2Y7QUFDdUQ7QUFDN0I7QUFDakUsTUFBTXVCLFlBQVksK0NBQStDQyxLQUFLLENBQUM7QUFDdkUsZ0RBQWdEO0FBQ2hELFNBQVNDLFNBQVNDLEtBQUs7SUFDbkIsSUFBSUEsU0FBUyxRQUFRSCxVQUFVSSxPQUFPLENBQUMsT0FBUUQsVUFBVyxHQUFHO1FBQ3pELE9BQU9BO0lBQ1g7SUFDQSx1QkFBdUI7SUFDdkIsSUFBSSxPQUFRQSxNQUFNekIsVUFBVSxLQUFNLFlBQVk7UUFDMUMsT0FBT3lCO0lBQ1g7SUFDQSxJQUFJRSxNQUFNQyxPQUFPLENBQUNILFFBQVE7UUFDdEIsT0FBUUEsTUFBTUksR0FBRyxDQUFDTDtJQUN0QjtJQUNBLElBQUksT0FBUUMsVUFBVyxVQUFVO1FBQzdCLE9BQU9LLE9BQU9DLElBQUksQ0FBQ04sT0FBT08sTUFBTSxDQUFDLENBQUNDLE9BQU9DO1lBQ3JDRCxLQUFLLENBQUNDLElBQUksR0FBR1QsS0FBSyxDQUFDUyxJQUFJO1lBQ3ZCLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO0lBQ1I7SUFDQSxNQUFNLElBQUlFLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRVYsTUFBTSxFQUFFLEVBQUUsT0FBUUEsTUFBTyxDQUFDLENBQUM7QUFDckU7QUFDQSxTQUFTVyxNQUFNQyxRQUFRO0lBQ25CLE9BQU8sSUFBSUMsUUFBUSxDQUFDQztRQUFjQyxXQUFXRCxTQUFTRjtJQUFXO0FBQ3JFO0FBQ0EsU0FBU0ksYUFBYWhCLEtBQUs7SUFDdkIsSUFBSUEsT0FBTztRQUNQLE9BQU9BLE1BQU1pQixXQUFXO0lB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ZXpKLEtBQUs7SUFDekIsTUFBTWlHLFNBQVMsRUFBRTtJQUNqQjZGLGdCQUFnQjlMLE9BQU9pRztJQUN2QixPQUFPQTtBQUNYLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLWpzb25ycGMuanM/N2U0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBPbmUgb2YgdGhlIG1vc3QgY29tbW9uIHdheXMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYmxvY2tjaGFpbiBpc1xuICogIGJ5IGEgbm9kZSBydW5uaW5nIGEgSlNPTi1SUEMgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgdG8sXG4gKiAgYmFzZWQgb24gdGhlIHRyYW5zcG9ydCwgdXNpbmc6XG4gKlxuICogIC0gSFRUUCBvciBIVFRQUyAtIFtbSnNvblJwY1Byb3ZpZGVyXV1cbiAqICAtIFdlYlNvY2tldCAtIFtbV2ViU29ja2V0UHJvdmlkZXJdXVxuICogIC0gSVBDIC0gW1tJcGNTb2NrZXRQcm92aWRlcl1dXG4gKlxuICogQF9zZWN0aW9uOiBhcGkvcHJvdmlkZXJzL2pzb25ycGM6SlNPTi1SUEMgUHJvdmlkZXIgIFthYm91dC1qc29ucnBjUHJvdmlkZXJdXG4gKi9cbi8vIEBUT0RPOlxuLy8gLSBBZGQgdGhlIGJhdGNoaW5nIEFQSVxuLy8gaHR0cHM6Ly9wbGF5Z3JvdW5kLm9wZW4tcnBjLm9yZy8/c2NoZW1hVXJsPWh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ldGhlcmV1bS9ldGgxLjAtYXBpcy9hc3NlbWJsZWQtc3BlYy9vcGVucnBjLmpzb24mdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpzcGxpdFZpZXclNUQ9dHJ1ZSZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOmlucHV0JTVEPWZhbHNlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6ZXhhbXBsZXNEcm9wZG93biU1RD1mYWxzZVxuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi4vYWJpL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIHRvUXVhbnRpdHksIHRvVXRmOEJ5dGVzLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIEZldGNoUmVxdWVzdCwgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFic3RyYWN0UHJvdmlkZXIsIFVubWFuYWdlZFN1YnNjcmliZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RTaWduZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIjtcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tIFwiLi9uZXR3b3JrLmpzXCI7XG5pbXBvcnQgeyBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciwgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciB9IGZyb20gXCIuL3N1YnNjcmliZXItZmlsdGVyaWQuanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmNvbnN0IFByaW1pdGl2ZSA9IFwiYmlnaW50LGJvb2xlYW4sZnVuY3Rpb24sbnVtYmVyLHN0cmluZyxzeW1ib2xcIi5zcGxpdCgvLC9nKTtcbi8vY29uc3QgTWV0aG9kcyA9IFwiZ2V0QWRkcmVzcyx0aGVuXCIuc3BsaXQoLywvZyk7XG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IFByaW1pdGl2ZS5pbmRleE9mKHR5cGVvZiAodmFsdWUpKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLy8gS2VlcCBhbnkgQWRkcmVzc2FibGVcbiAgICBpZiAodHlwZW9mICh2YWx1ZS5nZXRBZGRyZXNzKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUubWFwKGRlZXBDb3B5KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzaG91bGQgbm90IGhhcHBlbjogJHt2YWx1ZX0gKCR7dHlwZW9mICh2YWx1ZSl9KWApO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1BvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnBvbGxpbmdJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpO1xufVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcG9sbGluZzogZmFsc2UsXG4gICAgc3RhdGljTmV0d29yazogbnVsbCxcbiAgICBiYXRjaFN0YWxsVGltZTogMTAsXG4gICAgYmF0Y2hNYXhTaXplOiAoMSA8PCAyMCksXG4gICAgYmF0Y2hNYXhDb3VudDogMTAwLFxuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8vIEBUT0RPOiBVbmNoZWNrZWQgU2lnbmVyc1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBBYnN0cmFjdFNpZ25lciB7XG4gICAgYWRkcmVzcztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcykge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIFwiY2Fubm90IHJlY29ubmVjdCBKc29uUnBjU2lnbmVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgIH1cbiAgICAvLyBKU09OLVJQQyB3aWxsIGF1dG9tYXRpYWxseSBmaWxsIGluIG5vbmNlLCBldGMuIHNvIHdlIGp1c3QgY2hlY2sgZnJvbVxuICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBqdXN0IHRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBhZnRlciBzZW50LCB3aGljaCBpcyB3aGF0XG4gICAgLy8gdGhlIGJhcmUgSlNPTi1SUEMgQVBJIGRvZXM7XG4gICAgYXN5bmMgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IF9mcm9tID0gdHguZnJvbTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3MoX2Zyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKF90bywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IHVudGlsIGFsbCBvZiBvdXIgcHJvcGVydGllcyBhcmUgZmlsbGVkIGluXG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgLy8gZm9yIGEgcmVzcG9uc2UsIGFuZCB3ZSBuZWVkIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb24sIHNvIHdlIHBvbGxcbiAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgcmV0dXJuIGF3YWl0IChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0cyA9IFsxMDAwLCAxMDBdO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tUeCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBhbm90aGVyIDQgc2Vjb25kc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIuX3NldFRpbWVvdXQoKCkgPT4geyBjaGVja1R4KCk7IH0sIHRpbWVvdXRzLnBvcCgpIHx8IDQwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoZWNrVHgoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oX3R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gZGVlcENvcHkoX3R4KTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmcm9tIG1hdGNoZXMgdGhlIHNlbmRlclxuICAgICAgICBpZiAodHguZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHR4LmZyb20sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbXG4gICAgICAgICAgICBoZXhsaWZ5KG1lc3NhZ2UpLCB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ29weShfdmFsdWUpO1xuICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHJlc29sdmVBZGRyZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFR5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICBhc3luYyBfbGVnYWN5U2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkobWVzc2FnZSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiAgVGhlIEpzb25ScGNBcGlQcm92aWRlciBpcyBhbiBhYnN0cmFjdCBjbGFzcyBhbmQgKipNVVNUKiogYmVcbiAqICBzdWItY2xhc3NlZC5cbiAqXG4gKiAgSXQgcHJvdmlkZXMgdGhlIGJhc2UgZm9yIGFsbCBKU09OLVJQQy1iYXNlZCBQcm92aWRlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIE5vdGVzOlxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBvdmVycmlkZSBfc2VuZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIHRoZSBgX3N0YXJ0KClgIG1ldGhvZCBvbmNlIGNvbm5lY3RlZFxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0FwaVByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgI3NjaGVkdWxlRHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLiNkcmFpblRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIGJhdGNoaW5nLCBubyBoYXJkIGluIHNlbmRpbmcgaXQgaW1tZWlkYXRlbHlcbiAgICAgICAgY29uc3Qgc3RhbGxUaW1lID0gKHRoaXMuX2dldE9wdGlvbihcImJhdGNoTWF4Q291bnRcIikgPT09IDEpID8gMCA6IHRoaXMuX2dldE9wdGlvbihcImJhdGNoU3RhbGxUaW1lXCIpO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWRzID0gdGhpcy4jcGF5bG9hZHM7XG4gICAgICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXlsb2FkIGJhdGNoZXMgdGhhdCBzYXRpc2Z5IG91ciBiYXRjaCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gWyhwYXlsb2Fkcy5zaGlmdCgpKV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBheWxvYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID09PSB0aGlzLiNvcHRpb25zLmJhdGNoTWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goKHBheWxvYWRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBKU09OLnN0cmluZ2lmeShiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gdGhpcy4jb3B0aW9ucy5iYXRjaE1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzLnVuc2hpZnQoKGJhdGNoLnBvcCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSByZXN1bHQgdG8gZWFjaCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgoYmF0Y2gubGVuZ3RoID09PSAxKSA/IGJhdGNoWzBdLnBheWxvYWQgOiBiYXRjaC5tYXAoKHApID0+IHAucGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRzIGluIGJhdGNoIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0LCBwYXlsb2FkIH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtYWtlRXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlIGZvciByZXF1ZXN0XCIsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCwgaW5mbzogeyBwYXlsb2FkIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXNwb25zZSBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5nZXRScGNFcnJvcihwYXlsb2FkLCByZXNwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZ29vZDsgc2VuZCB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVqZWN0IH0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogYXVnbWVudCB0aGUgZXJyb3Igd2l0aCB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFsbFRpbWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNuZXh0SWQgPSAxO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICB0aGlzLiNkcmFpblRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jbm90UmVhZHkgPSB7IHByb21pc2UsIHJlc29sdmUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0aWNOZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGljTmV0d29yaykgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCghc3RhdGljTmV0d29yayB8fCBuZXR3b3JrICE9PSBcImFueVwiLCBcInN0YXRpY05ldHdvcmsgY2Fubm90IGJlIHVzZWQgb24gc3BlY2lhbCBuZXR3b3JrICdhbnknXCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNOZXR3b3JrICYmIG5ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBOZXR3b3JrLmZyb20obmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGljTmV0d29yaykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBzdGF0aWMgbmV0d29yayBpcyBjb21wYXRiaWxlIHdpdGggdGhlIHByb3ZpZGVkIG5ldHdyb2tcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI25ldHdvcmssIFwibmV0d29yayBpcyBub3QgYXZhaWxhYmxlIHlldFwiLCBcIk5FVFdPUktfRVJST1JcIik7XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG5vbi1ub3JtYWxpemVkIHZhbHVlIGJ5IHBlcmZvcm1pbmcgJSVyZXElJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgYmVoYXZpb3Igb2YgYWN0aW9ucyxcbiAgICAgKiAgYW5kIHNob3VsZCBnZW5lcmFsbHkgY2FsbCBgYHN1cGVyLl9wZXJmb3JtYGAgYXMgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgLy8gaXMgZmFpciksIHNvIHdlIGRlbGV0ZSB0eXBlIGlmIGl0IGlzIDAgYW5kIGEgbm9uLUVJUC0xNTU5IG5ldHdvcmtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgbGV0IHR4ID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHR4ICYmIHR4LnR5cGUgIT0gbnVsbCAmJiBnZXRCaWdJbnQodHgudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gRUlQLTE1NTkgcHJvcGVydGllcywgaXQgbWlnaHQgYmUgbm9uLUVJUC1hNTU5XG4gICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyB0eXBlOiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJwY1JlcXVlc3QocmVxKTtcbiAgICAgICAgaWYgKHJlcXVlc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzOyBpdCBkZXRlY3RzIHRoZSAqYWN0dWFsKiBuZXR3b3JrIHRoYXRcbiAgICAgKiAgd2UgYXJlICoqY3VycmVudGx5KiogY29ubmVjdGVkIHRvLlxuICAgICAqXG4gICAgICogIEtlZXAgaW4gbWluZCB0aGF0IFtbc2VuZF1dIG1heSBvbmx5IGJlIHVzZWQgb25jZSBbW3JlYWR5XV0sIG90aGVyd2lzZSB0aGVcbiAgICAgKiAgX3NlbmQgcHJpbWl0aXZlIG11c3QgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5fZ2V0T3B0aW9uKFwic3RhdGljTmV0d29ya1wiKTtcbiAgICAgICAgaWYgKG5ldHdvcmspIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE5ldHdvcmsuZnJvbShnZXRCaWdJbnQoYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pKSk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcGVuZGluZ0RldGVjdE5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBub3QgcmVhZHkgeWV0OyB1c2UgdGhlIHByaW1pdGl2ZSBfc2VuZFxuICAgICAgICB0aGlzLiNwZW5kaW5nRGV0ZWN0TmV0d29yayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLiNuZXh0SWQrKywgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIHBhcmFtczogW10sIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kUnBjUGF5bG9hZFwiLCBwYXlsb2FkIH0pO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKGF3YWl0IHRoaXMuX3NlbmQocGF5bG9hZCkpWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjRXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUnBjUmVzdWx0XCIsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIGlmIChcInJlc3VsdFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOZXR3b3JrLmZyb20oZ2V0QmlnSW50KHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3BlbmRpbmdEZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKipNVVNUKiogY2FsbCB0aGlzLiBVbnRpbCBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2FsbHNcbiAgICAgKiAgd2lsbCBiZSBwYXNzZWQgdG8gW1tfc2VuZF1dIGZyb20gW1tzZW5kXV0uIElmIGl0IGlzIG92ZXJyaWRkZW4sIHRoZW5cbiAgICAgKiAgYGBzdXBlci5fc3RhcnQoKWBgICoqTVVTVCoqIGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICBDYWxsaW5nIGl0IG11bHRpcGxlIHRpbWVzIGlzIHNhZmUgYW5kIGhhcyBubyBlZmZlY3QuXG4gICAgICovXG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCB8fCB0aGlzLiNub3RSZWFkeS5yZXNvbHZlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNub3RSZWFkeS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuI25vdFJlYWR5ID0gbnVsbDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgbmV0d29ya1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuI25ldHdvcmsgPT0gbnVsbCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gYXdhaXQgdGhpcy5fZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkpzb25ScGNQcm92aWRlciBmYWlsZWQgdG8gZGV0ZWN0IG5ldHdvcmsgYW5kIGNhbm5vdCBzdGFydCB1cDsgcmV0cnkgaW4gMXMgKHBlcmhhcHMgdGhlIFVSTCBpcyB3cm9uZyBvciB0aGUgbm9kZSBpcyBub3Qgc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG1ha2VFcnJvcihcImZhaWxlZCB0byBib290c3RyYXAgbmV0d29yayBkZXRlY3Rpb25cIiwgXCJORVRXT1JLX0VSUk9SXCIsIHsgZXZlbnQ6IFwiaW5pdGlhbC1uZXR3b3JrLWRpc2NvdmVyeVwiLCBpbmZvOiB7IGVycm9yIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdGFsbCgxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBkaXNwYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICAgICAgdGhpcy4jc2NoZWR1bGVEcmFpbigpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGUgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQuIFRoaXMgY2FuIGJlIHVzZWQgaW5cbiAgICAgKiAgc3ViLWNsYXNzZXMgdG8gZGVmZXIgc2VuZGluZyBkYXRhIHVudGlsIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogIGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF93YWl0VW50aWxSZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbm90UmVhZHkucHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFN1YnNjcmliZXIgdGhhdCB3aWxsIG1hbmFnZSB0aGUgJSVzdWIlJS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mXG4gICAgICogIHN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIF9nZXRTdWJzY3JpYmVyKHN1Yikge1xuICAgICAgICAvLyBQZW5kaW5nIEZpbHRlcnMgYXJlbid0IGF2YWlsYmxlIHZpYSBwb2xsaW5nXG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ycGhhbmVkIExvZ3MgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSwgYnkgdGhlIGZpbHRlciwgc2luY2VcbiAgICAgICAgLy8gbG9ncyB3aXRoIHJlbW92ZWQgYXJlIGVtaXR0ZWQgYnkgaXRcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcIm9ycGhhblwiICYmIHN1Yi5maWx0ZXIub3JwaGFuID09PSBcImRyb3AtbG9nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlcihcIm9ycGhhblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHkoKSB7IHJldHVybiB0aGlzLiNub3RSZWFkeSA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0eCUlIGFzIGEgbm9ybWFsaXplZCBKU09OLVJQQyB0cmFuc2FjdGlvbiByZXF1ZXN0LFxuICAgICAqICB3aGljaCBoYXMgYWxsIHZhbHVlcyBoZXhsaWZpZWQgYW5kIGFueSBudW1lcmljIHZhbHVlcyBjb252ZXJ0ZWRcbiAgICAgKiAgdG8gUXVhbnRpdHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFJwY1RyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRzdEtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGRzdEtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbZHN0S2V5XSA9IHRvUXVhbnRpdHkoZ2V0QmlnSW50KHR4W2tleV0sIGB0eC4ke2tleX1gKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWRkcmVzc2VzIGFuZCBkYXRhIGFyZSBsb3dlcmNhc2VcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHhba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGFjY2VzcyBsaXN0IG9iamVjdFxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHJlcXVlc3QgbWV0aG9kIGFuZCBhcmd1bWVudHMgcmVxdWlyZWQgdG8gcGVyZm9ybVxuICAgICAqICAlJXJlcSUlLlxuICAgICAqL1xuICAgIGdldFJwY1JlcXVlc3QocmVxKSB7XG4gICAgICAgIHN3aXRjaCAocmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2NoYWluSWRcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfYmxvY2tOdW1iZXJcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfZ2FzUHJpY2VcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRQcmlvcml0eUZlZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZDogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgYXJnczogW10gfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtnZXRMb3dlckNhc2UocmVxLmFkZHJlc3MpLCByZXEuYmxvY2tUYWddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIjB4XCIgKyByZXEucG9zaXRpb24udG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuc2lnbmVkVHJhbnNhY3Rpb25dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuYmxvY2tUYWcsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiYmxvY2tIYXNoXCIgaW4gcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldEJsb2NrQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrSGFzaCwgISFyZXEuaW5jbHVkZVRyYW5zYWN0aW9uc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtyZXEuaGFzaF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2NhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3RoaXMuZ2V0UnBjVHJhbnNhY3Rpb24ocmVxLnRyYW5zYWN0aW9uKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVxLmZpbHRlciAmJiByZXEuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEuZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSByZXEuZmlsdGVyLmFkZHJlc3MubWFwKGdldExvd2VyQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocmVxLmZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dldExvZ3NcIiwgYXJnczogW3JlcS5maWx0ZXJdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1zdHlsZSBFcnJvciBmb3IgdGhlIGdpdmVuIEpTT04tUlBDIGVycm9yXG4gICAgICogICUlcGF5bG9hZCUlLCBjb2FsZXNjaW5nIHRoZSB2YXJpb3VzIHN0cmluZ3MgYW5kIGVycm9yIHNoYXBlc1xuICAgICAqICB0aGF0IGRpZmZlcmVudCBub2RlcyByZXR1cm4sIGNvZXJjaW5nIHRoZW0gaW50byBhIG1hY2hpbmUtcmVhZGFibGVcbiAgICAgKiAgc3RhbmRhcmRpemVkIGVycm9yLlxuICAgICAqL1xuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIF9lcnJvcikge1xuICAgICAgICBjb25zdCB7IG1ldGhvZCB9ID0gcGF5bG9hZDtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gX2Vycm9yO1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIW1zZy5tYXRjaCgvcmV2ZXJ0L2kpICYmIG1zZy5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kc1wiLCBcIklOU1VGRklDSUVOVF9GVU5EU1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiAocGF5bG9hZC5wYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9jYWxsXCIgfHwgbWV0aG9kID09PSBcImV0aF9lc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YShlcnJvcik7XG4gICAgICAgICAgICBjb25zdCBlID0gQWJpQ29kZXIuZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oKG1ldGhvZCA9PT0gXCJldGhfY2FsbFwiKSA/IFwiY2FsbFwiIDogXCJlc3RpbWF0ZUdhc1wiLCAocGF5bG9hZC5wYXJhbXNbMF0pLCAocmVzdWx0ID8gcmVzdWx0LmRhdGEgOiBudWxsKSk7XG4gICAgICAgICAgICBlLmluZm8gPSB7IGVycm9yLCBwYXlsb2FkIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVzdGltYXRlR2FzIGFuZCBjYWxsIGNhbiByZXR1cm4gYXJiaXRyYXJ5IGNvbnRyYWN0LWRlZmluZWQgdGV4dCwgc28gbm93IHdlXG4gICAgICAgIC8vIHdlIGNhbiBwcm9jZXNzIHRleHQgc2FmZWx5LlxuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoc3BlbHVua01lc3NhZ2UoZXJyb3IpKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWR8ZXRoZXJzLXVzZXItZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25NYXAgPSB7XG4gICAgICAgICAgICAgICAgZXRoX3NpZ246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICBwZXJzb25hbF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IFwic2lnblR5cGVkRGF0YVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3NlbmRUcmFuc2FjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBldGhfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcmVxdWVzdEFjY291bnRzOiBcInJlcXVlc3RBY2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yKGB1c2VyIHJlamVjdGVkIGFjdGlvbmAsIFwiQUNUSU9OX1JFSkVDVEVEXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IChhY3Rpb25NYXBbbWV0aG9kXSB8fCBcInVua25vd25cIiksXG4gICAgICAgICAgICAgICAgcmVhc29uOiBcInJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBwYXlsb2FkLCBlcnJvciB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiB8fCBtZXRob2QgPT09IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IChwYXlsb2FkLnBhcmFtc1swXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0L2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHsgdHJhbnNhY3Rpb24sIGluZm86IHsgZXJyb3IgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uL2kpICYmIG1lc3NhZ2UubWF0Y2goL3VuZGVycHJpY2VkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwgeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlRXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCwgaW5mbzogeyBlcnJvciwgcGF5bG9hZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZUVycm9yKFwiY291bGQgbm90IGNvYWxlc2NlIGVycm9yXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7IGVycm9yLCBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVxdWVzdHMgdGhlICUlbWV0aG9kJSUgd2l0aCAlJXBhcmFtcyUlIHZpYSB0aGUgSlNPTi1SUEMgcHJvdG9jb2xcbiAgICAgKiAgb3ZlciB0aGUgdW5kZXJseWluZyBjaGFubmVsLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGwgbWV0aG9kc1xuICAgICAqICBvbiB0aGUgYmFja2VuZCB0aGF0IGRvIG5vdCBoYXZlIGEgaGlnaC1sZXZlbCBBUEkgd2l0aGluIHRoZSBQcm92aWRlclxuICAgICAqICBBUEkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZXRob2QgcXVldWVzIHJlcXVlc3RzIGFjY29yZGluZyB0byB0aGUgYmF0Y2ggY29uc3RyYWludHNcbiAgICAgKiAgaW4gdGhlIG9wdGlvbnMsIGFzc2lnbnMgdGhlIHJlcXVlc3QgYSB1bmlxdWUgSUQuXG4gICAgICpcbiAgICAgKiAgKipEbyBOT1Qgb3ZlcnJpZGUqKiB0aGlzIG1ldGhvZCBpbiBzdWItY2xhc3NlczsgaW5zdGVhZFxuICAgICAqICBvdmVycmlkZSBbW19zZW5kXV0gb3IgZm9yY2UgdGhlIG9wdGlvbnMgdmFsdWVzIGluIHRoZVxuICAgICAqICBjYWxsIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBjYWNoZSBjaGFpbklkPz8gcHVyZ2Ugb24gc3dpdGNoX25ldHdvcmtzXG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBkZXN0cm95ZWQ7IG5vIG9wZXJhdGlvbnMgYXJlIHN1cHBvcnRlZCBhbnltb3JlXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50c1Byb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFjY291bnQgYWRkcmVzc1xuICAgICAgICBhZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwYXlsb2FkcyA9IFtdO1xuICAgICAgICAvLyBQYXJlbnQgY2xlYW4tdXBcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNsYXNzIEpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jcG9sbGluZ0ludGVydmFsID0gNDAwMDtcbiAgICB9XG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSBzdXBlci5fZ2V0U3Vic2NyaWJlcihzdWIpO1xuICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWJzY3JpYmVyKSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcG9sbGluZyBpbnRlcnZhbCAoZGVmYXVsdDogNDAwMCBtcylcbiAgICAgKi9cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jcG9sbGluZ0ludGVydmFsOyB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnRlcnZhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaFN1YnNjcmliZXIoKHN1YikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUG9sbGFibGUoc3ViKSkge1xuICAgICAgICAgICAgICAgIHN1Yi5wb2xsaW5nSW50ZXJ2YWwgPSB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIFRoZSBKc29uUnBjUHJvdmlkZXIgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbiBQcm92aWRlcnMsXG4gKiAgd2hpY2ggcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgb3ZlciBIVFRQIChvciBIVFRQUykgcmVxdWVzdHMuXG4gKlxuICogIEV2ZW50cyBhcmUgcHJvY2Vzc2VkIGJ5IHBvbGxpbmcgdGhlIGJhY2tlbmQgZm9yIHRoZSBjdXJyZW50IGJsb2NrXG4gKiAgbnVtYmVyOyB3aGVuIGl0IGFkdmFuY2VzLCBhbGwgYmxvY2stYmFzZSBldmVudHMgYXJlIHRoZW4gY2hlY2tlZFxuICogIGZvciB1cGRhdGVzLlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciB7XG4gICAgI2Nvbm5lY3Q7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdXJsID0gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gbmV3IEZldGNoUmVxdWVzdCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9IHVybC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29ubmVjdC5jbG9uZSgpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEFsbCByZXF1ZXN0cyBhcmUgb3ZlciBIVFRQLCBzbyB3ZSBjYW4ganVzdCBzdGFydCBoYW5kbGluZyByZXF1ZXN0c1xuICAgICAgICAvLyBXZSBkbyB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gdGhlIGNvbnN0cnVjdG9yIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBhbnlcbiAgICAgICAgLy8gcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmsgKGkuZS4gZXRoX2NoYWluSWQpIHVudGlsIHdlIGFic29sdXRlbHkgaGF2ZSB0by5cbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBhIFBPU1QgY29ubmVjdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBtZXRob2RcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX2dldENvbm5lY3Rpb24oKTtcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgcmVzcG9uc2UuYXNzZXJ0T2soKTtcbiAgICAgICAgbGV0IHJlc3AgPSByZXNwb25zZS5ib2R5SnNvbjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3ApKSB7XG4gICAgICAgICAgICByZXNwID0gW3Jlc3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNwZWx1bmtEYXRhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWVzc2FnZS5tYXRjaCgvcmV2ZXJ0L2kpICYmIGlzSGV4U3RyaW5nKHZhbHVlLmRhdGEpKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGE6IHZhbHVlLmRhdGEgfTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rRGF0YSh2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rRGF0YShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGhlc2UgKmFyZSogdGhlIGRyb2lkcyB3ZSdyZSBsb29raW5nIGZvci5cbiAgICBpZiAodHlwZW9mICh2YWx1ZS5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBfc3BlbHVua01lc3NhZ2UodmFsdWVba2V5XSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfc3BlbHVua01lc3NhZ2UoSlNPTi5wYXJzZSh2YWx1ZSksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBzcGVsdW5rTWVzc2FnZSh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIF9zcGVsdW5rTWVzc2FnZSh2YWx1ZSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItanNvbnJwYy5qcy5tYXAiXSwibmFtZXMiOlsiQWJpQ29kZXIiLCJnZXRBZGRyZXNzIiwicmVzb2x2ZUFkZHJlc3MiLCJUeXBlZERhdGFFbmNvZGVyIiwiYWNjZXNzTGlzdGlmeSIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJoZXhsaWZ5IiwiaXNIZXhTdHJpbmciLCJ0b1F1YW50aXR5IiwidG9VdGY4Qnl0ZXMiLCJtYWtlRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkZldGNoUmVxdWVzdCIsInJlc29sdmVQcm9wZXJ0aWVzIiwiQWJzdHJhY3RQcm92aWRlciIsIlVubWFuYWdlZFN1YnNjcmliZXIiLCJBYnN0cmFjdFNpZ25lciIsIk5ldHdvcmsiLCJGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciIsIkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIiLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiUHJpbWl0aXZlIiwic3BsaXQiLCJkZWVwQ29weSIsInZhbHVlIiwiaW5kZXhPZiIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsImtleSIsIkVycm9yIiwic3RhbGwiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldExvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwiaXNQb2xsYWJsZSIsInBvbGxpbmdJbnRlcnZhbCIsImRlZmF1bHRPcHRpb25zIiwicG9sbGluZyIsInN0YXRpY05ldHdvcmsiLCJiYXRjaFN0YWxsVGltZSIsImJhdGNoTWF4U2l6ZSIsImJhdGNoTWF4Q291bnQiLCJjYWNoZVRpbWVvdXQiLCJKc29uUnBjU2lnbmVyIiwiY29uc3RydWN0b3IiLCJwcm92aWRlciIsImFkZHJlc3MiLCJjb25uZWN0Iiwib3BlcmF0aW9uIiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsInR4IiwicG9wdWxhdGVDYWxsIiwic2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uIiwiX3R4IiwicHJvbWlzZXMiLCJmcm9tIiwiX2Zyb20iLCJwdXNoIiwiZ2FzTGltaXQiLCJlc3RpbWF0ZUdhcyIsInRvIiwiX3RvIiwibGVuZ3RoIiwiYWxsIiwiaGV4VHgiLCJnZXRScGNUcmFuc2FjdGlvbiIsInNlbmQiLCJzZW5kVHJhbnNhY3Rpb24iLCJibG9ja051bWJlciIsImdldEJsb2NrTnVtYmVyIiwiaGFzaCIsInJlamVjdCIsInRpbWVvdXRzIiwiY2hlY2tUeCIsImdldFRyYW5zYWN0aW9uIiwicmVwbGFjZWFibGVUcmFuc2FjdGlvbiIsIl9zZXRUaW1lb3V0IiwicG9wIiwic2lnblRyYW5zYWN0aW9uIiwic2lnbk1lc3NhZ2UiLCJfbWVzc2FnZSIsIm1lc3NhZ2UiLCJzaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJfdmFsdWUiLCJwb3B1bGF0ZWQiLCJyZXNvbHZlTmFtZXMiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0UGF5bG9hZCIsInVubG9jayIsInBhc3N3b3JkIiwiX2xlZ2FjeVNpZ25NZXNzYWdlIiwiSnNvblJwY0FwaVByb3ZpZGVyIiwib3B0aW9ucyIsIm5leHRJZCIsInBheWxvYWRzIiwiZHJhaW5UaW1lciIsIm5vdFJlYWR5IiwibmV0d29yayIsInBlbmRpbmdEZXRlY3ROZXR3b3JrIiwic2NoZWR1bGVEcmFpbiIsInN0YWxsVGltZSIsIl9nZXRPcHRpb24iLCJiYXRjaCIsInNoaWZ0IiwiYnl0ZXMiLCJwIiwicGF5bG9hZCIsInVuc2hpZnQiLCJlbWl0IiwiYWN0aW9uIiwicmVzdWx0IiwiX3NlbmQiLCJkZXN0cm95ZWQiLCJtZXRob2QiLCJyZXNwIiwiZmlsdGVyIiwiciIsImlkIiwiZXJyb3IiLCJpbmZvIiwiZ2V0UnBjRXJyb3IiLCJhc3NpZ24iLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJtYXRjaGVzIiwiX25ldHdvcmsiLCJfcGVyZm9ybSIsInJlcSIsInRyYW5zYWN0aW9uIiwidHlwZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0IiwiZ2V0UnBjUmVxdWVzdCIsImFyZ3MiLCJfZGV0ZWN0TmV0d29yayIsInJlYWR5IiwicGFyYW1zIiwianNvbnJwYyIsIl9zdGFydCIsImNvbnNvbGUiLCJsb2ciLCJldmVudCIsIl93YWl0VW50aWxSZWFkeSIsIl9nZXRTdWJzY3JpYmVyIiwic3ViIiwib3JwaGFuIiwiZm9yRWFjaCIsImRzdEtleSIsImFjY2Vzc0xpc3QiLCJibG9ja1RhZyIsInBvc2l0aW9uIiwidG9TdHJpbmciLCJzaWduZWRUcmFuc2FjdGlvbiIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJibG9ja0hhc2giLCJfZXJyb3IiLCJtc2ciLCJtYXRjaCIsInNwZWx1bmtEYXRhIiwiZSIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiZGF0YSIsInNwZWx1bmtNZXNzYWdlIiwiYWN0aW9uTWFwIiwiZXRoX3NpZ24iLCJwZXJzb25hbF9zaWduIiwiZXRoX3NpZ25UeXBlZERhdGFfdjQiLCJldGhfc2lnblRyYW5zYWN0aW9uIiwiZXRoX3NlbmRUcmFuc2FjdGlvbiIsImV0aF9yZXF1ZXN0QWNjb3VudHMiLCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzIiwicmVhc29uIiwidW5zdXBwb3J0ZWQiLCJkZXRhaWxzIiwic3RhcnRzV2l0aCIsImdldFNpZ25lciIsImFjY291bnRzUHJvbWlzZSIsImFjY291bnRzIiwiZ2V0TmV0d29yayIsImFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJhIiwiZGVzdHJveSIsImNsZWFyVGltZW91dCIsIkpzb25ScGNBcGlQb2xsaW5nUHJvdmlkZXIiLCJzdWJzY3JpYmVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiX2ZvckVhY2hTdWJzY3JpYmVyIiwiSnNvblJwY1Byb3ZpZGVyIiwidXJsIiwiY2xvbmUiLCJfZ2V0Q29ubmVjdGlvbiIsImJvZHkiLCJzZXRIZWFkZXIiLCJyZXNwb25zZSIsImFzc2VydE9rIiwiYm9keUpzb24iLCJwYXJzZSIsIl9zcGVsdW5rTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        this.#transactions = block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            miner: block.miner,\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas)\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */ get transactions() {\n        return this.#transactions.map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, nonce, number, parentHash, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            hash,\n            miner,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            transactions\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return this.#transactions.length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash === hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    #logs;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.#logs = Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            gasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return this.#logs;\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    #startBlock;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            accessList,\n            blockNumber,\n            blockHash,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQTBEO0FBQ3lGO0FBQzNGO0FBQ3hELE1BQU1VLE9BQU9DLE9BQU87QUFDcEIsMEJBQTBCO0FBQzFCLFNBQVNDLFNBQVNDLEtBQUs7SUFDbkIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNDLE9BQU9ELEtBQUs7SUFDakIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTUUsUUFBUTtBQUN6QjtBQUNBLDBEQUEwRDtBQUMxRDs7O0NBR0MsR0FDTSxNQUFNQztJQTRCVDs7O0tBR0MsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixDQUFFO1FBQ3REcEIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmtCLFVBQVVOLFNBQVNNO1lBQ25CQyxjQUFjUCxTQUFTTztZQUN2QkMsc0JBQXNCUixTQUFTUTtRQUNuQztJQUNKO0lBQ0E7O0tBRUMsR0FDREMsU0FBUztRQUNMLE1BQU0sRUFBRUgsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUcsSUFBSTtRQUM3RCxPQUFPO1lBQ0hFLE9BQU87WUFDUEosVUFBVUosT0FBT0k7WUFDakJDLGNBQWNMLE9BQU9LO1lBQ3JCQyxzQkFBc0JOLE9BQU9NO1FBQ2pDO0lBQ0o7QUFDSjs7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRyxZQUFZQyxHQUFHO0lBQzNCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixzREFBc0Q7SUFDdEQsSUFBSUQsSUFBSUUsRUFBRSxFQUFFO1FBQ1JELE9BQU9DLEVBQUUsR0FBR0YsSUFBSUUsRUFBRTtJQUN0QjtJQUNBLElBQUlGLElBQUlHLElBQUksRUFBRTtRQUNWRixPQUFPRSxJQUFJLEdBQUdILElBQUlHLElBQUk7SUFDMUI7SUFDQSxJQUFJSCxJQUFJSSxJQUFJLEVBQUU7UUFDVkgsT0FBT0csSUFBSSxHQUFHekIsd0RBQU9BLENBQUNxQixJQUFJSSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsYUFBYSxvRUFBb0VDLEtBQUssQ0FBQztJQUM3RixLQUFLLE1BQU1DLE9BQU9GLFdBQVk7UUFDMUIsSUFBSSxDQUFFRSxDQUFBQSxPQUFPUCxHQUFFLEtBQU1BLEdBQUcsQ0FBQ08sSUFBSSxJQUFJLE1BQU07WUFDbkM7UUFDSjtRQUNBTixNQUFNLENBQUNNLElBQUksR0FBRzlCLDBEQUFTQSxDQUFDdUIsR0FBRyxDQUFDTyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUVBLElBQUksQ0FBQztJQUN0RDtJQUNBLE1BQU1DLGFBQWEsYUFBYUYsS0FBSyxDQUFDO0lBQ3RDLEtBQUssTUFBTUMsT0FBT0MsV0FBWTtRQUMxQixJQUFJLENBQUVELENBQUFBLE9BQU9QLEdBQUUsS0FBTUEsR0FBRyxDQUFDTyxJQUFJLElBQUksTUFBTTtZQUNuQztRQUNKO1FBQ0FOLE1BQU0sQ0FBQ00sSUFBSSxHQUFHN0IsMERBQVNBLENBQUNzQixHQUFHLENBQUNPLElBQUksRUFBRSxDQUFDLFFBQVEsRUFBRUEsSUFBSSxDQUFDO0lBQ3REO0lBQ0EsSUFBSVAsSUFBSVMsVUFBVSxFQUFFO1FBQ2hCUixPQUFPUSxVQUFVLEdBQUd4QixvRUFBYUEsQ0FBQ2UsSUFBSVMsVUFBVTtJQUNwRDtJQUNBLElBQUksY0FBY1QsS0FBSztRQUNuQkMsT0FBT1MsUUFBUSxHQUFHVixJQUFJVSxRQUFRO0lBQ2xDO0lBQ0EsSUFBSSxvQkFBb0JWLEtBQUs7UUFDekJDLE9BQU9VLGNBQWMsR0FBRyxDQUFDLENBQUNYLElBQUlXLGNBQWM7SUFDaEQ7SUFDQSxJQUFJLGdCQUFnQlgsS0FBSztRQUNyQkMsT0FBT1csVUFBVSxHQUFHWixJQUFJWSxVQUFVO0lBQ3RDO0lBQ0EsT0FBT1g7QUFDWDtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1ZO0lBcUVULENBQUNDLFlBQVksQ0FBQztJQUNkOzs7OztLQUtDLEdBQ0RyQixZQUFZc0IsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDekIsSUFBSSxDQUFDLENBQUNGLFlBQVksR0FBR0MsTUFBTUQsWUFBWSxDQUFDRyxHQUFHLENBQUMsQ0FBQ0M7WUFDekMsSUFBSSxPQUFRQSxPQUFRLFVBQVU7Z0JBQzFCLE9BQU8sSUFBSUMsb0JBQW9CRCxJQUFJRjtZQUN2QztZQUNBLE9BQU9FO1FBQ1g7UUFDQTFDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJ3QztZQUNBSSxNQUFNaEMsU0FBUzJCLE1BQU1LLElBQUk7WUFDekJDLFFBQVFOLE1BQU1NLE1BQU07WUFDcEJDLFdBQVdQLE1BQU1PLFNBQVM7WUFDMUJDLFlBQVlSLE1BQU1RLFVBQVU7WUFDNUJDLE9BQU9ULE1BQU1TLEtBQUs7WUFDbEJDLFlBQVlWLE1BQU1VLFVBQVU7WUFDNUJDLFVBQVVYLE1BQU1XLFFBQVE7WUFDeEJDLFNBQVNaLE1BQU1ZLE9BQU87WUFDdEJDLE9BQU9iLE1BQU1hLEtBQUs7WUFDbEJDLFdBQVdkLE1BQU1jLFNBQVM7WUFDMUJDLGVBQWUxQyxTQUFTMkIsTUFBTWUsYUFBYTtRQUMvQztJQUNKO0lBQ0E7OztLQUdDLEdBQ0QsSUFBSWhCLGVBQWU7UUFDZixPQUFPLElBQUksQ0FBQyxDQUFDQSxZQUFZLENBQUNHLEdBQUcsQ0FBQyxDQUFDQztZQUMzQixJQUFJLE9BQVFBLE9BQVEsVUFBVTtnQkFDMUIsT0FBT0E7WUFDWDtZQUNBLE9BQU9BLEdBQUdFLElBQUk7UUFDbEI7SUFDSjtJQUNBOzs7Ozs7O0tBT0MsR0FDRCxJQUFJVyx5QkFBeUI7UUFDekIsTUFBTUMsTUFBTSxJQUFJLENBQUMsQ0FBQ2xCLFlBQVksQ0FBQ21CLEtBQUs7UUFDcEMsb0JBQW9CO1FBQ3BCLElBQUlELElBQUlFLE1BQU0sS0FBSyxHQUFHO1lBQ2xCLE9BQU8sRUFBRTtRQUNiO1FBQ0EsMkNBQTJDO1FBQzNDckQsdURBQU1BLENBQUMsT0FBUW1ELEdBQUcsQ0FBQyxFQUFFLEtBQU0sVUFBVSx1REFBdUQseUJBQXlCO1lBQ2pIRyxXQUFXO1FBQ2Y7UUFDQSxPQUFPSDtJQUNYO0lBQ0E7O0tBRUMsR0FDRG5DLFNBQVM7UUFDTCxNQUFNLEVBQUVpQyxhQUFhLEVBQUVMLFVBQVUsRUFBRUksU0FBUyxFQUFFSCxRQUFRLEVBQUVDLE9BQU8sRUFBRVAsSUFBSSxFQUFFUSxLQUFLLEVBQUVKLEtBQUssRUFBRUgsTUFBTSxFQUFFRSxVQUFVLEVBQUVELFNBQVMsRUFBRVIsWUFBWSxFQUFFLEdBQUcsSUFBSTtRQUN6SSxPQUFPO1lBQ0hoQixPQUFPO1lBQ1BnQyxlQUFleEMsT0FBT3dDO1lBQ3RCTCxZQUFZbkMsT0FBT21DO1lBQ25CSTtZQUNBSCxVQUFVcEMsT0FBT29DO1lBQ2pCQyxTQUFTckMsT0FBT3FDO1lBQ2hCUDtZQUFNUTtZQUFPSjtZQUFPSDtZQUFRRTtZQUFZRDtZQUN4Q1I7UUFDSjtJQUNKO0lBQ0EsQ0FBQ3NCLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2hCLElBQUlDLFFBQVE7UUFDWixNQUFNTixNQUFNLElBQUksQ0FBQ2xCLFlBQVk7UUFDN0IsT0FBTztZQUNIeUIsTUFBTTtnQkFDRixJQUFJRCxRQUFRLElBQUksQ0FBQ0osTUFBTSxFQUFFO29CQUNyQixPQUFPO3dCQUNIN0MsT0FBTzJDLEdBQUcsQ0FBQ00sUUFBUTt3QkFBRUUsTUFBTTtvQkFDL0I7Z0JBQ0o7Z0JBQ0EsT0FBTztvQkFBRW5ELE9BQU9vRDtvQkFBV0QsTUFBTTtnQkFBSztZQUMxQztRQUNKO0lBQ0o7SUFDQTs7S0FFQyxHQUNELElBQUlOLFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDcEIsWUFBWSxDQUFDb0IsTUFBTTtJQUFFO0lBQ2pEOztLQUVDLEdBQ0QsSUFBSVEsT0FBTztRQUNQLElBQUksSUFBSSxDQUFDcEIsU0FBUyxJQUFJLE1BQU07WUFDeEIsT0FBTztRQUNYO1FBQ0EsT0FBTyxJQUFJcUIsS0FBSyxJQUFJLENBQUNyQixTQUFTLEdBQUc7SUFDckM7SUFDQTs7S0FFQyxHQUNELE1BQU1zQixlQUFlQyxXQUFXLEVBQUU7UUFDOUIsK0NBQStDO1FBQy9DLElBQUkzQixLQUFLdUI7UUFDVCxJQUFJLE9BQVFJLGdCQUFpQixVQUFVO1lBQ25DM0IsS0FBSyxJQUFJLENBQUMsQ0FBQ0osWUFBWSxDQUFDK0IsWUFBWTtRQUN4QyxPQUNLO1lBQ0QsTUFBTXpCLE9BQU95QixZQUFZQyxXQUFXO1lBQ3BDLEtBQUssTUFBTUMsS0FBSyxJQUFJLENBQUMsQ0FBQ2pDLFlBQVksQ0FBRTtnQkFDaEMsSUFBSSxPQUFRaUMsTUFBTyxVQUFVO29CQUN6QixJQUFJQSxNQUFNM0IsTUFBTTt3QkFDWjtvQkFDSjtvQkFDQUYsS0FBSzZCO29CQUNMO2dCQUNKLE9BQ0s7b0JBQ0QsSUFBSUEsRUFBRTNCLElBQUksS0FBS0EsTUFBTTt3QkFDakI7b0JBQ0o7b0JBQ0FGLEtBQUs2QjtvQkFDTDtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJN0IsTUFBTSxNQUFNO1lBQ1osTUFBTSxJQUFJOEIsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBUTlCLE9BQVEsVUFBVTtZQUMxQixPQUFRLE1BQU0sSUFBSSxDQUFDRixRQUFRLENBQUM0QixjQUFjLENBQUMxQjtRQUMvQyxPQUNLO1lBQ0QsT0FBT0E7UUFDWDtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCtCLHlCQUF5QkosV0FBVyxFQUFFO1FBQ2xDLE1BQU1iLE1BQU0sSUFBSSxDQUFDRCxzQkFBc0I7UUFDdkMsSUFBSSxPQUFRYyxnQkFBaUIsVUFBVTtZQUNuQyxPQUFPYixHQUFHLENBQUNhLFlBQVk7UUFDM0I7UUFDQUEsY0FBY0EsWUFBWUMsV0FBVztRQUNyQyxLQUFLLE1BQU01QixNQUFNYyxJQUFLO1lBQ2xCLElBQUlkLEdBQUdFLElBQUksS0FBS3lCLGFBQWE7Z0JBQ3pCLE9BQU8zQjtZQUNYO1FBQ0o7UUFDQXBDLCtEQUFjQSxDQUFDLE9BQU8sMkJBQTJCLGVBQWUrRDtJQUNwRTtJQUNBOzs7S0FHQyxHQUNESyxVQUFVO1FBQUUsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDOUIsSUFBSTtJQUFFO0lBQ2hDOztLQUVDLEdBQ0QrQixXQUFXO1FBQ1AsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDckIsYUFBYTtJQUMvQjtJQUNBOztLQUVDLEdBQ0RzQixnQkFBZ0I7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDRixPQUFPLElBQUk7WUFDakIsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO1FBQ0EsT0FBT0ssMEJBQTBCLElBQUk7SUFDekM7QUFDSjtBQUNBLHNCQUFzQjtBQUN0QixNQUFNO0FBQ047Ozs7Q0FJQyxHQUNNLE1BQU1DO0lBdURUOztLQUVDLEdBQ0Q3RCxZQUFZOEQsR0FBRyxFQUFFdkMsUUFBUSxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtRQUNoQixNQUFNd0MsU0FBU0MsT0FBT0MsTUFBTSxDQUFDSCxJQUFJQyxNQUFNLENBQUN2QixLQUFLO1FBQzdDekQsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQm1GLGlCQUFpQkosSUFBSUksZUFBZTtZQUNwQ0MsV0FBV0wsSUFBSUssU0FBUztZQUN4QkMsYUFBYU4sSUFBSU0sV0FBVztZQUM1QkMsU0FBU1AsSUFBSU8sT0FBTztZQUNwQkMsU0FBU1IsSUFBSVEsT0FBTztZQUNwQjNELE1BQU1tRCxJQUFJbkQsSUFBSTtZQUNkb0Q7WUFDQWxCLE9BQU9pQixJQUFJakIsS0FBSztZQUNoQjBCLGtCQUFrQlQsSUFBSVMsZ0JBQWdCO1FBQzFDO0lBQ0o7SUFDQTs7S0FFQyxHQUNEbkUsU0FBUztRQUNMLE1BQU0sRUFBRWtFLE9BQU8sRUFBRUgsU0FBUyxFQUFFQyxXQUFXLEVBQUV6RCxJQUFJLEVBQUVrQyxLQUFLLEVBQUV3QixPQUFPLEVBQUVOLE1BQU0sRUFBRUcsZUFBZSxFQUFFSyxnQkFBZ0IsRUFBRSxHQUFHLElBQUk7UUFDakgsT0FBTztZQUNIbEUsT0FBTztZQUNQaUU7WUFBU0g7WUFBV0M7WUFBYXpEO1lBQU1rQztZQUN2Q3dCO1lBQVNOO1lBQVFHO1lBQWlCSztRQUN0QztJQUNKO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyxXQUFXO1FBQ2IsTUFBTWxELFFBQVEsTUFBTSxJQUFJLENBQUNDLFFBQVEsQ0FBQ2lELFFBQVEsQ0FBQyxJQUFJLENBQUNMLFNBQVM7UUFDekQvRSx1REFBTUEsQ0FBQyxDQUFDLENBQUNrQyxPQUFPLDhCQUE4QixpQkFBaUIsQ0FBQztRQUNoRSxPQUFPQTtJQUNYO0lBQ0E7O0tBRUMsR0FDRCxNQUFNNkIsaUJBQWlCO1FBQ25CLE1BQU0xQixLQUFLLE1BQU0sSUFBSSxDQUFDRixRQUFRLENBQUM0QixjQUFjLENBQUMsSUFBSSxDQUFDZSxlQUFlO1FBQ2xFOUUsdURBQU1BLENBQUMsQ0FBQyxDQUFDcUMsSUFBSSw4QkFBOEIsaUJBQWlCLENBQUM7UUFDN0QsT0FBT0E7SUFDWDtJQUNBOzs7S0FHQyxHQUNELE1BQU1nRCx3QkFBd0I7UUFDMUIsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ25ELFFBQVEsQ0FBQ2tELHFCQUFxQixDQUFDLElBQUksQ0FBQ1AsZUFBZTtRQUM5RTlFLHVEQUFNQSxDQUFDLENBQUMsQ0FBQ3NGLFNBQVMsc0NBQXNDLGlCQUFpQixDQUFDO1FBQzFFLE9BQU9BO0lBQ1g7SUFDQTs7S0FFQyxHQUNEQyxlQUFlO1FBQ1gsT0FBT0MsdUJBQXVCLElBQUk7SUFDdEM7QUFDSjtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7Ozs7Ozs7Ozs7OztBQVlBLEdBQ0E7OztDQUdDLEdBQ00sTUFBTUM7SUF3RlQsQ0FBQ0MsSUFBSSxDQUFDO0lBQ047O0tBRUMsR0FDRDlFLFlBQVl5QixFQUFFLEVBQUVGLFFBQVEsQ0FBRTtRQUN0QixJQUFJLENBQUMsQ0FBQ3VELElBQUksR0FBR2QsT0FBT0MsTUFBTSxDQUFDeEMsR0FBR3FELElBQUksQ0FBQ3RELEdBQUcsQ0FBQyxDQUFDc0M7WUFDcEMsT0FBTyxJQUFJRCxJQUFJQyxLQUFLdkM7UUFDeEI7UUFDQSxJQUFJdEIsV0FBV1I7UUFDZixJQUFJZ0MsR0FBR3NELGlCQUFpQixJQUFJLE1BQU07WUFDOUI5RSxXQUFXd0IsR0FBR3NELGlCQUFpQjtRQUNuQyxPQUNLLElBQUl0RCxHQUFHeEIsUUFBUSxJQUFJLE1BQU07WUFDMUJBLFdBQVd3QixHQUFHeEIsUUFBUTtRQUMxQjtRQUNBbEIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQndDO1lBQ0FkLElBQUlnQixHQUFHaEIsRUFBRTtZQUNUQyxNQUFNZSxHQUFHZixJQUFJO1lBQ2JzRSxpQkFBaUJ2RCxHQUFHdUQsZUFBZTtZQUNuQ3JELE1BQU1GLEdBQUdFLElBQUk7WUFDYmtCLE9BQU9wQixHQUFHb0IsS0FBSztZQUNmc0IsV0FBVzFDLEdBQUcwQyxTQUFTO1lBQ3ZCQyxhQUFhM0MsR0FBRzJDLFdBQVc7WUFDM0JhLFdBQVd4RCxHQUFHd0QsU0FBUztZQUN2Qi9DLFNBQVNULEdBQUdTLE9BQU87WUFDbkJnRCxtQkFBbUJ6RCxHQUFHeUQsaUJBQWlCO1lBQ3ZDakY7WUFDQWtGLE1BQU0xRCxHQUFHMEQsSUFBSTtZQUNiLDBCQUEwQjtZQUMxQkMsUUFBUTNELEdBQUcyRCxNQUFNO1lBQ2pCQyxNQUFNNUQsR0FBRzRELElBQUk7UUFDakI7SUFDSjtJQUNBOztLQUVDLEdBQ0QsSUFBSVAsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7SUFBRTtJQUNoQzs7S0FFQyxHQUNEMUUsU0FBUztRQUNMLE1BQU0sRUFBRUssRUFBRSxFQUFFQyxJQUFJLEVBQUVzRSxlQUFlLEVBQUVyRCxJQUFJLEVBQUVrQixLQUFLLEVBQUVzQixTQUFTLEVBQUVDLFdBQVcsRUFBRWEsU0FBUyxFQUFFSCxJQUFJLEVBQ3ZGTSxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHLElBQUk7UUFDckIsT0FBTztZQUNIaEYsT0FBTztZQUNQOEQ7WUFBV0M7WUFDWCxhQUFhO1lBQ2JZO1lBQ0FFLG1CQUFtQnJGLE9BQU8sSUFBSSxDQUFDcUYsaUJBQWlCO1lBQ2hEeEU7WUFDQVQsVUFBVUosT0FBTyxJQUFJLENBQUNJLFFBQVE7WUFDOUJpQyxTQUFTckMsT0FBTyxJQUFJLENBQUNxQyxPQUFPO1lBQzVCUDtZQUFNa0I7WUFBT2lDO1lBQU1HO1lBQVdJO1lBQU1EO1lBQVEzRTtRQUNoRDtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxJQUFJZ0MsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDcUMsSUFBSSxDQUFDckMsTUFBTTtJQUFFO0lBQ3hDLENBQUNFLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2hCLElBQUlDLFFBQVE7UUFDWixPQUFPO1lBQ0hDLE1BQU07Z0JBQ0YsSUFBSUQsUUFBUSxJQUFJLENBQUNKLE1BQU0sRUFBRTtvQkFDckIsT0FBTzt3QkFBRTdDLE9BQU8sSUFBSSxDQUFDa0YsSUFBSSxDQUFDakMsUUFBUTt3QkFBRUUsTUFBTTtvQkFBTTtnQkFDcEQ7Z0JBQ0EsT0FBTztvQkFBRW5ELE9BQU9vRDtvQkFBV0QsTUFBTTtnQkFBSztZQUMxQztRQUNKO0lBQ0o7SUFDQTs7S0FFQyxHQUNELElBQUl1QyxNQUFNO1FBQ04sT0FBTyxJQUFJLENBQUNwRCxPQUFPLEdBQUcsSUFBSSxDQUFDakMsUUFBUTtJQUN2QztJQUNBOztLQUVDLEdBQ0QsTUFBTXVFLFdBQVc7UUFDYixNQUFNbEQsUUFBUSxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUFDaUQsUUFBUSxDQUFDLElBQUksQ0FBQ0wsU0FBUztRQUN6RCxJQUFJN0MsU0FBUyxNQUFNO1lBQ2YsTUFBTSxJQUFJaUMsTUFBTTtRQUNwQjtRQUNBLE9BQU9qQztJQUNYO0lBQ0E7O0tBRUMsR0FDRCxNQUFNNkIsaUJBQWlCO1FBQ25CLE1BQU0xQixLQUFLLE1BQU0sSUFBSSxDQUFDRixRQUFRLENBQUM0QixjQUFjLENBQUMsSUFBSSxDQUFDeEIsSUFBSTtRQUN2RCxJQUFJRixNQUFNLE1BQU07WUFDWixNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsT0FBTzlCO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU04RCxZQUFZO1FBQ2QsT0FBUSxNQUFNLElBQUksQ0FBQ2hFLFFBQVEsQ0FBQ2lFLG9CQUFvQixDQUFDLElBQUksQ0FBQzdELElBQUk7SUFDOUQ7SUFDQTs7S0FFQyxHQUNELE1BQU04RCxnQkFBZ0I7UUFDbEIsT0FBTyxNQUFPLElBQUksQ0FBQ2xFLFFBQVEsQ0FBQ21FLGNBQWMsS0FBTSxJQUFJLENBQUN0QixXQUFXLEdBQUc7SUFDdkU7SUFDQTs7S0FFQyxHQUNETyxlQUFlO1FBQ1gsT0FBT2dCLCtCQUErQixJQUFJO0lBQzlDO0lBQ0E7O0tBRUMsR0FDREMsZUFBZUMsS0FBSyxFQUFFO1FBQ2xCekcsdURBQU1BLENBQUMsQ0FBQ3lHLFNBQVNBLE1BQU1wQyxPQUFPLElBQUksaURBQWlELHlCQUF5QjtZQUFFZixXQUFXO1FBQXdCO1FBQ2pKLE9BQU9vRCxpQ0FBaUMsSUFBSSxFQUFFRDtJQUNsRDtBQUNKO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNbkU7SUEyR1QsQ0FBQ3FFLFVBQVUsQ0FBQztJQUNaOztLQUVDLEdBQ0QvRixZQUFZeUIsRUFBRSxFQUFFRixRQUFRLENBQUU7UUFDdEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQzZDLFdBQVcsR0FBRyxHQUFJQSxXQUFXLElBQUksT0FBUTNDLEdBQUcyQyxXQUFXLEdBQUc7UUFDL0QsSUFBSSxDQUFDRCxTQUFTLEdBQUcsR0FBSUEsU0FBUyxJQUFJLE9BQVExQyxHQUFHMEMsU0FBUyxHQUFHO1FBQ3pELElBQUksQ0FBQ3hDLElBQUksR0FBR0YsR0FBR0UsSUFBSTtRQUNuQixJQUFJLENBQUNrQixLQUFLLEdBQUdwQixHQUFHb0IsS0FBSztRQUNyQixJQUFJLENBQUNzQyxJQUFJLEdBQUcxRCxHQUFHMEQsSUFBSTtRQUNuQixJQUFJLENBQUN6RSxJQUFJLEdBQUdlLEdBQUdmLElBQUk7UUFDbkIsSUFBSSxDQUFDRCxFQUFFLEdBQUdnQixHQUFHaEIsRUFBRSxJQUFJO1FBQ25CLElBQUksQ0FBQ3dCLFFBQVEsR0FBR1IsR0FBR1EsUUFBUTtRQUMzQixJQUFJLENBQUNGLEtBQUssR0FBR04sR0FBR00sS0FBSztRQUNyQixJQUFJLENBQUNwQixJQUFJLEdBQUdjLEdBQUdkLElBQUk7UUFDbkIsSUFBSSxDQUFDZixLQUFLLEdBQUc2QixHQUFHN0IsS0FBSztRQUNyQixJQUFJLENBQUNLLFFBQVEsR0FBR3dCLEdBQUd4QixRQUFRO1FBQzNCLElBQUksQ0FBQ0Usb0JBQW9CLEdBQUcsR0FBSUEsb0JBQW9CLElBQUksT0FBUXNCLEdBQUd0QixvQkFBb0IsR0FBRztRQUMxRixJQUFJLENBQUNELFlBQVksR0FBRyxHQUFJQSxZQUFZLElBQUksT0FBUXVCLEdBQUd2QixZQUFZLEdBQUc7UUFDbEUsSUFBSSxDQUFDOEYsT0FBTyxHQUFHdkUsR0FBR3VFLE9BQU87UUFDekIsSUFBSSxDQUFDQyxTQUFTLEdBQUd4RSxHQUFHd0UsU0FBUztRQUM3QixJQUFJLENBQUNqRixVQUFVLEdBQUcsR0FBSUEsVUFBVSxJQUFJLE9BQVFTLEdBQUdULFVBQVUsR0FBRztRQUM1RCxJQUFJLENBQUMsQ0FBQytFLFVBQVUsR0FBRyxDQUFDO0lBQ3hCO0lBQ0E7O0tBRUMsR0FDRDNGLFNBQVM7UUFDTCxNQUFNLEVBQUVnRSxXQUFXLEVBQUVELFNBQVMsRUFBRXRCLEtBQUssRUFBRWxCLElBQUksRUFBRXdELElBQUksRUFBRTFFLEVBQUUsRUFBRUMsSUFBSSxFQUFFcUIsS0FBSyxFQUFFcEIsSUFBSSxFQUFFc0YsU0FBUyxFQUFFakYsVUFBVSxFQUFFLEdBQUcsSUFBSTtRQUN4RyxPQUFPO1lBQ0hYLE9BQU87WUFDUFc7WUFBWW9EO1lBQWFEO1lBQ3pCNkIsU0FBU25HLE9BQU8sSUFBSSxDQUFDbUcsT0FBTztZQUM1QnJGO1lBQU1EO1lBQ051QixVQUFVcEMsT0FBTyxJQUFJLENBQUNvQyxRQUFRO1lBQzlCaEMsVUFBVUosT0FBTyxJQUFJLENBQUNJLFFBQVE7WUFDOUIwQjtZQUNBekIsY0FBY0wsT0FBTyxJQUFJLENBQUNLLFlBQVk7WUFDdENDLHNCQUFzQk4sT0FBTyxJQUFJLENBQUNNLG9CQUFvQjtZQUN0RDRCO1lBQU9rRTtZQUFXeEY7WUFBSW9DO1lBQU9zQztZQUM3QnZGLE9BQU9DLE9BQU8sSUFBSSxDQUFDRCxLQUFLO1FBQzVCO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTTRFLFdBQVc7UUFDYixJQUFJSixjQUFjLElBQUksQ0FBQ0EsV0FBVztRQUNsQyxJQUFJQSxlQUFlLE1BQU07WUFDckIsTUFBTTNDLEtBQUssTUFBTSxJQUFJLENBQUMwQixjQUFjO1lBQ3BDLElBQUkxQixJQUFJO2dCQUNKMkMsY0FBYzNDLEdBQUcyQyxXQUFXO1lBQ2hDO1FBQ0o7UUFDQSxJQUFJQSxlQUFlLE1BQU07WUFDckIsT0FBTztRQUNYO1FBQ0EsTUFBTTlDLFFBQVEsSUFBSSxDQUFDQyxRQUFRLENBQUNpRCxRQUFRLENBQUNKO1FBQ3JDLElBQUk5QyxTQUFTLE1BQU07WUFDZixNQUFNLElBQUlpQyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT2pDO0lBQ1g7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTTZCLGlCQUFpQjtRQUNuQixPQUFPLElBQUksQ0FBQzVCLFFBQVEsQ0FBQzRCLGNBQWMsQ0FBQyxJQUFJLENBQUN4QixJQUFJO0lBQ2pEO0lBQ0E7O0tBRUMsR0FDRCxNQUFNOEQsZ0JBQWdCO1FBQ2xCLElBQUksSUFBSSxDQUFDckIsV0FBVyxJQUFJLE1BQU07WUFDMUIsTUFBTSxFQUFFM0MsRUFBRSxFQUFFMkMsV0FBVyxFQUFFLEdBQUcsTUFBTWpGLGtFQUFpQkEsQ0FBQztnQkFDaERzQyxJQUFJLElBQUksQ0FBQzBCLGNBQWM7Z0JBQ3ZCaUIsYUFBYSxJQUFJLENBQUM3QyxRQUFRLENBQUNtRSxjQUFjO1lBQzdDO1lBQ0EsbUJBQW1CO1lBQ25CLElBQUlqRSxNQUFNLFFBQVFBLEdBQUcyQyxXQUFXLElBQUksTUFBTTtnQkFDdEMsT0FBTztZQUNYO1lBQ0EsT0FBT0EsY0FBYzNDLEdBQUcyQyxXQUFXLEdBQUc7UUFDMUM7UUFDQSxNQUFNQSxjQUFjLE1BQU0sSUFBSSxDQUFDN0MsUUFBUSxDQUFDbUUsY0FBYztRQUN0RCxPQUFPdEIsY0FBYyxJQUFJLENBQUNBLFdBQVcsR0FBRztJQUM1QztJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTThCLEtBQUtDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQzVCLE1BQU1DLFdBQVcsYUFBYyxPQUFRLElBQUlGO1FBQzNDLE1BQU1HLFVBQVUsWUFBYSxPQUFRLElBQUlGO1FBQ3pDLElBQUlMLGFBQWEsSUFBSSxDQUFDLENBQUNBLFVBQVU7UUFDakMsSUFBSVEsV0FBVyxDQUFDO1FBQ2hCLElBQUlDLGVBQWUsZUFBZ0IsQ0FBQyxJQUFLLE9BQU87UUFDaEQsTUFBTUMsbUJBQW1CO1lBQ3JCLG9EQUFvRDtZQUNwRCxJQUFJRCxjQUFjO2dCQUNkLE9BQU87WUFDWDtZQUNBLE1BQU0sRUFBRXBDLFdBQVcsRUFBRXJDLEtBQUssRUFBRSxHQUFHLE1BQU01QyxrRUFBaUJBLENBQUM7Z0JBQ25EaUYsYUFBYSxJQUFJLENBQUM3QyxRQUFRLENBQUNtRSxjQUFjO2dCQUN6QzNELE9BQU8sSUFBSSxDQUFDUixRQUFRLENBQUNtRixtQkFBbUIsQ0FBQyxJQUFJLENBQUNoRyxJQUFJO1lBQ3REO1lBQ0EsNkRBQTZEO1lBQzdELDRDQUE0QztZQUM1QyxJQUFJcUIsUUFBUSxJQUFJLENBQUNBLEtBQUssRUFBRTtnQkFDcEJnRSxhQUFhM0I7Z0JBQ2I7WUFDSjtZQUNBLGdDQUFnQztZQUNoQyxJQUFJb0MsY0FBYztnQkFDZCxPQUFPO1lBQ1g7WUFDQSxNQUFNRyxRQUFRLE1BQU0sSUFBSSxDQUFDeEQsY0FBYztZQUN2QyxJQUFJd0QsU0FBU0EsTUFBTXZDLFdBQVcsSUFBSSxNQUFNO2dCQUNwQztZQUNKO1lBQ0Esd0RBQXdEO1lBQ3hELDREQUE0RDtZQUM1RCxJQUFJbUMsYUFBYSxDQUFDLEdBQUc7Z0JBQ2pCQSxXQUFXUixhQUFhO2dCQUN4QixJQUFJUSxXQUFXLElBQUksQ0FBQyxDQUFDUixVQUFVLEVBQUU7b0JBQzdCUSxXQUFXLElBQUksQ0FBQyxDQUFDUixVQUFVO2dCQUMvQjtZQUNKO1lBQ0EsTUFBT1EsWUFBWW5DLFlBQWE7Z0JBQzVCLDZCQUE2QjtnQkFDN0IsSUFBSW9DLGNBQWM7b0JBQ2QsT0FBTztnQkFDWDtnQkFDQSxNQUFNbEYsUUFBUSxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUFDaUQsUUFBUSxDQUFDK0IsVUFBVTtnQkFDckQsc0RBQXNEO2dCQUN0RCxJQUFJakYsU0FBUyxNQUFNO29CQUNmO2dCQUNKO2dCQUNBLGdDQUFnQztnQkFDaEMsS0FBSyxNQUFNSyxRQUFRTCxNQUFPO29CQUN0QixJQUFJSyxTQUFTLElBQUksQ0FBQ0EsSUFBSSxFQUFFO3dCQUNwQjtvQkFDSjtnQkFDSjtnQkFDQSw4Q0FBOEM7Z0JBQzlDLElBQUssSUFBSWlGLElBQUksR0FBR0EsSUFBSXRGLE1BQU1tQixNQUFNLEVBQUVtRSxJQUFLO29CQUNuQyxNQUFNbkYsS0FBSyxNQUFNSCxNQUFNNkIsY0FBYyxDQUFDeUQ7b0JBQ3RDLElBQUluRixHQUFHZixJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJLElBQUllLEdBQUdNLEtBQUssS0FBSyxJQUFJLENBQUNBLEtBQUssRUFBRTt3QkFDbEQsa0JBQWtCO3dCQUNsQixJQUFJeUUsY0FBYzs0QkFDZCxPQUFPO3dCQUNYO3dCQUNBLE1BQU05QixVQUFVLE1BQU0sSUFBSSxDQUFDbkQsUUFBUSxDQUFDa0QscUJBQXFCLENBQUNoRCxHQUFHRSxJQUFJO3dCQUNqRSxzREFBc0Q7d0JBQ3RELElBQUkrQyxXQUFXLE1BQU07NEJBQ2pCO3dCQUNKO3dCQUNBLHNFQUFzRTt3QkFDdEUsSUFBSSxjQUFlQSxRQUFRTixXQUFXLEdBQUcsSUFBS2lDLFVBQVU7NEJBQ3BEO3dCQUNKO3dCQUNBLDhCQUE4Qjt3QkFDOUIsSUFBSVEsU0FBUzt3QkFDYixJQUFJcEYsR0FBR2QsSUFBSSxLQUFLLElBQUksQ0FBQ0EsSUFBSSxJQUFJYyxHQUFHaEIsRUFBRSxLQUFLLElBQUksQ0FBQ0EsRUFBRSxJQUFJZ0IsR0FBRzdCLEtBQUssS0FBSyxJQUFJLENBQUNBLEtBQUssRUFBRTs0QkFDdkVpSCxTQUFTO3dCQUNiLE9BQ0ssSUFBSXBGLEdBQUdkLElBQUksS0FBSyxRQUFRYyxHQUFHZixJQUFJLEtBQUtlLEdBQUdoQixFQUFFLElBQUlnQixHQUFHN0IsS0FBSyxLQUFLSCxNQUFNOzRCQUNqRW9ILFNBQVM7d0JBQ2I7d0JBQ0F6SCx1REFBTUEsQ0FBQyxPQUFPLDRCQUE0Qix3QkFBd0I7NEJBQzlEMEgsV0FBWUQsV0FBVyxjQUFjQSxXQUFXOzRCQUNoREE7NEJBQ0FFLGFBQWF0RixHQUFHdUYsc0JBQXNCLENBQUNqQjs0QkFDdkNwRSxNQUFNRixHQUFHRSxJQUFJOzRCQUNiK0M7d0JBQ0o7b0JBQ0o7Z0JBQ0o7Z0JBQ0E2QjtZQUNKO1lBQ0E7UUFDSjtRQUNBLE1BQU1VLGVBQWUsQ0FBQ3ZDO1lBQ2xCLElBQUlBLFdBQVcsUUFBUUEsUUFBUVUsTUFBTSxLQUFLLEdBQUc7Z0JBQ3pDLE9BQU9WO1lBQ1g7WUFDQXRGLHVEQUFNQSxDQUFDLE9BQU8sa0NBQWtDLGtCQUFrQjtnQkFDOUQ4SCxRQUFRO2dCQUNSdkcsTUFBTTtnQkFBTWtHLFFBQVE7Z0JBQU1NLFlBQVk7Z0JBQU1DLFFBQVE7Z0JBQ3BEQyxhQUFhO29CQUNUNUcsSUFBSWlFLFFBQVFqRSxFQUFFO29CQUNkQyxNQUFNZ0UsUUFBUWhFLElBQUk7b0JBQ2xCQyxNQUFNLEdBQUcscURBQXFEO2dCQUNsRTtnQkFBRytEO1lBQ1A7UUFDSjtRQUNBLE1BQU1BLFVBQVUsTUFBTSxJQUFJLENBQUNuRCxRQUFRLENBQUNrRCxxQkFBcUIsQ0FBQyxJQUFJLENBQUM5QyxJQUFJO1FBQ25FLElBQUkwRSxhQUFhLEdBQUc7WUFDaEIsT0FBT1ksYUFBYXZDO1FBQ3hCO1FBQ0EsSUFBSUEsU0FBUztZQUNULElBQUksTUFBT0EsUUFBUWUsYUFBYSxNQUFPWSxVQUFVO2dCQUM3QyxPQUFPWSxhQUFhdkM7WUFDeEI7UUFDSixPQUNLO1lBQ0QsNkRBQTZEO1lBQzdELE1BQU0rQjtZQUNOLHlDQUF5QztZQUN6QyxJQUFJSixhQUFhLEdBQUc7Z0JBQ2hCLE9BQU87WUFDWDtRQUNKO1FBQ0EsTUFBTWlCLFNBQVMsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUNqQyx3RUFBd0U7WUFDeEUsTUFBTUMsYUFBYSxFQUFFO1lBQ3JCLE1BQU1DLFNBQVM7Z0JBQVFELFdBQVdFLE9BQU8sQ0FBQyxDQUFDQyxJQUFNQTtZQUFNO1lBQ3ZELDRDQUE0QztZQUM1Q0gsV0FBV0ksSUFBSSxDQUFDO2dCQUFRdEIsZUFBZTtZQUFNO1lBQzdDLCtCQUErQjtZQUMvQixJQUFJRixVQUFVLEdBQUc7Z0JBQ2IsTUFBTXlCLFFBQVFDLFdBQVc7b0JBQ3JCTDtvQkFDQUYsT0FBT2xJLDBEQUFTQSxDQUFDLGdDQUFnQztnQkFDckQsR0FBRytHO2dCQUNIb0IsV0FBV0ksSUFBSSxDQUFDO29CQUFRRyxhQUFhRjtnQkFBUTtZQUNqRDtZQUNBLE1BQU1HLGFBQWEsT0FBT3hEO2dCQUN0QixtQkFBbUI7Z0JBQ25CLElBQUksTUFBT0EsUUFBUWUsYUFBYSxNQUFPWSxVQUFVO29CQUM3Q3NCO29CQUNBLElBQUk7d0JBQ0FILFFBQVFQLGFBQWF2QztvQkFDekIsRUFDQSxPQUFPeUQsT0FBTzt3QkFDVlYsT0FBT1U7b0JBQ1g7Z0JBQ0o7WUFDSjtZQUNBVCxXQUFXSSxJQUFJLENBQUM7Z0JBQVEsSUFBSSxDQUFDdkcsUUFBUSxDQUFDNkcsR0FBRyxDQUFDLElBQUksQ0FBQ3pHLElBQUksRUFBRXVHO1lBQWE7WUFDbEUsSUFBSSxDQUFDM0csUUFBUSxDQUFDOEcsRUFBRSxDQUFDLElBQUksQ0FBQzFHLElBQUksRUFBRXVHO1lBQzVCLG1EQUFtRDtZQUNuRCxJQUFJbkMsY0FBYyxHQUFHO2dCQUNqQixNQUFNdUMsa0JBQWtCO29CQUNwQixJQUFJO3dCQUNBLDREQUE0RDt3QkFDNUQsTUFBTTdCO29CQUNWLEVBQ0EsT0FBTzBCLE9BQU87d0JBQ1YsOERBQThEO3dCQUM5RCxJQUFJN0ksd0RBQU9BLENBQUM2SSxPQUFPLHlCQUF5Qjs0QkFDeENSOzRCQUNBRixPQUFPVTs0QkFDUDt3QkFDSjtvQkFDSjtvQkFDQSx1Q0FBdUM7b0JBQ3ZDLElBQUksQ0FBQzNCLGNBQWM7d0JBQ2YsSUFBSSxDQUFDakYsUUFBUSxDQUFDZ0gsSUFBSSxDQUFDLFNBQVNEO29CQUNoQztnQkFDSjtnQkFDQVosV0FBV0ksSUFBSSxDQUFDO29CQUFRLElBQUksQ0FBQ3ZHLFFBQVEsQ0FBQzZHLEdBQUcsQ0FBQyxTQUFTRTtnQkFBa0I7Z0JBQ3JFLElBQUksQ0FBQy9HLFFBQVEsQ0FBQ2dILElBQUksQ0FBQyxTQUFTRDtZQUNoQztRQUNKO1FBQ0EsT0FBTyxNQUFNaEI7SUFDakI7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0Q3RCxVQUFVO1FBQ04sT0FBUSxJQUFJLENBQUNVLFNBQVMsSUFBSTtJQUM5QjtJQUNBOzs7Ozs7S0FNQyxHQUNEcUUsV0FBVztRQUNQLE9BQVEsSUFBSSxDQUFDckQsSUFBSSxLQUFLO0lBQzFCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RzRCxXQUFXO1FBQ1AsT0FBUSxJQUFJLENBQUN0RCxJQUFJLEtBQUs7SUFDMUI7SUFDQTs7Ozs7O0tBTUMsR0FDRHpCLFdBQVc7UUFDUCxPQUFRLElBQUksQ0FBQ3lCLElBQUksS0FBSztJQUMxQjtJQUNBOzs7S0FHQyxHQUNEUixlQUFlO1FBQ1h2Rix1REFBTUEsQ0FBQyxJQUFJLENBQUNxRSxPQUFPLElBQUkseUNBQXlDLHlCQUF5QjtZQUFFZixXQUFXO1FBQWdCO1FBQ3RILE9BQU9pRCwrQkFBK0IsSUFBSTtJQUM5QztJQUNBOzs7S0FHQyxHQUNEQyxlQUFlQyxLQUFLLEVBQUU7UUFDbEJ6Ryx1REFBTUEsQ0FBQyxJQUFJLENBQUNxRSxPQUFPLElBQUkseUNBQXlDLHlCQUF5QjtZQUFFZixXQUFXO1FBQWdCO1FBQ3RIdEQsdURBQU1BLENBQUMsQ0FBQ3lHLFNBQVNBLE1BQU1wQyxPQUFPLElBQUksaURBQWlELHlCQUF5QjtZQUFFZixXQUFXO1FBQWdCO1FBQ3pJLE9BQU9vRCxpQ0FBaUMsSUFBSSxFQUFFRDtJQUNsRDtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RtQix1QkFBdUJqQixVQUFVLEVBQUU7UUFDL0IxRywrREFBY0EsQ0FBQ3FKLE9BQU9DLFNBQVMsQ0FBQzVDLGVBQWVBLGNBQWMsR0FBRyxzQkFBc0IsY0FBY0E7UUFDcEcsTUFBTXRFLEtBQUssSUFBSUMsb0JBQW9CLElBQUksRUFBRSxJQUFJLENBQUNILFFBQVE7UUFDdERFLEdBQUcsQ0FBQ3NFLFVBQVUsR0FBR0E7UUFDakIsT0FBT3RFO0lBQ1g7QUFDSjtBQUNBLFNBQVNtQywwQkFBMEJ0QyxLQUFLO0lBQ3BDLE9BQU87UUFBRXNILFFBQVE7UUFBY2pILE1BQU1MLE1BQU1LLElBQUk7UUFBRUMsUUFBUU4sTUFBTU0sTUFBTTtJQUFDO0FBQzFFO0FBQ0EsU0FBU2tFLGlDQUFpQ3JFLEVBQUUsRUFBRW9FLEtBQUs7SUFDL0MsT0FBTztRQUFFK0MsUUFBUTtRQUF1Qm5IO1FBQUlvRTtJQUFNO0FBQ3REO0FBQ0EsU0FBU0YsK0JBQStCbEUsRUFBRTtJQUN0QyxPQUFPO1FBQUVtSCxRQUFRO1FBQW9Cbkg7SUFBRztBQUM1QztBQUNBLFNBQVNtRCx1QkFBdUJkLEdBQUc7SUFDL0IsT0FBTztRQUFFOEUsUUFBUTtRQUFZOUUsS0FBSztZQUMxQkksaUJBQWlCSixJQUFJSSxlQUFlO1lBQ3BDQyxXQUFXTCxJQUFJSyxTQUFTO1lBQ3hCQyxhQUFhTixJQUFJTSxXQUFXO1lBQzVCRSxTQUFTUixJQUFJUSxPQUFPO1lBQ3BCM0QsTUFBTW1ELElBQUluRCxJQUFJO1lBQ2RvRCxRQUFRQyxPQUFPQyxNQUFNLENBQUNILElBQUlDLE1BQU0sQ0FBQ3ZCLEtBQUs7WUFDdENLLE9BQU9pQixJQUFJakIsS0FBSztRQUNwQjtJQUFFO0FBQ1YsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvcHJvdmlkZXIuanM/NjhhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBoZXhsaWZ5LCByZXNvbHZlUHJvcGVydGllcywgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCwgaXNFcnJvciwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvSnNvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cbi8vIEBUT0RPPyA8VCBleHRlbmRzIEZlZURhdGEgPSB7IH0+IGltcGxlbWVudHMgUmVxdWlyZWQ8VD5cbi8qKlxuICogIEEgKipGZWVEYXRhKiogd3JhcHMgYWxsIHRoZSBmZWUtcmVsYXRlZCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoXG4gKiAgdGhlIG5ldHdvcmsuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVEYXRhIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgdG8gcGF5IHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cbiAgICAgKiAgY29uZ2VzdGlvbiwgaW5jcmVhc2luZyB0aGUgY29zdCBkdXJpbmcgdGltZXMgb2YgaGVhdnkgbG9hZFxuICAgICAqICBhbmQgbG93ZXJpbmcgd2hlbiBsZXNzIGJ1c3kuXG4gICAgICpcbiAgICAgKiAgVGhlIGFjdHVhbCBmZWUgcGVyIGdhcyB3aWxsIGJlIHRoZSBiYXNlIGZlZSBmb3IgdGhlIGJsb2NrXG4gICAgICogIGFuZCB0aGUgcHJpb3JpdHkgZmVlLCB1cCB0byB0aGUgbWF4IGZlZSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkaXRpb25hbCBhbW91dCB0byBwYXkgcGVyIGdhcyB0byBlbmNvdXJhZ2UgYSB2YWxpZGF0b3JcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIHB1cnBvc2Ugb2YgdGhpcyBpcyB0byBjb21wZW5zYXRlIHRoZSB2YWxpZGF0b3IgZm9yIHRoZVxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcbiAgICAgKiAgJSVtYXhQcmlvcml0eUZlZVBlckdhcyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZ2FzUHJpY2U6IGdldFZhbHVlKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0VmFsdWUobWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1mcmllbmRseSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJGZWVEYXRhXCIsXG4gICAgICAgICAgICBnYXNQcmljZTogdG9Kc29uKGdhc1ByaWNlKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogdG9Kc29uKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG47XG4vKipcbiAqICBSZXR1cm5zIGEgY29weSBvZiAlJXJlcSUlIHdpdGggYWxsIHByb3BlcnRpZXMgY29lcmNlZCB0byB0aGVpciBzdHJpY3RcbiAqICB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZXF1ZXN0KHJlcSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIFRoZXNlIGNvdWxkIGJlIGFkZHJlc3NlcywgRU5TIG5hbWVzIG9yIEFkZHJlc3NhYmxlc1xuICAgIGlmIChyZXEudG8pIHtcbiAgICAgICAgcmVzdWx0LnRvID0gcmVxLnRvO1xuICAgIH1cbiAgICBpZiAocmVxLmZyb20pIHtcbiAgICAgICAgcmVzdWx0LmZyb20gPSByZXEuZnJvbTtcbiAgICB9XG4gICAgaWYgKHJlcS5kYXRhKSB7XG4gICAgICAgIHJlc3VsdC5kYXRhID0gaGV4bGlmeShyZXEuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGJpZ0ludEtleXMgPSBcImNoYWluSWQsZ2FzTGltaXQsZ2FzUHJpY2UsbWF4RmVlUGVyR2FzLG1heFByaW9yaXR5RmVlUGVyR2FzLHZhbHVlXCIuc3BsaXQoLywvKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBiaWdJbnRLZXlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXEpIHx8IHJlcVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gZ2V0QmlnSW50KHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbnVtYmVyS2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldE51bWJlcihyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmIChyZXEuYWNjZXNzTGlzdCkge1xuICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IGFjY2Vzc0xpc3RpZnkocmVxLmFjY2Vzc0xpc3QpO1xuICAgIH1cbiAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuYmxvY2tUYWcgPSByZXEuYmxvY2tUYWc7XG4gICAgfVxuICAgIGlmIChcImVuYWJsZUNjaXBSZWFkXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5lbmFibGVDY2lwUmVhZCA9ICEhcmVxLmVuYWJsZUNjaXBSZWFkO1xuICAgIH1cbiAgICBpZiAoXCJjdXN0b21EYXRhXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5jdXN0b21EYXRhID0gcmVxLmN1c3RvbURhdGE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBBICoqQmxvY2sqKiByZXByZXNlbnRzIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGZ1bGwgYmxvY2sgb25cbiAqICBFdGhlcmV1bS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgYmxvY2sgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyLCBzb21ldGltZXMgY2FsbGVkIHRoZSBibG9jayBoZWlnaHQuIFRoaXMgaXMgYVxuICAgICAqICBzZXF1ZW50aWFsIG51bWJlciB0aGF0IGlzIG9uZSBoaWdoZXIgdGhhbiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIG51bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2guXG4gICAgICpcbiAgICAgKiAgVGhpcyBoYXNoIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzLCBzbyBjYW4gYmUgc2FmZWx5IHVzZWQgdG8gaWRlbnRpZnlcbiAgICAgKiAgYW4gZXhhY3Qgc2V0IG9mIGJsb2NrIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVzdGFtcCBmb3IgdGhpcyBibG9jaywgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogIGVwb2NoIHRoYXQgdGhpcyBibG9jayB3YXMgaW5jbHVkZWQuXG4gICAgICovXG4gICAgdGltZXN0YW1wO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgcGFyZW50IGJsb2NrLlxuICAgICAqL1xuICAgIHBhcmVudEhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcbiAgICAgKiAgcGVybWl0dGVkIHRoZSBkaWZmaWN1bHR5IHRhcmdldCB0byBiZSByZWFjaGVkLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGlmZmljdWx0eSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSBwcm9vZi1vZi13b3JrIHRhcmdldCByZXF1aXJlZFxuICAgICAqICBmb3IgYSBibG9jayB0byBtZWV0IHRoZSBwcm90b2NvbCBydWxlcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBPbiBtb2Rlcm4gbmV0d29ya3MsIHRoaXMgaXMgYSByYW5kb20gbnVtYmVyIGFycml2ZWQgYXQgdXNpbmdcbiAgICAgKiAgcmFuZGFvLiAgQFRPRE86IEZpbmQgbGlua3M/XG4gICAgICovXG4gICAgZGlmZmljdWx0eTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyB1c2VkIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmVyIGNvaW5iYXNlIGFkZHJlc3MsIHdpaGNoIHJlY2VpdmVzIGFueSBzdWJzaWRpZXMgZm9yXG4gICAgICogIGluY2x1ZGluZyB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIG1pbmVyO1xuICAgIC8qKlxuICAgICAqICBBbnkgZXh0cmEgZGF0YSB0aGUgdmFsaWRhdG9yIHdpc2hlZCB0byBpbmNsdWRlLlxuICAgICAqL1xuICAgIGV4dHJhRGF0YTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgdGhhdCBhbGwgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2sgd2VyZVxuICAgICAqICBjaGFyZ2VkLlxuICAgICAqXG4gICAgICogIFRoaXMgYWRqdXN0cyBhZnRlciBlYWNoIGJsb2NrLCBkZXBlbmRpbmcgb24gaG93IGNvbmdlc3RlZCB0aGUgbmV0d29ya1xuICAgICAqICBpcy5cbiAgICAgKi9cbiAgICBiYXNlRmVlUGVyR2FzO1xuICAgICN0cmFuc2FjdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkJsb2NrKiogb2JqZWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgbmVjZXNzYXJ5IGFzIHRoZSB1bmxlc3MgaW1wbGVtZW50aW5nIGFcbiAgICAgKiAgbG93LWxldmVsIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0eCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodHgsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBoYXNoOiBnZXRWYWx1ZShibG9jay5oYXNoKSxcbiAgICAgICAgICAgIG51bWJlcjogYmxvY2subnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBibG9jay50aW1lc3RhbXAsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBibG9jay5wYXJlbnRIYXNoLFxuICAgICAgICAgICAgbm9uY2U6IGJsb2NrLm5vbmNlLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBibG9jay5nYXNMaW1pdCxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJsb2NrLmdhc1VzZWQsXG4gICAgICAgICAgICBtaW5lcjogYmxvY2subWluZXIsXG4gICAgICAgICAgICBleHRyYURhdGE6IGJsb2NrLmV4dHJhRGF0YSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IGdldFZhbHVlKGJsb2NrLmJhc2VGZWVQZXJHYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eHNbaW5kZXgrK10sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1qcy1kYXRlXV0gdGhpcyBibG9jayB3YXMgaW5jbHVkZWQgYXQuXG4gICAgICovXG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgdHJhbnNhY3Rpb24gYXQgJSVpbmRleGUlJSB3aXRoaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBpbnRlcm5hbCB2YWx1ZSBieSBpdHMgaW5kZXggb3IgaGFzaFxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdHggPSB0aGlzLiN0cmFuc2FjdGlvbnNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhICoqQmxvY2sqKiB3YXMgZmV0Y2hlZCB3aXRoIGEgcmVxdWVzdCB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgdGhpcyB3aWxsIGFsbG93IHN5bmNocm9ub3VzIGFjY2VzcyB0byB0aG9zZSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIG5vdCBwcmVmZXRjaGVkLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMucHJlZmV0Y2hlZFRyYW5zYWN0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleE9ySGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XG4gICAgICAgICAgICBpZiAodHguaGFzaCA9PT0gaW5kZXhPckhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwibm8gbWF0Y2hpbmcgdHJhbnNhY3Rpb25cIiwgXCJpbmRleE9ySGFzaFwiLCBpbmRleE9ySGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhpcyBibG9jayBiZWVuIG1pbmVkLiBUaGlzIHByb3ZpZGVzIGEgdHlwZSBndWFyZFxuICAgICAqICBmb3IgYWxsIHByb3BlcnRpZXMgb24gYSBbW01pbmVkQmxvY2tdXS5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkgeyByZXR1cm4gISF0aGlzLmhhc2g7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgaXMgYW4gW1tsaW5rLWVpcC0yOTMwXV0gYmxvY2suXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYmFzZUZlZVBlckdhcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIG9ycGhhbmVkRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMb2dcbi8qKlxuICogIEEgKipMb2cqKiBpbiBFdGhlcmV1bSByZXByZXNlbnRzIGFuIGV2ZW50IHRoYXQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gYVxuICogIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBgYExPRypgYCBvcGNvZGVzLCB3aGljaCBhcmUgbW9zdCBjb21tb25seSB1c2VkIGJ5XG4gKiAgU29saWRpdHkncyBlbWl0IGZvciBhbm5vdW5jaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRUcmFuc2FjdGlvbl1dIHRvIGdldCB0aGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBJdCBpcyBwcmVmZXJyZWRcbiAgICAgKiAgdG8gdXNlIHRoZSBbW0Jsb2NrLWhhc2hdXSB3aGVuIGZldGNoaW5nIHRoZSByZWxhdGVkIFtbQmxvY2tdXSxcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcbiAgICAgKiAgaGF2ZSBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgKipMb2cqKiByZXByZXNlbnRzIGEgYmxvY2sgdGhhdCB3YXMgcmVtb3ZlZCBkdWUgdG8gYW4gb3JwaGFuZWRcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdpdGhpbiBhbiBvcnBoYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgcmVtb3ZlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleGVkIHRvcGljcyBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogIEFsbCB0b3BpY3MgYXJlIGluY2x1ZGVkIGluIHRoZSBibG9vbSBmaWx0ZXJzLCBzbyB0aGV5IGNhbiBiZVxuICAgICAqICBlZmZpY2llbnRseSBmaWx0ZXJlZCB1c2luZyB0aGUgW1tQcm92aWRlci1nZXRMb2dzXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHRvcGljcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XG4gICAgICogIG5vdCB1c2VmdWwgdG8gZGV2ZWxvcGVycywgYnV0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHZhcmlvdXMgcm9vdHNcbiAgICAgKiAgdG8gcHJvb2YgaW5jbHVzaW9uIHdpdGhpbiBhIGJsb2NrLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkluZGV4O1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgdG9waWNzID0gT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBsb2cucmVtb3ZlZCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICB0b3BpY3MsXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbG9nLnRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LCByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgYWRkcmVzcywgYmxvY2tIYXNoLCBibG9ja051bWJlciwgZGF0YSwgaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkLCB0b3BpY3MsIHRyYW5zYWN0aW9uSGFzaCwgdHJhbnNhY3Rpb25JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmxvY2sgdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhYmxvY2ssIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gdGhhdCB0aGlzIGxvZyBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCBmb3QgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpc1xuICAgICAqICBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBhc3NlcnQoISFyZWNlaXB0LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uIHJlY2VpcHRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKHRoaXMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRyYW5zYWN0aW9uIFJlY2VpcHRcbi8qXG5leHBvcnQgaW50ZXJmYWNlIExlZ2FjeVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiBmYWxzZTtcbiAgICBzdGF0dXM6IG51bGw7XG4gICAgcm9vdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ5emFudGl1bVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiB0cnVlO1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHJvb3Q6IG51bGw7XG59XG4qL1xuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYVxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gd2FzIHNlbnQgdG8uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZyb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGRpcmVjdGx5XG4gICAgICogIHJlc3BvbnNpYmxlIGZvciBkZXBsb3lpbmcgb25lLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm9uLW51bGwgKipvbmx5KiogaWYgdGhlIGBgdG9gYCBpcyBlbXB0eSBhbmQgdGhlIGBgZGF0YWBgXG4gICAgICogIHdhcyBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQgYXMgaW5pdGNvZGUuXG4gICAgICovXG4gICAgY29udHJhY3RBZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggb2YgdGhpcyB0cmFuc2FjdGlvbiB3aXRoaW4gdGhlIGJsb2NrIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIFtbQmxvY2tdXSB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb29tIGZpbHRlciBieXRlcyB0aGF0IHJlcHJlc2VudCBhbGwgbG9ncyB0aGF0IG9jY3VycmVkIHdpdGhpblxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLiBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIGZvciBtb3N0IGRldmVsb3BlcnMsXG4gICAgICogIGJ1dCBjYW4gYmUgdXNlZCB0byB2YWxpZGF0ZSB0aGUgaW5jbHVkZWQgbG9ncy5cbiAgICAgKi9cbiAgICBsb2dzQmxvb207XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgV2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uLCB0aGUgYW1vdW50IG9mIGdhcyB0aGF0IHdpbGwgYmUgdXNlZCBjYW5cbiAgICAgKiAgb25seSBiZSBhcHByb3hpbWF0ZWQsIGJ1dCB0aGUgc2VuZGVyIG11c3QgcGF5IHRoZSBnYXMgZmVlIGZvciB0aGVcbiAgICAgKiAgZW50aXJlIGdhcyBsaW1pdC4gQWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCB0aGUgZGlmZmVyZW5jZSBpcyByZWZ1bmRlZC5cbiAgICAgKi9cbiAgICBnYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLy9yZWFkb25seSBieXphbnRpdW0hOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdHVzIG9mIHRoaXMgdHJhbnNhY3Rpb24sIGluZGljYXRpbmcgc3VjY2VzcyAoaS5lLiBgYDFgYCkgb3JcbiAgICAgKiAgYSByZXZlcnQgKGkuZS4gYGAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYXZhaWxhYmxlIGluIHBvc3QtYnl6YW50aXVtIGJsb2NrcywgYnV0IHNvbWUgYmFja2VuZHMgbWF5XG4gICAgICogIGJhY2tmaWxsIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdHVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgcm9vdCBoYXNoIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBubyBwcmVzZW50IGFuZCB3YXMgb25seSBpbmNsdWRlZCBpbiBwcmUtYnl6YW50aXVtIGJsb2NrcywgYnV0XG4gICAgICogIGNvdWxkIGJlIHVzZWQgdG8gdmFsaWRhdGUgY2VydGFpbiBwYXJ0cyBvZiB0aGUgcmVjZWlwdC5cbiAgICAgKi9cbiAgICByb290O1xuICAgICNsb2dzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jbG9ncyA9IE9iamVjdC5mcmVlemUodHgubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2cobG9nLCBwcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IGdhc1ByaWNlID0gQk5fMDtcbiAgICAgICAgaWYgKHR4LmVmZmVjdGl2ZUdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdhc1ByaWNlID0gdHguZWZmZWN0aXZlR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICB0eXBlOiB0eC50eXBlLFxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcbiAgICAgICAgICAgIHN0YXR1czogdHguc3RhdHVzLFxuICAgICAgICAgICAgcm9vdDogdHgucm9vdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkgeyByZXR1cm4gdGhpcy4jbG9nczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSwgY29udHJhY3RBZGRyZXNzLCBoYXNoLCBpbmRleCwgYmxvY2tIYXNoLCBibG9ja051bWJlciwgbG9nc0Jsb29tLCBsb2dzLCAvL2J5emFudGl1bSwgXG4gICAgICAgIHN0YXR1cywgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgYmxvY2tIYXNoLCBibG9ja051bWJlcixcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0b0pzb24odGhpcy5jdW11bGF0aXZlR2FzVXNlZCksXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2N0aW9uIGNhbm5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW9yZGVyZWRFdmVudChvdGhlcilcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciB0aGlzIGlzIGNvbm5lY3RlZCB0bywgd2hpY2ggd2lsbCBpbmZsdWVuY2UgaG93IGl0c1xuICAgICAqICBtZXRob2RzIHdpbGwgcmVzb2x2ZSBpdHMgYXN5bmMgaW5zcGVjdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2tIYXNoIG9mIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYGBudWxsYGAgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHJlc2lkZXMgYXQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI3MThdXSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0eXBlLiBUaGlzIGlzXG4gICAgICogIGBgMGBgIGZvciBsZWdhY3kgdHJhbnNhY3Rpb25zIHR5cGVzLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNlaXZlciBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIElmIGBgbnVsbGBgLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbml0Y29kZSB0cmFuc2FjdGlvbi5cbiAgICAgKiAgVGhpcyBtZWFucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGUgW1tkYXRhXV0gd2lsbCBiZSBkZXBsb3llZFxuICAgICAqICBhcyBhIG5ldyBjb250cmFjdCBvbiBjaGFpbiAoYXNzdW1pbmcgaXQgZG9lcyBub3QgcmV2ZXJ0KSBhbmQgdGhlXG4gICAgICogIGFkZHJlc3MgbWF5IGJlIGNvbXB1dGVkIHVzaW5nIFtbZ2V0Q3JlYXRlQWRkcmVzc11dLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uIEl0IGlzIGltcGxpY2l0bHkgY29tcHV0ZWRcbiAgICAgKiAgZnJvbSB0aGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlIGhhc2ggKGFzIHRoZSBkaWdlc3QpIGFuZCB0aGVcbiAgICAgKiAgW1tzaWduYXR1cmVdXSB1c2luZyBlY3JlY292ZXIuXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5vbmNlLCB3aGljaCBpcyB1c2VkIHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MgYW5kIG9mZmVyXG4gICAgICogIGEgbWV0aG9kIHRvIGVuc3VyZSB0cmFuc2FjdGlvbnMgZnJvbSBhIGdpdmVuIHNlbmRlciBhcmUgZXhwbGljaXRseVxuICAgICAqICBvcmRlcmVkLlxuICAgICAqXG4gICAgICogIFdoZW4gc2VuZGluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIG11c3QgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAqICB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGJ5IFtbZnJvbV1dLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB1bml0cyBvZiBnYXMgdGhpcyB0cmFuc2FjdGlvbiBjYW4gY29uc3VtZS4gSWYgZXhlY3V0aW9uXG4gICAgICogIGV4Y2VlZHMgdGhpcywgdGhlIGVudHJpZXMgdHJhbnNhY3Rpb24gaXMgcmV2ZXJ0ZWQgYW5kIHRoZSBzZW5kZXJcbiAgICAgKiAgaXMgY2hhcmdlZCBmb3IgdGhlIGZ1bGwgYW1vdW50LCBkZXNwaXRlIG5vdCBzdGF0ZSBjaGFuZ2VzIGJlaW5nIG1hZGUuXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UgY2FuIGhhdmUgdmFyaW91cyB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqICBJbiBtb2Rlcm4gbmV0d29ya3MsIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgaW5jbHVkZWQgdGhpcyBpc1xuICAgICAqICB0aGUgLy9lZmZlY3RpdmUgZ2FzIHByaWNlLy8gKHRoZSBmZWUgcGVyIGdhcyB0aGF0IHdhcyBhY3R1YWxseVxuICAgICAqICBjaGFyZ2VkKSwgd2hpbGUgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGhhdmUgbm90IGJlZW4gaW5jbHVkZWQgeWV0XG4gICAgICogIGlzIHRoZSBbW21heEZlZVBlckdhc11dLlxuICAgICAqXG4gICAgICogIEZvciBsZWdhY3kgdHJhbnNhY3Rpb25zLCBvciB0cmFuc2FjdGlvbnMgb24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzXG4gICAgICogIGlzIHRoZSBmZWUgdGhhdCB3aWxsIGJlIGNoYXJnZWQgcGVyIHVuaXQgb2YgZ2FzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqICBjb25zdW1lcy5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gcHJpb3JpdHkgZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IGFcbiAgICAgKiAgdmFsaWRhdG9yIHRvIGNoYXJnZSB0aGUgc2VuZGVyLiBUaGlzIGlzIGluY2x1c2l2ZSBvZiB0aGVcbiAgICAgKiAgW1ttYXhGZWVGZWVQZXJHYXNdXS5cbiAgICAgKi9cbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gZmVlIChwZXIgdW5pdCBvZiBnYXMpIHRvIGFsbG93IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiAgdG8gY2hhcmdlIHRoZSBzZW5kZXIuXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgI3N0YXJ0QmxvY2s7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYmxvY2tOdW1iZXIgPSAodHguYmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0eC5ibG9ja051bWJlciA6IG51bGw7XG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gKHR4LmJsb2NrSGFzaCAhPSBudWxsKSA/IHR4LmJsb2NrSGFzaCA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0eC5pbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gdHgudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gdHguZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHR4LnRvIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgdGhpcy5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB0aGlzLnZhbHVlID0gdHgudmFsdWU7XG4gICAgICAgIHRoaXMuZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgdGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9ICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYXhGZWVQZXJHYXMgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyR2FzIDogbnVsbDtcbiAgICAgICAgdGhpcy5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB0eC5zaWduYXR1cmU7XG4gICAgICAgIHRoaXMuYWNjZXNzTGlzdCA9ICh0eC5hY2Nlc3NMaXN0ICE9IG51bGwpID8gdHguYWNjZXNzTGlzdCA6IG51bGw7XG4gICAgICAgIHRoaXMuI3N0YXJ0QmxvY2sgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGJsb2NrSGFzaCwgaW5kZXgsIGhhc2gsIHR5cGUsIHRvLCBmcm9tLCBub25jZSwgZGF0YSwgc2lnbmF0dXJlLCBhY2Nlc3NMaXN0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0LCBibG9ja051bWJlciwgYmxvY2tIYXNoLFxuICAgICAgICAgICAgY2hhaW5JZDogdG9Kc29uKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBkYXRhLCBmcm9tLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG5vbmNlLCBzaWduYXR1cmUsIHRvLCBpbmRleCwgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB0b0pzb24odGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgQmxvY2sgdGhhdCB0aGlzIHRyYW5zYWN0aW9uIHdhcyBpbmNsdWRlZCBpbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCB5ZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGxldCBibG9ja051bWJlciA9IHRoaXMuYmxvY2tOdW1iZXI7XG4gICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja051bWJlcik7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoaXMgdHJhbnNhY3Rpb24gYmVpbmcgcmUtcmVxdWVzdGVkIGZyb20gdGhlXG4gICAgICogIHByb3ZpZGVyLiBUaGlzIGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlIGFuIHVubWluZWQgdHJhbnNhY3Rpb25cbiAgICAgKiAgYW5kIHdpc2ggdG8gZ2V0IGFuIHVwLXRvLWRhdGUgcG9wdWxhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgdGhpcyB0cmFuc2FjdGlvbiBoYXMuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWF0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeyB0eCwgYmxvY2tOdW1iZXIgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5mcm9tKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBObyB0cmFuc2FjdGlvbiBvciBvdXIgbm9uY2UgaGFzIG5vdCBiZWVuIG1pbmVkIHlldDsgYnV0IHdlXG4gICAgICAgICAgICAvLyBjYW4gc3RhcnQgc2Nhbm5pbmcgbGF0ZXIgd2hlbiB3ZSBkbyBzdGFydFxuICAgICAgICAgICAgaWYgKG5vbmNlIDwgdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluZWQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQ7IHN0YXJ0IHNjYW5uaW5nIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTdGFydGluZyB0byBzY2FuOyBsb29rIGJhY2sgYSBmZXcgZXh0cmEgYmxvY2tzIGZvciBzYWZldHlcbiAgICAgICAgICAgIGlmIChuZXh0U2NhbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHN0YXJ0QmxvY2sgLSAzO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2NhbiA8IHRoaXMuI3N0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNjYW4gPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChuZXh0U2NhbiA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBibG9jayB0byBzY2FuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKG5leHRTY2FuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID09PSB0aGlzLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHJlcGxhY2VkIHVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGJsb2NrLmdldFRyYW5zYWN0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gdGhpcy5mcm9tICYmIHR4Lm5vbmNlID09PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eC5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgcmV0cnkgdGhpcyBvbiB0aGUgbmV4dCBibG9jayAodGhpcyBjYXNlIGNvdWxkIGJlIG9wdGltaXplZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyICsgMSkgPCBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5kYXRhID09PSB0aGlzLmRhdGEgJiYgdHgudG8gPT09IHRoaXMudG8gJiYgdHgudmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5kYXRhID09PSBcIjB4XCIgJiYgdHguZnJvbSA9PT0gdHgudG8gJiYgdHgudmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZFwiLCBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQ6IChyZWFzb24gPT09IFwicmVwbGFjZWRcIiB8fCByZWFzb24gPT09IFwiY2FuY2VsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTY2FuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoZWNrUmVjZWlwdCA9IChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsIHx8IHJlY2VpcHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtYWtlRXJyb3IoXCJ3YWl0IGZvciB0cmFuc2FjdGlvbiB0aW1lb3V0XCIsIFwiVElNRU9VVFwiKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eExpc3RlbmVyID0gYXN5bmMgKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb25lOyByZXR1cm4gaXQhXG4gICAgICAgICAgICAgICAgaWYgKChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNoZWNrUmVjZWlwdChyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7IH0pO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gV2Ugc3VwcG9ydCByZXBsYWNlbWVudCBkZXRlY3Rpb247IHN0YXJ0IGNoZWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxpc3RlbmVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRoaXMgdGhyb3dzIG9ubHkgaWYgb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGVja1JlcGxhY2VtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkICh3aXRoIGVub3VnaCBjb25maXJtcyk7IHJlLXRocm93IHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNjaGV1ZGxlIGEgY2hlY2sgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub25jZShcImJsb2NrXCIsIHJlcGxhY2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHRoaXMucHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB3YWl0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBlZmZlY3RpdmUgb25seSBhcyBvZiB0aGUgdGltZSB0aGUgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgICAqICB3YXMgaW5zdGFudGlhdGVkLiBUbyBnZXQgdXAtdG8tZGF0ZSBpbmZvcm1hdGlvbiwgdXNlXG4gICAgICogIFtbZ2V0VHJhbnNhY3Rpb25dXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIG5vbi1udWxsIHByb3BlcnR5IHZhbHVlcyBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBudWxsIGZvclxuICAgICAqICB1bm1pbmVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc01pbmVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmxvY2tIYXNoICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIGxlZ2FjeSAoaS5lLiBgYHR5cGUgPT0gMGBgKVxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBCZXJsaW4gKGkuZS4gYGB0eXBlID09IDFgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTIwNzBdXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNCZXJsaW4oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYSBMb25kb24gKGkuZS4gYGB0eXBlID09IDJgYClcbiAgICAgKiAgdHJhbnNhY3Rpb24uIFNlZSBbW2xpbmstZWlwLTE1NTldXS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBoYXZlXG4gICAgICogIHRoZSBgYG51bGxgYC1uZXNzIGZvciBoYXJkZm9yay1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNldCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaXNMb25kb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgZXZpY3QgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICByZW1vdmVkRXZlbnQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIGFzc2VydCghb3RoZXIgfHwgb3RoZXIuaXNNaW5lZCgpLCBcInVubWluZWQgJ290aGVyJyB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UgaW5zdGFuY2Ugd2hpY2ggaGFzIHRoZSBhYmlsaXR5IHRvXG4gICAgICogIGRldGVjdCAoYW5kIHRocm93IGFuIGVycm9yKSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcmVwbGFjZWQsIHdoaWNoXG4gICAgICogIHdpbGwgYmVnaW4gc2Nhbm5pbmcgYXQgJSVzdGFydEJsb2NrJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSB1c2VkIGJ5IGRldmVsb3BlcnMgYW5kIGlzIGludGVuZGVkXG4gICAgICogIHByaW1hcmlseSBmb3IgaW50ZXJuYWwgdXNlLiBTZXR0aW5nIGFuIGluY29ycmVjdCAlJXN0YXJ0QmxvY2slJSBjYW5cbiAgICAgKiAgaGF2ZSBkZXZhc3RhdGluZyBwZXJmb3JtYW5jZSBjb25zZXF1ZW5jZXMgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgKi9cbiAgICByZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlcihibG9jaykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWJsb2NrXCIsIGhhc2g6IGJsb2NrLmhhc2gsIG51bWJlcjogYmxvY2subnVtYmVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0eCwgb3RoZXIpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwicmVvcmRlci10cmFuc2FjdGlvblwiLCB0eCwgb3RoZXIgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0eCkge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLXRyYW5zYWN0aW9uXCIsIHR4IH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkTG9nRmlsdGVyKGxvZykge1xuICAgIHJldHVybiB7IG9ycGhhbjogXCJkcm9wLWxvZ1wiLCBsb2c6IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogbG9nLmJsb2NrSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzOiBPYmplY3QuZnJlZXplKGxvZy50b3BpY3Muc2xpY2UoKSksXG4gICAgICAgICAgICBpbmRleDogbG9nLmluZGV4XG4gICAgICAgIH0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0QmlnSW50IiwiZ2V0TnVtYmVyIiwiaGV4bGlmeSIsInJlc29sdmVQcm9wZXJ0aWVzIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYWNjZXNzTGlzdGlmeSIsIkJOXzAiLCJCaWdJbnQiLCJnZXRWYWx1ZSIsInZhbHVlIiwidG9Kc29uIiwidG9TdHJpbmciLCJGZWVEYXRhIiwiY29uc3RydWN0b3IiLCJnYXNQcmljZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwidG9KU09OIiwiX3R5cGUiLCJjb3B5UmVxdWVzdCIsInJlcSIsInJlc3VsdCIsInRvIiwiZnJvbSIsImRhdGEiLCJiaWdJbnRLZXlzIiwic3BsaXQiLCJrZXkiLCJudW1iZXJLZXlzIiwiYWNjZXNzTGlzdCIsImJsb2NrVGFnIiwiZW5hYmxlQ2NpcFJlYWQiLCJjdXN0b21EYXRhIiwiQmxvY2siLCJ0cmFuc2FjdGlvbnMiLCJibG9jayIsInByb3ZpZGVyIiwibWFwIiwidHgiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiaGFzaCIsIm51bWJlciIsInRpbWVzdGFtcCIsInBhcmVudEhhc2giLCJub25jZSIsImRpZmZpY3VsdHkiLCJnYXNMaW1pdCIsImdhc1VzZWQiLCJtaW5lciIsImV4dHJhRGF0YSIsImJhc2VGZWVQZXJHYXMiLCJwcmVmZXRjaGVkVHJhbnNhY3Rpb25zIiwidHhzIiwic2xpY2UiLCJsZW5ndGgiLCJvcGVyYXRpb24iLCJTeW1ib2wiLCJpdGVyYXRvciIsImluZGV4IiwibmV4dCIsImRvbmUiLCJ1bmRlZmluZWQiLCJkYXRlIiwiRGF0ZSIsImdldFRyYW5zYWN0aW9uIiwiaW5kZXhPckhhc2giLCJ0b0xvd2VyQ2FzZSIsInYiLCJFcnJvciIsImdldFByZWZldGNoZWRUcmFuc2FjdGlvbiIsImlzTWluZWQiLCJpc0xvbmRvbiIsIm9ycGhhbmVkRXZlbnQiLCJjcmVhdGVPcnBoYW5lZEJsb2NrRmlsdGVyIiwiTG9nIiwibG9nIiwidG9waWNzIiwiT2JqZWN0IiwiZnJlZXplIiwidHJhbnNhY3Rpb25IYXNoIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJyZW1vdmVkIiwiYWRkcmVzcyIsInRyYW5zYWN0aW9uSW5kZXgiLCJnZXRCbG9jayIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInJlY2VpcHQiLCJyZW1vdmVkRXZlbnQiLCJjcmVhdGVSZW1vdmVkTG9nRmlsdGVyIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwibG9ncyIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiY29udHJhY3RBZGRyZXNzIiwibG9nc0Jsb29tIiwiY3VtdWxhdGl2ZUdhc1VzZWQiLCJ0eXBlIiwic3RhdHVzIiwicm9vdCIsImZlZSIsImdldFJlc3VsdCIsImdldFRyYW5zYWN0aW9uUmVzdWx0IiwiY29uZmlybWF0aW9ucyIsImdldEJsb2NrTnVtYmVyIiwiY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyIiwicmVvcmRlcmVkRXZlbnQiLCJvdGhlciIsImNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyIiwic3RhcnRCbG9jayIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJ3YWl0IiwiX2NvbmZpcm1zIiwiX3RpbWVvdXQiLCJjb25maXJtcyIsInRpbWVvdXQiLCJuZXh0U2NhbiIsInN0b3BTY2FubmluZyIsImNoZWNrUmVwbGFjZW1lbnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwibWluZWQiLCJpIiwicmVhc29uIiwiY2FuY2VsbGVkIiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiY2hlY2tSZWNlaXB0IiwiYWN0aW9uIiwiaW52b2NhdGlvbiIsInJldmVydCIsInRyYW5zYWN0aW9uIiwid2FpdGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWxsZXJzIiwiY2FuY2VsIiwiZm9yRWFjaCIsImMiLCJwdXNoIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidHhMaXN0ZW5lciIsImVycm9yIiwib2ZmIiwib24iLCJyZXBsYWNlTGlzdGVuZXIiLCJvbmNlIiwiaXNMZWdhY3kiLCJpc0JlcmxpbiIsIk51bWJlciIsImlzSW50ZWdlciIsIm9ycGhhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-filterid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterIdEventSubscriber: () => (/* binding */ FilterIdEventSubscriber),\n/* harmony export */   FilterIdPendingSubscriber: () => (/* binding */ FilterIdPendingSubscriber),\n/* harmony export */   FilterIdSubscriber: () => (/* binding */ FilterIdSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subscriber-polling.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\");\n\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */ _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */ _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */ _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [\n                filterId\n            ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId)=>{\n                this.#provider.send(\"eth_uninstallFilter\", [\n                    filterId\n                ]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */ constructor(provider, filter){\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new _subscriber_polling_js__WEBPACK_IMPORTED_MODULE_1__.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [\n            this.#event\n        ]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(\"pending\", result);\n        }\n    }\n} //# sourceMappingURL=subscriber-filterid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItZmlsdGVyaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDcUI7QUFDakUsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1JO0lBQ1QsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsZUFBZSxDQUFDO0lBQ2pCLENBQUNDLE1BQU0sQ0FBQztJQUNSLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLEtBQUssQ0FBQztJQUNQOzs7O0tBSUMsR0FDREMsWUFBWU4sUUFBUSxDQUFFO1FBQ2xCLElBQUksQ0FBQyxDQUFDQSxRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDQyxlQUFlLEdBQUc7UUFDeEIsSUFBSSxDQUFDLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQ0ssSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuQyxJQUFJLENBQUMsQ0FBQ0wsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNDLEtBQUssR0FBRztJQUNsQjtJQUNBOztLQUVDLEdBQ0RJLFdBQVdULFFBQVEsRUFBRTtRQUNqQixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNEQyxhQUFhWCxRQUFRLEVBQUVZLE1BQU0sRUFBRTtRQUMzQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQTs7S0FFQyxHQUNERyxTQUFTYixRQUFRLEVBQUU7UUFDZixNQUFNLElBQUlVLE1BQU07SUFDcEI7SUFDQSxNQUFNLENBQUNILElBQUksQ0FBQ08sV0FBVztRQUNuQixJQUFJO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksSUFBSSxDQUFDLENB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QUk7QUFDN0I7QUFDQTs7OztDQUlDLEdBQ00sTUFBTU0sZ0NBQWdDbEM7SUFDekMsQ0FBQ21DLEtBQUssQ0FBQztJQUNQOzs7S0FHQyxHQUNENUIsWUFBWU4sUUFBUSxFQUFFbUMsTUFBTSxDQUFFO1FBQzFCLEtBQUssQ0FBQ25DO1FBQ04sSUFBSSxDQUFDLENBQUNrQyxLQUFLLEdBQUd4QyxLQUFLeUM7SUFDdkI7SUFDQXRCLFNBQVNiLFFBQVEsRUFBRTtRQUNmLE9BQU8sSUFBSVAsMEVBQXNCQSxDQUFDTyxVQUFVLElBQUksQ0FBQyxDQUFDa0MsS0FBSztJQUMzRDtJQUNBLE1BQU16QixXQUFXVCxRQUFRLEVBQUU7UUFDdkIsTUFBTWUsV0FBVyxNQUFNZixTQUFTcUIsSUFBSSxDQUFDLGlCQUFpQjtZQUFDLElBQUksQ0FBQyxDQUFDYSxLQUFLO1NBQUM7UUFDbkUsT0FBT25CO0lBQ1g7SUFDQSxNQUFNSixhQUFhWCxRQUFRLEVBQUVvQyxPQUFPLEVBQUU7UUFDbEMsS0FBSyxNQUFNeEIsVUFBVXdCLFFBQVM7WUFDMUJwQyxTQUFTcUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDSCxLQUFLLEVBQUVsQyxTQUFTc0MsUUFBUSxDQUFDMUIsUUFBUVosU0FBU3VDLFFBQVE7UUFDMUU7SUFDSjtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1DLGtDQUFrQ3pDO0lBQzNDLE1BQU1VLFdBQVdULFFBQVEsRUFBRTtRQUN2QixPQUFPLE1BQU1BLFNBQVNxQixJQUFJLENBQUMsbUNBQW1DLEVBQUU7SUFDcEU7SUFDQSxNQUFNVixhQUFhWCxRQUFRLEVBQUVvQyxPQUFPLEVBQUU7UUFDbEMsS0FBSyxNQUFNeEIsVUFBVXdCLFFBQVM7WUFDMUJwQyxTQUFTcUMsSUFBSSxDQUFDLFdBQVd6QjtRQUM3QjtJQUNKO0FBQ0osRUFDQSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcz85YzIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IFBvbGxpbmdFdmVudFN1YnNjcmliZXIgfSBmcm9tIFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIjtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBTb21lIGJhY2tlbmRzIHN1cHBvcnQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzIHVzaW5nIGEgRmlsdGVyIElELlxuICpcbiAqICBXaGVuIHN1YnNjcmliaW5nIHdpdGggdGhpcyB0ZWNobmlxdWUsIHRoZSBub2RlIGlzc3VlcyBhIHVuaXF1ZVxuICogIC8vRmlsdGVyIElELy8uIEF0IHRoaXMgcG9pbnQgdGhlIG5vZGUgZGVkaWNhdGVzIHJlc291cmNlcyB0b1xuICogIHRoZSBmaWx0ZXIsIHNvIHRoYXQgcGVyaW9kaWMgY2FsbHMgdG8gZm9sbG93IHVwIG9uIHRoZSAvL0ZpbHRlciBJRC8vXG4gKiAgd2lsbCByZWNlaXZlIGFueSBldmVudHMgc2luY2UgdGhlIGxhc3QgY2FsbC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiKSB8fCBlcnJvci5vcGVyYXRpb24gIT09IFwiZXRoX25ld0ZpbHRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgRmlsdGVyIElEOyBkb3duZ3JhZGUgdG9cbiAgICAgICAgICAgIC8vIHBvbGxpbmdcbiAgICAgICAgICAgIGlmIChmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVjb3ZlclN1YnNjcmliZXIodGhpcywgdGhpcy5fcmVjb3Zlcih0aGlzLiNwcm92aWRlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI25ldHdvcmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrLmNoYWluSWQgIT09IG5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWlkIGNoYW5nZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0UmVzdWx0cyh0aGlzLiNwcm92aWRlciwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFRPRE9cIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICAjdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkUHJvbWlzZSA9IHRoaXMuI2ZpbHRlcklkUHJvbWlzZTtcbiAgICAgICAgaWYgKGZpbHRlcklkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy4jZmlsdGVySWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIGZpbHRlcklkUHJvbWlzZS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jdGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICAjZXZlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJVxuICAgICAqICBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50ID0gY29weShmaWx0ZXIpO1xuICAgIH1cbiAgICBfcmVjb3Zlcihwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdFdmVudFN1YnNjcmliZXIocHJvdmlkZXIsIHRoaXMuI2V2ZW50KTtcbiAgICB9XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZCA9IGF3YWl0IHByb3ZpZGVyLnNlbmQoXCJldGhfbmV3RmlsdGVyXCIsIFt0aGlzLiNldmVudF0pO1xuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KHRoaXMuI2V2ZW50LCBwcm92aWRlci5fd3JhcExvZyhyZXN1bHQsIHByb3ZpZGVyLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqRmlsdGVySWRTdWJzY3JpYmVyKiogZm9yIHJlY2VpdmluZyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIGV4dGVuZHMgRmlsdGVySWRTdWJzY3JpYmVyIHtcbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0UmVzdWx0cyhwcm92aWRlciwgcmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1maWx0ZXJpZC5qcy5tYXAiXSwibmFtZXMiOlsiaXNFcnJvciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJjb3B5Iiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiRmlsdGVySWRTdWJzY3JpYmVyIiwicHJvdmlkZXIiLCJmaWx0ZXJJZFByb21pc2UiLCJwb2xsZXIiLCJydW5uaW5nIiwibmV0d29yayIsImhhdWx0IiwiY29uc3RydWN0b3IiLCJwb2xsIiwiYmluZCIsIl9zdWJzY3JpYmUiLCJFcnJvciIsIl9lbWl0UmVzdWx0cyIsInJlc3VsdCIsIl9yZWNvdmVyIiwiYmxvY2tOdW1iZXIiLCJmaWx0ZXJJZCIsImVycm9yIiwib3BlcmF0aW9uIiwiX3JlY292ZXJTdWJzY3JpYmVyIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJzZW5kIiwiY29uc29sZSIsImxvZyIsIm9uY2UiLCJ0ZWFyZG93biIsInRoZW4iLCJzdGFydCIsInN0b3AiLCJvZmYiLCJwYXVzZSIsImRyb3BXaGlsZVBhdXNlZCIsInJlc3VtZSIsIkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyIiwiZXZlbnQiLCJmaWx0ZXIiLCJyZXN1bHRzIiwiZW1pdCIsIl93cmFwTG9nIiwiX25ldHdvcmsiLCJGaWx0ZXJJZFBlbmRpbmdTdWJzY3JpYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-filterid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/subscriber-polling.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnBlockSubscriber: () => (/* binding */ OnBlockSubscriber),\n/* harmony export */   PollingBlockSubscriber: () => (/* binding */ PollingBlockSubscriber),\n/* harmony export */   PollingBlockTagSubscriber: () => (/* binding */ PollingBlockTagSubscriber),\n/* harmony export */   PollingEventSubscriber: () => (/* binding */ PollingEventSubscriber),\n/* harmony export */   PollingOrphanSubscriber: () => (/* binding */ PollingOrphanSubscriber),\n/* harmony export */   PollingTransactionSubscriber: () => (/* binding */ PollingTransactionSubscriber),\n/* harmony export */   getPollingSubscriber: () => (/* binding */ getPollingSubscriber)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\",\n        info: {\n            event\n        }\n    });\n}\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */ get pollingInterval() {\n        return this.#interval;\n    }\n    set pollingInterval(value) {\n        this.#interval = value;\n    }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for(let b = this.#blockNumber + 1; b <= blockNumber; b++){\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        } catch (error) {\n        // @TODO: Minor bump, add an \"error\" event to let subscribers\n        //        know things went awry.\n        //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber)=>{\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */ async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n    }\n    resume() {\n        this.start();\n    }\n}\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n    #tag;\n    #lastBlock;\n    constructor(provider, tag){\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#lastBlock = -2;\n        }\n        super.pause(dropWhilePaused);\n    }\n    async _poll(blockNumber, provider) {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) {\n            return;\n        }\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter){\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */ constructor(provider, hash){\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */ constructor(provider, filter){\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs){\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber)=>{\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n} //# sourceMappingURL=subscriber-polling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDeEQsU0FBU0UsS0FBS0MsR0FBRztJQUNiLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSDtBQUNyQztBQUNBOzs7O0NBSUMsR0FDTSxTQUFTSSxxQkFBcUJDLFFBQVEsRUFBRUMsS0FBSztJQUNoRCxJQUFJQSxVQUFVLFNBQVM7UUFDbkIsT0FBTyxJQUFJQyx1QkFBdUJGO0lBQ3RDO0lBQ0EsSUFBSVAsNERBQVdBLENBQUNRLE9BQU8sS0FBSztRQUN4QixPQUFPLElBQUlFLDZCQUE2QkgsVUFBVUM7SUFDdEQ7SUFDQVQsdURBQU1BLENBQUMsT0FBTyw2QkFBNkIseUJBQXlCO1FBQ2hFWSxXQUFXO1FBQXdCQyxNQUFNO1lBQUVKO1FBQU07SUFDckQ7QUFDSjtBQUNBLHVCQUF1QjtBQUN2Qjs7Ozs7Q0FLQyxHQUNNLE1BQU1DO0lBQ1QsQ0FBQ0YsUUFBUSxDQUFDO0lBQ1YsQ0FBQ00sTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNEQyxZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNNLE1BQU0sR0FBRztRQUNmLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQUc7UUFDakIsSUFBSSxDQUFDLENBQUNDLFdBQVcsR0FBRyxDQUFDO0lBQ3pCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJRSxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQUU7SUFDL0MsSUFBSUcsZ0JBQWdCQyxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ0osUUFBUSxHQUFHSTtJQUFP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Q3BELElBQUksQ0FBQyxDQUFDaEMsV0FBVyxHQUFHZ0MsSUFBSWhDLFdBQVc7UUFDdkM7SUFDSjtJQUNBVyxRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsQ0FBQ08sT0FBTyxFQUFFO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDQSxPQUFPLEdBQUc7UUFDaEIsSUFBSSxJQUFJLENBQUMsQ0FBQ2xCLFdBQVcsS0FBSyxDQUFDLEdBQUc7WUFDMUIsSUFBSSxDQUFDLENBQUNSLFFBQVEsQ0FBQ2EsY0FBYyxHQUFHcUMsSUFBSSxDQUFDLENBQUMxQztnQkFDbEMsSUFBSSxDQUFDLENBQUNBLFdBQVcsR0FBR0E7WUFDeEI7UUFDSjtRQUNBLElBQUksQ0FBQyxDQUFDUixRQUFRLENBQUM2QixFQUFFLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQ3ZCLE1BQU07SUFDM0M7SUFDQWMsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ00sT0FBTyxFQUFFO1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDMUIsUUFBUSxDQUFDOEIsR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUN4QixNQUFNO0lBQzVDO0lBQ0FnQixNQUFNQyxlQUFlLEVBQUU7UUFDbkIsSUFBSSxDQUFDSCxJQUFJO1FBQ1QsSUFBSUcsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxDQUFDZixXQUFXLEdBQUcsQ0FBQztRQUN6QjtJQUNKO0lBQ0FnQixTQUFTO1FBQ0wsSUFBSSxDQUFDTCxLQUFLO0lBQ2Q7QUFDSixFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3Byb3ZpZGVycy9zdWJzY3JpYmVyLXBvbGxpbmcuanM/YjZjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBwb2xsaW5nIHN1YnNjcmliZXIgZm9yIGNvbW1vbiBldmVudHMuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2xsaW5nU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgPT09IFwiYmxvY2tcIikge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdCbG9ja1N1YnNjcmliZXIocHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcoZXZlbnQsIDMyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KTtcbiAgICB9XG4gICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHBvbGxpbmcgZXZlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0UG9sbGluZ1N1YnNjcmliZXJcIiwgaW5mbzogeyBldmVudCB9XG4gICAgfSk7XG59XG4vLyBAVE9ETzogcmVmYWN0b3IgdGhpc1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBwb2xscyBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgZm9yIGEgY2hhbmdlXG4gKiAgaW4gdGhlIGJsb2NrIG51bWJlci5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbGxpbmdCbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbGVyO1xuICAgICNpbnRlcnZhbDtcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuI2ludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsLlxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNpbnRlcnZhbDsgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHsgdGhpcy4jaW50ZXJ2YWwgPSB2YWx1ZTsgfVxuICAgIGFzeW5jICNwb2xsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIHBvbGwgdG8gc2V0dXAgb3VyIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAVE9ETzogUHV0IGEgY2FwIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgcGVyIGxvb3A/XG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHRoaXMuI2Jsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTsgYiA8PSBibG9ja051bWJlcjsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmVtaXQoXCJibG9ja1wiLCBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiBNaW5vciBidW1wLCBhZGQgYW4gXCJlcnJvclwiIGV2ZW50IHRvIGxldCBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgLy8gICAgICAgIGtub3cgdGhpbmdzIHdlbnQgYXdyeS5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYmVlbiBzdG9wcGVkXG4gICAgICAgIGlmICh0aGlzLiNwb2xsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3Byb3ZpZGVyLl9zZXRUaW1lb3V0KHRoaXMuI3BvbGwuYmluZCh0aGlzKSwgdGhpcy4jaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLiNwb2xsKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvdmlkZXIuX2NsZWFyVGltZW91dCh0aGlzLiNwb2xsZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gKipPbkJsb2NrU3Vic2NyaWJlcioqIGNhbiBiZSBzdWItY2xhc3NlZCwgd2l0aCBhIFtbX3BvbGxdXVxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjcG9sbDtcbiAgICAjcnVubmluZztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqT25CbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwb2xsID0gKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsKGJsb2NrTnVtYmVyLCB0aGlzLiNwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICAgICAqL1xuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub24oXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IHRoaXMuc3RvcCgpOyB9XG4gICAgcmVzdW1lKCkgeyB0aGlzLnN0YXJ0KCk7IH1cbn1cbmV4cG9ydCBjbGFzcyBQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICN0YWc7XG4gICAgI2xhc3RCbG9jaztcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgdGFnKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jdGFnID0gdGFnO1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2sgPSAtMjtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhdXNlKGRyb3BXaGlsZVBhdXNlZCk7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKHRoaXMuI3RhZyk7XG4gICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RCbG9jayA9IGJsb2NrLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay5udW1iZXIgPiB0aGlzLiNsYXN0QmxvY2spIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jdGFnLCBibG9jay5udW1iZXIpO1xuICAgICAgICAgICAgdGhpcy4jbGFzdEJsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIGFzeW5jIF9wb2xsKGJsb2NrTnVtYmVyLCBwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy4jZmlsdGVyKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvblxuICogIGhhc2ggZm9yIGl0cyByZWNlaXB0LlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciBleHRlbmRzIE9uQmxvY2tTdWJzY3JpYmVyIHtcbiAgICAjaGFzaDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWhhc2glJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaGFzaCkge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2hhc2ggPSBoYXNoO1xuICAgIH1cbiAgICBhc3luYyBfcG9sbChibG9ja051bWJlciwgcHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy4jaGFzaCk7XG4gICAgICAgIGlmICh0eCkge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLiNoYXNoLCB0eCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICBBICoqUG9sbGluZ0V2ZW50U3Vic2NyaWJlcioqIHdpbGwgcG9sbCBmb3IgYSBnaXZlbiBmaWx0ZXIgZm9yIGl0cyBsb2dzLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgUG9sbGluZ0V2ZW50U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgYmxvY2sgd2UgaGF2ZSBzY2FubmVkIGZvciBldmVudHMuIFRoZSB2YWx1ZSAtMlxuICAgIC8vIGluZGljYXRlcyB3ZSBzdGlsbCBuZWVkIHRvIGZldGNoIGFuIGluaXRpYWwgYmxvY2sgbnVtYmVyXG4gICAgI2Jsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogYXR0YWNoZWQgdG9cbiAgICAgKiAgJSVwcm92aWRlciUlLCBsaXN0ZW5pbmcgZm9yICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBjb3B5KGZpbHRlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IHRoaXMuI3BvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICBhc3luYyAjcG9sbChibG9ja051bWJlcikge1xuICAgICAgICAvLyBUaGUgaW5pdGlhbCBibG9jayBoYXNuJ3QgYmVlbiBkZXRlcm1pbmVkIHlldFxuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY29weSh0aGlzLiNmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICBjb25zdCBsb2dzID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAvLyBObyBsb2dzIGNvdWxkIGp1c3QgbWVhbiB0aGUgbm9kZSBoYXMgbm90IGluZGV4ZWQgdGhlbSB5ZXQsXG4gICAgICAgIC8vIHNvIHdlIGtlZXAgYSBzbGlkaW5nIHdpbmRvdyBvZiA2MCBibG9ja3MgdG8ga2VlcCBzY2FubmluZ1xuICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA8IGJsb2NrTnVtYmVyIC0gNjApIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZW1pdCh0aGlzLiNmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAvLyBPbmx5IGFkdmFuY2UgdGhlIGJsb2NrIG51bWJlciB3aGVuIGxvZ3Mgd2VyZSBmb3VuZCB0b1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgbmV0d29ya3MgKGxpa2UgQk5CIGFuZCBQb2x5Z29uKSB3aGljaCBtYXlcbiAgICAgICAgICAgIC8vIHNhY3JpZmljZSBldmVudCBjb25zaXN0ZW5jeSBmb3IgYmxvY2sgZXZlbnQgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5nZXRCbG9ja051bWJlcigpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9uKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vZmYoXCJibG9ja1wiLCB0aGlzLiNwb2xsZXIpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmIChkcm9wV2hpbGVQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlci1wb2xsaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnQiLCJpc0hleFN0cmluZyIsImNvcHkiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJnZXRQb2xsaW5nU3Vic2NyaWJlciIsInByb3ZpZGVyIiwiZXZlbnQiLCJQb2xsaW5nQmxvY2tTdWJzY3JpYmVyIiwiUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciIsIm9wZXJhdGlvbiIsImluZm8iLCJwb2xsZXIiLCJpbnRlcnZhbCIsImJsb2NrTnVtYmVyIiwiY29uc3RydWN0b3IiLCJwb2xsaW5nSW50ZXJ2YWwiLCJ2YWx1ZSIsInBvbGwiLCJnZXRCbG9ja051bWJlciIsImIiLCJlbWl0IiwiZXJyb3IiLCJfc2V0VGltZW91dCIsImJpbmQiLCJzdGFydCIsInN0b3AiLCJfY2xlYXJUaW1lb3V0IiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJPbkJsb2NrU3Vic2NyaWJlciIsInJ1bm5pbmciLCJfcG9sbCIsIkVycm9yIiwib24iLCJvZmYiLCJQb2xsaW5nQmxvY2tUYWdTdWJzY3JpYmVyIiwidGFnIiwibGFzdEJsb2NrIiwiYmxvY2siLCJnZXRCbG9jayIsIm51bWJlciIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiZmlsdGVyIiwiY29uc29sZSIsImxvZyIsImhhc2giLCJ0eCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibG9ncyIsImdldExvZ3MiLCJsZW5ndGgiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/subscriber-polling.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n} //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEUsU0FBU0csYUFBYUMsSUFBSSxFQUFFQyxXQUFXO0lBQ25DLE9BQU87UUFDSEMsU0FBU04sNkRBQVVBLENBQUNJO1FBQ3BCQyxhQUFhQSxZQUFZRSxHQUFHLENBQUMsQ0FBQ0MsWUFBWUM7WUFDdENSLCtEQUFjQSxDQUFDQyw0REFBV0EsQ0FBQ00sWUFBWSxLQUFLLGdCQUFnQixDQUFDLFlBQVksRUFBRUMsTUFBTSxDQUFDLENBQUMsRUFBRUQ7WUFDckYsT0FBT0EsV0FBV0UsV0FBVztRQUNqQztJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE9BQU9BLE1BQU1MLEdBQUcsQ0FBQyxDQUFDUSxLQUFLTjtZQUNuQixJQUFJSSxNQUFNQyxPQUFPLENBQUNDLE1BQU07Z0JBQ3BCZCwrREFBY0EsQ0FBQ2MsSUFBSUMsTUFBTSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFUCxNQUFNLENBQUMsQ0FBQyxFQUFFTTtnQkFDeEUsT0FBT1osYUFBYVksR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDdEM7WUFDQWQsK0RBQWNBLENBQUNjLE9BQU8sUUFBUSxPQUFRQSxRQUFTLFVBQVUsNEJBQTRCLFNBQVNIO1lBQzlGLE9BQU9ULGFBQWFZLElBQUlULE9BQU8sRUFBRVMsSUFBSVYsV0FBVztRQUNwRDtJQUNKO0lBQ0FKLCtEQUFjQSxDQUFDVyxTQUFTLFFBQVEsT0FBUUEsVUFBVyxVQUFVLHVCQUF1QixTQUFTQTtJQUM3RixNQUFNSyxTQUFTQyxPQUFPQyxJQUFJLENBQUNQLE9BQU9MLEdBQUcsQ0FBQyxDQUFDSDtRQUNuQyxNQUFNQyxjQUFjTyxLQUFLLENBQUNSLEtBQUssQ0FBQ2dCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYjtZQUMzQ2EsS0FBSyxDQUFDYixXQUFXLEdBQUc7WUFDcEIsT0FBT2E7UUFDWCxHQUFHLENBQUM7UUFDSixPQUFPbEIsYUFBYUMsTUFBTWMsT0FBT0MsSUFBSSxDQUFDZCxhQUFhaUIsSUFBSTtJQUMzRDtJQUNBTCxPQUFPSyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBT0QsRUFBRWpCLE9BQU8sQ0FBQ21CLGFBQWEsQ0FBQ0QsRUFBRWxCLE9BQU87SUFDeEQsT0FBT1c7QUFDWCxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanM/ZWU1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBpc0hleFN0cmluZyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHN0b3JhZ2VLZXksIDMyKSwgXCJpbnZhbGlkIHNsb3RcIiwgYHN0b3JhZ2VLZXlzWyR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbQWNjZXNzTGlzdF1dIGZyb20gYW55IGV0aGVycy1zdXBwb3J0ZWQgYWNjZXNzLWxpc3Qgc3RydWN0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0Lmxlbmd0aCA9PT0gMiwgXCJpbnZhbGlkIHNsb3Qgc2V0XCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWNjZXNzIGxpc3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3NsaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiYXNzZXJ0QXJndW1lbnQiLCJpc0hleFN0cmluZyIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsImFkZHJlc3MiLCJtYXAiLCJzdG9yYWdlS2V5IiwiaW5kZXgiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc0xpc3RpZnkiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInNldCIsImxlbmd0aCIsInJlc3VsdCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/address.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/address.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n\n\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */ function computeAddress(key) {\n    let pubkey;\n    if (typeof key === \"string\") {\n        pubkey = _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_2__.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */ function recoverAddress(digest, signature) {\n    return computeAddress(_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.SigningKey.recoverPublicKey(digest, signature));\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNVO0FBQzNEOzs7O0NBSUMsR0FDTSxTQUFTRyxlQUFlQyxHQUFHO0lBQzlCLElBQUlDO0lBQ0osSUFBSSxPQUFRRCxRQUFTLFVBQVU7UUFDM0JDLFNBQVNILHdEQUFVQSxDQUFDSSxnQkFBZ0IsQ0FBQ0YsS0FBSztJQUM5QyxPQUNLO1FBQ0RDLFNBQVNELElBQUlHLFNBQVM7SUFDMUI7SUFDQSxPQUFPUCw2REFBVUEsQ0FBQ0MsMkRBQVNBLENBQUMsT0FBT0ksT0FBT0csU0FBUyxDQUFDLElBQUlBLFNBQVMsQ0FBQztBQUN0RTtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLGVBQWVDLE1BQU0sRUFBRUMsU0FBUztJQUM1QyxPQUFPUixlQUFlRCx3REFBVUEsQ0FBQ1UsZ0JBQWdCLENBQUNGLFFBQVFDO0FBQzlELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWRkcmVzcy5qcz8wZDBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduaW5nS2V5IH0gZnJvbSBcIi4uL2NyeXB0by9pbmRleC5qc1wiO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlICUla2V5JSUuXG4gKlxuICogIFRoZSBrZXkgbWF5IGJlIGFueSBzdGFuZGFyZCBmb3JtIG9mIHB1YmxpYyBrZXkgb3IgYSBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwdWJrZXkgPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWJrZXkgPSBrZXkucHVibGljS2V5O1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhrZWNjYWsyNTYoXCIweFwiICsgcHVia2V5LnN1YnN0cmluZyg0KSkuc3Vic3RyaW5nKDI2KSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSByZWNvdmVyZWQgYWRkcmVzcyBmb3IgdGhlIHByaXZhdGUga2V5IHRoYXQgd2FzXG4gKiAgdXNlZCB0byBzaWduICUlZGlnZXN0JSUgdGhhdCByZXN1bHRlZCBpbiAlJXNpZ25hdHVyZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwia2VjY2FrMjU2IiwiU2lnbmluZ0tleSIsImNvbXB1dGVBZGRyZXNzIiwia2V5IiwicHVia2V5IiwiY29tcHV0ZVB1YmxpY0tleSIsInB1YmxpY0tleSIsInN1YnN0cmluZyIsInJlY292ZXJBZGRyZXNzIiwiZGlnZXN0Iiwic2lnbmF0dXJlIiwicmVjb3ZlclB1YmxpY0tleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/transaction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transaction: () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signature.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\");\n/* harmony import */ var _accesslist_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accesslist.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/address.js\");\n\n\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(value);\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(_value, param);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(_value, \"value\");\n    const result = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction _parseLegacy(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.decodeRlp)(data);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    } else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from({\n            r: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[7], 32),\n            s: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[8], 32),\n            v\n        });\n        tx.hash = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\"\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(v));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.r));\n    fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.s));\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    } catch (error) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[1], 32);\n    const s = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)(fields[2], 32);\n    const signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from({\n        r,\n        s,\n        yParity\n    });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data));\n    const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n    const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\")\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    tx.hash = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\",\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n        \"0x02\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.decodeRlp)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(data).slice(1));\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    tx.hash = (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\",\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.r));\n        fields.push((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toBeArray)(sig.s));\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n        \"0x01\",\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.encodeRlp)(fields)\n    ]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */ class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */ get type() {\n        return this.#type;\n    }\n    set type(value) {\n        switch(value){\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            default:\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */ get typeName() {\n        switch(this.type){\n            case 0:\n                return \"legacy\";\n            case 1:\n                return \"eip-2930\";\n            case 2:\n                return \"eip-1559\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */ get to() {\n        return this.#to;\n    }\n    set to(value) {\n        this.#to = value == null ? null : (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */ get nonce() {\n        return this.#nonce;\n    }\n    set nonce(value) {\n        this.#nonce = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getNumber)(value, \"value\");\n    }\n    /**\n     *  The gas limit.\n     */ get gasLimit() {\n        return this.#gasLimit;\n    }\n    set gasLimit(value) {\n        this.#gasLimit = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value);\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */ get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = value == null ? null : (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */ get data() {\n        return this.#data;\n    }\n    set data(value) {\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value);\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */ get value() {\n        return this.#value;\n    }\n    set value(value) {\n        this.#value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.getBigInt)(value);\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */ get signature() {\n        return this.#sig || null;\n    }\n    set signature(value) {\n        this.#sig = value == null ? null : _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */ get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2) {\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = value == null ? null : (0,_accesslist_js__WEBPACK_IMPORTED_MODULE_1__.accessListify)(value);\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */ constructor(){\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BigInt(0);\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BigInt(0);\n        this.#chainId = BigInt(0);\n        this.#sig = null;\n        this.#accessList = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */ get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */ get unsignedHash() {\n        return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_7__.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */ get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0,_address_js__WEBPACK_IMPORTED_MODULE_9__.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */ get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return _crypto_index_js__WEBPACK_IMPORTED_MODULE_10__.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */ isSigned() {\n        //isSigned(): this is SignedTransaction {\n        return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */ get serialized() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */ get unsignedSerialized() {\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".unsignedSerialized\"\n        });\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */ inferType() {\n        return this.inferTypes().pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */ inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n        const hasAccessList = this.accessList != null;\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n                value: this\n            });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n            value: this\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n            value: this\n        });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        } else {\n            if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */ clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */ toJSON() {\n        const s = (v)=>{\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */ static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof tx === \"string\") {\n            const payload = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx);\n            if (payload[0] >= 0x7f) {\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch(payload[0]){\n                case 1:\n                    return Transaction.from(_parseEip2930(payload));\n                case 2:\n                    return Transaction.from(_parseEip1559(payload));\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"from\"\n            });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = _crypto_index_js__WEBPACK_IMPORTED_MODULE_6__.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.hash != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ3FCO0FBQ3FGO0FBQzNHO0FBQ0Y7QUFDOUMsTUFBTWlCLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxRQUFRRixPQUFPO0FBQ3JCLE1BQU1HLFFBQVFILE9BQU87QUFDckIsTUFBTUksUUFBUUosT0FBTztBQUNyQixNQUFNSyxjQUFjTCxPQUFPO0FBQzNCLFNBQVNNLGNBQWNDLEtBQUs7SUFDeEIsSUFBSUEsVUFBVSxNQUFNO1FBQ2hCLE9BQU87SUFDWDtJQUNBLE9BQU96Qiw2REFBVUEsQ0FBQ3lCO0FBQ3RCO0FBQ0EsU0FBU0MsaUJBQWlCRCxLQUFLLEVBQUVFLEtBQUs7SUFDbEMsSUFBSTtRQUNBLE9BQU9aLDZEQUFhQSxDQUFDVTtJQUN6QixFQUNBLE9BQU9HLE9BQU87UUFDVmhCLCtEQUFjQSxDQUFDLE9BQU9nQixNQUFNQyxPQUFPLEVBQUVGLE9BQU9GO0lBQ2hEO0FBQ0o7QUFDQSxTQUFTSyxhQUFhQyxNQUFNLEVBQUVKLEtBQUs7SUFDL0IsSUFBSUksV0FBVyxNQUFNO1FBQ2pCLE9BQU87SUFDWDtJQUNBLE9BQU90QiwwREFBU0EsQ0FBQ3NCLFFBQVFKO0FBQzdCO0FBQ0EsU0FBU0ssV0FBV0QsTUFBTSxFQUFFSixLQUFLO0lBQzdCLElBQUlJLFdBQVcsTUFBTTtRQUNqQixPQUFPZDtJQUNYO0lBQ0EsTUFBTVEsUUFBUWpCLDBEQUFTQSxDQUFDdUIsUUFBUUo7SUFDaENmLCtEQUFjQSxDQUFDYSxTQUFTRixhQUFhLDJCQUEyQkksT0FBT0Y7SUFDdkUsT0FBT0E7QUFDWDtBQUNBLFNBQVNRLGFBQWFGLE1BQU0sRUFBRUcsSUFBSTtJQUM5QixNQUFNVCxRQUFRakIsMERBQVNBLENBQUN1QixRQUFRO0lBQ2hDLE1BQU1JLFNBQVN0QiwwREFB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QUNYO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcz82ZWJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2LCBTaWduYXR1cmUsIFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBjb25jYXQsIGRlY29kZVJscCwgZW5jb2RlUmxwLCBnZXRCeXRlcywgZ2V0QmlnSW50LCBnZXROdW1iZXIsIGhleGxpZnksIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQsIHRvQmVBcnJheSwgemVyb1BhZFZhbHVlIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIi4vYWNjZXNzbGlzdC5qc1wiO1xuaW1wb3J0IHsgcmVjb3ZlckFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IEJOX01BWF9VSU5UID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NMaXN0KHZhbHVlLCBwYXJhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcihfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TnVtYmVyKF92YWx1ZSwgcGFyYW0pO1xufVxuZnVuY3Rpb24gaGFuZGxlVWludChfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBCTl8wO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIHBhcmFtKTtcbiAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9CZUFycmF5KHZhbHVlKTtcbiAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZVJscChkYXRhKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDkgfHwgZmllbGRzLmxlbmd0aCA9PT0gNiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9uXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMCxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwibm9uY2VcIiksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVVaW50KGZpZWxkc1sxXSwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbM10pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNF0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGNoYWluSWQgIT09IEJOXzAgfHwgKHYgPT09IEJOXzI3IHx8IHYgPT09IEJOXzI4KSwgXCJub24tY2Fub25pY2FsIGxlZ2FjeSB2XCIsIFwidlwiLCBmaWVsZHNbNl0pO1xuICAgICAgICB0eC5zaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzddLCAzMiksXG4gICAgICAgICAgICBzOiB6ZXJvUGFkVmFsdWUoZmllbGRzWzhdLCAzMiksXG4gICAgICAgICAgICB2XG4gICAgICAgIH0pO1xuICAgICAgICB0eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgIF07XG4gICAgbGV0IGNoYWluSWQgPSBCTl8wO1xuICAgIGlmICh0eC5jaGFpbklkICE9IEJOXzApIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IGdldEJpZ0ludCh0eC5jaGFpbklkLCBcInR4LmNoYWluSWRcIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBjaGFpbklkIGluIHRoZSB0eCBhbmQgYW4gRUlQLTE1NSB2IGluIHRoZSBzaWduYXR1cmUsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFncmVlIHdpdGggZWFjaCBvdGhlclxuICAgICAgICBhc3NlcnRBcmd1bWVudCghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KGNoYWluSWQpKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGF0IHR4LnNpZ25hdHVyZSwgY2hhaW5JZCwgYW5kIHNpZ1xuICAgIC8vICAgICAgICBtYXRjaCBidXQgdGhhdCBsb2dpYyBjb3VsZCBicmVhayBleGlzdGluZyBjb2RlLCBzbyBzY2hlZHVsZVxuICAgIC8vICAgICAgICB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciBidW1wLlxuICAgIC8vIENvbXB1dGUgdGhlIEVJUC0xNTUgdlxuICAgIGxldCB2ID0gQmlnSW50KDI3ICsgc2lnLnlQYXJpdHkpO1xuICAgIGlmIChjaGFpbklkICE9PSBCTl8wKSB7XG4gICAgICAgIHYgPSBTaWduYXR1cmUuZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgc2lnLnYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCaWdJbnQoc2lnLnYpICE9PSB2KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBzaWduYXR1cmVcbiAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkodikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucikpO1xuICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIHJldHVybiBlbmNvZGVSbHAoZmllbGRzKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XG4gICAgbGV0IHlQYXJpdHk7XG4gICAgdHJ5IHtcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHlQYXJpdHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgeVBhcml0eVwiLCBcInlQYXJpdHlcIiwgZmllbGRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgciA9IHplcm9QYWRWYWx1ZShmaWVsZHNbMV0sIDMyKTtcbiAgICBjb25zdCBzID0gemVyb1BhZFZhbHVlKGZpZWxkc1syXSwgMzIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHsgciwgcywgeVBhcml0eSB9KTtcbiAgICB0eC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KGRhdGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVSbHAoZ2V0Qnl0ZXMoZGF0YSkuc2xpY2UoMSkpO1xuICAgIGFzc2VydEFyZ3VtZW50KEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSAxMiksIFwiaW52YWxpZCBmaWVsZCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcImRhdGFcIiwgaGV4bGlmeShkYXRhKSk7XG4gICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKTtcbiAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDIsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6IGhleGxpZnkoZmllbGRzWzddKSxcbiAgICAgICAgYWNjZXNzTGlzdDogaGFuZGxlQWNjZXNzTGlzdChmaWVsZHNbOF0sIFwiYWNjZXNzTGlzdFwiKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5oYXNoID0ga2VjY2FrMjU2KGRhdGEpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLnNsaWNlKDkpKTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0eCwgc2lnKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHguY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCh0b0JlQXJyYXkoc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQoW1wiMHgwMlwiLCBlbmNvZGVSbHAoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChkYXRhKSB7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlUmxwKGdldEJ5dGVzKGRhdGEpLnNsaWNlKDEpKTtcbiAgICBhc3NlcnRBcmd1bWVudChBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgKGZpZWxkcy5sZW5ndGggPT09IDggfHwgZmllbGRzLmxlbmd0aCA9PT0gMTEpLCBcImludmFsaWQgZmllbGQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJkYXRhXCIsIGhleGxpZnkoZGF0YSkpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVVaW50KGZpZWxkc1swXSwgXCJjaGFpbklkXCIpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1sxXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzJdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbM10sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1s0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s1XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogaGV4bGlmeShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9IGtlY2NhazI1NihkYXRhKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcy5zbGljZSg4KSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHgsIHNpZykge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4LmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHR4LnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0eC50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHR4LmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHguYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcueVBhcml0eSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2godG9CZUFycmF5KHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHRvQmVBcnJheShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0KFtcIjB4MDFcIiwgZW5jb2RlUmxwKGZpZWxkcyldKTtcbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvbioqIGRlc2NyaWJlcyBhbiBvcGVyYXRpb24gdG8gYmUgZXhlY3V0ZWQgb25cbiAqICBFdGhlcmV1bSBieSBhbiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuIEl0IGluY2x1ZGVzXG4gKiAgd2hvICh0aGUgW1t0b11dIGFkZHJlc3MpLCB3aGF0ICh0aGUgW1tkYXRhXV0pIGFuZCBob3cgbXVjaCAodGhlXG4gKiAgW1t2YWx1ZV1dIGluIGV0aGVyKSB0aGUgb3BlcmF0aW9uIHNob3VsZCBlbnRhaWwuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHR4LmRhdGEgPSBcIjB4MTIzNFwiO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgICN0eXBlO1xuICAgICN0bztcbiAgICAjZGF0YTtcbiAgICAjbm9uY2U7XG4gICAgI2dhc0xpbWl0O1xuICAgICNnYXNQcmljZTtcbiAgICAjbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgI21heEZlZVBlckdhcztcbiAgICAjdmFsdWU7XG4gICAgI2NoYWluSWQ7XG4gICAgI3NpZztcbiAgICAjYWNjZXNzTGlzdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICpcbiAgICAgKiAgSWYgbnVsbCwgdGhlIHR5cGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGJhc2VkIG9uXG4gICAgICogIGV4cGxpY2l0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLiN0eXBlOyB9XG4gICAgc2V0IHR5cGUodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSBcImxlZ2FjeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImJlcmxpblwiOlxuICAgICAgICAgICAgY2FzZSBcImVpcC0yOTMwXCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwibG9uZG9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTE1NTlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuI3RvOyB9XG4gICAgc2V0IHRvKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3RvID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEFkZHJlc3ModmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIG5vbmNlLlxuICAgICAqL1xuICAgIGdldCBub25jZSgpIHsgcmV0dXJuIHRoaXMuI25vbmNlOyB9XG4gICAgc2V0IG5vbmNlKHZhbHVlKSB7IHRoaXMuI25vbmNlID0gZ2V0TnVtYmVyKHZhbHVlLCBcInZhbHVlXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgbGltaXQuXG4gICAgICovXG4gICAgZ2V0IGdhc0xpbWl0KCkgeyByZXR1cm4gdGhpcy4jZ2FzTGltaXQ7IH1cbiAgICBzZXQgZ2FzTGltaXQodmFsdWUpIHsgdGhpcy4jZ2FzTGltaXQgPSBnZXRCaWdJbnQodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzIHRoaXMgZGVmaW5lcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBwYWlkLiBPblxuICAgICAqICBFSVAtMTU1OSBuZXR3b3JrcywgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGdhc1ByaWNlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2dhc1ByaWNlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAodGhpcy50eXBlID09PSAwIHx8IHRoaXMudHlwZSA9PT0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGdhc1ByaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGdldEJpZ0ludCh2YWx1ZSwgXCJnYXNQcmljZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHByaW9yaXR5IGZlZSBwZXIgdW5pdCBvZiBnYXMgdG8gcGF5LiBPbiBsZWdhY3lcbiAgICAgKiAgbmV0d29ya3MgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdG90YWwgZmVlIHBlciB1bml0IG9mIGdhcyB0byBwYXkuIE9uIGxlZ2FjeVxuICAgICAqICBuZXR3b3JrcyB0aGlzIHNob3VsZCBiZSBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgbWF4RmVlUGVyR2FzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21heEZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heEZlZVBlckdhcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNtYXhGZWVQZXJHYXMgPSAodmFsdWUgPT0gbnVsbCkgPyBudWxsIDogZ2V0QmlnSW50KHZhbHVlLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYGBpbml0YGAgdHJhbnNhY3Rpb25zIHRoaXMgaXMgdGhlXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gaGV4bGlmeSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFtb3VudCBvZiBldGhlciAoaW4gd2VpKSB0byBzZW5kIGluIHRoaXMgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbHVlOyB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZ2V0QmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElEIHRoaXMgdHJhbnNhY3Rpb24gaXMgdmFsaWQgb24uXG4gICAgICovXG4gICAgZ2V0IGNoYWluSWQoKSB7IHJldHVybiB0aGlzLiNjaGFpbklkOyB9XG4gICAgc2V0IGNoYWluSWQodmFsdWUpIHsgdGhpcy4jY2hhaW5JZCA9IGdldEJpZ0ludCh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgSWYgc2lnbmVkLCB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxuICAgIHNldCBzaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IFNpZ25hdHVyZS5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhY2Nlc3MgbGlzdC5cbiAgICAgKlxuICAgICAqICBBbiBhY2Nlc3MgbGlzdCBwZXJtaXRzIGRpc2NvdW50ZWQgKGJ1dCBwcmUtcGFpZCkgYWNjZXNzIHRvXG4gICAgICogIGJ5dGVjb2RlIGFuZCBzdGF0ZSB2YXJpYWJsZSBhY2Nlc3Mgd2l0aGluIGNvbnRyYWN0IGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgYWNjZXNzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNhY2Nlc3NMaXN0IHx8IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAxIHx8IHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWNjZXNzTGlzdCA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgVHJhbnNhY3Rpb24gd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RvID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbm9uY2UgPSAwO1xuICAgICAgICB0aGlzLiNnYXNMaW1pdCA9IEJpZ0ludCgwKTtcbiAgICAgICAgdGhpcy4jZ2FzUHJpY2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBcIjB4XCI7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNjaGFpbklkID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNzaWcgPSBudWxsO1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJlLWltYWdlIGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy51bnNpZ25lZFNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRpbmcgYWRkcmVzcywgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY292ZXJBZGRyZXNzKHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLCBpZiBzaWduZWQuIE90aGVyd2lzZSwgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGZyb21QdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgc2lnbmVkLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcbiAgICAgKiAgdHJhbnNhY3Rpb24gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICAvL2lzU2lnbmVkKCk6IHRoaXMgaXMgU2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmUgIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICBhc3NlcnQodGhpcy5zaWduYXR1cmUgIT0gbnVsbCwgXCJjYW5ub3Qgc2VyaWFsaXplIHVuc2lnbmVkIHRyYW5zYWN0aW9uOyBtYXliZSB5b3UgbWVhbnQgLnVuc2lnbmVkU2VyaWFsaXplZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIuc2VyaWFsaXplZFwiIH0pO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodGhpcywgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIi5zZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gcHJlLWltYWdlLlxuICAgICAqXG4gICAgICogIFRoZSBoYXNoIG9mIHRoaXMgaXMgdGhlIGRpZ2VzdCB3aGljaCBuZWVkcyB0byBiZSBzaWduZWQgdG9cbiAgICAgKiAgYXV0aG9yaXplIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IHVuc2lnbmVkU2VyaWFsaXplZCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmluZmVyVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcyk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRoaXMpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIudW5zaWduZWRTZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIG1vc3QgXCJsaWtlbHlcIiB0eXBlOyBjdXJyZW50bHkgdGhlIGhpZ2hlc3RcbiAgICAgKiAgc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgaW5mZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5mZXJUeXBlcygpLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlcyB0aGUgZXhwbGljaXQgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGF0aWJsZVxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpbmZlclR5cGVzKCkge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0ZlZSA9ICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xuICAgICAgICAvL2lmIChoYXNHYXNQcmljZSAmJiBoYXNGZWUpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2UgYW5kIG1heEZlZVBlckdhc1wiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMubWF4RmVlUGVyR2FzID49IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMsIFwicHJpb3JpdHlGZWUgY2Fubm90IGJlIG1vcmUgdGhhbiBtYXhGZWVcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vaWYgKHRoaXMudHlwZSA9PT0gMiAmJiBoYXNHYXNQcmljZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBjYW5ub3QgaGF2ZSBnYXNQcmljZVwiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGFzc2VydCghaGFzRmVlIHx8ICh0aGlzLnR5cGUgIT09IDAgJiYgdGhpcy50eXBlICE9PSAxKSwgXCJ0cmFuc2FjdGlvbiB0eXBlIGNhbm5vdCBoYXZlIG1heEZlZVBlckdhcyBvciBtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWU6IHRoaXMgfSk7XG4gICAgICAgIGFzc2VydCh0aGlzLnR5cGUgIT09IDAgfHwgIWhhc0FjY2Vzc0xpc3QsIFwibGVnYWN5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGFjY2Vzc0xpc3RcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICAvLyBFeHBsaWNpdCB0eXBlXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0ZlZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR5cGVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGJlcmxpbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgdHJhbnNhY2l0b24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgSlNPTi1mcmllbmRseSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzID0gKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNMaW1pdDogcyh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBzKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHModGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHModGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgdmFsdWU6IHModGhpcy52YWx1ZSksXG4gICAgICAgICAgICBjaGFpbklkOiBzKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBzaWc6IHRoaXMuc2lnbmF0dXJlID8gdGhpcy5zaWduYXR1cmUudG9KU09OKCkgOiBudWxsLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSAqKlRyYW5zYWN0aW9uKiogZnJvbSBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb3IgYVxuICAgICAqICBUcmFuc2FjdGlvbi1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eCkge1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGdldEJ5dGVzKHR4KTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkWzBdID49IDB4N2YpIHsgLy8gQFRPRE86ID4gdnMgPj0gPz9cbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VMZWdhY3kocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAyOTMwKHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKF9wYXJzZUVpcDE1NTkocGF5bG9hZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZnJvbVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICBpZiAodHgudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50byA9IHR4LnRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0eC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20odHguc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYWNjZXNzTGlzdCA9IHR4LmFjY2Vzc0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lmhhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSBoYXNoXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0Lmhhc2ggPT09IHR4Lmhhc2gsIFwiaGFzaCBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lIGZyb21cIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChyZXN1bHQuZnJvbS50b0xvd2VyQ2FzZSgpID09PSAodHguZnJvbSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLCBcImZyb20gbWlzbWF0Y2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImtlY2NhazI1NiIsIlNpZ25hdHVyZSIsIlNpZ25pbmdLZXkiLCJjb25jYXQiLCJkZWNvZGVSbHAiLCJlbmNvZGVSbHAiLCJnZXRCeXRlcyIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsInRvQmVBcnJheSIsInplcm9QYWRWYWx1ZSIsImFjY2Vzc0xpc3RpZnkiLCJyZWNvdmVyQWRkcmVzcyIsIkJOXzAiLCJCaWdJbnQiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwiQk5fTUFYX1VJTlQiLCJoYW5kbGVBZGRyZXNzIiwidmFsdWUiLCJoYW5kbGVBY2Nlc3NMaXN0IiwicGFyYW0iLCJlcnJvciIsIm1lc3NhZ2UiLCJoYW5kbGVOdW1iZXIiLCJfdmFsdWUiLCJoYW5kbGVVaW50IiwiZm9ybWF0TnVtYmVyIiwibmFtZSIsInJlc3VsdCIsImxlbmd0aCIsImZvcm1hdEFjY2Vzc0xpc3QiLCJtYXAiLCJzZXQiLCJhZGRyZXNzIiwic3RvcmFnZUtleXMiLCJfcGFyc2VMZWdhY3kiLCJkYXRhIiwiZmllbGRzIiwiQXJyYXkiLCJpc0FycmF5IiwidHgiLCJ0eXBlIiwibm9uY2UiLCJnYXNQcmljZSIsImdhc0xpbWl0IiwidG8iLCJjaGFpbklkIiwidiIsInIiLCJzIiwic2lnbmF0dXJlIiwiZnJvbSIsImhhc2giLCJfc2VyaWFsaXplTGVnYWN5Iiwic2lnIiwibmV0d29ya1YiLCJsZWdhY3lDaGFpbklkIiwibGVnYWN5IiwicHVzaCIsInlQYXJpdHkiLCJnZXRDaGFpbklkViIsIl9wYXJzZUVpcFNpZ25hdHVyZSIsIkVycm9yIiwiX3BhcnNlRWlwMTU1OSIsInNsaWNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJhY2Nlc3NMaXN0IiwiX3NlcmlhbGl6ZUVpcDE1NTkiLCJfcGFyc2VFaXAyOTMwIiwiX3NlcmlhbGl6ZUVpcDI5MzAiLCJUcmFuc2FjdGlvbiIsInR5cGVOYW1lIiwiY29uc3RydWN0b3IiLCJzZXJpYWxpemVkIiwidW5zaWduZWRIYXNoIiwidW5zaWduZWRTZXJpYWxpemVkIiwiZnJvbVB1YmxpY0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJpc1NpZ25lZCIsIm9wZXJhdGlvbiIsImluZmVyVHlwZSIsImluZmVyVHlwZXMiLCJwb3AiLCJoYXNHYXNQcmljZSIsImhhc0ZlZSIsImhhc0FjY2Vzc0xpc3QiLCJ0eXBlcyIsInNvcnQiLCJpc0xlZ2FjeSIsImlzQmVybGluIiwiaXNMb25kb24iLCJjbG9uZSIsInRvSlNPTiIsInRvU3RyaW5nIiwicGF5bG9hZCIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/base58.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base58.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase58: () => (/* binding */ decodeBase58),\n/* harmony export */   encodeBase58: () => (/* binding */ encodeBase58)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */ \n\n\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for(let i = 0; i < Alphabet.length; i++){\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */ function encodeBase58(_value) {\n    let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_2__.getBytes)(_value));\n    let result = \"\";\n    while(value){\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    return result;\n}\n/**\n *  Decode the Base58-encoded %%value%%.\n */ function decodeBase58(value) {\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n} //# sourceMappingURL=base58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ29DO0FBQ1E7QUFDUDtBQUN0QyxNQUFNRyxXQUFXO0FBQ2pCLElBQUlDLFNBQVM7QUFDYixTQUFTQyxTQUFTQyxNQUFNO0lBQ3BCLElBQUlGLFVBQVUsTUFBTTtRQUNoQkEsU0FBUyxDQUFDO1FBQ1YsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlKLFNBQVNLLE1BQU0sRUFBRUQsSUFBSztZQUN0Q0gsTUFBTSxDQUFDRCxRQUFRLENBQUNJLEVBQUUsQ0FBQyxHQUFHRSxPQUFPRjtRQUNqQztJQUNKO0lBQ0EsTUFBTUcsU0FBU04sTUFBTSxDQUFDRSxPQUFPO0lBQzdCTCwwREFBY0EsQ0FBQ1MsVUFBVSxNQUFNLENBQUMsb0JBQW9CLENBQUMsRUFBRSxVQUFVSjtJQUNqRSxPQUFPSTtBQUNYO0FBQ0EsTUFBTUMsT0FBT0YsT0FBTztBQUNwQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCOztDQUVDLEdBQ00sU0FBU0ksYUFBYUMsTUFBTTtJQUMvQixJQUFJQyxRQUFRYixtREFBUUEsQ0FBQ0Ysa0RBQVFBLENBQUNjO0lBQzlCLElBQUlKLFNBQVM7SUFDYixNQUFPSyxNQUFPO1FBQ1ZMLFNBQVNQLFFBQVEsQ0FBQ2EsT0FBT0QsUUFBUUgsT0FBTyxHQUFHRjtRQUMzQ0ssU0FBU0g7SUFDYjtJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNPLGFBQWFGLEtBQUs7SUFDOUIsSUFBSUwsU0FBU0M7SUFDYixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSVEsTUFBTVAsTUFBTSxFQUFFRCxJQUFLO1FBQ25DRyxVQUFVRTtRQUNWRixVQUFVTCxTQUFTVSxLQUFLLENBQUNSLEVBQUU7SUFDL0I7SUFDQSxPQUFPRztBQUNYLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTU4LmpzP2M0ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgVGhlIFtCYXNlNTggRW5jb2RpbmddKGxpbmstYmFzZTU4KSBzY2hlbWUgYWxsb3dzIGEgKipudW1lcmljKiogdmFsdWVcbiAqICB0byBiZSBlbmNvZGVkIGFzIGEgY29tcGFjdCBzdHJpbmcgdXNpbmcgYSByYWRpeCBvZiA1OCB1c2luZyBvbmx5XG4gKiAgYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLiBDb25mdXNpbmdseSBzaW1pbGFyIGNoYXJhY3RlcnMgYXJlIG9taXR0ZWRcbiAqICAoaS5lLiBgYFwibDBPXCJgYCkuXG4gKlxuICogIE5vdGUgdGhhdCBCYXNlNTggZW5jb2RlcyBhICoqbnVtZXJpYyoqIHZhbHVlLCBub3QgYXJiaXRyYXJ5IGJ5dGVzLFxuICogIHNpbmNlIGFueSB6ZXJvLWJ5dGVzIG9uIHRoZSBsZWZ0IHdvdWxkIGdldCByZW1vdmVkLiBUbyBtaXRpZ2F0ZSB0aGlzXG4gKiAgaXNzdWUgbW9zdCBzY2hlbWVzIHRoYXQgdXNlIEJhc2U1OCBjaG9vc2Ugc3BlY2lmaWMgaGlnaC1vcmRlciB2YWx1ZXNcbiAqICB0byBlbnN1cmUgbm9uLXplcm8gcHJlZml4ZXMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOkJhc2U1OCBFbmNvZGluZyBbYWJvdXQtYmFzZTU4XVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB0b0JpZ0ludCB9IGZyb20gXCIuL21hdGhzLmpzXCI7XG5jb25zdCBBbHBoYWJldCA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xubGV0IExvb2t1cCA9IG51bGw7XG5mdW5jdGlvbiBnZXRBbHBoYShsZXR0ZXIpIHtcbiAgICBpZiAoTG9va3VwID09IG51bGwpIHtcbiAgICAgICAgTG9va3VwID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIExvb2t1cFtBbHBoYWJldFtpXV0gPSBCaWdJbnQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gTG9va3VwW2xldHRlcl07XG4gICAgYXNzZXJ0QXJndW1lbnQocmVzdWx0ICE9IG51bGwsIGBpbnZhbGlkIGJhc2U1OCB2YWx1ZWAsIFwibGV0dGVyXCIsIGxldHRlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl81OCA9IEJpZ0ludCg1OCk7XG4vKipcbiAqICBFbmNvZGUgJSV2YWx1ZSUlIGFzIGEgQmFzZTU4LWVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSkpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICByZXN1bHQgPSBBbHBoYWJldFtOdW1iZXIodmFsdWUgJSBCTl81OCldICsgcmVzdWx0O1xuICAgICAgICB2YWx1ZSAvPSBCTl81ODtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIERlY29kZSB0aGUgQmFzZTU4LWVuY29kZWQgJSV2YWx1ZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTU4KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IEJOXzA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKj0gQk5fNTg7XG4gICAgICAgIHJlc3VsdCArPSBnZXRBbHBoYSh2YWx1ZVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNTguanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJ0b0JpZ0ludCIsIkFscGhhYmV0IiwiTG9va3VwIiwiZ2V0QWxwaGEiLCJsZXR0ZXIiLCJpIiwibGVuZ3RoIiwiQmlnSW50IiwicmVzdWx0IiwiQk5fMCIsIkJOXzU4IiwiZW5jb2RlQmFzZTU4IiwiX3ZhbHVlIiwidmFsdWUiLCJOdW1iZXIiLCJkZWNvZGVCYXNlNTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/base58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/base64.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/base64.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode\n *  arbitrary bytes into a string using 65 printable symbols, the\n *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,\n *  ``\"+\"`` and ``\"/\"`` with the ``\"=\"`` used for padding.\n *\n *  @_subsection: api/utils:Base64 Encoding  [about-base64]\n */ \n/**\n *  Decodes the base-64 encoded %%value%%.\n *\n *  @example:\n *    // The decoded value is always binary data...\n *    result = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n *    //_result:\n *\n *    // ...use toUtf8String to convert it to a string.\n *    toUtf8String(result)\n *    //_result:\n *\n *    // Decoding binary data\n *    decodeBase64(\"EjQ=\")\n *    //_result:\n */ function decodeBase64(value) {\n    return (0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytesCopy)(Buffer.from(value, \"base64\"));\n}\n;\n/**\n *  Encodes %%data%% as a base-64 encoded string.\n *\n *  @example:\n *    // Encoding binary data as a hexstring\n *    encodeBase64(\"0x1234\")\n *    //_result:\n *\n *    // Encoding binary data as a Uint8Array\n *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n *    //_result:\n *\n *    // The input MUST be data...\n *    encodeBase64(\"Hello World!!\")\n *    //_error:\n *\n *    // ...use toUtf8Bytes for this.\n *    encodeBase64(toUtf8Bytes(\"Hello World!!\"))\n *    //_result:\n */ function encodeBase64(data) {\n    return Buffer.from((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data)).toString(\"base64\");\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FDa0Q7QUFDbkQ7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sU0FBU0UsYUFBYUMsS0FBSztJQUM5QixPQUFPRixzREFBWUEsQ0FBQ0csT0FBT0MsSUFBSSxDQUFDRixPQUFPO0FBQzNDOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU0csYUFBYUMsSUFBSTtJQUM3QixPQUFPSCxPQUFPQyxJQUFJLENBQUNMLGtEQUFRQSxDQUFDTyxPQUFPQyxRQUFRLENBQUM7QUFDaEQsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9iYXNlNjQuanM/MDAwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBbQmFzZTY0IGVuY29kaW5nXShsaW5rLXdpa2ktYmFzZTY0KSB1c2luZyA2LWJpdCB3b3JkcyB0byBlbmNvZGVcbiAqICBhcmJpdHJhcnkgYnl0ZXMgaW50byBhIHN0cmluZyB1c2luZyA2NSBwcmludGFibGUgc3ltYm9scywgdGhlXG4gKiAgdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSBhbHBoYWJldCwgdGhlIGRpZ2l0cyBgYDBgYCB0aHJvdWdoIGBgOWBgLFxuICogIGBgXCIrXCJgYCBhbmQgYGBcIi9cImBgIHdpdGggdGhlIGBgXCI9XCJgYCB1c2VkIGZvciBwYWRkaW5nLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNjQgRW5jb2RpbmcgIFthYm91dC1iYXNlNjRdXG4gKi9cbmltcG9ydCB7IGdldEJ5dGVzLCBnZXRCeXRlc0NvcHkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG4vKipcbiAqICBEZWNvZGVzIHRoZSBiYXNlLTY0IGVuY29kZWQgJSV2YWx1ZSUlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBkZWNvZGVkIHZhbHVlIGlzIGFsd2F5cyBiaW5hcnkgZGF0YS4uLlxuICogICAgcmVzdWx0ID0gZGVjb2RlQmFzZTY0KFwiU0dWc2JHOGdWMjl5YkdRaElRPT1cIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyAuLi51c2UgdG9VdGY4U3RyaW5nIHRvIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuXG4gKiAgICB0b1V0ZjhTdHJpbmcocmVzdWx0KVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIERlY29kaW5nIGJpbmFyeSBkYXRhXG4gKiAgICBkZWNvZGVCYXNlNjQoXCJFalE9XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCYXNlNjQodmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0Qnl0ZXNDb3B5KEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKSk7XG59XG47XG4vKipcbiAqICBFbmNvZGVzICUlZGF0YSUlIGFzIGEgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBFbmNvZGluZyBiaW5hcnkgZGF0YSBhcyBhIGhleHN0cmluZ1xuICogICAgZW5jb2RlQmFzZTY0KFwiMHgxMjM0XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gRW5jb2RpbmcgYmluYXJ5IGRhdGEgYXMgYSBVaW50OEFycmF5XG4gKiAgICBlbmNvZGVCYXNlNjQobmV3IFVpbnQ4QXJyYXkoWyAweDEyLCAweDM0IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFRoZSBpbnB1dCBNVVNUIGJlIGRhdGEuLi5cbiAqICAgIGVuY29kZUJhc2U2NChcIkhlbGxvIFdvcmxkISFcIilcbiAqICAgIC8vX2Vycm9yOlxuICpcbiAqICAgIC8vIC4uLnVzZSB0b1V0ZjhCeXRlcyBmb3IgdGhpcy5cbiAqICAgIGVuY29kZUJhc2U2NCh0b1V0ZjhCeXRlcyhcIkhlbGxvIFdvcmxkISFcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCYXNlNjQoZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShnZXRCeXRlcyhkYXRhKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiZ2V0Qnl0ZXNDb3B5IiwiZGVjb2RlQmFzZTY0IiwidmFsdWUiLCJCdWZmZXIiLCJmcm9tIiwiZW5jb2RlQmFzZTY0IiwiZGF0YSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNvRDtBQUNyRCxTQUFTRSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxJQUFJRixpQkFBaUJHLFlBQVk7UUFDN0IsSUFBSUQsTUFBTTtZQUNOLE9BQU8sSUFBSUMsV0FBV0g7UUFDMUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFRQSxVQUFXLFlBQVlBLE1BQU1JLEtBQUssQ0FBQyw2QkFBNkI7UUFDeEUsTUFBTUMsU0FBUyxJQUFJRixXQUFXLENBQUNILE1BQU1NLE1BQU0sR0FBRyxLQUFLO1FBQ25ELElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBT0MsTUFBTSxFQUFFRSxJQUFLO1lBQ3BDSCxNQUFNLENBQUNHLEVBQUUsR0FBR0MsU0FBU1QsTUFBTVUsU0FBUyxDQUFDSCxRQUFRQSxTQUFTLElBQUk7WUFDMURBLFVBQVU7UUFDZDtRQUNBLE9BQU9GO0lBQ1g7SUFDQVAsMERBQWNBLENBQUMsT0FBTywyQkFBMkJHLFFBQVEsU0FBU0Q7QUFDdEU7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxTQUFTWCxLQUFLLEVBQUVDLElBQUk7SUFDaEMsT0FBT0YsVUFBVUMsT0FBT0MsTUFBTTtBQUNsQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNXLGFBQWFaLEtBQUssRUFBRUMsSUFBSTtJQUNwQyxPQUFPRixVQUFVQyxPQUFPQyxNQUFNO0FBQ2xDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1ksWUFBWWIsS0FBSyxFQUFFTSxNQUFNO0lBQ3JDLElBQUksT0FBUU4sVUFBVyxZQUFZLENBQUNBLE1BQU1JLEtBQUssQ0FBQyxxQkFBcUI7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFRRSxXQUFZLFlBQVlOLE1BQU1NLE1BQU0s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YWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcz9jNjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5mdW5jdGlvbiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGNvcHkpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1hdGNoKC9eMHgoWzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJfZ2V0Qnl0ZXMiLCJ2YWx1ZSIsIm5hbWUiLCJjb3B5IiwiVWludDhBcnJheSIsIm1hdGNoIiwicmVzdWx0IiwibGVuZ3RoIiwib2Zmc2V0IiwiaSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJpc0hleFN0cmluZyIsImlzQnl0ZXNMaWtlIiwiSGV4Q2hhcmFjdGVycyIsImhleGxpZnkiLCJkYXRhIiwiYnl0ZXMiLCJ2IiwiY29uY2F0IiwiZGF0YXMiLCJtYXAiLCJkIiwiam9pbiIsImRhdGFMZW5ndGgiLCJkYXRhU2xpY2UiLCJzdGFydCIsImVuZCIsImJ1ZmZlciIsInNsaWNlIiwic3RyaXBaZXJvc0xlZnQiLCJzdGFydHNXaXRoIiwiemVyb1BhZCIsImxlZnQiLCJmaWxsIiwic2V0IiwiemVyb1BhZFZhbHVlIiwiemVyb1BhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map(stringify).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return value.toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUN3QztBQUNVO0FBQ25ELFNBQVNFLFVBQVVDLEtBQUs7SUFDcEIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE9BQU8sT0FBTyxNQUFPRyxHQUFHLENBQUNKLFdBQVlLLElBQUksQ0FBQyxRQUFRO0lBQ3REO0lBQ0EsSUFBSUosaUJBQWlCSyxZQUFZO1FBQzdCLE1BQU1DLE1BQU07UUFDWixJQUFJQyxTQUFTO1FBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLE1BQU1TLE1BQU0sRUFBRUQsSUFBSztZQUNuQ0QsVUFBVUQsR0FBRyxDQUFDTixLQUFLLENBQUNRLEVBQUUsSUFBSSxFQUFFO1lBQzVCRCxVQUFVRCxHQUFHLENBQUNOLEtBQUssQ0FBQ1EsRUFBRSxHQUFHLElBQUk7UUFDakM7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsSUFBSSxPQUFRUCxVQUFXLFlBQVksT0FBUUEsTUFBTVUsTUFBTSxLQUFNLFlBQVk7UUFDckUsT0FBT1gsVUFBVUMsTUFBTVUsTUFBTTtJQUNqQztJQUNBLE9BQVEsT0FBUVY7UUFDWixLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU9BLE1BQU1XLFFBQVE7UUFDekIsS0FBSztZQUNELE9BQU9DLE9BQU9aLE9BQU9XLFFBQVE7UUFDakMsS0FBSztZQUNELE9BQU8sTUFBUUEsUUFBUTtRQUMzQixLQUFLO1lBQ0QsT0FBT0UsS0FBS2QsU0FBUyxDQUFDQztRQUMxQixLQUFLO1lBQVU7Z0JBQ1gsTUFBTWMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDZDtnQkFDekJjLEtBQUtFLElBQUk7Z0JBQ1QsT0FBTyxPQUFPRixLQUFLWCxHQUFHLENBQUMsQ0FBQ2MsSUFBTSxDQUFDLEVBQUVsQixVQUFVa0IsR0FBRyxFQUFFLEVBQUVsQixVQUFVQyxLQUFLLENBQUNpQixFQUFFLEVBQUUsQ0FBQyxFQUFFYixJQUFJLENBQUMsUUFBUTtZQUMxRjtJQUNKO0lBQ0EsT0FBTyxDQUFDLHVCQUF1QixDQUFDO0FBQ3BDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNjLFFBQVFDLEtBQUssRUFBRUMsSUFBSTtJQUMvQixPQUFRRCxTQUFTQSxNQUFNQyxJQUFJLEtBQUtBO0FBQ3BDO0FBQ0E7O0NBRUMsR0FDTSxTQUFTQyxnQkFBZ0JGLEtBQUs7SUFDakMsT0FBT0QsUUFBUUMsT0FBTztBQUMxQjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVNHLFVBQVVDLE9BQU8sRUFBRUgsSUFBSSxFQUFFSSxJQUFJO0lBQ3pDLElBQUlDLGVBQWVGO0lBQ25CO1FBQ0ksTUFBTUcsVUFBVSxFQUFFO1FBQ2xCLElBQUlGLE1BQU07WUFDTixJQUFJLGFBQWFBLFFBQVEsVUFBVUEsUUFBUSxVQUFVQSxNQUFNO2dCQUN2RCxNQUFNLElBQUlHLE1BQU0sQ0FBQyx1Q0FBdUMsRUFBRTVCLFVBQVV5QixNQUFNLENBQUM7WUFDL0U7WUFDQSxJQUFLLE1BQU1JLE9BQU9KLEtBQU07Z0JBQ3BCLElBQUlJLFFBQVEsZ0JBQWdCO29CQUN4QjtnQkFDSjtnQkFDQSxNQUFNNUIsUUFBU3dCLElBQUksQ0FBQ0ksSUFBSTtnQkFDeEIsdUJBQXVCO2dCQUN2QkYsUUFBUUcsSUFBSSxDQUFDRCxNQUFNLE1BQU03QixVQUFVQztZQUNuQyx3Q0FBd0M7WUFDeEMsb0RBQW9EO1lBQ3BELDBFQUEwRTtZQUMxRSxtQkFBbUI7WUFDdkI7UUFDSjtRQUNBMEIsUUFBUUcsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFVCxLQUFLLENBQUM7UUFDM0JNLFFBQVFHLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRWhDLGdEQUFPQSxDQUFDLENBQUM7UUFDakMsSUFBSTZCLFFBQVFqQixNQUFNLEVBQUU7WUFDaEJjLFdBQVcsT0FBT0csUUFBUXRCLElBQUksQ0FBQyxRQUFRO1FBQzNDO0lBQ0o7SUFDQSxJQUFJZTtJQUNKLE9BQVFDO1FBQ0osS0FBSztZQUNERCxRQUFRLElBQUlXLFVBQVVQO1lBQ3RCO1FBQ0osS0FBSztRQUNMLEtBQUs7WUFDREosUUFBUSxJQUFJWSxXQUFXUjtZQUN2QjtRQUNKO1lBQ0lKLFFBQVEsSUFBSVEsTUFBTUo7SUFDMUI7SUFDQXpCLGdFQUFnQkEsQ0FBQ3FCLE9BQU87UUFBRUM7SUFBSztJQUMvQixJQUFJSSxNQUFNO1FBQ05ULE9BQU9pQixNQUFNLENBQUNiLE9BQU9LO0lBQ3pCO0lBQ0EsSUFBSUwsTUFBTU0sWUFBWSxJQUFJLE1BQU07UUFDNUIzQixnRUFBZ0JBLENBQUNxQixPQUFPO1lBQUVNO1FBQWE7SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTYyxPQUFPQyxLQUFLLEVBQUVYLE9BQU8sRUFBRUgsSUFBSSxFQUFFSSxJQUFJO0lBQzdDLElBQUksQ0FBQ1UsT0FBTztRQUNSLE1BQU1aLFVBQVVDLFNBQVNILE1BQU1JO0lBQ25DO0FBQ0o7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxlQUFlRCxLQUFLLEVBQUVYLE9BQU8sRUFBRWEsSUFBSSxFQUFFcEMsS0FBSztJQUN0RGlDLE9BQU9DLE9BQU9YLFNBQVMsb0JBQW9CO1FBQUVjLFVBQVVEO1FBQU1wQyxPQUFPQTtJQUFNO0FBQzlFO0FBQ08sU0FBU3NDLG9CQUFvQkMsS0FBSyxFQUFFQyxhQUFhLEVBQUVqQixPQUFPO0lBQzdELElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVTtJQUNkO0lBQ0EsSUFBSUEsU0FBUztRQUNUQSxVQUFVLE9BQU9BO0lBQ3JCO0lBQ0FVLE9BQU9NLFNBQVNDLGVBQWUscUJBQXFCakIsU0FBUyxvQkFBb0I7UUFDN0VnQixPQUFPQTtRQUNQQyxlQUFlQTtJQUNuQjtJQUNBUCxPQUFPTSxTQUFTQyxlQUFlLHVCQUF1QmpCLFNBQVMsdUJBQXVCO1FBQ2xGZ0IsT0FBT0E7UUFDUEMsZUFBZUE7SUFDbkI7QUFDSjtBQUNBLE1BQU1DLGtCQUFrQjtJQUFDO0lBQU87SUFBTztJQUFRO0NBQU8sQ0FBQ0MsTUFBTSxDQUFDLENBQUNDLE9BQU9DO0lBQ2xFLElBQUk7UUFDQSw2QkFBNkI7UUFDN0IsbUJBQW1CLEdBQ25CLElBQUksT0FBT0MsU0FBUyxDQUFDRCxVQUFVLFFBQVE7WUFDbkMsTUFBTSxJQUFJakIsTUFBTTtRQUNwQjs7UUFFQSxrQkFBa0IsR0FDbEIsSUFBSWlCLFNBQVMsT0FBTztZQUNoQixNQUFNVixRQUFRWSxPQUFPQyxZQUFZLENBQUMsTUFBTUYsU0FBUyxDQUFDO1lBQ2xELE1BQU1HLFdBQVdGLE9BQU9DLFlBQVksQ0FBQyxNQUFNO1lBQzNDLG1CQUFtQixHQUNuQixJQUFJYixVQUFVYyxVQUFVO2dCQUNwQixNQUFNLElBQUlyQixNQUFNO1lBQ3BCO1FBQ0Esa0JBQWtCLEdBQ3RCO1FBQ0FnQixNQUFNZCxJQUFJLENBQUNlO0lBQ2YsRUFDQSxPQUFPekIsT0FBTyxDQUFFO0lBQ2hCLE9BQU93QjtBQUNYLEdBQUcsRUFBRTtBQUNMOztDQUVDLEdBQ00sU0FBU00sZ0JBQWdCTCxJQUFJO0lBQ2hDWCxPQUFPUSxnQkFBZ0JTLE9BQU8sQ0FBQ04sU0FBUyxHQUFHLCtDQUErQyx5QkFBeUI7UUFDL0dPLFdBQVc7UUFBOEIzQixNQUFNO1lBQUVvQjtRQUFLO0lBQzFEO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNRLGNBQWNDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxTQUFTO0lBQ3RELElBQUlBLGFBQWEsTUFBTTtRQUNuQkEsWUFBWTtJQUNoQjtJQUNBLElBQUlGLGVBQWVDLE9BQU87UUFDdEIsSUFBSUUsU0FBU0QsV0FBV0osWUFBWTtRQUNwQyxJQUFJSSxXQUFXO1lBQ1hDLFVBQVU7WUFDVkwsYUFBYSxNQUFNSTtRQUN2QjtRQUNBdEIsT0FBTyxPQUFPLENBQUMseUJBQXlCLEVBQUV1QixPQUFPLGFBQWEsQ0FBQyxFQUFFLHlCQUF5QjtZQUN0Rkw7UUFDSjtJQUNKO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9lcnJvcnMuanM/ODY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBBbGwgZXJyb3JzIGluIGV0aGVycyBpbmNsdWRlIHByb3BlcnRpZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGJvdGhcbiAqICBodW1hbi1yZWFkYWJsZSAoaS5lLiBgYC5tZXNzYWdlYGApIGFuZCBtYWNoaW5lLXJlYWRhYmxlIChpLmUuIGBgLmNvZGVgYCkuXG4gKlxuICogIFRoZSBbW2lzRXJyb3JdXSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjaGVjayB0aGUgZXJyb3IgYGBjb2RlYGAgYW5kXG4gKiAgcHJvdmlkZSBhIHR5cGUgZ3VhcmQgZm9yIHRoZSBwcm9wZXJ0aWVzIHByZXNlbnQgb24gdGhhdCBlcnJvciBpbnRlcmZhY2UuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3V0aWxzL2Vycm9yczpFcnJvcnMgIFthYm91dC1lcnJvcnNdXG4gKi9cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcChzdHJpbmdpZnkpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldICYgMHhmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoayl9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSl9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZpcm9ubWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyb3IoZXJyb3IsIGNvZGUpIHtcbiAgICByZXR1cm4gKGVycm9yICYmIGVycm9yLmNvZGUgPT09IGNvZGUpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikge1xuICAgIHJldHVybiBpc0Vycm9yKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIG5ldyBFcnJvciBjb25maWd1cmVkIHRvIHRoZSBmb3JtYXQgZXRoZXJzIGVtaXRzIGVycm9ycywgd2l0aFxuICogIHRoZSAlJW1lc3NhZ2UlJSwgW1thcGk6RXJyb3JDb2RlXV0gJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogIGZvciB0aGUgY29ycmVzcG9uZGluZyBFdGhlcnNFcnJvci5cbiAqXG4gKiAgRWFjaCBlcnJvciBpbiBldGhlcnMgaW5jbHVkZXMgdGhlIHZlcnNpb24gb2YgZXRoZXJzLCBhXG4gKiAgbWFjaGluZS1yZWFkYWJsZSBbW0Vycm9yQ29kZV1dLCBhbmQgZGVwZW5kaW5nIG9uICUlY29kZSUlLCBhZGRpdGlvbmFsXG4gKiAgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBhbHNvIGluY2x1ZGUgdGhlICUlbWVzc2FnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkZGl0aW9uYWwgcHJvcGVydGllcywgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgbGV0IHNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gW107XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gaW5mbyB8fCBcImNvZGVcIiBpbiBpbmZvIHx8IFwibmFtZVwiIGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlIHdpbGwgb3ZlcndyaXRlIHBvcHVsYXRlZCB2YWx1ZXM6ICR7c3RyaW5naWZ5KGluZm8pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwic2hvcnRNZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGluZm9ba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBzdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNTU1cIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChrZXkgKyBcIj1bY291bGQgbm90IHNlcmlhbGl6ZSBvYmplY3RdXCIpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBkZXRhaWxzLnB1c2goYHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBjb2RlIH0pO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc2hvcnRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogIFRocm93cyBhbiBFdGhlcnNFcnJvciB3aXRoICUlbWVzc2FnZSUlLCAlJWNvZGUlJSBhbmQgYWRkaXRpb25hbCBlcnJvclxuICogICUlaW5mbyUlIHdoZW4gJSVjaGVjayUlIGlzIGZhbHNpc2guLlxuICpcbiAqICBAc2VlIFtbYXBpOm1ha2VFcnJvcl1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIGNvZGUsIGluZm8pIHtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgIHRocm93IG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBpbmZvKTtcbiAgICB9XG59XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50KGNoZWNrLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGFzc2VydChjaGVjaywgbWVzc2FnZSwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgfVxuICAgIGFzc2VydChjb3VudCA+PSBleHBlY3RlZENvdW50LCBcIm1pc3NpbmcgYXJndWVtbnRcIiArIG1lc3NhZ2UsIFwiTUlTU0lOR19BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xuICAgIGFzc2VydChjb3VudCA8PSBleHBlY3RlZENvdW50LCBcInRvbyBtYW55IGFyZ3VlbW50c1wiICsgbWVzc2FnZSwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHtcbiAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgfSk7XG59XG5jb25zdCBfbm9ybWFsaXplRm9ybXMgPSBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5yZWR1Y2UoKGFjY3VtLCBmb3JtKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2VuZXJhbCB0ZXN0IGZvciBub3JtYWxpemVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoZm9ybSA9PT0gXCJORkRcIikge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2sgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICBhY2N1bS5wdXNoKGZvcm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBhY2N1bTtcbn0sIFtdKTtcbi8qKlxuICogIFRocm93cyBpZiB0aGUgbm9ybWFsaXphdGlvbiAlJWZvcm0lJSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm9ybWFsaXplKGZvcm0pIHtcbiAgICBhc3NlcnQoX25vcm1hbGl6ZUZvcm1zLmluZGV4T2YoZm9ybSkgPj0gMCwgXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGluZm86IHsgZm9ybSB9XG4gICAgfSk7XG59XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcml2YXRlKGdpdmVuR3VhcmQsIGd1YXJkLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGdpdmVuR3VhcmQgIT09IGd1YXJkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBjbGFzc05hbWUsIG9wZXJhdGlvbiA9IFwibmV3XCI7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSBcIi5cIjtcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBwcml2YXRlIGNvbnN0cnVjdG9yOyB1c2UgJHttZXRob2R9ZnJvbSogbWV0aG9kc2AsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJkZWZpbmVQcm9wZXJ0aWVzIiwic3RyaW5naWZ5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJqb2luIiwiVWludDhBcnJheSIsIkhFWCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJ0b0pTT04iLCJ0b1N0cmluZyIsIkJpZ0ludCIsIkpTT04iLCJrZXlzIiwiT2JqZWN0Iiwic29ydCIsImsiLCJpc0Vycm9yIiwiZXJyb3IiLCJjb2RlIiwiaXNDYWxsRXhjZXB0aW9uIiwibWFrZUVycm9yIiwibWVzc2FnZSIsImluZm8iLCJzaG9ydE1lc3NhZ2UiLCJkZXRhaWxzIiwiRXJyb3IiLCJrZXkiLCJwdXNoIiwiVHlwZUVycm9yIiwiUmFuZ2VFcnJvciIsImFzc2lnbiIsImFzc2VydCIsImNoZWNrIiwiYXNzZXJ0QXJndW1lbnQiLCJuYW1lIiwiYXJndW1lbnQiLCJhc3NlcnRBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiX25vcm1hbGl6ZUZvcm1zIiwicmVkdWNlIiwiYWNjdW0iLCJmb3JtIiwibm9ybWFsaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhwZWN0ZWQiLCJhc3NlcnROb3JtYWxpemUiLCJpbmRleE9mIiwib3BlcmF0aW9uIiwiYXNzZXJ0UHJpdmF0ZSIsImdpdmVuR3VhcmQiLCJndWFyZCIsImNsYXNzTmFtZSIsIm1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ \n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ2tEO0FBQ25EOzs7O0NBSUMsR0FDTSxNQUFNQztJQVNULENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7S0FHQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVGLFFBQVEsRUFBRUcsTUFBTSxDQUFFO1FBQ25DLElBQUksQ0FBQyxDQUFDSCxRQUFRLEdBQUdBO1FBQ2pCRixnRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVJO1lBQVNDO1FBQU87SUFDN0M7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGlCQUFpQjtRQUNuQixJQUFJLElBQUksQ0FBQyxDQUFDSixRQUFRLElBQUksTUFBTTtZQUN4QjtRQUNKO1FBQ0EsTUFBTSxJQUFJLENBQUNFLE9BQU8sQ0FBQ0csR0FBRyxDQUFDLElBQUksQ0FBQ0YsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQ3REO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9ldmVudHMuanM/NzMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBFdmVudHMgYWxsb3cgZm9yIGFwcGxpY2F0aW9ucyB0byB1c2UgdGhlIG9ic2VydmVyIHBhdHRlcm4sIHdoaWNoXG4gKiAgYWxsb3dzIHN1YnNjcmliaW5nIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgb3V0c2lkZSB0aGUgbm9ybWFsXG4gKiAgZXhlY3V0aW9uIHBhdGhzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2V2ZW50czpFdmVudHMgIFthYm91dC1ldmVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG4vKipcbiAqICBXaGVuIGFuIFtbRXZlbnRFbWl0dGVyYWJsZV1dIHRyaWdnZXJzIGEgW1tMaXN0ZW5lcl1dLCB0aGVcbiAqICBjYWxsYmFjayBhbHdheXMgYWhhcyBvbmUgYWRkaXRpb25hbCBhcmd1bWVudCBwYXNzZWQsIHdoaWNoIGlzXG4gKiAgYW4gKipFdmVudFBheWxvYWQqKi5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBmaWx0ZXIuXG4gICAgICovXG4gICAgZmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgKipFdmVudEVtaXR0ZXJhYmxlKiouXG4gICAgICovXG4gICAgZW1pdHRlcjtcbiAgICAjbGlzdGVuZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkV2ZW50UGF5bG9hZCoqIGZvciAlJWVtaXR0ZXIlJSB3aXRoXG4gICAgICogIHRoZSAlJWxpc3RlbmVyJSUgYW5kIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXIsIGxpc3RlbmVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGVtaXR0ZXIsIGZpbHRlciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVucmVnaXN0ZXIgdGhlIHRyaWdnZXJlZCBsaXN0ZW5lciBmb3IgZnV0dXJlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZmlsdGVyLCB0aGlzLiNsaXN0ZW5lcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiRXZlbnRQYXlsb2FkIiwibGlzdGVuZXIiLCJjb25zdHJ1Y3RvciIsImVtaXR0ZXIiLCJmaWx0ZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fetch.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchCancelSignal: () => (/* binding */ FetchCancelSignal),\n/* harmony export */   FetchRequest: () => (/* binding */ FetchRequest),\n/* harmony export */   FetchResponse: () => (/* binding */ FetchResponse)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/base64.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utf8_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _geturl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geturl.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js\");\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */ \n\n\n\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n        }, match[2] ? (0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.decodeBase64)(match[3]) : unpercent(match[3]));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */ function getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */ class FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request){\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, ()=>{\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners){\n                setTimeout(()=>{\n                    listener();\n                }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() {\n        return this.#cancelled;\n    }\n    checkSignal() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */ class FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URL to request.\n     */ get url() {\n        return this.#url;\n    }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */ get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof body === \"string\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof body === \"object\") {\n            this.#body = (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */ get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */ get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0,_base64_js__WEBPACK_IMPORTED_MODULE_1__.encodeBase64)((0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */ setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */ clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */ get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */ setCredentials(username, password) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */ get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */ get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */ get timeout() {\n        return this.#timeout;\n    }\n    set timeout(timeout) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */ get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */ get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */ get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */ get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */ constructor(url){\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */ setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\",\n            reason: \"timeout\",\n            request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof error.stall !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                    // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) {}\n            // Things won't get any better on another attempt; abort\n            return response;\n        } else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof error.stall !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */ send() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.send\"\n        });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */ cancel() {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.cancel\"\n        });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */ redirect(location) {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */ clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */ static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */ static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */ static createGetUrlFunc(options) {\n        return (0,_geturl_js__WEBPACK_IMPORTED_MODULE_0__.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */ static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */ static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n;\n/**\n *  The response for a FetchRequest.\n */ class FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */ get statusCode() {\n        return this.#statusCode;\n    }\n    /**\n     *  The response status message.\n     */ get statusMessage() {\n        return this.#statusMessage;\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */ get headers() {\n        return Object.assign({}, this.#headers);\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */ get body() {\n        return this.#body == null ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */ get bodyText() {\n        try {\n            return this.#body == null ? \"\" : (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(this.#body);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */ get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request){\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k)=>{\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = body == null ? null : new Uint8Array(body);\n        this.#request = request || null;\n        this.#error = {\n            message: \"\"\n        };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */ makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = {\n            message,\n            error\n        };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */ throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_5__.defineProperties)(error, {\n            stall,\n            throttle: true\n        });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true if the response has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The request made for this response.\n     */ get request() {\n        return this.#request;\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */ ok() {\n        return this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */ assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.assert)(false, message, \"SERVER_ERROR\", {\n            request: this.request || \"unknown request\",\n            response: this,\n            error\n        });\n    }\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction unpercent(value) {\n    return (0,_utf8_js__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUN3RDtBQUNyQjtBQUNpQjtBQUNGO0FBQ0c7QUFDWDtBQUMzQyxNQUFNUyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0Qiw2Q0FBNkM7QUFDN0MsSUFBSUMsb0JBQW9CSCx3REFBWUE7QUFDcEMsTUFBTUksU0FBUyxJQUFJQyxPQUFPLG1DQUFtQztBQUM3RCxNQUFNQyxTQUFTLElBQUlELE9BQU8seUJBQTBCO0FBQ3BELDBDQUEwQztBQUMxQyxJQUFJRSxTQUFTO0FBQ2IsNkVBQTZFO0FBQzdFLGVBQWVDLGdCQUFnQkMsR0FBRyxFQUFFQyxNQUFNO0lBQ3RDLElBQUk7UUFDQSxNQUFNQyxRQUFRRixJQUFJRSxLQUFLLENBQUNQO1FBQ3hCLElBQUksQ0FBQ08sT0FBTztZQUNSLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSUMsY0FBYyxLQUFLLE1BQU07WUFDaEMsZ0JBQWlCRixLQUFLLENBQUMsRUFBRSxJQUFJO1FBQ2pDLEdBQUlBLEtBQUssQ0FBQyxFQUFFLEdBQUduQix3REFBWUEsQ0FBQ21CLEtBQUssQ0FBQyxFQUFFLElBQUlHLFVBQVVILEtBQUssQ0FBQyxFQUFFO0lBQzlELEVBQ0EsT0FBT0ksT0FBTztRQUNWLE9BQU8sSUFBSUYsY0FBYyxLQUFLLG1DQUFtQyxDQUFDLEdBQUcsTUFBTSxJQUFJRyxhQUFhUDtJQUNoRztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU1EsbUJBQW1CQyxPQUFPO0lBQy9CLGVBQWVDLFlBQVlWLEdBQUcsRUFBRUMsTUFBTTtRQUNsQyxJQUFJO1lBQ0EsTUFBTUMsUUFBUUYsSUFBSUUsS0FBSyxDQUFDTDtZQUN4QixJQUFJLENBQUNLLE9BQU87Z0JBQ1IsTUFBTSxJQUFJQyxNQUFNO1lBQ3BCO1lBQ0EsT0FBTyxJ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Q0FBQyxDQUFDM0gsS0FBSyxDQUFDdUgsT0FBTyxLQUFLLE1BQU0sSUFBSSxDQUFDL0IsVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDQSxVQUFVLEdBQUc7SUFDdEY7SUFDQTs7S0FFQyxHQUNERixXQUFXO1FBQ1AsSUFBSSxJQUFJLENBQUNxQyxFQUFFLElBQUk7WUFDWDtRQUNKO1FBQ0EsSUFBSSxFQUFFSixPQUFPLEVBQUV2SCxLQUFLLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQ0EsS0FBSztRQUNwQyxJQUFJdUgsWUFBWSxJQUFJO1lBQ2hCQSxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDL0IsVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNDLGFBQWEsQ0FBQyxDQUFDO1FBQ3hFO1FBQ0E3RyxrREFBTUEsQ0FBQyxPQUFPMkksU0FBUyxnQkFBZ0I7WUFDbkMzRyxTQUFVLElBQUksQ0FBQ0EsT0FBTyxJQUFJO1lBQW9Cd0UsVUFBVSxJQUFJO1lBQUVwRjtRQUNsRTtJQUNKO0FBQ0o7QUFDQSxTQUFTNEU7SUFBWSxPQUFPLElBQUtnRCxPQUFRaEQsT0FBTztBQUFJO0FBQ3BELFNBQVM3RSxVQUFVaUQsS0FBSztJQUNwQixPQUFPakUscURBQVdBLENBQUNpRSxNQUFNNkUsT0FBTyxDQUFDLHlCQUF5QixDQUFDQyxLQUFLQztRQUM1RCxPQUFPOUYsT0FBTytGLFlBQVksQ0FBQy9CLFNBQVM4QixNQUFNO0lBQzlDO0FBQ0o7QUFDQSxTQUFTakQsS0FBS04sS0FBSztJQUNmLE9BQU8sSUFBSXlELFFBQVEsQ0FBQ0MsVUFBWW5ILFdBQVdtSCxTQUFTMUQ7QUFDeEQsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9mZXRjaC5qcz9lMWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEZldGNoaW5nIGNvbnRlbnQgZnJvbSB0aGUgd2ViIGlzIGVudmlyb25tZW50LXNwZWNpZmljLCBzbyBFdGhlcnNcbiAqICBwcm92aWRlcyBhbiBhYnN0cmFjdGlvbiB0aGF0IGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJpZXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRpY2F0aW9uLCBldGMuXG4gKlxuICogIEl0IGFsc28gaGFuZGxlcyBjb21tb24gZ2F0ZXdheXMsIHN1Y2ggYXMgSVBGUyBhbmQgZGF0YSBVUklzLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL3V0aWxzL2ZldGNoaW5nOkZldGNoaW5nIFdlYiBDb250ZW50ICBbYWJvdXQtZmV0Y2hdXG4gKi9cbmltcG9ydCB7IGRlY29kZUJhc2U2NCwgZW5jb2RlQmFzZTY0IH0gZnJvbSBcIi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBoZXhsaWZ5IH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gXCIuL3Byb3BlcnRpZXMuanNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVHZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmwuanNcIjtcbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDEyO1xuY29uc3QgU0xPVF9JTlRFUlZBTCA9IDI1MDtcbi8vIFRoZSBnbG9iYWwgRmV0Y2hHZXRVcmxGdW5jIGltcGxlbWVudGF0aW9uLlxubGV0IGRlZmF1bHRHZXRVcmxGdW5jID0gY3JlYXRlR2V0VXJsKCk7XG5jb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG5jb25zdCByZUlwZnMgPSBuZXcgUmVnRXhwKFwiXmlwZnM6L1xcLyhpcGZzLyk/KC4qKSRcIiwgXCJpXCIpO1xuLy8gSWYgbG9ja2VkLCBuZXcgR2F0ZXdheXMgY2Fubm90IGJlIGFkZGVkXG5sZXQgbG9ja2VkID0gZmFsc2U7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jhc2ljc19vZl9IVFRQL0RhdGFfVVJMc1xuYXN5bmMgZnVuY3Rpb24gZGF0YUdhdGV3YXlGdW5jKHVybCwgc2lnbmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVEYXRhKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSgyMDAsIFwiT0tcIiwge1xuICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogKG1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSxcbiAgICAgICAgfSwgKG1hdGNoWzJdID8gZGVjb2RlQmFzZTY0KG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaENhbmNlbFNpZ25hbCB7XG4gICAgI2xpc3RlbmVycztcbiAgICAjY2FuY2VsbGVkO1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBmZXRjaFNpZ25hbHMuc2V0KHJlcXVlc3QsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgbGlzdGVuZXIoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy4jY2FuY2VsbGVkLCBcInNpbmdhbCBhbHJlYWR5IGNhbmNlbGxlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZmV0Y2hDYW5jZWxTaWduYWwuYWRkQ2FuY2VsTGlzdGVuZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkgeyByZXR1cm4gdGhpcy4jY2FuY2VsbGVkOyB9XG4gICAgY2hlY2tTaWduYWwoKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0IHtcbiAgICAjYWxsb3dJbnNlY3VyZTtcbiAgICAjZ3ppcDtcbiAgICAjaGVhZGVycztcbiAgICAjbWV0aG9kO1xuICAgICN0aW1lb3V0O1xuICAgICN1cmw7XG4gICAgI2JvZHk7XG4gICAgI2JvZHlUeXBlO1xuICAgICNjcmVkcztcbiAgICAvLyBIb29rc1xuICAgICNwcmVmbGlnaHQ7XG4gICAgI3Byb2Nlc3M7XG4gICAgI3JldHJ5O1xuICAgICNzaWduYWw7XG4gICAgI3Rocm90dGxlO1xuICAgICNnZXRVcmxGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmV0Y2ggVVJMIHRvIHJlcXVlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKS5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5zaWMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluc2ljIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSB0b1V0ZjhCeXRlcyhKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaGFuZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHtlbmNvZGVCYXNlNjQodG9VdGY4Qnl0ZXModGhpcy4jY3JlZHMpKX1gO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJnemlwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCAmJiB0aGlzLiNib2R5VHlwZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHRoaXMuI2JvZHlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IFN0cmluZyh0aGlzLmJvZHkubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGhlYWRlciBmb3IgJSVrZXklJSB0byAlJXZhbHVlJSUuIEFsbCB2YWx1ZXMgYXJlIGNvZXJjZWRcbiAgICAgKiAgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVyc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDbGVhciBhbGwgaGVhZGVycywgcmVzZXR0aW5nIGFsbCBpbnRyaW5zaWMgaGVhZGVycy5cbiAgICAgKi9cbiAgICBjbGVhckhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgc2VudCBmb3IgdGhlIGBgQXV0aG9yaXphdGlvbmBgIGhlYWRlci5cbiAgICAgKlxuICAgICAqICBUbyBzZXQgdGhlIGNyZWRlbnRpYWxzLCB1c2UgdGhlIGBgc2V0Q3JlZGVudGlhbHNgYCBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3JlZHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgYW4gYGBBdXRob3JpemF0aW9uYGAgZm9yICUldXNlcm5hbWUlJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyh1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIXVzZXJuYW1lLm1hdGNoKC86LyksIFwiaW52YWxpZCBiYXNpYyBhdXRoZW50aWNhdGlvbiB1c2VybmFtZVwiLCBcInVzZXJuYW1lXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgdGhpcy4jY3JlZHMgPSBgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5hYmxlIGFuZCByZXF1ZXN0IGd6aXAtZW5jb2RlZCByZXNwb25zZXMuIFRoZSByZXNwb25zZSB3aWxsXG4gICAgICogIGF1dG9tYXRpY2FsbHkgYmUgZGVjb21wcmVzc2VkLiAvLyhkZWZhdWx0OiB0cnVlKS8vXG4gICAgICovXG4gICAgZ2V0IGFsbG93R3ppcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2d6aXA7XG4gICAgfVxuICAgIHNldCBhbGxvd0d6aXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ3ppcCA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBbGxvdyBgYEF1dGhlbnRpY2F0aW9uYGAgY3JlZGVudGlhbHMgdG8gYmUgc2VudCBvdmVyIGluc2VjdXJlXG4gICAgICogIGNoYW5uZWxzLiAvLyhkZWZhdWx0OiBmYWxzZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2FsbG93SW5zZWN1cmU7XG4gICAgfVxuICAgIHNldCBhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy4jYWxsb3dJbnNlY3VyZSA9ICEhdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhIGNvbXBsZXRlIHJlc3BvbnNlLlxuICAgICAqICAvLyhkZWZhdWx0OiA1IG1pbnV0ZXMpLy9cbiAgICAgKi9cbiAgICBnZXQgdGltZW91dCgpIHsgcmV0dXJuIHRoaXMuI3RpbWVvdXQ7IH1cbiAgICBzZXQgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyBoZXhsaWZ5KHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoZ2V0VGltZSgpIDw9IGV4cGlyZXMsIFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3Quc2VuZFwiLCByZWFzb246IFwidGltZW91dFwiLCByZXF1ZXN0OiBfcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgd2FpdChkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gKHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIFByb2Nlc3MgYW55IEdhdGV3YXlzXG4gICAgICAgIGlmIChzY2hlbWUgaW4gR2F0ZXdheXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEdhdGV3YXlzW3NjaGVtZV0ocmVxLnVybCwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZldGNoUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGUgPT0gbnVsbCB8fCB0eXBlb2YgKGVycm9yLnN0YWxsKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgYSBwcmVmbGlnaHQgZnVuY3Rpb247IHVwZGF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5wcmVmbGlnaHRGdW5jKSB7XG4gICAgICAgICAgICByZXEgPSBhd2FpdCB0aGlzLnByZWZsaWdodEZ1bmMocmVxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5nZXRVcmxGdW5jKHJlcSwgY2hlY2tTaWduYWwoX3JlcXVlc3QuI3NpZ25hbCkpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZShyZXNwLnN0YXR1c0NvZGUsIHJlc3Auc3RhdHVzTWVzc2FnZSwgcmVzcC5oZWFkZXJzLCByZXNwLmJvZHksIF9yZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXEucmVkaXJlY3QobG9jYXRpb24pLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCAwLCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIFRoaW5ncyB3b24ndCBnZXQgYW55IGJldHRlciBvbiBhbm90aGVyIGF0dGVtcHQ7IGFib3J0XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlGdW5jID09IG51bGwgfHwgKGF3YWl0IHRoaXMucmV0cnlGdW5jKHJlcSwgcmVzcG9uc2UsIGF0dGVtcHQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy4jdGhyb3R0bGUuc2xvdEludGVydmFsICogTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLmNsb25lKCkuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIGRlbGF5LCBfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByb2Nlc3NGdW5jKHJlcSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHByb2Nlc3Npbmc7IHRocm93IGEgNXh4IHNlcnZlciBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1ha2VTZXJ2ZXJFcnJvcihcImVycm9yIGluIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvblwiLCBlcnJvcikuYXNzZXJ0T2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhyb3R0bGVcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGFsbCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gZXJyb3Iuc3RhbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGJ5IHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCA9PSBudWxsLCBcInJlcXVlc3QgYWxyZWFkeSBzZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZldGNoUmVxdWVzdC5zZW5kXCIgfSk7XG4gICAgICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBGZXRjaENhbmNlbFNpZ25hbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NlbmQoMCwgZ2V0VGltZSgpICsgdGhpcy50aW1lb3V0LCAwLCB0aGlzLCBuZXcgRmV0Y2hSZXNwb25zZSgwLCBcIlwiLCB7fSwgbnVsbCwgdGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FuY2VscyB0aGUgaW5mbGlnaHQgcmVzcG9uc2UsIGNhdXNpbmcgYSBgYENBTkNFTExFRGBgXG4gICAgICogIGVycm9yIHRvIGJlIHJlamVjdGVkIGZyb20gdGhlIFtbc2VuZF1dLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGlvbnNcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhdGlvbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgcmVkaXJlY3Rpbmc6XG4gICAgICAgIC8vIC0gbm9uLUdFVCByZXF1ZXN0c1xuICAgICAgICAvLyAtIGRvd25ncmFkaW5nIHRoZSBzZWN1cml0eSAoZS5nLiBodHRwcyA9PiBodHRwKVxuICAgICAgICAvLyAtIHRvIG5vbi1IVFRQIChvciBub24tSFRUUFMpIHByb3RvY29scyBbdGhpcyBjb3VsZCBiZSByZWxheGVkP11cbiAgICAgICAgYXNzZXJ0KHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICBjbG9uZS4jZ2V0VXJsRnVuYyA9IHRoaXMuI2dldFVybEZ1bmM7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIExvY2tzIGFsbCBzdGF0aWMgY29uZmlndXJhdGlvbiBmb3IgZ2F0ZXdheXMgYW5kIEZldGNoR2V0VXJsRnVuY1xuICAgICAqICByZWdpc3RyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGxvY2tDb25maWcoKSB7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0R2F0ZXdheShzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHYXRld2F5KHNjaGVtZSwgZnVuYykge1xuICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGludGVyY2VwdCAke3NjaGVtZX07IHVzZSByZWdpc3RlckdldFVybGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdldFVybChnZXRVcmwpIHtcbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRHZXRVcmxGdW5jID0gZ2V0VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGdldFVybCBmdW5jdGlvbiB0aGF0IGZldGNoZXMgY29udGVudCBmcm9tIEhUVFAgYW5kXG4gICAgICogIEhUVFBTIFVSTHMuXG4gICAgICpcbiAgICAgKiAgVGhlIGF2YWlsYWJsZSAlJW9wdGlvbnMlJSBhcmUgZGVwZW5kZW50IG9uIHRoZSBwbGF0Zm9ybVxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IGlzIHVzZWZ1bFxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcbiAgICAgKiAgY29udGVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVHZXRVcmwob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gXCJmZXRjaFwiIGRhdGEgVVJJcy5cbiAgICAgKlxuICAgICAqICBOb3RlIHRoYXQgdGhpcyBpcyBhdXRvbWF0aWNhbGx5IGRvbmUgaW50ZXJuYWxseSB0byBzdXBwb3J0XG4gICAgICogIGRhdGEgVVJJcywgc28gaXQgaXMgbm90IG5lY2Vzc2FyeSB0byByZWdpc3RlciBpdC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vdCBnZW5lcmFsbHkgc29tZXRoaW5nIHRoYXQgaXMgbmVlZGVkLCBidXQgbWF5XG4gICAgICogIGJlIHVzZWZ1bCBpbiBhIHdyYXBwZXIgdG8gcGVyZm9tIGN1c3RvbSBkYXRhIFVSSSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEYXRhR2F0ZXdheSgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFHYXRld2F5RnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZmV0Y2ggSVBGUyAodW52YWxpZGF0ZWQpIGZyb21cbiAgICAgKiAgYSBjdXN0b20gZ2F0ZXdheSBiYXNlVXJsLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0IElQRlMgZ2F0ZXdheSB1c2VkIGludGVybmFsbHkgaXNcbiAgICAgKiAgYGBcImh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy9cImBgLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCkge1xuICAgICAgICByZXR1cm4gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpO1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFRoZSByZXNwb25zZSBmb3IgYSBGZXRjaFJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlc3BvbnNlIHtcbiAgICAjc3RhdHVzQ29kZTtcbiAgICAjc3RhdHVzTWVzc2FnZTtcbiAgICAjaGVhZGVycztcbiAgICAjYm9keTtcbiAgICAjcmVxdWVzdDtcbiAgICAjZXJyb3I7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVzcG9uc2Ugc3RhdHVzPSR7dGhpcy5zdGF0dXNDb2RlfSBib2R5PSR7dGhpcy4jYm9keSA/IGhleGxpZnkodGhpcy4jYm9keSkgOiBcIm51bGxcIn0+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzQ29kZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c0NvZGU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNNZXNzYWdlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzTWVzc2FnZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgaGVhZGVycy4gQWxsIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgb3IgYGBudWxsYGAgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5IGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcsIG9yIHRoZSBlbXB0eVxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIFVURi04IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGJvZHlUZXh0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6IHRvVXRmOFN0cmluZyh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBVVEYtOCBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keVRleHRcIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIGJvZHksIGRlY29kZWQgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqICBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGJvZHkgaXMgaW52YWxpZCBKU09OLWVuY29kZWQgZGF0YVxuICAgICAqICBvciBpZiB0aGVyZSB3YXMgbm8gYm9keS5cbiAgICAgKi9cbiAgICBnZXQgYm9keUpzb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmJvZHlUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJyZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiYm9keUpzb25cIiwgaW5mbzogeyByZXNwb25zZTogdGhpcyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzLCBib2R5LCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuI3N0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLiNzdGF0dXNNZXNzYWdlID0gc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLnJlZHVjZSgoYWNjdW0sIGspID0+IHtcbiAgICAgICAgICAgIGFjY3VtW2sudG9Mb3dlckNhc2UoKV0gPSBTdHJpbmcoaGVhZGVyc1trXSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy4jYm9keSA9ICgoYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheShib2R5KSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSAocmVxdWVzdCB8fCBudWxsKTtcbiAgICAgICAgdGhpcy4jZXJyb3IgPSB7IG1lc3NhZ2U6IFwiXCIgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIFJlc3BvbnNlIHdpdGggbWF0Y2hpbmcgaGVhZGVycyBhbmQgYm9keSwgYnV0IHdpdGhcbiAgICAgKiAgYW4gZXJyb3Igc3RhdHVzIGNvZGUgKGkuZS4gNTk5KSBhbmQgJSVtZXNzYWdlJSUgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJWVycm9yJSUuXG4gICAgICovXG4gICAgbWFrZVNlcnZlckVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgIGxldCBzdGF0dXNNZXNzYWdlO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfWA7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXNNZXNzYWdlID0gYENMSUVOVCBFU0NBTEFURUQgU0VSVkVSIEVSUk9SICgke3RoaXMuc3RhdHVzQ29kZX0gJHt0aGlzLnN0YXR1c01lc3NhZ2V9OyAke21lc3NhZ2V9KWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIHN0YXR1c01lc3NhZ2UsIHRoaXMuaGVhZGVycywgdGhpcy5ib2R5LCB0aGlzLiNyZXF1ZXN0IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3BvbnNlLiNlcnJvciA9IHsgbWVzc2FnZSwgZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgY2FsbGVkIHdpdGhpbiBhIFtyZXF1ZXN0LnByb2Nlc3NGdW5jXShGZXRjaFJlcXVlc3QtcHJvY2Vzc0Z1bmMpXG4gICAgICogIGNhbGwsIGNhdXNlcyB0aGUgcmVxdWVzdCB0byByZXRyeSBhcyBpZiB0aHJvdHRsZWQgZm9yICUlc3RhbGwlJVxuICAgICAqICBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGhyb3dUaHJvdHRsZUVycm9yKG1lc3NhZ2UsIHN0YWxsKSB7XG4gICAgICAgIGlmIChzdGFsbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFsbCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcihzdGFsbCkgJiYgc3RhbGwgPj0gMCwgXCJpbnZhbGlkIHN0YWxsIHRpbWVvdXRcIiwgXCJzdGFsbFwiLCBzdGFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc3RhbGwsIHRocm90dGxlOiB0cnVlIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIHZhbHVlIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlcXVlc3QgbWFkZSBmb3IgdGhpcyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHsgcmV0dXJuIHRoaXMuI3JlcXVlc3Q7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxuICAgICAqL1xuICAgIG9rKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cbiAgICAgKi9cbiAgICBhc3NlcnRPaygpIHtcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgc2VydmVyIHJlc3BvbnNlICR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgbWVzc2FnZSwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogKHRoaXMucmVxdWVzdCB8fCBcInVua25vd24gcmVxdWVzdFwiKSwgcmVzcG9uc2U6IHRoaXMsIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiB1bnBlcmNlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUucmVwbGFjZSgvJShbMC05YS1mXVswLTlhLWZdKS9naSwgKGFsbCwgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWNvZGVCYXNlNjQiLCJlbmNvZGVCYXNlNjQiLCJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidG9VdGY4Qnl0ZXMiLCJ0b1V0ZjhTdHJpbmciLCJjcmVhdGVHZXRVcmwiLCJNQVhfQVRURU1QVFMiLCJTTE9UX0lOVEVSVkFMIiwiZGVmYXVsdEdldFVybEZ1bmMiLCJyZURhdGEiLCJSZWdFeHAiLCJyZUlwZnMiLCJsb2NrZWQiLCJkYXRhR2F0ZXdheUZ1bmMiLCJ1cmwiLCJzaWduYWwiLCJtYXRjaCIsIkVycm9yIiwiRmV0Y2hSZXNwb25zZSIsInVucGVyY2VudCIsImVycm9yIiwiRmV0Y2hSZXF1ZXN0IiwiZ2V0SXBmc0dhdGV3YXlGdW5jIiwiYmFzZVVybCIsImdhdGV3YXlJcGZzIiwiR2F0ZXdheXMiLCJmZXRjaFNpZ25hbHMiLCJXZWFrTWFwIiwiRmV0Y2hDYW5jZWxTaWduYWwiLCJsaXN0ZW5lcnMiLCJjYW5jZWxsZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVlc3QiLCJzZXQiLCJsaXN0ZW5lciIsInNldFRpbWVvdXQiLCJhZGRMaXN0ZW5lciIsIm9wZXJhdGlvbiIsInB1c2giLCJjaGVja1NpZ25hbCIsImFsbG93SW5zZWN1cmUiLCJnemlwIiwiaGVhZGVycyIsIm1ldGhvZCIsInRpbWVvdXQiLCJib2R5IiwiYm9keVR5cGUiLCJjcmVkcyIsInByZWZsaWdodCIsInByb2Nlc3MiLCJyZXRyeSIsInRocm90dGxlIiwiZ2V0VXJsRnVuYyIsIlN0cmluZyIsIlVpbnQ4QXJyYXkiLCJ1bmRlZmluZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzQm9keSIsInRvVXBwZXJDYXNlIiwiT2JqZWN0IiwiYXNzaWduIiwiYWxsb3dHemlwIiwibGVuZ3RoIiwiZ2V0SGVhZGVyIiwia2V5IiwidG9Mb3dlckNhc2UiLCJzZXRIZWFkZXIiLCJ2YWx1ZSIsImNsZWFySGVhZGVycyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwia2V5cyIsImluZGV4IiwibmV4dCIsImRvbmUiLCJjcmVkZW50aWFscyIsInNldENyZWRlbnRpYWxzIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiIsInByZWZsaWdodEZ1bmMiLCJwcm9jZXNzRnVuYyIsInJldHJ5RnVuYyIsInNsb3RJbnRlcnZhbCIsIm1heEF0dGVtcHRzIiwidG9TdHJpbmciLCJzZXRUaHJvdHRsZVBhcmFtcyIsInBhcmFtcyIsInNlbmQiLCJhdHRlbXB0IiwiZXhwaXJlcyIsImRlbGF5IiwiX3JlcXVlc3QiLCJfcmVzcG9uc2UiLCJtYWtlU2VydmVyRXJyb3IiLCJnZXRUaW1lIiwicmVhc29uIiwid2FpdCIsInJlcSIsImNsb25lIiwic2NoZW1lIiwic3BsaXQiLCJyZXN1bHQiLCJyZXNwb25zZSIsInN0YWxsIiwiYXNzZXJ0T2siLCJyZXNwIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJsb2NhdGlvbiIsInJlZGlyZWN0IiwicmV0cnlBZnRlciIsIk1hdGgiLCJ0cnVuYyIsInJhbmRvbSIsInBvdyIsInBhcnNlSW50IiwiY2FuY2VsIiwiZ2V0IiwiY3VycmVudCIsInRhcmdldCIsImxvY2tDb25maWciLCJnZXRHYXRld2F5IiwicmVnaXN0ZXJHYXRld2F5IiwiZnVuYyIsInJlZ2lzdGVyR2V0VXJsIiwiZ2V0VXJsIiwiY3JlYXRlR2V0VXJsRnVuYyIsIm9wdGlvbnMiLCJjcmVhdGVEYXRhR2F0ZXdheSIsImNyZWF0ZUlwZnNHYXRld2F5RnVuYyIsImJvZHlUZXh0IiwiaW5mbyIsImJvZHlKc29uIiwicGFyc2UiLCJyZWR1Y2UiLCJhY2N1bSIsImsiLCJtZXNzYWdlIiwidGhyb3dUaHJvdHRsZUVycm9yIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwib2siLCJEYXRlIiwicmVwbGFjZSIsImFsbCIsImNvZGUiLCJmcm9tQ2hhckNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */ \n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile(Zeros.length < 80){\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while(result.length < decimals){\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = BN_1 << width - BN_1;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        } else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    } else {\n        const limit = BN_1 << width;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || val >= 0 && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        val = (val % limit + limit) % limit & limit - BN_1;\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof value === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof value === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n        // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = match[1] !== \"u\";\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue)=>{\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return {\n        signed,\n        width,\n        decimals,\n        name\n    };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return negative + str;\n    }\n    // Pad out to the whole component (including a whole digit)\n    while(str.length <= decimals){\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while(str[0] === \"0\" && str[1] !== \".\"){\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while(str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\"){\n        str = str.substring(0, str.length - 1);\n    }\n    return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */ class FixedNumber {\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */ constructor(guard, value, format){\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            format: format.name,\n            _value\n        });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */ get signed() {\n        return this.#format.signed;\n    }\n    /**\n     *  The number of bits available to store the value.\n     */ get width() {\n        return this.#format.width;\n    }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */ get decimals() {\n        return this.#format.decimals;\n    }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */ get value() {\n        return this.#val;\n    }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */ val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */ addUnsafe(other) {\n        return this.#add(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ add(other) {\n        return this.#add(other, \"add\");\n    }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */ subUnsafe(other) {\n        return this.#sub(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ sub(other) {\n        return this.#sub(other, \"sub\");\n    }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */ mulUnsafe(other) {\n        return this.#mul(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ mul(other) {\n        return this.#mul(other, \"mul\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */ mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % this.#tens === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ divUnsafe(other) {\n        return this.#div(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ div(other) {\n        return this.#div(other, \"div\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */ divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(other);\n        const value = this.#val * this.#tens;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % other.#val === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */ cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        } else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */ eq(other) {\n        return this.cmp(other) === 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */ lt(other) {\n        return this.cmp(other) < 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */ lte(other) {\n        return this.cmp(other) <= 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */ gt(other) {\n        return this.cmp(other) > 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */ gte(other) {\n        return this.cmp(other) >= 0;\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */ round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = value / tens * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */ isZero() {\n        return this.#val === BN_0;\n    }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */ isNegative() {\n        return this.#val < BN_0;\n    }\n    /**\n     *  Returns the string representation of %%this%%.\n     */ toString() {\n        return this._value;\n    }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */ toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */ toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */ static fromValue(_value, _decimals, _format) {\n        const decimals = _decimals == null ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\",\n                fault: \"underflow\",\n                value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */ static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = match[2] || \"0\", decimal = match[3] || \"\";\n        // Pad out the decimals\n        while(decimal.length < format.decimals){\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\",\n            fault: \"underflow\",\n            value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */ static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n} //const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n //const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n //console.log(f1.divSignal(f2));\n //const BUMP = FixedNumber.from(\"0.5\");\n //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDb0M7QUFDK0I7QUFDUTtBQUN6QjtBQUNuRCxNQUFNVSxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLE9BQU9ILE9BQU87QUFDcEIsTUFBTUksU0FBUyxDQUFDO0FBQ2hCLDhDQUE4QztBQUM5QyxJQUFJQyxRQUFRO0FBQ1osTUFBT0EsTUFBTUMsTUFBTSxHQUFHLEdBQUk7SUFDdEJELFNBQVNBO0FBQ2I7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0UsUUFBUUMsUUFBUTtJQUNyQixJQUFJQyxTQUFTSjtJQUNiLE1BQU9JLE9BQU9ILE1BQU0sR0FBR0UsU0FBVTtRQUM3QkMsVUFBVUE7SUFDZDtJQUNBLE9BQU9ULE9BQU8sTUFBTVMsT0FBT0MsU0FBUyxDQUFDLEdBQUdGO0FBQzVDO0FBQ0EsU0FBU0csV0FBV0MsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDbkMsTUFBTUMsUUFBUWYsT0FBT2EsT0FBT0UsS0FBSztJQUNqQyxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZixNQUFNQyxRQUFTZixRQUFTYSxRQUFRYjtRQUNoQ1osa0RBQU1BLENBQUN3QixVQUFVLFFBQVNGLE9BQU8sQ0FBQ0ssU0FBU0wsTUFBTUssT0FBUSxZQUFZLGlCQUFpQjtZQUNsRkMsV0FBV0o7WUFBUUssT0FBTztZQUFZQyxPQUFPUjtRQUNqRDtRQUNBLElBQUlBLE1BQU1YLE1BQU07WUFDWlcsTUFBTWpCLG1EQUFRQSxDQUFDQywrQ0FBSUEsQ0FBQ2dCLEtBQUtHLFFBQVFBO1FBQ3JDLE9BQ0s7WUFDREgsTUFBTSxDQUFDakIsbURBQVFBLENBQUNDLCtDQUFJQSxDQUFDLENBQUNnQixLQUFLRyxRQUFRQTtRQUN2QztJQUNK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Yi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanM/NDU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgZnJvbVR3b3MsIG1hc2ssIHRvQmlnSW50IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xud2hpbGUgKFplcm9zLmxlbmd0aCA8IDgwKSB7XG4gICAgWmVyb3MgKz0gWmVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChcIjFcIiArIHJlc3VsdC5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGZvcm1hdC53aWR0aCk7XG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbCA9ICgoKHZhbCAlIGxpbWl0KSArIGxpbWl0KSAlIGxpbWl0KSAmIChsaW1pdCAtIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICB9XG4gICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgbGV0IHdpZHRoID0gMTI4O1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBQYXJzZSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdpZHRoICUgOCkgPT09IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgIGFzc2VydEFyZ3VtZW50KGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGFuIHZhbHVlIHdpdGggMSBkZWNpbWFsIHBsYWNlIG1heSBzdG9yZSBhIG51bWJlciBhcyBzbWFsbFxuICogIGFzIGBgMC4xYGAsIGJ1dCB0aGUgdmFsdWUgb2YgYGAwLjEgLyAyYGAgaXMgYGAwLjA1YGAsIHdoaWNoIGNhbm5vdCBmaXRcbiAqICBpbnRvIDEgZGVjaW1hbCBwbGFjZSwgc28gdW5kZXJmbG93IG9jY3VycyB3aGljaCBtZWFucyBwcmVjaXNpb24gaXMgbG9zdFxuICogIGFuZCB0aGUgdmFsdWUgYmVjb21lcyBgYDBgYC5cbiAqXG4gKiAgU29tZSBvcGVyYXRpb25zIGhhdmUgYSBub3JtYWwgYW5kIC8vc2lnbmFsbGluZy8vIHZhcmlhbnQuIFRoZSBub3JtYWxcbiAqICB2YXJpYW50IHdpbGwgc2lsZW50bHkgaWdub3JlIHVuZGVyZmxvdywgd2hpbGUgdGhlIC8vc2lnbmFsbGluZy8vIHZhcmlhbnRcbiAqICB3aWxsIHRob3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gdW5kZXJmbG93LlxuICovXG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmb3JtYXQ7XG4gICAgI2Zvcm1hdDtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcbiAgICAjdmFsO1xuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxuICAgICN0ZW5zO1xuICAgIC8qKlxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbHVlO1xuICAgIC8vIFVzZSB0aGlzIHdoZW4gY2hhbmdpbmcgdGhpcyBmaWxlIHRvIGdldCBzb21lIHR5cGluZyBpbmZvLFxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRml4ZWROdW1iZXJcIik7XG4gICAgICAgIHRoaXMuI3ZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLiNmb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZm9ybWF0OiBmb3JtYXQubmFtZSwgX3ZhbHVlIH0pO1xuICAgICAgICB0aGlzLiN0ZW5zID0gZ2V0VGVucyhmb3JtYXQuZGVjaW1hbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdHJ1ZSwgbmVnYXRpdmUgdmFsdWVzIGFyZSBwZXJtaXR0ZWQsIG90aGVyd2lzZSBvbmx5XG4gICAgICogIHBvc2l0aXZlIHZhbHVlcyBhbmQgemVybyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBnZXQgc2lnbmVkKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LnNpZ25lZDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGJpdHMgYXZhaWxhYmxlIHRvIHN0b3JlIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQud2lkdGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpbiB0aGUgZml4ZWQtcG9pbnQgYXJpdGhtZW50IGZpZWxkLlxuICAgICAqL1xuICAgIGdldCBkZWNpbWFscygpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC5kZWNpbWFsczsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUgYXMgYW4gaW50ZWdlciwgYmFzZWQgb24gdGhlIHNtYWxsZXN0IHVuaXQgdGhlXG4gICAgICogIFtbZGVjaW1hbHNdXSBhbGxvdy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWw7IH1cbiAgICAjY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodGhpcy5mb3JtYXQgPT09IG90aGVyLmZvcm1hdCwgXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgfVxuICAgICNjaGVja1ZhbHVlKHZhbCwgc2FmZU9wKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBCaWdJbnQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAtbGltaXQgICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmcm9tVHdvcyhtYXNrKHZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAtZnJvbVR3b3MobWFzaygtdmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrZWQgPSBtYXNrKHZhbCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA9PT0gbWFza2VkKSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiA8c3RyaW5nPnNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsID0gY2hlY2tWYWx1ZSh2YWwsIHRoaXMuI2Zvcm1hdCwgc2FmZU9wKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbCwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgI2FkZChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCArIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIGFkZFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIGFkZChvdGhlcikgeyByZXR1cm4gdGhpcy4jYWRkKG90aGVyLCBcImFkZFwiKTsgfVxuICAgICNzdWIobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgLSBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3ViVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIHN1YihvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyLCBcInN1YlwiKTsgfVxuICAgICNtdWwobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSgodGhpcy4jdmFsICogby4jdmFsKSAvIHRoaXMuI3RlbnMsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUsIGlnbm9yaW5nIG92ZXJmbG93IGFuZCB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBtdWxVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bChvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyLCBcIm11bFwiKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMgb3IgaWYgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIG11bFNpZ25hbChvdGhlcikge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsICogb3RoZXIuI3ZhbDtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRoaXMuI3RlbnMpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIG11bFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gdGhpcy4jdGVucywgXCJtdWxTaWduYWxcIik7XG4gICAgfVxuICAgICNkaXYobywgc2FmZU9wKSB7XG4gICAgICAgIGFzc2VydChvLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKSAvIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2VW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3JpbmcgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuIEFcbiAgICAgKiAgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvdyBvY2N1cnMuXG4gICAgICovXG4gICAgZGl2KG90aGVyKSB7IHJldHVybiB0aGlzLiNkaXYob3RoZXIsIFwiZGl2XCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBkaXZpZGVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIHVuZGVyZmxvd1xuICAgICAqICAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZTaWduYWwob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KG90aGVyLiN2YWwgIT09IEJOXzAsIFwiZGl2aXNpb24gYnkgemVyb1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlwiLCBmYXVsdDogXCJkaXZpZGUtYnktemVyb1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICh0aGlzLiN2YWwgKiB0aGlzLiN0ZW5zKTtcbiAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xuICAgICAqICBib3RoIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnZhbHVlLCBiID0gb3RoZXIudmFsdWU7XG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbW5wYXJlXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBsYXJnZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXG4gICAgICovXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXG4gICAgICAgIGlmIChkZWNpbWFscyA+PSB0aGlzLmRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBkZWNpbWFscztcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xuICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBlcXVhbCB0byBgYDBgYC5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxuICAgICAqL1xuICAgIGlzTmVnYXRpdmUoKSB7IHJldHVybiAodGhpcy4jdmFsIDwgQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZsb2F0IGFwcHJveGltYXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAgY2FuIG9ubHkgcmV0dXJuIGFuIGFwcHJveGltYXRpb24gYW5kIG1vc3QgdmFsdWVzIHdpbGwgY29udGFpblxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcbiAgICAgKiAgaXRzIGZpZWxkIHNldCB0byAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxuICAgICAqICAlJWRlY2ltYWwlJSBwbGFjZXMgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcbiAgICAgKiAgZm9yICUlZGVjaW1hbHMlJSkgY2Fubm90IGZpdCBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93XG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUoX3ZhbHVlLCBfZGVjaW1hbHMsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6IGdldE51bWJlcihfZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoX2Zvcm1hdCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZGVjaW1hbHMgLSBmb3JtYXQuZGVjaW1hbHM7XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgICAgIGFzc2VydCgodmFsdWUgJSB0ZW5zKSA9PT0gQk5fMCwgXCJ2YWx1ZSBsb3NlcyBwcmVjaXNpb24gZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVmFsdWVcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUgLz0gdGVucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlICo9IGdldFRlbnMoLWRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbVZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSBmb3IgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSwgZWl0aGVyIGR1ZSB0byBvdmVyZmxvdyBvciB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBfdmFsdWUubWF0Y2goL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLyk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcbiAgICAgICAgd2hpbGUgKGRlY2ltYWwubGVuZ3RoIDwgZm9ybWF0LmRlY2ltYWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHByZWNpc2lvbiBpcyBzYWZlXG4gICAgICAgIGFzc2VydChkZWNpbWFsLnN1YnN0cmluZyhmb3JtYXQuZGVjaW1hbHMpLm1hdGNoKC9eMCokLyksIFwidG9vIG1hbnkgZGVjaW1hbHMgZm9yIGZvcm1hdFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21TdHJpbmdcIiwgZmF1bHQ6IFwidW5kZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSBwYWRkaW5nXG4gICAgICAgIGRlY2ltYWwgPSBkZWNpbWFsLnN1YnN0cmluZygwLCBmb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChtYXRjaFsxXSArIHdob2xlICsgZGVjaW1hbCk7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tU3RyaW5nXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uXG4gICAgICogICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUgZHVlIHRvIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnl0ZXMoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRvQmlnSW50KGdldEJ5dGVzKF92YWx1ZSwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZnJvbVR3b3ModmFsdWUsIGZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21CeXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbn1cbi8vY29uc3QgZjEgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMTIuNTZcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnN0IGYyID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjAuM1wiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc29sZS5sb2coZjEuZGl2U2lnbmFsKGYyKSk7XG4vL2NvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnRQcml2YXRlIiwiZ2V0QmlnSW50IiwiZ2V0TnVtYmVyIiwiZnJvbVR3b3MiLCJtYXNrIiwidG9CaWdJbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiQk5fTjEiLCJCaWdJbnQiLCJCTl8wIiwiQk5fMSIsIkJOXzUiLCJfZ3VhcmQiLCJaZXJvcyIsImxlbmd0aCIsImdldFRlbnMiLCJkZWNpbWFscyIsInJlc3VsdCIsInN1YnN0cmluZyIsImNoZWNrVmFsdWUiLCJ2YWwiLCJmb3JtYXQiLCJzYWZlT3AiLCJ3aWR0aCIsInNpZ25lZCIsImxpbWl0Iiwib3BlcmF0aW9uIiwiZmF1bHQiLCJ2YWx1ZSIsImdldEZvcm1hdCIsIm1hdGNoIiwicGFyc2VJbnQiLCJ2IiwiY2hlY2siLCJrZXkiLCJ0eXBlIiwiZGVmYXVsdFZhbHVlIiwibmFtZSIsIlN0cmluZyIsInRvU3RyaW5nIiwibmVnYXRpdmUiLCJzdHIiLCJpbmRleCIsIkZpeGVkTnVtYmVyIiwidGVucyIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJfdmFsdWUiLCJjaGVja0Zvcm1hdCIsIm90aGVyIiwiYWRkIiwibyIsImFkZFVuc2FmZSIsInN1YiIsInN1YlVuc2FmZSIsIm11bCIsIm11bFVuc2FmZSIsIm11bFNpZ25hbCIsImRpdiIsImRpdlVuc2FmZSIsImRpdlNpZ25hbCIsImNtcCIsImEiLCJiIiwiZGVsdGEiLCJlcSIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJmbG9vciIsImNlaWxpbmciLCJyb3VuZCIsImJ1bXAiLCJpc1plcm8iLCJpc05lZ2F0aXZlIiwidG9VbnNhZmVGbG9hdCIsInBhcnNlRmxvYXQiLCJ0b0Zvcm1hdCIsImZyb21TdHJpbmciLCJmcm9tVmFsdWUiLCJfZGVjaW1hbHMiLCJfZm9ybWF0Iiwid2hvbGUiLCJkZWNpbWFsIiwiZnJvbUJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/geturl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGetUrl: () => (/* binding */ createGetUrl),\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\n\n\n\n/**\n *  @_ignore:\n */ function createGetUrl(options) {\n    async function getUrl(req, signal) {\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: {\n                protocol\n            },\n            operation: \"request\"\n        });\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        const method = req.method;\n        const headers = Object.assign({}, req.headers);\n        const reqOptions = {\n            method,\n            headers\n        };\n        if (options) {\n            if (options.agent) {\n                reqOptions.agent = options.agent;\n            }\n        }\n        const request = (protocol === \"http\" ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__).request(req.url, reqOptions);\n        request.setTimeout(req.timeout);\n        const body = req.body;\n        if (body) {\n            request.write(Buffer.from(body));\n        }\n        request.end();\n        return new Promise((resolve, reject)=>{\n            // @TODO: Node 15 added AbortSignal; once we drop support for\n            // Node14, we can add that in here too\n            request.once(\"response\", (resp)=>{\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name)=>{\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {});\n                let body = null;\n                //resp.setEncoding(\"utf8\");\n                resp.on(\"data\", (chunk)=>{\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                    if (body == null) {\n                        body = chunk;\n                    } else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n                resp.on(\"end\", ()=>{\n                    if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                        body = (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.getBytes)((0,zlib__WEBPACK_IMPORTED_MODULE_2__.gunzipSync)(body));\n                    }\n                    resolve({\n                        statusCode,\n                        statusMessage,\n                        headers,\n                        body\n                    });\n                });\n                resp.on(\"error\", (error)=>{\n                    //@TODO: Should this just return nornal response with a server error?\n                    error.response = {\n                        statusCode,\n                        statusMessage,\n                        headers,\n                        body\n                    };\n                    reject(error);\n                });\n            });\n            request.on(\"error\", (error)=>{\n                reject(error);\n            });\n        });\n    }\n    return getUrl;\n}\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */ async function getUrl(req, signal) {\n    return defaultGetUrl(req, signal);\n} //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZ2V0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0I7QUFDRTtBQUNRO0FBQ0c7QUFDQTtBQUNyQzs7Q0FFQyxHQUNNLFNBQVNLLGFBQWFDLE9BQU87SUFDaEMsZUFBZUMsT0FBT0MsR0FBRyxFQUFFQyxNQUFNO1FBQzdCLE1BQU1DLFdBQVdGLElBQUlHLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLFdBQVc7UUFDbERWLGtEQUFNQSxDQUFDTyxhQUFhLFVBQVVBLGFBQWEsU0FBUyxDQUFDLHFCQUFxQixFQUFFQSxTQUFTLENBQUMsRUFBRSx5QkFBeUI7WUFDN0dJLE1BQU07Z0JBQUVKO1lBQVM7WUFDakJLLFdBQVc7UUFDZjtRQUNBWixrREFBTUEsQ0FBQ08sYUFBYSxXQUFXLENBQUNGLElBQUlRLFdBQVcsSUFBSVIsSUFBSVMsMkJBQTJCLEVBQUUsK0NBQStDLHlCQUF5QjtZQUN4SkYsV0FBVztRQUNmO1FBQ0EsTUFBTUcsU0FBU1YsSUFBSVUsTUFBTTtRQUN6QixNQUFNQyxVQUFVQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHYixJQUFJVyxPQUFPO1FBQzdDLE1BQU1HLGFBQWE7WUFBRUo7WUFBUUM7UUFBUTtRQUNyQyxJQUFJYixTQUFTO1lBQ1QsSUFBSUEsUUFBUWlCLEtBQUssRUFBRTtnQkFDZkQsV0FBV0MsS0FBSyxHQUFHakIsUUFBUWlCLEtBQUs7WUFDcEM7UUFDSjtRQUNBLE1BQU1DLFVBQVUsQ0FBQyxhQUFjLFNBQVV4QixpQ0FBSUEsR0FBR0Msa0NBQUksRUFBR3VCLE9BQU8sQ0FBQ2hCLElBQUlHLEdBQUcsRUFBRVc7UUFDeEVFLFFBQVFDLFVBQVUsQ0FBQ2pCLElBQUlrQixPQUFPO1FBQzlCLE1BQU1DLE9BQU9uQixJQUFJbUIsSUFBSTtRQUNyQixJQUFJQSxNQUFNO1lBQ05ILFFBQVFJLEtBQUssQ0FBQ0MsT0FBT0MsSUFBSSxDQUFDSDtRQUM5QjtRQUNBSCxRQUFRTyxHQUFHO1FBQ1gsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLDZEQUE2RDtZQUM3RCxzQ0FBc0M7WUFDdENWLFFBQVFXLElBQUksQ0FBQyxZQUFZLENBQUNDO2dCQUN0QixNQUFNQyxhQUFhRCxLQUFLQyxVQUFVLElBQUk7Z0JBQ3RDLE1BQU1DLGdCQUFnQkYsS0FBS0UsYUFBYSxJQUFJO2dCQUM1QyxNQUFNbkIsVUFBVUMsT0FBT21CLElBQUksQ0FBQ0gsS0FBS2pCLE9BQU8sSUFBSSxDQUFDLEdBQUdxQixNQUFNLENBQUMsQ0FBQ0MsT0FBT0M7b0JBQzNELElBQUlDLFFBQVFQLEtBQUtqQixPQUFPLENBQUN1QixLQUFLLElBQUk7b0JBQ2xDLElBQUlFLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUTt3QkFDdEJBLFFBQVFBLE1BQU1HLElBQUksQ0FBQztvQkFDdkI7b0JBQ0FMLEtBQUssQ0FBQ0MsS0FBSyxHQUFHQztvQkFDZCxPQUFPRjtnQkFDWCxHQUFHLENBQUM7Z0JBQ0osSUFBSWQsT0FBTztnQkFDWCwyQkFBMkI7Z0JBQzNCUyxLQUFLVyxFQUFFLENBQUMsUUFBUSxDQUFDQztvQkFDYixJQUFJdkMsUUFBUTt3QkFDUixJQUFJOzRCQUNBQSxPQUFPd0MsV0FBVzt3QkFDdEIsRUFDQSxPQUFPQyxPQUFPOzRCQUNWLE9BQU9oQixPQUFPZ0I7d0JBQ2xCO29CQUNKO29CQUNBLElBQUl2QixRQUFRLE1BQU07d0JBQ2RBLE9BQU9xQjtvQkFDWCxPQUNLO3dCQUNELE1BQU1HLFVBQVUsSUFBSUMsV0FBV3pCLEtBQUswQixNQUFNLEdBQUdMLE1BQU1LLE1BQU07d0JBQ3pERixRQUFRRyxHQUFHLENBQUMzQixNQUFNO3dCQUNsQndCLFFBQVFHLEdBQUcsQ0FBQ04sT0FBT3JCLEtBQUswQixNQUFNO3dCQUM5QjFCLE9BQU93QjtvQkFDWDtnQkFDSjtnQkFDQWYsS0FBS1csRUFBRSxDQUFDLE9BQU87b0JBQ1gsSUFBSTVCLE9BQU8sQ0FBQyxtQkFBbUIsS0FBSyxVQUFVUSxNQUFNO3dCQUNoREEsT0FBT3ZCLGtEQUFRQSxDQUFDRixnREFBVUEsQ0FBQ3lCO29CQUMvQjtvQkFDQU0sUUFBUTt3QkFBRUk7d0JBQVlDO3dCQUFlbkI7d0JBQVNRO29CQUFLO2dCQUN2RDtnQkFDQVMsS0FBS1csRUFBRSxDQUFDLFNBQVMsQ0FBQ0c7b0JBQ2QscUVBQXFFO29CQUNyRUEsTUFBTUssUUFBUSxHQUFHO3dCQUFFbEI7d0JBQVlDO3dCQUFlbkI7d0JBQVNRO29CQUFLO29CQUM1RE8sT0FBT2dCO2dCQUNYO1lBQ0o7WUFDQTFCLFFBQVF1QixFQUFFLENBQUMsU0FBUyxDQUFDRztnQkFBWWhCLE9BQU9nQjtZQUFRO1FBQ3BEO0lBQ0o7SUFDQSxPQUFPM0M7QUFDWDtBQUNBLHFEQUFxRDtBQUNyRCxNQUFNaUQsZ0JBQWdCbkQsYUFBYSxDQUFDO0FBQ3BDOztDQUVDLEdBQ00sZUFBZUUsT0FBT0MsR0FBRyxFQUFFQyxNQUFNO0lBQ3BDLE9BQU8rQyxjQUFjaEQsS0FBS0M7QUFDOUIsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9nZXR1cmwuanM/NGM3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tIFwiaHR0cFwiO1xuaW1wb3J0IGh0dHBzIGZyb20gXCJodHRwc1wiO1xuaW1wb3J0IHsgZ3VuemlwU3luYyB9IGZyb20gXCJ6bGliXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHZXRVcmwob3B0aW9ucykge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFVybChyZXEsIHNpZ25hbCkge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS51cmwuc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFzc2VydChwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KHByb3RvY29sID09PSBcImh0dHBzXCIgfHwgIXJlcS5jcmVkZW50aWFscyB8fCByZXEuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uLCBcImluc2VjdXJlIGF1dGhvcml6ZWQgY29ubmVjdGlvbnMgdW5zdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcS5oZWFkZXJzKTtcbiAgICAgICAgY29uc3QgcmVxT3B0aW9ucyA9IHsgbWV0aG9kLCBoZWFkZXJzIH07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZ2VudCkge1xuICAgICAgICAgICAgICAgIHJlcU9wdGlvbnMuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoKHByb3RvY29sID09PSBcImh0dHBcIikgPyBodHRwIDogaHR0cHMpLnJlcXVlc3QocmVxLnVybCwgcmVxT3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Quc2V0VGltZW91dChyZXEudGltZW91dCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSByZXEuYm9keTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qud3JpdGUoQnVmZmVyLmZyb20oYm9keSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBAVE9ETzogTm9kZSAxNSBhZGRlZCBBYm9ydFNpZ25hbDsgb25jZSB3ZSBkcm9wIHN1cHBvcnQgZm9yXG4gICAgICAgICAgICAvLyBOb2RlMTQsIHdlIGNhbiBhZGQgdGhhdCBpbiBoZXJlIHRvb1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKFwicmVzcG9uc2VcIiwgKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcC5zdGF0dXNDb2RlIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IHJlc3Auc3RhdHVzTWVzc2FnZSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3Qua2V5cyhyZXNwLmhlYWRlcnMgfHwge30pLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcmVzcC5oZWFkZXJzW25hbWVdIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy9yZXNwLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgICAgICByZXNwLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuY2hlY2tTaWduYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JvZHkgPSBuZXcgVWludDhBcnJheShib2R5Lmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCb2R5LnNldChib2R5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvZHkuc2V0KGNodW5rLCBib2R5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gbmV3Qm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3Aub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtZW5jb2RpbmdcIl0gPT09IFwiZ3ppcFwiICYmIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBnZXRCeXRlcyhndW56aXBTeW5jKGJvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNwLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vQFRPRE86IFNob3VsZCB0aGlzIGp1c3QgcmV0dXJuIG5vcm5hbCByZXNwb25zZSB3aXRoIGEgc2VydmVyIGVycm9yP1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSB9O1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7IHJlamVjdChlcnJvcik7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFVybDtcbn1cbi8vIEBUT0RPOiByZW1vdmUgaW4gdjc7IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0XG5jb25zdCBkZWZhdWx0R2V0VXJsID0gY3JlYXRlR2V0VXJsKHt9KTtcbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXJsKHJlcSwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRHZXRVcmwocmVxLCBzaWduYWwpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0dXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJodHRwIiwiaHR0cHMiLCJndW56aXBTeW5jIiwiYXNzZXJ0IiwiZ2V0Qnl0ZXMiLCJjcmVhdGVHZXRVcmwiLCJvcHRpb25zIiwiZ2V0VXJsIiwicmVxIiwic2lnbmFsIiwicHJvdG9jb2wiLCJ1cmwiLCJzcGxpdCIsInRvTG93ZXJDYXNlIiwiaW5mbyIsIm9wZXJhdGlvbiIsImNyZWRlbnRpYWxzIiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwibWV0aG9kIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsInJlcU9wdGlvbnMiLCJhZ2VudCIsInJlcXVlc3QiLCJzZXRUaW1lb3V0IiwidGltZW91dCIsImJvZHkiLCJ3cml0ZSIsIkJ1ZmZlciIsImZyb20iLCJlbmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uY2UiLCJyZXNwIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJuYW1lIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwib24iLCJjaHVuayIsImNoZWNrU2lnbmFsIiwiZXJyb3IiLCJuZXdCb2R5IiwiVWludDhBcnJheSIsImxlbmd0aCIsInNldCIsInJlc3BvbnNlIiwiZGVmYXVsdEdldFVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDZ0Q7QUFDSTtBQUNyRCxNQUFNSSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QyxNQUFNRSxXQUFXO0FBQ2pCOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQ25DLE1BQU1DLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsTUFBTUksUUFBUVIsT0FBT1MsVUFBVUosUUFBUTtJQUN2Q1Isa0RBQU1BLENBQUMsU0FBVVcsVUFBV1QsTUFBTSxZQUFZLGlCQUFpQjtRQUMzRFcsV0FBVztRQUFZQyxPQUFPO1FBQVlMLE9BQU9GO0lBQ3JEO0lBQ0EseUNBQXlDO0lBQ3pDLElBQUlFLFNBQVVFLFFBQVFQLE1BQU87UUFDekIsTUFBTVcsT0FBTyxDQUFDWCxRQUFRTyxLQUFJLElBQUtQO1FBQy9CLE9BQU8sQ0FBRSxFQUFDLENBQUVLLFFBQVNNLElBQUcsSUFBS1gsSUFBRztJQUNwQztJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNPLE9BQU9ULE1BQU0sRUFBRUMsTUFBTTtJQUNqQyxJQUFJQyxRQUFRUSxVQUFVVixRQUFRO0lBQzlCLE1BQU1JLFFBQVFSLE9BQU9TLFVBQVVKLFFBQVE7SUFDdkMsTUFBTVUsUUFBU2QsUUFBU08sUUFBUVA7SUFDaEMsSUFBSUssUUFBUVAsTUFBTTtRQUNkTyxRQUFRLENBQUNBO1FBQ1RULGtEQUFNQSxDQUFDUyxTQUFTUyxPQUFPLFdBQVcsaUJBQWlCO1lBQy9DTCxXQUFXO1lBQVVDLE9BQU87WUFBWUwsT0FBT0Y7UUFDbkQ7UUFDQSxNQUFNUSxPQUFPLENBQUNYLFFBQVFPLEtBQUksSUFBS1A7UUFDL0IsT0FBTyxDQUFDLENBQUVLLFFBQVNNLElB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SUFBSSxHQUFHQSxJQUFJWCxPQUFPUSxNQUFNLEVBQUVHLElBQUs7UUFDcEMsTUFBTUMsU0FBU0QsSUFBSTtRQUNuQlgsTUFBTSxDQUFDVyxFQUFFLEdBQUdFLFNBQVNILElBQUliLFNBQVMsQ0FBQ2UsUUFBUUEsU0FBUyxJQUFJO0lBQzVEO0lBQ0EsT0FBT1o7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLFdBQVdqQyxLQUFLO0lBQzVCLElBQUltQixTQUFTOUIsaURBQU9BLENBQUNDLHFEQUFXQSxDQUFDVSxTQUFTQSxRQUFRNEIsVUFBVTVCLFFBQVFnQixTQUFTLENBQUM7SUFDOUUsTUFBT0csT0FBT2UsVUFBVSxDQUFDLEtBQU07UUFDM0JmLFNBQVNBLE9BQU9ILFNBQVMsQ0FBQztJQUM5QjtJQUNBLElBQUlHLFdBQVcsSUFBSTtRQUNmQSxTQUFTO0lBQ2I7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanM/YmNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIG1hdGhlbWF0aWMgb3BlcmF0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6TWF0aCBIZWxwZXJzICBbYWJvdXQtbWF0aHNdXG4gKi9cbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG4vL2NvbnN0IEJOX01heDI1NiA9IChCTl8xIDw8IEJpZ0ludCgyNTYpKSAtIEJOXzE7XG4vLyBJRUVFIDc1NCBzdXBwb3J0IDUzLWJpdHMgb2YgbWFudGlzc2FcbmNvbnN0IG1heFZhbHVlID0gMHgxZmZmZmZmZmZmZmZmZjtcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIGZyb20gYSB0d29zLWNvbXBsaW1lbnQgcmVwcmVzZW50YXRpb24gb2YgJSV3aWR0aCUlXG4gKiAgYml0cyB0byBpdHMgdmFsdWUuXG4gKlxuICogIElmIHRoZSBoaWdoZXN0IGJpdCBpcyBgYDFgYCwgdGhlIHJlc3VsdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGFzc2VydCgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R3b3MoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIikpO1xuICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgKHdpZHRoIC0gQk5fMSkpO1xuICAgIGlmICh2YWx1ZSA8IEJOXzApIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8PSBsaW1pdCwgXCJ0b28gbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gKCh+dmFsdWUpICYgbWFzaykgKyBCTl8xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiAgTWFzayAlJXZhbHVlJSUgd2l0aCBhIGJpdG1hc2sgb2YgJSViaXRzJSUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soX3ZhbHVlLCBfYml0cykge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3QgYml0cyA9IEJpZ0ludChnZXROdW1iZXIoX2JpdHMsIFwiYml0c1wiKSk7XG4gICAgcmV0dXJuIHZhbHVlICYgKChCTl8xIDw8IGJpdHMpIC0gQk5fMSk7XG59XG4vKipcbiAqICBHZXRzIGEgQmlnSW50IGZyb20gJSV2YWx1ZSUlLiBJZiBpdCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvclxuICogIGEgQmlnSW50LCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6IHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIgJiYgdmFsdWVbMV0gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtQmlnSW50KHZhbHVlLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGludmFsaWQgQmlnTnVtYmVyaXNoIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIFJldHVybnMgJSV2YWx1ZSUlIGFzIGEgYmlnaW50LCB2YWxpZGF0aW5nIGl0IGlzIHZhbGlkIGFzIGEgYmlnaW50XG4gKiAgdmFsdWUgYW5kIHRoYXQgaXQgaXMgcG9zaXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50KHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0QmlnSW50KHZhbHVlLCBuYW1lKTtcbiAgICBhc3NlcnQocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IE5pYmJsZXMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qXG4gKiBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiAodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE51bWJlcihCaWdJbnQodmFsdWUpLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIG51bWVyaWMgc3RyaW5nOiAke2UubWVzc2FnZX1gLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIG51bWJlci4gSWYgJSV2YWx1ZSUlIGlzIGEgVWludDhBcnJheSwgaXRcbiAqICBpcyB0cmVhdGVkIGFzIEJpZyBFbmRpYW4gZGF0YS4gVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2FmZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldE51bWJlcih0b0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBoZXhzdHJpbmcsIG9wdGlvbmFsbHkgcGFkZGVkIHRvXG4gKiAgJSV3aWR0aCUlIGJ5dGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgIGFzc2VydCh3aWR0aCAqIDIgPj0gcmVzdWx0Lmxlbmd0aCwgYHZhbHVlIGV4Y2VlZHMgd2lkdGggKCR7d2lkdGh9IGJ5dGVzKWAsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9CZUhleFwiLFxuICAgICAgICAgICAgZmF1bHQ6IFwib3ZlcmZsb3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhZCB0aGUgdmFsdWUgdG8gdGhlIHJlcXVpcmVkIHdpZHRoXG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgKHdpZHRoICogMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBCaWcgRW5kaWFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JlQXJyYXkoX3ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAodmFsdWUgPT09IEJOXzApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICB9XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMjtcbiAgICAgICAgcmVzdWx0W2ldID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9RdWFudGl0eSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBoZXhsaWZ5KGlzQnl0ZXNMaWtlKHZhbHVlKSA/IHZhbHVlIDogdG9CZUFycmF5KHZhbHVlKSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChyZXN1bHQuc3RhcnRzV2l0aChcIjBcIikpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBcIjBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCJdLCJuYW1lcyI6WyJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJCTl8xIiwibWF4VmFsdWUiLCJmcm9tVHdvcyIsIl92YWx1ZSIsIl93aWR0aCIsInZhbHVlIiwiZ2V0VWludCIsIndpZHRoIiwiZ2V0TnVtYmVyIiwib3BlcmF0aW9uIiwiZmF1bHQiLCJtYXNrIiwidG9Ud29zIiwiZ2V0QmlnSW50IiwibGltaXQiLCJfYml0cyIsImJpdHMiLCJuYW1lIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJzdWJzdHJpbmciLCJlIiwibWVzc2FnZSIsInJlc3VsdCIsIk5pYmJsZXMiLCJ0b0JpZ0ludCIsIlVpbnQ4QXJyYXkiLCJ2IiwidG9OdW1iZXIiLCJ0b0JlSGV4IiwidG9TdHJpbmciLCJsZW5ndGgiLCJ0b0JlQXJyYXkiLCJoZXgiLCJpIiwib2Zmc2V0IiwicGFyc2VJbnQiLCJ0b1F1YW50aXR5Iiwic3RhcnRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0NBSUMsR0FDRCxTQUFTQSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxNQUFNQyxRQUFRRixLQUFLRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJO0lBQzdDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsT0FBUVA7WUFDSixLQUFLO2dCQUNEO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLE9BQVFELFVBQVdDLE1BQU07b0JBQ3pCO2dCQUNKO1FBQ1I7SUFDSjtJQUNBLE1BQU1TLFFBQVEsSUFBSUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFVixLQUFLLENBQUM7SUFDeERTLE1BQU1FLElBQUksR0FBRztJQUNiRixNQUFNRyxRQUFRLEdBQUcsQ0FBQyxNQUFNLEVBQUVYLEtBQUssQ0FBQztJQUNoQ1EsTUFBTVYsS0FBSyxHQUFHQTtJQUNkLE1BQU1VO0FBQ1Y7QUFDQTs7O0NBR0MsR0FDTSxlQUFlSSxrQkFBa0JkLEtBQUs7SUFDekMsTUFBTWUsT0FBT0MsT0FBT0QsSUFBSSxDQUFDZjtJQUN6QixNQUFNaUIsVUFBVSxNQUFNQyxRQUFRQyxHQUFHLENBQUNKLEtBQUtWLEdBQUcsQ0FBQyxDQUFDZSxJQUFNRixRQUFRRyxPQUFPLENBQUNyQixLQUFLLENBQUNvQixFQUFFO0lBQzFFLE9BQU9ILFFBQVFLLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQyxHQUFHQztRQUM3QkYsS0FBSyxDQUFDUixJQUFJLENBQUNVLE1BQU0sQ0FBQyxHQUFHRDtRQUNyQixPQUFPRDtJQUNYLEdBQUcsQ0FBQztBQUNSO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNHLGlCQUFpQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUV6QixLQUFLO0lBQ2xELElBQUssSUFBSTBCLE9BQU9ELE9BQVE7UUFDcEIsSUFBSTVCLFFBQVE0QixNQUFNLENBQUNDLElBQUk7UUFDdkIsTUFBTTVCLE9BQVFFLFFBQVFBLEtBQUssQ0FBQzBCLElBQUksR0FBRztRQUNuQyxJQUFJNUIsTUFBTTtZQUNORixVQUFVQyxPQUFPQyxNQUFNNEI7UUFDM0I7UUFDQWIsT0FBT2MsY0FBYyxDQUFDSCxRQUFRRSxLQUFLO1lBQUVFLFlBQVk7WUFBTS9CO1lBQU9nQyxVQUFVO1FBQU07SUFDbEY7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3Byb3BlcnRpZXMuanM/NTIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBQcm9wZXJ0eSBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlByb3BlcnRpZXMgIFthYm91dC1wcm9wZXJ0aWVzXVxuICovXG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChrZXlzLm1hcCgoaykgPT4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlW2tdKSkpO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGFjY3VtW2tleXNbaW5kZXhdXSA9IHY7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCB7fSk7XG59XG4vKipcbiAqICBBc3NpZ25zIHRoZSAlJXZhbHVlcyUlIHRvICUldGFyZ2V0JSUgYXMgcmVhZC1vbmx5IHZhbHVlcy5cbiAqXG4gKiAgSXQgJSV0eXBlcyUlIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlcyBhcmUgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCB2YWx1ZXMsIHR5cGVzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgdHlwZSA9ICh0eXBlcyA/IHR5cGVzW2tleV0gOiBudWxsKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0aWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJjaGVja1R5cGUiLCJ2YWx1ZSIsInR5cGUiLCJuYW1lIiwidHlwZXMiLCJzcGxpdCIsIm1hcCIsInQiLCJ0cmltIiwiaSIsImxlbmd0aCIsImVycm9yIiwiRXJyb3IiLCJjb2RlIiwiYXJndW1lbnQiLCJyZXNvbHZlUHJvcGVydGllcyIsImtleXMiLCJPYmplY3QiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsImsiLCJyZXNvbHZlIiwicmVkdWNlIiwiYWNjdW0iLCJ2IiwiaW5kZXgiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwidmFsdWVzIiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-decode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlp: () => (/* binding */ decodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while(result.length < 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length,\n            offset\n        });\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data,\n        length: 0,\n        offset: 1\n    });\n    const checkOffset = (offset)=>{\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length: data.length,\n            offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: hexlifyByte(data[offset])\n    };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */ function decodeRlp(_data) {\n    const data = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n} //# sourceMappingURL=rlp-decode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWRlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnREFBZ0Q7QUFDWjtBQUNpQjtBQUNoQjtBQUNyQyxTQUFTSSxZQUFZQyxLQUFLO0lBQ3RCLElBQUlDLFNBQVNELE1BQU1FLFFBQVEsQ0FBQztJQUM1QixNQUFPRCxPQUFPRSxNQUFNLEdBQUcsRUFBRztRQUN0QkYsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT0E7QUFDbEI7QUFDQSxTQUFTRyxrQkFBa0JDLElBQUksRUFBRUMsTUFBTSxFQUFFSCxNQUFNO0lBQzNDLElBQUlGLFNBQVM7SUFDYixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUosUUFBUUksSUFBSztRQUM3Qk4sU0FBUyxTQUFVLE1BQU9JLElBQUksQ0FBQ0MsU0FBU0MsRUFBRTtJQUM5QztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTTyxnQkFBZ0JILElBQUksRUFBRUMsTUFBTSxFQUFFRyxXQUFXLEVBQUVOLE1BQU07SUFDdEQsTUFBTUYsU0FBUyxFQUFFO0lBQ2pCLE1BQU9RLGNBQWNILFNBQVMsSUFBSUgsT0FBUTtRQUN0QyxNQUFNTyxVQUFVQyxRQUFRTixNQUFNSTtRQUM5QlIsT0FBT1csSUFBSSxDQUFDRixRQUFRVCxNQUFNO1FBQzFCUSxlQUFlQyxRQUFRRyxRQUFRO1FBQy9CakIsa0RBQU1BLENBQUNhLGVBQWVILFNBQVMsSUFBSUgsUUFBUSx3QkFBd0Isa0JBQWtCO1lBQ2pGVyxRQUFRVDtZQUFNRjtZQUFRRztRQUMxQjtJQUNKO0lBQ0EsT0FBTztRQUFFTyxVQUFXLElBQUlWO1FBQVNGLFFBQVFBO0lBQU87QUFDcEQ7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBU1UsUUFBUU4sSUFBSSxFQUFFQyxNQUFNO0lBQ3pCVixrREFBTUEsQ0FBQ1MsS0FBS0YsTUFBTSxLQUFLLEdBQUcsa0JBQWtCLGtCQUFrQjtRQUMxRFcsUUFBUVQ7UUFBTUYsUUFBUTtRQUFHRyxRQUFRO0lBQ3JDO0lBQ0EsTUFBTVMsY0FBYyxDQUFDVDtRQUNqQlYsa0RBQU1BLENBQUNVLFVBQVVELEtBQUtGLE1BQU0sRUFBRSxnQ0FBZ0Msa0JBQWtCO1lBQzVFVyxRQUFRVDtZQUFNRixRQUFRRSxLQUFLRixNQUFNO1lBQUVHO1FBQ3ZDO0lBQ0o7SUFDQSxpQ0FBaUM7SUFDakMsSUFBSUQsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUN0QixNQUFNVSxlQUFlWCxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNwQ1MsWUFBWVQsU0FBUyxJQUFJVTtRQUN6QixNQUFNYixTQUFTQyxrQkFBa0JDLE1BQU1DLFNBQVMsR0FBR1U7UUFDbkRELFlBQVlULFNBQVMsSUFBSVUsZUFBZWI7UUFDeEMsT0FBT0ssZ0JBQWdCSCxNQUFNQyxRQUFRQSxTQUFTLElBQUlVLGNBQWNBLGVBQWViO0lBQ25GLE9BQ0ssSUFBSUUsSUFBSSxDQUFDQyxPQUFPLElBQUksTUFBTTtRQUMzQixNQUFNSCxTQUFTRSxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUM5QlMsWUFBWVQsU0FBUyxJQUFJSDtRQUN6QixPQUFPSyxnQkFBZ0JILE1BQU1DLFFBQVFBLFNBQVMsR0FBR0g7SUFDckQsT0FDSyxJQUFJRSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1VLGVBQWVYLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ3BDUyxZQUFZVCxTQUFTLElBQUlVO1FBQ3pCLE1BQU1iLFNBQVNDLGtCQUFrQkMsTUFBTUMsU0FBUyxHQUFHVTtRQUNuREQsWUFBWVQsU0FBUyxJQUFJVSxlQUFlYjtRQUN4QyxNQUFNRixTQUFTTixpREFBT0EsQ0FBQ1UsS0FBS1ksS0FBSyxDQUFDWCxTQUFTLElBQUlVLGNBQWNWLFNBQVMsSUFBSVUsZUFBZWI7UUFDekYsT0FBTztZQUFFVSxVQUFXLElBQUlHLGVBQWViO1lBQVNGLFFBQVFBO1FBQU87SUFDbkUsT0FDSyxJQUFJSSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1ILFNBQVNFLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQzlCUyxZQUFZVCxTQUFTLElBQUlIO1FBQ3pCLE1BQU1GLFNBQVNOLGlEQUFPQSxDQUFDVSxLQUFLWSxLQUFLLENBQUNYLFNBQVMsR0FBR0EsU0FBUyxJQUFJSDtRQUMzRCxPQUFPO1lBQUVVLFVBQVcsSUFBSVY7WUFBU0YsUUFBUUE7UUFBTztJQUNwRDtJQUNBLE9BQU87UUFBRVksVUFBVTtRQUFHWixRQUFRRixZQUFZTSxJQUFJLENBQUNDLE9BQU87SUFBRTtBQUM1RDtBQUNBOztDQUVDLEdBQ00sU0FBU1ksVUFBVUMsS0FBSztJQUMzQixNQUFNZCxPQUFPUCxrREFBUUEsQ0FBQ3FCLE9BQU87SUFDN0IsTUFBTVQsVUFBVUMsUUFBUU4sTUFBTTtJQUM5QlIsMERBQWNBLENBQUNhLFFBQVFHLFFBQVEsS0FBS1IsS0FBS0YsTUFBTSxFQUFFLHFDQUFxQyxRQUFRZ0I7SUFDOUYsT0FBT1QsUUFBUVQsTUFBTTtBQUN6QixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3JscC1kZWNvZGUuanM/NmUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGhleGxpZnkgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmZ1bmN0aW9uIGhleGxpZnlCeXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGFzc2VydChjaGlsZE9mZnNldCA8PSBvZmZzZXQgKyAxICsgbGVuZ3RoLCBcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMCwgXCJkYXRhIHRvbyBzaG9ydFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IDAsIG9mZnNldDogMVxuICAgIH0pO1xuICAgIGNvbnN0IGNoZWNrT2Zmc2V0ID0gKG9mZnNldCkgPT4ge1xuICAgICAgICBhc3NlcnQob2Zmc2V0IDw9IGRhdGEubGVuZ3RoLCBcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogZGF0YS5sZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQgKyAxLCBsZW5ndGhMZW5ndGgpO1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnlCeXRlKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbi8qKlxuICogIERlY29kZXMgJSVkYXRhJSUgaW50byB0aGUgc3RydWN0dXJlZCBkYXRhIGl0IHJlcHJlc2VudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcbiAgICBhc3NlcnRBcmd1bWVudChkZWNvZGVkLmNvbnN1bWVkID09PSBkYXRhLmxlbmd0aCwgXCJ1bmV4cGVjdGVkIGp1bmsgYWZ0ZXIgcmxwIHBheWxvYWRcIiwgXCJkYXRhXCIsIF9kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZC5yZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZGVjb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJoZXhsaWZ5IiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRCeXRlcyIsImhleGxpZnlCeXRlIiwidmFsdWUiLCJyZXN1bHQiLCJ0b1N0cmluZyIsImxlbmd0aCIsInVuYXJyYXlpZnlJbnRlZ2VyIiwiZGF0YSIsIm9mZnNldCIsImkiLCJfZGVjb2RlQ2hpbGRyZW4iLCJjaGlsZE9mZnNldCIsImRlY29kZWQiLCJfZGVjb2RlIiwicHVzaCIsImNvbnN1bWVkIiwiYnVmZmVyIiwiY2hlY2tPZmZzZXQiLCJsZW5ndGhMZW5ndGgiLCJzbGljZSIsImRlY29kZVJscCIsIl9kYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/rlp-decode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/rlp-encode.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeRlp: () => (/* binding */ encodeRlp)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0,_data_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */ function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)){\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n} //# sourceMappingURL=rlp-encode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUFnRDtBQUNYO0FBQ3JDLFNBQVNDLGdCQUFnQkMsS0FBSztJQUMxQixNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBT0QsTUFBTztRQUNWQyxPQUFPQyxPQUFPLENBQUNGLFFBQVE7UUFDdkJBLFVBQVU7SUFDZDtJQUNBLE9BQU9DO0FBQ1g7QUFDQSxTQUFTRSxRQUFRQyxNQUFNO0lBQ25CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN2QixJQUFJRyxVQUFVLEVBQUU7UUFDaEJILE9BQU9JLE9BQU8sQ0FBQyxTQUFVQyxLQUFLO1lBQzFCRixVQUFVQSxRQUFRRyxNQUFNLENBQUNQLFFBQVFNO1FBQ3JDO1FBQ0EsSUFBSUYsUUFBUUksTUFBTSxJQUFJLElBQUk7WUFDdEJKLFFBQVFMLE9BQU8sQ0FBQyxPQUFPSyxRQUFRSSxNQUFNO1lBQ3JDLE9BQU9KO1FBQ1g7UUFDQSxNQUFNSSxTQUFTWixnQkFBZ0JRLFFBQVFJLE1BQU07UUFDN0NBLE9BQU9ULE9BQU8sQ0FBQyxPQUFPUyxPQUFPQSxNQUFNO1FBQ25DLE9BQU9BLE9BQU9ELE1BQU0sQ0FBQ0g7SUFDekI7SUFDQSxNQUFNSyxPQUFPUCxNQUFNUSxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDakIsa0RBQVFBLENBQUNNLFFBQVE7SUFDekQsSUFBSVEsS0FBS0QsTUFBTSxLQUFLLEtBQUtDLElBQUksQ0FBQyxFQUFFLElBQUksTUFBTTtRQUN0QyxPQUFPQTtJQUNYLE9BQ0ssSUFBSUEsS0FBS0QsTUFBTSxJQUFJLElBQUk7UUFDeEJDLEtBQUtWLE9BQU8sQ0FBQyxPQUFPVSxLQUFLRCxNQUFNO1FBQy9CLE9BQU9DO0lBQ1g7SUFDQSxNQUFNRCxTQUFTWixnQkFBZ0JhLEtBQUtELE1BQU07SUFDMUNBLE9BQU9ULE9BQU8sQ0FBQyxPQUFPUyxPQUFPQSxNQUFNO0lBQ25DLE9BQU9BLE9BQU9ELE1BQU0sQ0FBQ0U7QUFDekI7QUFDQSxNQUFNSSxVQUFVO0FBQ2hCOztDQUVDLEdBQ00sU0FBU0MsVUFBVWIsTUFBTTtJQUM1QixJQUFJSCxTQUFTO0lBQ2IsS0FBSyxNQUFNaUIsS0FBS2YsUUFBUUMsUUFBUztRQUM3QkgsVUFBVWUsT0FBTyxDQUFDRSxLQUFLLEVBQUU7UUFDekJqQixVQUFVZSxPQUFPLENBQUNFLElBQUksSUFBSTtJQUM5QjtJQUNBLE9BQU9qQjtBQUNYLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcmxwLWVuY29kZS5qcz8wNzgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRCeXRlcyhvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmxwKG9iamVjdCkge1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChjb25zdCB2IG9mIF9lbmNvZGUob2JqZWN0KSkge1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ID4+IDRdO1xuICAgICAgICByZXN1bHQgKz0gbmliYmxlc1t2ICYgMHhmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJscC1lbmNvZGUuanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXJyYXlpZnlJbnRlZ2VyIiwidmFsdWUiLCJyZXN1bHQiLCJ1bnNoaWZ0IiwiX2VuY29kZSIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInBheWxvYWQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjb25jYXQiLCJsZW5ndGgiLCJkYXRhIiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwibmliYmxlcyIsImVuY29kZVJscCIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/rlp-encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */ \n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */ function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, {\n        decimals,\n        width: 512\n    }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */ function parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof value === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, {\n        decimals,\n        width: 512\n    }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */ function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */ function parseEther(ether) {\n    return parseUnits(ether, 18);\n} //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdW5pdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUM0QztBQUNFO0FBQ1I7QUFDdkMsTUFBTUcsUUFBUTtJQUNWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRDs7Ozs7Q0FLQyxHQUNNLFNBQVNDLFlBQVlDLEtBQUssRUFBRUMsSUFBSTtJQUNuQyxJQUFJQyxXQUFXO0lBQ2YsSUFBSSxPQUFRRCxTQUFVLFVBQVU7UUFDNUIsTUFBTUUsUUFBUUwsTUFBTU0sT0FBTyxDQUFDSDtRQUM1Qk4sMERBQWNBLENBQUNRLFNBQVMsR0FBRyxnQkFBZ0IsUUFBUUY7UUFDbkRDLFdBQVcsSUFBSUM7SUFDbkIsT0FDSyxJQUFJRixRQUFRLE1BQU07UUFDbkJDLFdBQVdMLG9EQUFTQSxDQUFDSSxNQUFNO0lBQy9CO0lBQ0EsT0FBT0wsd0RBQVdBLENBQUNTLFNBQVMsQ0FBQ0wsT0FBT0UsVUFBVTtRQUFFQTtRQUFVSSxPQUFPO0lBQUksR0FBR0MsUUFBUTtBQUNwRjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxXQUFXUixLQUFLLEVBQUVDLElBQUk7SUFDbENOLDBEQUFjQSxDQUFDLE9BQVFLLFVBQVcsVUFBVSwwQkFBMEIsU0FBU0E7SUFDL0UsSUFBSUUsV0FBVztJQUNmLElBQUksT0FBUUQsU0FBVSxVQUFVO1FBQzVCLE1BQU1FLFFBQVFMLE1BQU1NLE9BQU8sQ0FBQ0g7UUFDNUJOLDBEQUFjQSxDQUFDUSxTQUFTLEdBQUcsZ0JBQWdCLFFBQVFGO1FBQ25EQyxXQUFXLElBQUlDO0lBQ25CLE9BQ0ssSUFBSUYsUUFBUSxNQUFNO1FBQ25CQyxXQUFXTCxvREFBU0EsQ0FBQ0ksTUFBTTtJQUMvQjtJQUNBLE9BQU9MLHdEQUFXQSxDQUFDYSxVQUFVLENBQUNULE9BQU87UUFBRUU7UUFBVUksT0FBTztJQUFJLEdBQUdOLEtBQUs7QUFDeEU7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLEdBQUc7SUFDM0IsT0FBT1osWUFBWVksS0FBSztBQUM1QjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLFdBQVdDLEtBQUs7SUFDNUIsT0FBT0wsV0FBV0ssT0FBTztBQUM3QixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzPzY4YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZE51bWJlciB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1iZXIgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogIG9yIHRoZSBuYW1lIG9mIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vIHVzaW5nIDE4IGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XG4gKiAgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnRBcmd1bWVudCIsIkZpeGVkTnVtYmVyIiwiZ2V0TnVtYmVyIiwibmFtZXMiLCJmb3JtYXRVbml0cyIsInZhbHVlIiwidW5pdCIsImRlY2ltYWxzIiwiaW5kZXgiLCJpbmRleE9mIiwiZnJvbVZhbHVlIiwid2lkdGgiLCJ0b1N0cmluZyIsInBhcnNlVW5pdHMiLCJmcm9tU3RyaW5nIiwiZm9ybWF0RXRoZXIiLCJ3ZWkiLCJwYXJzZUV0aGVyIiwiZXRoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/units.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ \n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ29DO0FBQ3lCO0FBQzlELFNBQVNHLFVBQVVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUMxRFAsMERBQWNBLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFSSxPQUFPLEVBQUUsRUFBRUQsT0FBTyxDQUFDLEVBQUUsU0FBU0U7QUFDdkY7QUFDQSxTQUFTRyxXQUFXTCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0QsdUdBQXVHO0lBQ3ZHLElBQUlKLFdBQVcsZ0JBQWdCQSxXQUFXLHVCQUF1QjtRQUM3RCxJQUFJTSxJQUFJO1FBQ1IsSUFBSyxJQUFJQyxJQUFJTixTQUFTLEdBQUdNLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztZQUM1QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsSUFBSSxNQUFNLE1BQU07Z0JBQ3hCO1lBQ0o7WUFDQUQ7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLElBQUlOLFdBQVcsV0FBVztRQUN0QixPQUFPRSxNQUFNTSxNQUFNLEdBQUdQLFNBQVM7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEIsT0FBTztBQUNYO0FBQ0EsU0FBU1EsWUFBWVQsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzVELHNGQUFzRjtJQUN0RixJQUFJSixXQUFXLFlBQVk7UUFDdkJILDBEQUFjQSxDQUFDLE9BQVFPLGlCQUFrQixVQUFVLDBDQUEwQyxnQkFBZ0JBO1FBQzdHRCxPQUFPTyxJQUFJLENBQUNOO1FBQ1osT0FBTztJQUNYO0lBQ0EsZ0RBQWdEO0lBQ2hERCxPQUFPTyxJQUFJLENBQUM7SUFDWiwyQ0FBMkM7SUFDM0MsT0FBT0wsV0FBV0wsUUFBUUMsUUFBUUMsT0FBT0MsUUFBUUM7QUFDckQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLE1BQU1PLGlCQUFpQkMsT0FBT0MsTUFBTSxDQUFDO0lBQ3hDQyxPQUFPZjtJQUNQZ0IsUUFBUVY7SUFDUlcsU0FBU1A7QUFDYixHQUFHO0FBQ0gsb0ZBQW9GO0FBQ3BGLFNBQVNRLGtCQUFrQkMsTUFBTSxFQUFFQyxPQUFPO0lBQ3RDLElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVVIsZUFBZUcsS0FBSztJQUNsQztJQUNBLE1BQU1aLFFBQVFOLGtEQUFRQSxDQUFDc0IsUUFBUTtJQUMvQixNQUFNRSxTQUFTLEVBQUU7SUFDakIsSUFBSWQsSUFBSTtJQUNSLDRCQUE0QjtJQUM1QixNQUFPQSxJQUFJSixNQUFNTSxNQUFNLENBQUU7UUFDckIsTUFBTWEsSUFBSW5CLEtBQUssQ0FBQ0ksSUFBSTtRQUNwQixZQUFZO1FBQ1osSUFBSWUsS0FBSyxNQUFNLEdBQUc7WUFDZEQsT0FBT1YsSUFBSSxDQUFDVztZQUNaO1FBQ0o7UUFDQSxxREFBcUQ7UUFDckQsSUFBSUMsY0FBYztRQUNsQixJQUFJQyxlQUFlO1FBQ25CLHNCQUFzQjtRQUN0QixJQUFJLENBQUNGLElBQUksSUFBRyxNQUFPLE1BQU07WUFDckJDLGNBQWM7WUFDZEMsZUFBZTtRQUNmLGdDQUFnQztRQUNwQyxPQUNLLElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtZQUMxQkMsY0FBYztZQUNkQyxlQUFlO1FBQ2YsMENBQTBDO1FBQzlDLE9BQ0ssSUFBSSxDQUFDRixJQUFJLElBQUcsTUFBTyxNQUFNO1lBQzFCQyxjQUFjO1lBQ2RDLGVBQWU7UUFDbkIsT0FDSztZQUNELElBQUksQ0FBQ0YsSUFBSSxJQUFHLE1BQU8sTUFBTTtnQkFDckJmLEtBQUthLFFBQVEsdUJBQXVCYixJQUFJLEdBQUdKLE9BQU9rQjtZQUN0RCxPQUNLO2dCQUNEZCxLQUFLYSxRQUFRLGNBQWNiLElBQUksR0FBR0osT0FBT2tCO1lBQzdDO1lBQ0E7UUFDSjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJZCxJQUFJLElBQUlnQixlQUFlcEIsTUFBTU0sTUFBTSxFQUFFO1lBQ3JDRixLQUFLYSxRQUFRLFdBQVdiLElBQUksR0FBR0osT0FBT2tCO1lBQ3RDO1FBQ0o7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSUksTUFBTUgsSUFBSyxDQUFDLEtBQU0sSUFBSUMsY0FBYyxDQUFDLElBQUs7UUFDOUMsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlILGFBQWFHLElBQUs7WUFDbEMsSUFBSUMsV0FBV3hCLEtBQUssQ0FBQ0ksRUFBRTtZQUN2Qiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDb0IsV0FBVyxJQUFHLEtBQU0sTUFBTTtnQkFDM0JwQixLQUFLYSxRQUFRLG9CQUFvQmIsR0FBR0osT0FBT2tCO2dCQUMzQ0ksTUFBTTtnQkFDTjtZQUNKOztZQUVBQSxNQUFNLE9BQVEsSUFBTUUsV0FBVztZQUMvQnBCO1FBQ0o7UUFDQSwrQ0FBK0M7UUFDL0MsSUFBSWtCLFFBQVEsTUFBTTtZQUNkO1FBQ0o7UUFDQSxxQkFBcUI7UUFDckIsSUFBSUEsTUFBTSxVQUFVO1lBQ2hCbEIsS0FBS2EsUUFBUSxnQkFBZ0JiLElBQUksSUFBSWdCLGFBQWFwQixPQUFPa0IsUUFBUUk7WUFDakU7UUFDSjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJQSxPQUFPLFVBQVVBLE9BQU8sUUFBUTtZQUNoQ2xCLEtBQUthLFFBQVEsbUJBQW1CYixJQUFJLElBQUlnQixhQUFhcEIsT0FBT2tCLFFBQVFJO1lBQ3BFO1FBQ0o7UUFDQSx3REFBd0Q7UUFDeEQsSUFBSUEsT0FBT0QsY0FBYztZQUNyQmpCLEtBQUthLFFBQVEsWUFBWWIsSUFBSSxJQUFJZ0IsYUFBYXBCLE9BQU9rQixRQUFRSTtZQUM3RDtRQUNKO1FBQ0FKLE9BQU9WLElBQUksQ0FBQ2M7SUFDaEI7SUFDQSxPQUFPSjtBQUNYO0FBQ0EsdUZBQXVGO0FBQ3ZGOzs7O0NBSUMsR0FDTSxTQUFTTyxZQUFZQyxHQUFHLEVBQUVDLElBQUk7SUFDakMsSUFBSUEsUUFBUSxNQUFNO1FBQ2QvQiwyREFBZUEsQ0FBQytCO1FBQ2hCRCxNQUFNQSxJQUFJRSxTQUFTLENBQUNEO0lBQ3hCO0lBQ0EsSUFBSVQsU0FBUyxFQUFFO0lBQ2YsSUFBSyxJQUFJZCxJQUFJLEdBQUdBLElBQUlzQixJQUFJcEIsTUFBTSxFQUFFRixJQUFLO1FBQ2pDLE1BQU1lLElBQUlPLElBQUlHLFVBQVUsQ0FBQ3pCO1FBQ3pCLElBQUllLElBQUksTUFBTTtZQUNWRCxPQUFPVixJQUFJLENBQUNXO1FBQ2hCLE9BQ0ssSUFBSUEsSUFBSSxPQUFPO1lBQ2hCRCxPQUFPVixJQUFJLENBQUMsS0FBTSxJQUFLO1lBQ3ZCVSxPQUFPVixJQUFJLENBQUMsSUFBSyxPQUFRO1FBQzdCLE9BQ0ssSUFBSSxDQUFDVyxJQUFJLE1BQUssS0FBTSxRQUFRO1lBQzdCZjtZQUNBLE1BQU0wQixLQUFLSixJQUFJRyxVQUFVLENBQUN6QjtZQUMxQlQsMERBQWNBLENBQUNTLElBQUlzQixJQUFJcEIsTUFBTSxJQUFLLENBQUN3QixLQUFLLE1BQUssTUFBTyxRQUFTLDBCQUEwQixPQUFPSjtZQUM5RixpQkFBaUI7WUFDakIsTUFBTUssT0FBTyxVQUFXLEVBQUNaLElBQUksTUFBSyxLQUFNLEVBQUMsSUFBTVcsQ0FBQUEsS0FBSyxNQUFLO1lBQ3pEWixPQUFPVixJQUFJLENBQUMsUUFBUyxLQUFNO1lBQzNCVSxPQUFPVixJQUFJLENBQUMsUUFBVSxLQUFNLE9BQVE7WUFDcENVLE9BQU9WLElBQUksQ0FBQyxRQUFVLElBQUssT0FBUTtZQUNuQ1UsT0FBT1YsSUFBSSxDQUFDLE9BQVEsT0FBUTtRQUNoQyxPQUNLO1lBQ0RVLE9BQU9WLElBQUksQ0FBQyxLQUFNLEtBQU07WUFDeEJVLE9BQU9WLElBQUksQ0FBQyxLQUFPLElBQUssT0FBUTtZQUNoQ1UsT0FBT1YsSUFBSSxDQUFDLElBQUssT0FBUTtRQUM3QjtJQUNKO0lBQ0EsT0FBTyxJQUFJd0IsV0FBV2Q7QUFDMUI7O0FBRUEsU0FBUztBQUNULFNBQVNlLGNBQWNDLFVBQVU7SUFDN0IsT0FBT0EsV0FBV0MsR0FBRyxDQUFDLENBQUNDO1FBQ25CLElBQUlBLGFBQWEsUUFBUTtZQUNyQixPQUFPQyxPQUFPQyxZQUFZLENBQUNGO1FBQy9CO1FBQ0FBLGFBQWE7UUFDYixPQUFPQyxPQUFPQyxZQUFZLENBQUUsQ0FBQyxhQUFjLEtBQU0sS0FBSSxJQUFLLFFBQVUsQ0FBQ0YsWUFBWSxLQUFJLElBQUs7SUFDOUYsR0FBR0csSUFBSSxDQUFDO0FBQ1o7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxhQUFheEMsS0FBSyxFQUFFaUIsT0FBTztJQUN2QyxPQUFPZ0IsY0FBY2xCLGtCQUFrQmYsT0FBT2lCO0FBQ2xEO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVN3QixpQkFBaUJmLEdBQUcsRUFBRUMsSUFBSTtJQUN0QyxPQUFPWixrQkFBa0JVLFlBQVlDLEtBQUtDO0FBQzlDLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcz8zMmJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBhc3NlcnROb3JtYWxpemUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0Tm9ybWFsaXplKGZvcm0pO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBjb2RlLXBvaW50cyBmb3IgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnROb3JtYWxpemUiLCJlcnJvckZ1bmMiLCJyZWFzb24iLCJvZmZzZXQiLCJieXRlcyIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJpIiwibyIsImxlbmd0aCIsInJlcGxhY2VGdW5jIiwicHVzaCIsIlV0ZjhFcnJvckZ1bmNzIiwiT2JqZWN0IiwiZnJlZXplIiwiZXJyb3IiLCJpZ25vcmUiLCJyZXBsYWNlIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJfYnl0ZXMiLCJvbkVycm9yIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwidG9VdGY4Qnl0ZXMiLCJzdHIiLCJmb3JtIiwibm9ybWFsaXplIiwiY2hhckNvZGVBdCIsImMyIiwicGFpciIsIlVpbnQ4QXJyYXkiLCJfdG9VdGY4U3RyaW5nIiwiY29kZVBvaW50cyIsIm1hcCIsImNvZGVQb2ludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhDb2RlUG9pbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQzFCO0FBQ3FCO0FBQ1A7QUFDeEQsd0NBQXdDO0FBQ2pDLFNBQVNJLFFBQVFDLElBQUk7SUFDeEIsT0FBTztRQUNIQTtRQUNBTCxNQUFNLENBQUNNLEtBQUssR0FBR0MsT0FBU1Asd0RBQUlBLENBQUNLLE1BQU1DLEtBQUtMLGdFQUFXQSxJQUFJTTtRQUN2REwsV0FBV0EsOERBQUFBO0lBQ2Y7QUFDSjtBQUNPLFNBQVNNLFlBQVlDLFFBQVEsRUFBRUMsT0FBTztJQUN6QyxNQUFNQyxTQUFTLENBQUNOLE9BQVNGLHFFQUFXQSxDQUFDO1lBQUUsR0FBR00sUUFBUTtZQUFFLEdBQUdMLFFBQVFDLEtBQUs7UUFBQztJQUNyRSxPQUFPTyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHRixPQUFPRCxRQUFRO1FBQUVDO0lBQU87QUFDdEQsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/ZmQzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDBCQUEwQjtBQUM0QjtBQUNWO0FBQzVDLE1BQU1HLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQiw2REFBNkQ7QUFDN0QsbUdBQW1HO0FBQ25HLHlEQUF5RDtBQUN6RCw0REFBNEQ7QUFDNUQsK0VBQStFO0FBQy9FLG9HQUFvRztBQUNwRyxvR0FBb0c7QUFDcEcscUNBQXFDO0FBQ3JDLGtHQUFrRztBQUNsRyxnR0FBZ0c7QUFDaEcsOENBQThDO0FBQ3ZDLFNBQVNFLEtBQUtDLENBQUMsRUFBRUMsSUFBSTtJQUN4QixNQUFNQyxrQkFBa0IsQ0FBQ0MsV0FBV0M7UUFDaEMsTUFBTUMsTUFBTUQsS0FBS0UsTUFBTTtRQUN2QixPQUFPSCxZQUFZRSxNQUFNRDtJQUM3QjtJQUNBLE1BQU1HLE9BQU8sQ0FBQ0M7UUFDVixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNWLE9BQU9PLEtBQUssR0FBRyxjQUFjO1FBQ3ZELE1BQU1JLGFBQWEsS0FBTUosQ0FBQUEsSUFBSSxJQUFJLDBCQUEwQjtRQUMzRCxPQUFPO1lBQUVDO1lBQVNHO1FBQVc7SUFDakM7SUFDQSxPQUFPO1FBQ0hWO1FBQ0EsdUNBQXVDO1FBQ3ZDVyxjQUFhQyxHQUFHLEVBQUVDLENBQUM7WUFDZixJQUFJQyxJQUFJaEIsRUFBRWlCLElBQUk7WUFDZCxJQUFJQyxJQUFJSjtZQUNSLE1BQU9DLElBQUluQixJQUFLO2dCQUNaLElBQUltQixJQUFJakIsS0FDSmtCLElBQUlBLEVBQUVHLEdBQUcsQ0FBQ0Q7Z0JBQ2RBLElBQUlBLEVBQUVFLE1BQU07Z0JBQ1pMLE1BQU1qQjtZQUNWO1lBQ0EsT0FBT2tCO1FBQ1g7UUFDQTs7Ozs7Ozs7O1NBU0MsR0FDREssa0JBQWlCUCxHQUFHLEVB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eUQsTUFBTUMsRUFBRTtJQUN0QnhELHlEQUFjQSxDQUFDdUQsT0FBTztRQUNsQm5DLEdBQUc7UUFDSHFDLEdBQUc7UUFDSEMsSUFBSTtRQUNKQyxJQUFJO0lBQ1IsR0FBRztRQUNDQyxZQUFZO1FBQ1pDLGFBQWE7SUFDakI7SUFDQSxlQUFlO0lBQ2YsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQ2pCLEdBQUdoRSxvREFBT0EsQ0FBQ3dELE1BQU1uQyxDQUFDLEVBQUVtQyxNQUFNSyxVQUFVLENBQUM7UUFDckMsR0FBR0wsS0FBSztRQUNSLEdBQUc7WUFBRWxDLEdBQUdrQyxNQUFNQyxFQUFFLENBQUNRLEtBQUs7UUFBQyxDQUFDO0lBQzVCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzP2E4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVGaWVsZCIsIm5MZW5ndGgiLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIndOQUYiLCJjIiwiYml0cyIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJvcHRzIiwiVyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ1bnNhZmVMYWRkZXIiLCJlbG0iLCJuIiwicCIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsInBvaW50cyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwiaSIsInByZWNvbXB1dGVzIiwiZiIsIkJBU0UiLCJtYXNrIiwibWF4TnVtYmVyIiwic2hpZnRCeSIsIm9mZnNldCIsIndiaXRzIiwiTnVtYmVyIiwib2Zmc2V0MSIsIm9mZnNldDIiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwid05BRkNhY2hlZCIsIlAiLCJwcmVjb21wdXRlc01hcCIsInRyYW5zZm9ybSIsIl9XSU5ET1dfU0laRSIsImNvbXAiLCJnZXQiLCJzZXQiLCJ2YWxpZGF0ZUJhc2ljIiwiY3VydmUiLCJGcCIsImgiLCJHeCIsIkd5IiwibkJpdExlbmd0aCIsIm5CeXRlTGVuZ3RoIiwiT2JqZWN0IiwiZnJlZXplIiwiT1JERVIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array) return dst;\n    if (typeof dst === \"string\") return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error(\"DST must be Uint8Array or string\");\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDb0Q7QUFDdkYsU0FBU0ssWUFBWUMsR0FBRztJQUNwQixJQUFJQSxlQUFlQyxZQUNmLE9BQU9EO0lBQ1gsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsT0FBT0gsc0RBQVdBLENBQUNHO0lBQ3ZCLE1BQU0sSUFBSUUsTUFBTTtBQUNwQjtBQUNBLDZGQUE2RjtBQUM3RixNQUFNQyxRQUFRUixzREFBZUE7QUFDN0IsNENBQTRDO0FBQzVDLFNBQVNTLE1BQU1DLEtBQUssRUFBRUMsTUFBTTtJQUN4QixJQUFJRCxRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJQyxRQUFTO1FBQ3pDLE1BQU0sSUFBSUosTUFBTSxDQUFDLHNCQUFzQixFQUFFRyxNQUFNLFFBQVEsRUFBRUMsT0FBTyxDQUFDO0lBQ3JFO0lBQ0EsTUFBTUMsTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVIO0lBQU8sR0FBR0ksSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSUwsU0FBUyxHQUFHSyxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHTixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlKLFdBQVdNO0FBQzFCO0FBQ0EsU0FBU0ssT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSWQsV0FBV1ksRUFBRVAsTUFBTTtJQUNuQyxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUUsRUFBRVAsTUFBTSxFQUFFSyxJQUFLO1FBQy9CSSxHQUFHLENBQUNKLEVBQUUsR0FBR0UsQ0FBQyxDQUFDRixFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRTtJQUN4QjtJQUNBLE9BQU9JO0FBQ1g7QUFDQSxTQUFTQyxRQUFRQyxJQUFJO0lBQ2pC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S04sTUFBTUssVUFBVSxDQUFDSixXQUFXekIsQ0FBQyxDQUFDLEVBQUU7WUFDM0MsTUFBTStCLElBQUlILEdBQUdSLEdBQUcsQ0FBQ1UsSUFBSUUsYUFBYTtZQUNsQ0QsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO1FBQ0EseUNBQXlDO1FBQ3pDLHdFQUF3RTtRQUN4RUcsZUFBY3ZFLEdBQUcsRUFBRTBCLE9BQU87WUFDdEIsTUFBTVcsSUFBSWIsY0FBY3hCLEtBQUssR0FBRztnQkFBRSxHQUFHK0QsR0FBRztnQkFBRTlELEtBQUs4RCxJQUFJUyxTQUFTO2dCQUFFLEdBQUc5QyxPQUFPO1lBQUM7WUFDekUsTUFBTTBDLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3pCLENBQUMsQ0FBQyxFQUFFLEdBQUdnQyxhQUFhO1lBQzFERCxFQUFFRSxjQUFjO1lBQ2hCLE9BQU9GO1FBQ1g7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzP2QyNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZHN0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RTVCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3Igc3RyaW5nJyk7XG59XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoaXRlbSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuLy8gMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbi8vICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZ09yVWludDhBcnJheScsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzTnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB2YWxpZGF0ZURTVChfRFNUKTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIm1vZCIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRlRFNUIiwiZHN0IiwiVWludDhBcnJheSIsIkVycm9yIiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJzdHJ4b3IiLCJhIiwiYiIsImFyciIsImlzQnl0ZXMiLCJpdGVtIiwiaXNOdW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJjcmVhdGVIYXNoZXIiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSxzREFBc0Q7QUFDaUY7QUFDdkksa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU1KLE9BQU8sSUFBSUssTUFBTUwsT0FBTyxJQUFJTSxNQUFNTixPQUFPO0FBQ3JELGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNUCxPQUFPLElBQUlRLE9BQU9SLE9BQU87QUFDckMsd0JBQXdCO0FBQ2pCLFNBQVNTLElBQUlDLENBQUMsRUFBRUMsQ0FBQztJQUNwQixNQUFNQyxTQUFTRixJQUFJQztJQUNuQixPQUFPQyxVQUFVYixNQUFNYSxTQUFTRCxJQUFJQztBQUN4QztBQUNBOzs7OztDQUtDLEdBQ0Qsb0NBQW9DO0FBQzdCLFNBQVNDLElBQUlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLElBQUlBLFVBQVVqQixPQUFPZ0IsUUFBUWhCLEtBQ3pCLE1BQU0sSUFBSWtCLE1BQU07SUFDcEIsSUFBSUQsV0FBV2YsS0FDWCxPQUFPRjtJQUNYLElBQUltQixNQUFNakI7SUFDVixNQUFPYyxRQUFRaEIsSUFBSztRQUNoQixJQUFJZ0IsUUFBUWQsS0FDUmlCLE1BQU0sTUFBT0osTUFBT0U7UUFDeEJGLE1BQU0sTUFBT0EsTUFBT0U7UUFDcEJELFVBQVVkO0lBQ2Q7SUFDQSxPQUFPaUI7QUFDWDtBQUNBLDBEQUEwRDtBQUNuRCxTQUFTQyxLQUFLQyxDQUFDLEVBQUVMLEtBQUssRUFBRUMsTUFBTTtJQUNqQyxJQUFJRSxNQUFNRTtJQUNWLE1BQU9MLFVBQVVoQixJQUFLO1FBQ2xCbUIsT0FB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aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz8xNDE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbImJpdE1hc2siLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0J5dGVzTEUiLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsInZhbGlkYXRlT2JqZWN0IiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiXzVuIiwiXzhuIiwiXzluIiwiXzE2biIsIm1vZCIsImEiLCJiIiwicmVzdWx0IiwicG93IiwibnVtIiwicG93ZXIiLCJtb2R1bG8iLCJFcnJvciIsInJlcyIsInBvdzIiLCJ4IiwiaW52ZXJ0IiwibnVtYmVyIiwieSIsInUiLCJ2IiwicSIsInIiLCJtIiwibiIsImdjZCIsInRvbmVsbGlTaGFua3MiLCJQIiwibGVnZW5kcmVDIiwiUSIsIlMiLCJaIiwicDFkaXY0IiwidG9uZWxsaUZhc3QiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsIm5lZyIsIk9ORSIsImciLCJtdWwiLCJaRVJPIiwidDIiLCJnZSIsIkZwU3FydCIsInNxcnQzbW9kNCIsImMxIiwic3FydDVtb2Q4IiwibjIiLCJudiIsImkiLCJzdWIiLCJpc05lZ2F0aXZlTEUiLCJGSUVMRF9GSUVMRFMiLCJ2YWxpZGF0ZUZpZWxkIiwiZmllbGQiLCJpbml0aWFsIiwiT1JERVIiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsIkZwUG93IiwiZiIsInAiLCJkIiwiRnBJbnZlcnRCYXRjaCIsIm51bXMiLCJ0bXAiLCJBcnJheSIsImxlbmd0aCIsImxhc3RNdWx0aXBsaWVkIiwiYWNjIiwiaXMwIiwiaW52ZXJ0ZWQiLCJpbnYiLCJyZWR1Y2VSaWdodCIsIkZwRGl2IiwibGhzIiwicmhzIiwiRnBJc1NxdWFyZSIsImxlZ2VuZHJlQ29uc3QiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiRmllbGQiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsIk9iamVjdCIsImZyZWV6ZSIsImNyZWF0ZSIsImlzVmFsaWQiLCJpc09kZCIsImFkZCIsImRpdiIsInNxck4iLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJ0IiwiaW52ZXJ0QmF0Y2giLCJsc3QiLCJjbW92IiwiYyIsInRvQnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || val instanceof Uint8Array,\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n} // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLDBFQUEwRTtBQUMxRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLHVDQUF1QztBQUN2QyxNQUFNQSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNLENBQUNDLElBQU1BLGFBQWFDO0FBQ2hDLE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO0FBQy9GOztDQUVDLEdBQ00sU0FBU0MsV0FBV0MsS0FBSztJQUM1QixJQUFJLENBQUNaLElBQUlZLFFBQ0wsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUlJLE1BQU1OLE1BQU0sRUFBRUUsSUFBSztRQUNuQ00sT0FBT1gsS0FBSyxDQUFDUyxLQUFLLENBQUNKLEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9NO0FBQ1g7QUFDTyxTQUFTQyxvQkFBb0JDLEdBQUc7SUFDbkMsTUFBTUYsTUFBTUUsSUFBSVAsUUFBUSxDQUFDO0lBQ3pCLE9BQU9LLElBQUlSLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFUSxJQUFJLENBQUMsR0FBR0E7QUFDeEM7QUFDTyxTQUFTRyxZQUFZSCxHQUFHO0lBQzNCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUQsTUFBTSw4QkFBOEIsT0FBT0M7SUFDekQsYUFBYTtJQUNiLE9BQU9qQixPQUFPaUIsUUFBUSxLQUFLLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQztBQUMvQztBQUNBOztDQUVDLEdBQ00sU0FBU0ksV0FBV0osR0FBRztJQUMxQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlELE1BQU0sOEJBQThCLE9BQU9DO0lBQ3pELE1BQU1LLE1BQU1MLElBQUlSLE1BQU07SUFDdEIsSUFBSWEsTUFBTSxHQUNOLE1BQU0sSUFBSU4sTUFBTSw0REFBNERNO0lBQ2hGLE1BQU1DLFFBQVEsSUFBSWxCLFdBQVdpQixNQUFNO0lBQ25DLElBQUssSUFBSVgsSUFBSSxHQUFHQSxJQUFJWSxNQUFNZCxNQUFNLEVBQUVFLElBQUs7UUFDbkMsTUFBTWEsSUFBSWIsSUFBSTtRQUNkLE1BQU1jLFVBQVVSLElBQUlTLEtBQUssQ0FBQ0YsR0FBR0EsSUFBSTtRQUNqQyxNQUFNRyxPQUFPQyxPQUFPQyxRQUFRLENBQUNKLFNBQVM7UUFDdEMsSUFBSUcsT0FBT0UsS0FBSyxDQUFDSCxTQUFTQSxPQUFPLEdBQzdCLE1BQU0sSUFBSVgsTUFBTTtRQUNwQk8sS0FBSyxDQUFDWixFQUFFLEdBQUdnQjtJQUNmO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLG9DQUFvQztBQUM3QixTQUFTUSxnQkFBZ0JoQixLQUFLO0lBQ2pDLE9BQU9LLFlBQVlOLFdBQVdDO0FBQ2xDO0FBQ08sU0FBU2lCLGdCQUFnQmpCLEtBQUs7SUFDakMsSUFBSSxDQUFDWixJQUFJWSxRQUNMLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixPQUFPSSxZQUFZTixXQUFXVCxXQUFXRyxJQUFJLENBQUNPLE9BQU9rQixPQUFPO0FBQ2hFO0FBQ08sU0FBU0MsZ0JBQWdCQyxDQUFDLEVBQUViLEdBQUc7SUFDbEMsT0FBT0QsV0FBV2MsRUFBRXZCLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUNTLE1BQU0sR0FBRztBQUN2RDtBQUNPLFNBQVNjLGdCQUFnQkQsQ0FBQyxFQUFFYixHQUFHO0lBQ2xDLE9BQU9ZLGdCQUFnQkMsR0FBR2IsS0FBS1csT0FBTztBQUMxQztBQUNBLHdCQUF3QjtBQUNqQixTQUFTSSxtQkFBbUJGLENBQUM7SUFDaEMsT0FBT2QsV0FBV0gsb0JBQW9CaUI7QUFDMUM7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNHLFlBQVlDLEtBQUssRUFBRXRCLEdBQUcsRUFBRXVCLGNBQWM7SUFDbEQsSUFBSUM7SUFDSixJQUFJLE9BQU94QixRQUFRLFVBQVU7UUFDekIsSUFBSTtZQUNBd0IsTUFBTXBCLFdBQVdKO1FBQ3JCLEVBQ0EsT0FBT3lCLEdBQUc7WUFDTixNQUFNLElBQUkxQixNQUFNLENBQUMsRUFBRXVCLE1BQU0sZ0NBQWdDLEVBQUV0QixJQUFJLFVBQVUsRUFBRXlCLEVBQUUsQ0FBQztRQUNsRjtJQUNKLE9BQ0ssSUFBSXZDLElBQUljLE1BQU07UUFDZixtRUFBbUU7UUFDbkUsc0VBQXNFO1FBQ3RFd0IsTUFBTXBDLFdBQVdHLElBQUksQ0FBQ1M7SUFDMUIsT0FDSztRQUNELE1BQU0sSUFBSUQsTUFBTSxDQUFDLEVBQUV1QixNQUFNLGlDQUFpQyxDQUFDO0lBQy9EO0lBQ0EsTUFBTWpCLE1BQU1tQixJQUFJaEMsTUFBTTtJQUN0QixJQUFJLE9BQU8rQixtQkFBbUIsWUFBWWxCLFFBQVFrQixnQkFDOUMsTUFBTSxJQUFJeEIsTUFBTSxDQUFDLEVBQUV1QixNQUFNLFVBQVUsRUFBRUMsZUFBZSxZQUFZLEVBQUVsQixJQUFJLENBQUM7SUFDM0UsT0FBT21CO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNFLFlBQVksR0FBR0MsTUFBTTtJQUNqQyxNQUFNQyxJQUFJLElBQUl4QyxXQUFXdUMsT0FBT0UsTUFBTSxDQUFDLENBQUNDLEtBQUszQyxJQUFNMkMsTUFBTTNDLEVBQUVLLE1BQU0sRUFBRTtJQUNuRSxJQUFJdUMsTUFBTSxHQUFHLHVEQUF1RDtJQUNwRUosT0FBT0ssT0FBTyxDQUFDLENBQUM3QztRQUNaLElBQUksQ0FBQ0QsSUFBSUMsSUFDTCxNQUFNLElBQUlZLE1BQU07UUFDcEI2QixFQUFFSyxHQUFHLENBQUM5QyxHQUFHNEM7UUFDVEEsT0FBTzVDLEVBQUVLLE1BQU07SUFDbkI7SUFDQSxPQUFPb0M7QUFDWDtBQUNPLFNBQVNNLFdBQVdDLEVBQUUsRUFBRUMsRUFBRTtJQUM3QiwwQ0FBMEM7SUFDMUMsSUFBSUQsR0FBRzNDLE1BQU0sS0FBSzRDLEdBQUc1QyxNQUFNLEVBQ3ZCLE9BQU87SUFDWCxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSXlDLEdBQUczQyxNQUFNLEVBQUVFLElBQzNCLElBQUl5QyxFQUFFLENBQUN6QyxFQUFFLEtBQUswQyxFQUFFLENBQUMxQyxFQUFFLEVBQ2YsT0FBTztJQUNmLE9BQU87QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBUzJDLFlBQVlDLEdBQUc7SUFDM0IsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJdkMsTUFBTSxDQUFDLGlDQUFpQyxFQUFFLE9BQU91QyxJQUFJLENBQUM7SUFDcEUsT0FBTyxJQUFJbEQsV0FBVyxJQUFJbUQsY0FBY0MsTUFBTSxDQUFDRixPQUFPLDRCQUE0QjtBQUN0RjtBQUNBLGlCQUFpQjtBQUNqQjs7O0NBR0MsR0FDTSxTQUFTRyxPQUFPdkIsQ0FBQztJQUNwQixJQUFJYjtJQUNKLElBQUtBLE1BQU0sR0FBR2EsSUFBSXBDLEtBQUtvQyxNQUFNbEMsS0FBS3FCLE9BQU87SUFFekMsT0FBT0E7QUFDWDtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTcUMsT0FBT3hCLENBQUMsRUFBRXlCLEdBQUc7SUFDekIsT0FBTyxLQUFNNUQsT0FBTzRELE9BQVEzRDtBQUNoQztBQUNBOztDQUVDLEdBQ00sTUFBTTRELFNBQVMsQ0FBQzFCLEdBQUd5QixLQUFLRTtJQUMzQixPQUFPM0IsSUFBSyxDQUFDMkIsUUFBUTdELE1BQU1GLEdBQUUsS0FBTUMsT0FBTzREO0FBQzlDLEVBQUU7QUFDRjs7O0NBR0MsR0FDTSxNQUFNRyxVQUFVLENBQUM1QixJQUFNLENBQUNqQyxPQUFPRixPQUFPbUMsSUFBSSxFQUFDLElBQUtsQyxJQUFJO0FBQzNELE9BQU87QUFDUCxNQUFNK0QsTUFBTSxDQUFDQyxPQUFTLElBQUk1RCxXQUFXNEQsT0FBTyxxQkFBcUI7QUFDakUsTUFBTUMsT0FBTyxDQUFDQyxNQUFROUQsV0FBV0csSUFBSSxDQUFDMkQsTUFBTSxtQkFBbUI7QUFDL0Q7Ozs7OztDQU1DLEdBQ00sU0FBU0MsZUFBZUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLE1BQU07SUFDcEQsSUFBSSxPQUFPRixZQUFZLFlBQVlBLFVBQVUsR0FDekMsTUFBTSxJQUFJckQsTUFBTTtJQUNwQixJQUFJLE9BQU9zRCxhQUFhLFlBQVlBLFdBQVcsR0FDM0MsTUFBTSxJQUFJdEQsTUFBTTtJQUNwQixJQUFJLE9BQU91RCxXQUFXLFlBQ2xCLE1BQU0sSUFBSXZELE1BQU07SUFDcEIsZ0RBQWdEO0lBQ2hELElBQUl3RCxJQUFJUixJQUFJSyxVQUFVLHFFQUFxRTtJQUMzRixJQUFJSSxJQUFJVCxJQUFJSyxVQUFVLHFFQUFxRTtJQUMzRixJQUFJMUQsSUFBSSxHQUFHLGdEQUFnRDtJQUMzRCxNQUFNK0QsUUFBUTtRQUNWRixFQUFFRyxJQUFJLENBQUM7UUFDUEYsRUFBRUUsSUFBSSxDQUFDO1FBQ1BoRSxJQUFJO0lBQ1I7SUFDQSxNQUFNaUUsSUFBSSxDQUFDLEdBQUdDLElBQU1OLE9BQU9FLEdBQUdELE1BQU1LLElBQUksd0JBQXdCO0lBQ2hFLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBT2YsS0FBSztRQUN4Qix5Q0FBeUM7UUFDekNTLElBQUlHLEVBQUVWLEtBQUs7WUFBQztTQUFLLEdBQUdhLE9BQU8sbUNBQW1DO1FBQzlEUCxJQUFJSSxLQUFLLG1CQUFtQjtRQUM1QixJQUFJRyxLQUFLdEUsTUFBTSxLQUFLLEdBQ2hCO1FBQ0pnRSxJQUFJRyxFQUFFVixLQUFLO1lBQUM7U0FBSyxHQUFHYSxPQUFPLG1DQUFtQztRQUM5RFAsSUFBSUksS0FBSyxtQkFBbUI7SUFDaEM7SUFDQSxNQUFNSSxNQUFNO1FBQ1IsZ0NBQWdDO1FBQ2hDLElBQUlyRSxPQUFPLE1BQ1AsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCLElBQUlNLE1BQU07UUFDVixNQUFNMkQsTUFBTSxFQUFFO1FBQ2QsTUFBTzNELE1BQU1nRCxTQUFVO1lBQ25CRSxJQUFJSTtZQUNKLE1BQU1NLEtBQUtWLEVBQUU5QyxLQUFLO1lBQ2xCdUQsSUFBSUUsSUFBSSxDQUFDRDtZQUNUNUQsT0FBT2tELEVBQUUvRCxNQUFNO1FBQ25CO1FBQ0EsT0FBT2tDLGVBQWVzQztJQUMxQjtJQUNBLE1BQU1HLFdBQVcsQ0FBQ0wsTUFBTU07UUFDcEJYO1FBQ0FJLE9BQU9DLE9BQU8sWUFBWTtRQUMxQixJQUFJdEMsTUFBTTZDLFdBQVcsdUNBQXVDO1FBQzVELE1BQU8sQ0FBRTdDLENBQUFBLE1BQU00QyxLQUFLTCxNQUFLLEVBQ3JCRjtRQUNKSjtRQUNBLE9BQU9qQztJQUNYO0lBQ0EsT0FBTzJDO0FBQ1g7QUFDQSwrQkFBK0I7QUFDL0IsTUFBTUcsZUFBZTtJQUNqQkMsUUFBUSxDQUFDQyxNQUFRLE9BQU9BLFFBQVE7SUFDaENDLFVBQVUsQ0FBQ0QsTUFBUSxPQUFPQSxRQUFRO0lBQ2xDRSxTQUFTLENBQUNGLE1BQVEsT0FBT0EsUUFBUTtJQUNqQ0csUUFBUSxDQUFDSCxNQUFRLE9BQU9BLFFBQVE7SUFDaENJLG9CQUFvQixDQUFDSixNQUFRLE9BQU9BLFFBQVEsWUFBWUEsZUFBZXBGO0lBQ3ZFeUYsZUFBZSxDQUFDTCxNQUFRN0QsT0FBT2tFLGFBQWEsQ0FBQ0w7SUFDN0NsRSxPQUFPLENBQUNrRSxNQUFRbEYsTUFBTXdGLE9BQU8sQ0FBQ047SUFDOUJPLE9BQU8sQ0FBQ1AsS0FBS1EsU0FBV0EsT0FBT0MsRUFBRSxDQUFDQyxPQUFPLENBQUNWO0lBQzFDVyxNQUFNLENBQUNYLE1BQVEsT0FBT0EsUUFBUSxjQUFjN0QsT0FBT2tFLGFBQWEsQ0FBQ0wsSUFBSVksU0FBUztBQUNsRjtBQUNBLHdFQUF3RTtBQUNqRSxTQUFTQyxlQUFlTCxNQUFNLEVBQUVNLFVBQVUsRUFBRUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNqRSxNQUFNQyxhQUFhLENBQUNDLFdBQVdDLE1BQU1DO1FBQ2pDLE1BQU1DLFdBQVd0QixZQUFZLENBQUNvQixLQUFLO1FBQ25DLElBQUksT0FBT0UsYUFBYSxZQUNwQixNQUFNLElBQUk3RixNQUFNLENBQUMsbUJBQW1CLEVBQUUyRixLQUFLLG9CQUFvQixDQUFDO1FBQ3BFLE1BQU1sQixNQUFNUSxNQUFNLENBQUNTLFVBQVU7UUFDN0IsSUFBSUUsY0FBY25CLFFBQVFILFdBQ3RCO1FBQ0osSUFBSSxDQUFDdUIsU0FBU3BCLEtBQUtRLFNBQVM7WUFDeEIsTUFBTSxJQUFJakYsTUFBTSxDQUFDLGNBQWMsRUFBRThGLE9BQU9KLFdBQVcsQ0FBQyxFQUFFakIsSUFBSSxFQUFFLEVBQUUsT0FBT0EsSUFBSSxZQUFZLEVBQUVrQixLQUFLLENBQUM7UUFDakc7SUFDSjtJQUNBLEtBQUssTUFBTSxDQUFDRCxXQUFXQyxLQUFLLElBQUlJLE9BQU9DLE9BQU8sQ0FBQ1QsWUFDM0NFLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSUksT0FBT0MsT0FBTyxDQUFDUixlQUMzQ0MsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxPQUFPVjtBQUNYLEVBQ0Esc0JBQXNCO0NBQ3RCLHVFQUF1RTtDQUN2RSxnRkFBZ0Y7Q0FDaEYsNEJBQTRCO0NBQzVCLDJEQUEyRDtDQUMzRCxxRUFBcUU7Q0FDckUsK0RBQStEO0NBQy9ELDREQUE0RDtDQUM1RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzM4NzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwidThhIiwiYSIsIlVpbnQ4QXJyYXkiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsIkVycm9yIiwiaGV4IiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsIm51bSIsImhleFRvTnVtYmVyIiwiaGV4VG9CeXRlcyIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXNCRSIsIm4iLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsInRpdGxlIiwiZXhwZWN0ZWRMZW5ndGgiLCJyZXMiLCJlIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJyIiwicmVkdWNlIiwic3VtIiwicGFkIiwiZm9yRWFjaCIsInNldCIsImVxdWFsQnl0ZXMiLCJiMSIsImIyIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJpdExlbiIsImJpdEdldCIsInBvcyIsImJpdFNldCIsInZhbHVlIiwiYml0TWFzayIsInU4biIsImRhdGEiLCJ1OGZyIiwiYXJyIiwiY3JlYXRlSG1hY0RyYmciLCJoYXNoTGVuIiwicUJ5dGVMZW4iLCJobWFjRm4iLCJ2IiwiayIsInJlc2V0IiwiZmlsbCIsImgiLCJiIiwicmVzZWVkIiwic2VlZCIsImdlbiIsIm91dCIsInNsIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInVuZGVmaW5lZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiT2JqZWN0IiwiZW50cmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (key instanceof Uint8Array) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSw0REFBNEQ7QUFDeEI7QUFDSDtBQUNRO0FBQ1E7QUFDakQsU0FBU0ssa0JBQWtCQyxLQUFLO0lBQzVCLE1BQU1DLE9BQU9ILHdEQUFhQSxDQUFDRTtJQUMzQkwscURBQWlCLENBQUNNLE1BQU07UUFDcEJFLEdBQUc7UUFDSEMsR0FBRztJQUNQLEdBQUc7UUFDQ0MsMEJBQTBCO1FBQzFCQyxnQkFBZ0I7UUFDaEJDLGVBQWU7UUFDZkMsZUFBZTtRQUNmQyxvQkFBb0I7UUFDcEJDLFdBQVc7UUFDWEMsU0FBUztJQUNiO0lBQ0EsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRVYsQ0FBQyxFQUFFLEdBQUdGO0lBQ3hCLElBQUlXLE1BQU07UUFDTixJQUFJLENBQUNDLEdBQUdDLEdBQUcsQ0FBQ1gsR0FBR1UsR0FBR0UsSUFBSSxHQUFHO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBT0osU0FBUyxZQUNoQixPQUFPQSxLQUFLSyxJQUFJLEtBQUssWUFDckIsT0FBT0wsS0FBS00sV0FBVyxLQUFLLFlBQVk7WUFDeEMsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPRyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHbkIsSUFBSTtJQUFDO0FBQ25DO0FBQ0EsK0JBQStCO0FBQy9CLE1BQU0sRUFBRW9CLGlCQUFpQkMsR0FBRyxFQUFFQyxZQUFZQyxHQUFHLEVBQUUsR0FBRzdCLHNDQUFFQTtBQUM3QyxNQUFNOEIsTUFBTTtJQUNmLDJCQUEyQjtJQUMzQkMsS0FBSyxNQUFNQyxlQUFlWDtRQUN0QlksWUFBWUMsSUFBSSxFQUFFLENBQUU7WUFDaEIsS0FBSyxDQUFDQTtRQUNWO0lBQ0o7SUFDQUMsV0FB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SSxxQ0FBcUM7UUFDekQxTyxJQUFJNUQsR0FBR29FLEdBQUcsQ0FBQ1IsR0FBR29QLFFBQVEsbUJBQW1CO1FBQ3pDclAsSUFBSTNELEdBQUc2UyxJQUFJLENBQUNsUCxHQUFHOE8sS0FBSzlNLFVBQVUsd0NBQXdDO1FBQ3RFL0IsSUFBSTVELEdBQUc2UyxJQUFJLENBQUNqUCxHQUFHb1AsT0FBT3JOLFVBQVUsdUNBQXVDO1FBQ3ZFLE1BQU1vTixLQUFLL1MsR0FBR29ILEtBQUssQ0FBQ2tMLE9BQU90UyxHQUFHb0gsS0FBSyxDQUFDeEQsSUFBSSwrQkFBK0I7UUFDdkVBLElBQUk1RCxHQUFHNlMsSUFBSSxDQUFDN1MsR0FBRytILEdBQUcsQ0FBQ25FLElBQUlBLEdBQUdtUCxLQUFLLDRCQUE0QjtRQUMzRHBQLElBQUkzRCxHQUFHdVQsR0FBRyxDQUFDNVAsR0FBR2dQLE1BQU0sb0JBQW9CO1FBQ3hDLE9BQU87WUFBRWhQO1lBQUdDO1FBQUU7SUFDbEI7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/ZWY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyB3cm9uZyByZXByZXNlbnRhdGlvbiBvZiBaRVJPIGFuZCBpcyBhbHdheXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAodGhpcy5weSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBhc3NlcnRHRShuKTsgLy8gV2lsbCB0aHJvdyBvbiAwXG4gICAgICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICghZW5kbylcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4pO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJtb2QiLCJ1dCIsImVuc3VyZUJ5dGVzIiwid05BRiIsInZhbGlkYXRlQmFzaWMiLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwib3B0cyIsInZhbGlkYXRlT2JqZWN0IiwiYSIsImIiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJ3cmFwUHJpdmF0ZUtleSIsImlzVG9yc2lvbkZyZWUiLCJjbGVhckNvZmFjdG9yIiwiYWxsb3dJbmZpbml0eVBvaW50IiwiZnJvbUJ5dGVzIiwidG9CeXRlcyIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsIk9iamVjdCIsImZyZWV6ZSIsImJ5dGVzVG9OdW1iZXJCRSIsImIybiIsImhleFRvQnl0ZXMiLCJoMmIiLCJERVIiLCJFcnIiLCJERVJFcnIiLCJjb25zdHJ1Y3RvciIsIm0iLCJfcGFyc2VJbnQiLCJkYXRhIiwiRSIsImxlbmd0aCIsImxlbiIsInJlcyIsInN1YmFycmF5IiwiZCIsImwiLCJ0b1NpZyIsImhleCIsIlVpbnQ4QXJyYXkiLCJyIiwic0J5dGVzIiwicyIsInJCeXRlc0xlZnQiLCJoZXhGcm9tU2lnIiwic2lnIiwic2xpY2UiLCJOdW1iZXIiLCJwYXJzZUludCIsImgiLCJudW0iLCJ0b1N0cmluZyIsInNobCIsInJobCIsInNsIiwicmwiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiX2MiLCJwb2ludCIsIl9pc0NvbXByZXNzZWQiLCJ0b0FmZmluZSIsImNvbmNhdEJ5dGVzIiwiZnJvbSIsIngiLCJ5IiwiYnl0ZXMiLCJ0YWlsIiwiQllURVMiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsIkd5IiwiR3giLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJuIiwiYXNzZXJ0R0UiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiYnl0ZXNUb0hleCIsImluY2x1ZGVzIiwicGFkU3RhcnQiLCJlcnJvciIsInBvaW50UHJlY29tcHV0ZXMiLCJNYXAiLCJhc3NlcnRQcmpQb2ludCIsIm90aGVyIiwiUG9pbnQiLCJweCIsInB5IiwicHoiLCJpc1ZhbGlkIiwiZnJvbUFmZmluZSIsInAiLCJpczAiLCJpIiwiT05FIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwiaW52ZXJ0QmF0Y2giLCJtYXAiLCJmcm9tSGV4IiwiUCIsImFzc2VydFZhbGlkaXR5IiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiQkFTRSIsIm11bHRpcGx5IiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwiX1dJTkRPV19TSVpFIiwiZGVsZXRlIiwibGVmdCIsInJpZ2h0IiwiaGFzRXZlblkiLCJpc09kZCIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIlUxIiwiVTIiLCJuZWdhdGUiLCJuZWciLCJkb3VibGUiLCJiMyIsIlgzIiwiWTMiLCJaMyIsInQwIiwidDEiLCJ0MiIsInQzIiwic3ViIiwidDQiLCJ0NSIsInN1YnRyYWN0Iiwid25hZiIsIndOQUZDYWNoZWQiLCJjb21wIiwibXVsdGlwbHlVbnNhZmUiLCJJIiwidW5zYWZlTGFkZGVyIiwiazFuZWciLCJrMSIsImsybmVnIiwiazIiLCJrMXAiLCJrMnAiLCJzY2FsYXIiLCJmYWtlIiwiZiIsImYxcCIsImYycCIsImNvbnN0VGltZU5lZ2F0ZSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwiUSIsIkciLCJzdW0iLCJ1bmRlZmluZWQiLCJpeiIsInoiLCJpbnYiLCJheCIsImF5IiwienoiLCJjb2ZhY3RvciIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJ0b0hleCIsIl9iaXRzIiwibkJpdExlbmd0aCIsIk1hdGgiLCJjZWlsIiwiUHJvamVjdGl2ZVBvaW50IiwidmFsaWRhdGVPcHRzIiwiaGFzaCIsImhtYWMiLCJyYW5kb21CeXRlcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsImxvd1MiLCJ3ZWllcnN0cmFzcyIsImN1cnZlRGVmIiwiQ1VSVkVfT1JERVIiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwiaXNWYWxpZEZpZWxkRWxlbWVudCIsIk9SREVSIiwibW9kTiIsImludk4iLCJpbnZlcnQiLCJjYXQiLCJoZWFkIiwieTIiLCJzcXJ0IiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwibnVtVG9OQnl0ZVN0ciIsIm51bWJlclRvQnl0ZXNCRSIsImlzQmlnZ2VyVGhhbkhhbGZPcmRlciIsIm51bWJlciIsIkhBTEYiLCJub3JtYWxpemVTIiwic2xjTnVtIiwidG8iLCJTaWduYXR1cmUiLCJyZWNvdmVyeSIsImZyb21Db21wYWN0IiwiZnJvbURFUiIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsInByZWhhc2giLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsImNyZWF0ZUhtYWNEcmJnIiwib3V0cHV0TGVuIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5Iiwic2ciLCJfc2lnIiwiZGVyRXJyb3IiLCJtZXNzYWdlIiwiaXMiLCJ2IiwiU1dVRnBTcXJ0UmF0aW8iLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJwb3ciLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInZhbHVlIiwieTEiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwidmFsaWRhdGVGaWVsZCIsIkEiLCJCIiwidHY2IiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r)) return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    } catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDdEI7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQsTUFBTWEsYUFBYUMsT0FBTztBQUMxQixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxhQUFhLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0QsSUFBSUMsSUFBSUgsR0FBRSxJQUFLRztBQUM3Qzs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsTUFBTUMsSUFBSVY7SUFDVixrQkFBa0I7SUFDbEIsTUFBTVcsTUFBTVYsT0FBTyxJQUFJVyxNQUFNWCxPQUFPLElBQUlZLE9BQU9aLE9BQU8sS0FBS2EsT0FBT2IsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTWMsT0FBT2QsT0FBTyxLQUFLZSxPQUFPZixPQUFPLEtBQUtnQixPQUFPaEIsT0FBTztJQUMxRCxNQUFNaUIsS0FBSyxJQUFLVCxJQUFJQSxJQUFLQyxHQUFHLFVBQVU7SUFDdEMsTUFBTVMsS0FBSyxLQUFNRCxLQUFLVCxJQUFLQyxHQUFHLE1BQU07SUFDcEMsTUFBTVUsS0FBSywyREFBTUQsSUFBSVIsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVcsS0FBSywyREFBTUQsSUFBSVQsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVksTUFBTSwyREFBTUQsSUFBSWpCLEtBQUtNLEtBQUtRLEtBQU1SO0lBQ3RDLE1BQU1hLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1ILEtBQUtZLE1BQU9aO0lBQ3pDLE1BQU1jLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1KLEtBQUthLE1BQU9iO0lBQ3pDLE1BQU1lLE1BQU0sMkRBQU1ELEtBQUtSLE1B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LE9BQU9WLE9BQU90RSxHQUFHbkQ7SUFDckIsR0FBRztRQUNDb0ksS0FBSztRQUNMQyxXQUFXO1FBQ1hwRCxHQUFHMUQsR0FBRytHLEtBQUs7UUFDWHRDLEdBQUc7UUFDSDFELEdBQUc7UUFDSGlHLFFBQVE7UUFDUkMsTUFBTTlKLHdEQUFNQTtJQUNoQixFQUFDO0FBQ00sTUFBTStKLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxJQUFJTyxXQUFXLElBQUk7QUFDOUQsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixJQUFJUSxhQUFhLElBQUksQ0FDekUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/ZjQ1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJGaWVsZCIsIm1vZCIsInBvdzIiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJjcmVhdGVDdXJ2ZSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnAiLCJlcWwiLCJzcXIiLCJFcnJvciIsInVuZGVmaW5lZCIsInNxcnQiLCJzZWNwMjU2azEiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJrMiIsImsxbmVnIiwiazJuZWciLCJfMG4iLCJmZSIsIngiLCJnZSIsIlRBR0dFRF9IQVNIX1BSRUZJWEVTIiwidGFnZ2VkSGFzaCIsInRhZyIsIm1lc3NhZ2VzIiwidGFnUCIsInRhZ0giLCJVaW50OEFycmF5IiwiZnJvbSIsImMiLCJjaGFyQ29kZUF0IiwicG9pbnRUb0J5dGVzIiwicG9pbnQiLCJ0b1Jhd0J5dGVzIiwic2xpY2UiLCJudW1UbzMyYiIsIm1vZFAiLCJtb2ROIiwiUG9pbnQiLCJQcm9qZWN0aXZlUG9pbnQiLCJHbXVsQWRkIiwiUSIsIkJBU0UiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInNjaG5vcnJHZXRFeHRQdWJLZXkiLCJwcml2IiwiZF8iLCJ1dGlscyIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJwIiwiZnJvbVByaXZhdGVLZXkiLCJzY2FsYXIiLCJoYXNFdmVuWSIsImJ5dGVzIiwibGlmdF94IiwieHgiLCJhc3NlcnRWYWxpZGl0eSIsImNoYWxsZW5nZSIsImFyZ3MiLCJzY2hub3JyR2V0UHVibGljS2V5IiwicHJpdmF0ZUtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJrXyIsInJ4IiwiZSIsInNpZyIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJzY2hub3JyIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsInZlcmlmeSIsInJhbmRvbVByaXZhdGVLZXkiLCJpc29NYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxPQUFPQyxDQUFDO0lBQ2IsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLENBQUMsd0JBQXdCLEVBQUVILEVBQUUsQ0FBQztBQUN0RDtBQUNBLFNBQVNJLEtBQUtDLENBQUM7SUFDWCxJQUFJLE9BQU9BLE1BQU0sV0FDYixNQUFNLElBQUlGLE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUUsRUFBRSxDQUFDO0FBQ3BEO0FBQ0EsU0FBU0MsTUFBTUQsQ0FBQyxFQUFFLEdBQUdFLE9BQU87SUFDeEIsSUFBSSxDQUFFRixDQUFBQSxhQUFhRyxVQUFTLEdBQ3hCLE1BQU0sSUFBSUwsTUFBTTtJQUNwQixJQUFJSSxRQUFRRSxNQUFNLEdBQUcsS0FBSyxDQUFDRixRQUFRRyxRQUFRLENBQUNMLEVBQUVJLE1BQU0sR0FDaEQsTUFBTSxJQUFJTixNQUFNLENBQUMsOEJBQThCLEVBQUVJLFFBQVEsZ0JBQWdCLEVBQUVGLEVBQUVJLE1BQU0sQ0FBQyxDQUFDO0FBQzdGO0FBQ0EsU0FBU0UsS0FBS0EsSUFBSTtJQUNkLElBQUksT0FBT0EsU0FBUyxjQUFjLE9BQU9BLEtBQUtDLE1BQU0sS0FBSyxZQUNyRCxNQUFNLElBQUlULE1BQU07SUFDcEJKLE9BQU9ZLEtBQUtFLFNBQVM7SUFDckJkLE9BQU9ZLEtBQUtHLFFBQVE7QUFDeEI7QUFDQSxTQUFTQyxPQUFPQyxRQUFRLEVBQUVDLGdCQUFnQixJQUFJO0lBQzFDLElBQUlELFNBQVNFLFNBQVMsRUFDbEIsTUFBTSxJQUFJZixNQUFNO0lBQ3BCLElBQUljLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUloQixNQUFNO0FBQ3hCO0FBQ0EsU0FBU2lCLE9BQU9DLEdBQUcsRUFBRUwsUUFBUTtJQUN6QlYsTUFBTWU7SUFDTixNQUFNQyxNQUFNTixTQUFTSCxTQUFTO0lBQzlCLElBQUlRLElBQUlaLE1BQU0sR0FBR2EsS0FBSztRQUNsQixNQUFNLElBQUluQixNQUFNLENBQUMsc0RBQXNELEVBQUVtQixJQUFJLENBQUM7SUFDbEY7QUFDSjtBQUNxRDtBQUNyRCxNQUFNQyxTQUFTO0lBQUV4QjtJQUFRSztJQUFNRTtJQUFPSztJQUFNSTtJQUFRSztBQUFPO0FBQzNELGlFQUFlRyxNQUFNQSxFQUFDLENBQ3RCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcz9kMzUyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbIm51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJib29sIiwiYiIsImJ5dGVzIiwibGVuZ3RocyIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImhhc2giLCJjcmVhdGUiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImV4aXN0cyIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwib3V0cHV0Iiwib3V0IiwibWluIiwiYXNzZXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n} //# sourceMappingURL=_sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RCx5QkFBeUI7QUFDekIsU0FBU0ssYUFBYUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUMvQyxJQUFJLE9BQU9ILEtBQUtELFlBQVksS0FBSyxZQUM3QixPQUFPQyxLQUFLRCxZQUFZLENBQUNFLFlBQVlDLE9BQU9DO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9OLFFBQVFJO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVMsR0FBR0gsSUFBSUo7SUFDbkNILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVUsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSw2QkFBNkI7QUFDdEIsTUFBTVUsYUFBYWpCLDJDQUFJQTtJQUMxQmtCLFlBQVlDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVkLElBQUksQ0FBRTtRQUM5QyxLQUFLO1FBQ0wsSUFBSSxDQUFDWSxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDZCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDZSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlDLFdBQVdSO1FBQzdCLElBQUksQ0FBQ2YsSUFBSSxHQUFHSCxxREFBVUEsQ0FBQyxJQUFJLENBQUN5QixNQUFNO0lBQ3RDO0lBQ0FFLE9BQU9DLElBQUksRUFBRTtRQUNUL0Isa0RBQU1BLENBQUMsSUFBSTtRQUNYLE1BQU0sRUFBRU0sSUFBSSxFQUFFc0IsTUFBTSxFQUFFUCxRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQ3ZDVSxPQUFPM0Isa0RBQU9BLENBQUMyQjtRQUNmLE1BQU1DLE1BQU1ELEtBQUtOLE1BQU07UUFDdkIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1NLEtBQU07WUFDMUIsTUFBTUMsT0FBT0MsS0FBS0MsR0FBRyxDQUFDZCxXQUFXLElBQUksQ0FBQ0ssR0FBRyxFQUFFTSxNQUFNTjtZQUNqRCw4RUFBOEU7WUFDOUUsSUFBSU8sU0FBU1osVUFBVTtnQkFDbkIsTUFBTWUsV0FBV2pDLHFEQUFVQSxDQUFDNEI7Z0JBQzVCLE1BQU9WLFlBQVlXLE1BQU1OLEtBQUtBLE9BQU9MLFNBQ2pDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ0QsVUFBVVY7Z0JBQzNCO1lBQ0o7WUFDQUUsT0FBT1UsR0FBRyxDQUFDUCxLQUFLUSxRQUFRLENBQUNiLEtBQUtBLE1BQU1PLE9BQU8sSUFBSSxDQUFDUCxHQUFHO1lBQ25ELElBQUksQ0FBQ0EsR0FBRyxJQUFJTztZQUNaUCxPQUFPTztZQUNQLElBQUksSUFBSSxDQUFDUCxHQUFHLEtBQUtMLFVBQVU7Z0JBQ3ZCLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQy9CLE1BQU07Z0JBQ25CLElBQUksQ0FBQ29CLEdBQUcsR0FBRztZQUNmO1FBQ0o7UUFDQSxJQUFJLENBQUNELE1BQU0sSUFBSU0sS0FBS04sTUFBTTtRQUMxQixJQUFJLENBQUNlLFVBQVU7UUFDZixPQUFPLElBQUk7SUFDZjtJQUNBQyxXQUFXQyxHQUFHLEVBQUU7UUFDWjFDLGtEQUFNQSxDQUFDLElBQUk7UUFDWEMsa0RBQU1BLENBQUN5QyxLQUFLLElBQUk7UUFDaEIsSUFBSSxDQUFDbEIsUUFBUSxHQUFHO1FBQ2hCLFVBQVU7UUFDVixpRUFBaUU7UUFDakUsc0VBQXNFO1FBQ3RFLE1BQU0sRUFBRUksTUFBTSxFQUFFdEIsSUFBSSxFQUFFZSxRQUFRLEVBQUVaLElBQUksRUFBRSxHQUFHLElBQUk7UUFDN0MsSUFBSSxFQUFFaUIsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNsQixvQ0FBb0M7UUFDcENFLE1BQU0sQ0FBQ0YsTUFBTSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0UsTUFBTSxDQUFDVyxRQUFRLENBQUNiLEtBQUtpQixJQUFJLENBQUM7UUFDL0Isc0hBQXNIO1FBQ3RILElBQUksSUFBSSxDQUFDcEIsU0FBUyxHQUFHRixXQUFXSyxLQUFLO1lBQ2pDLElBQUksQ0FBQ1csT0FBTyxDQUFDL0IsTUFBTTtZQUNuQm9CLE1BQU07UUFDVjtRQUNBLHVDQUF1QztRQUN2QyxJQUFLLElBQUlrQixJQUFJbEIsS0FBS2tCLElBQUl2QixVQUFVdUIsSUFDNUJoQixNQUFNLENBQUNnQixFQUFFLEdBQUc7UUFDaEIsZ0dBQWdHO1FBQ2hHLG9GQUFvRjtRQUNwRixpREFBaUQ7UUFDakR2QyxhQUFhQyxNQUFNZSxXQUFXLEdBQUdWLE9BQU8sSUFBSSxDQUFDYyxNQUFNLEdBQUcsSUFBSWhCO1FBQzFELElBQUksQ0FBQzRCLE9BQU8sQ0FBQy9CLE1BQU07UUFDbkIsTUFBTXVDLFFBQVExQyxxREFBVUEsQ0FBQ3VDO1FBQ3pCLE1BQU1WLE1BQU0sSUFBSSxDQUFDVixTQUFTO1FBQzFCLHlGQUF5RjtRQUN6RixJQUFJVSxNQUFNLEdBQ04sTUFBTSxJQUFJYyxNQUFNO1FBQ3BCLE1BQU1DLFNBQVNmLE1BQU07UUFDckIsTUFBTWdCLFFBQVEsSUFBSSxDQUFDQyxHQUFHO1FBQ3RCLElBQUlGLFNBQVNDLE1BQU12QixNQUFNLEVBQ3JCLE1BQU0sSUFBSXFCLE1BQU07UUFDcEIsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlHLFFBQVFILElBQ3hCQyxNQUFNM0IsU0FBUyxDQUFDLElBQUkwQixHQUFHSSxLQUFLLENBQUNKLEVBQUUsRUFBRW5DO0lBQ3pDO0lBQ0F5QyxTQUFTO1FBQ0wsTUFBTSxFQUFFdEIsTUFBTSxFQUFFTixTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ2xDLElBQUksQ0FBQ21CLFVBQVUsQ0FBQ2I7UUFDaEIsTUFBTXVCLE1BQU12QixPQUFPd0IsS0FBSyxDQUFDLEdBQUc5QjtRQUM1QixJQUFJLENBQUMrQixPQUFPO1FBQ1osT0FBT0Y7SUFDWDtJQUNBRyxXQUFXQyxFQUFFLEVBQUU7UUFDWEEsTUFBT0EsQ0FBQUEsS0FBSyxJQUFJLElBQUksQ0FBQ25DLFdBQVcsRUFBQztRQUNqQ21DLEdBQUdqQixHQUFHLElBQUksSUFBSSxDQUFDVyxHQUFHO1FBQ2xCLE1BQU0sRUFBRTVCLFFBQVEsRUFBRU8sTUFBTSxFQUFFSCxNQUFNLEVBQUVELFFBQVEsRUFBRUcsU0FBUyxFQUFFRCxHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ25FNkIsR0FBRzlCLE1BQU0sR0FBR0E7UUFDWjhCLEdBQUc3QixHQUFHLEdBQUdBO1FBQ1Q2QixHQUFHL0IsUUFBUSxHQUFHQTtRQUNkK0IsR0FBRzVCLFNBQVMsR0FBR0E7UUFDZixJQUFJRixTQUFTSixVQUNUa0MsR0FBRzNCLE1BQU0sQ0FBQ1UsR0FBRyxDQUFDVjtRQUNsQixPQUFPMkI7SUFDWDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcz8yOTA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJleGlzdHMiLCJvdXRwdXQiLCJIYXNoIiwiY3JlYXRlVmlldyIsInRvQnl0ZXMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsInZhbHVlIiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIlNIQTIiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwidXBkYXRlIiwiZGF0YSIsImxlbiIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsImZpbGwiLCJpIiwib3ZpZXciLCJFcnJvciIsIm91dExlbiIsInN0YXRlIiwiZ2V0IiwiZGlnZXN0IiwicmVzIiwic2xpY2UiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBTUEsYUFBYSxhQUFhLEdBQUdDLE9BQU8sS0FBSyxLQUFLO0FBQ3BELE1BQU1DLE9BQU8sYUFBYSxHQUFHRCxPQUFPO0FBQ3BDLCtFQUErRTtBQUMvRSxTQUFTRSxRQUFRQyxDQUFDLEVBQUVDLEtBQUssS0FBSztJQUMxQixJQUFJQSxJQUNBLE9BQU87UUFBRUMsR0FBR0MsT0FBT0gsSUFBSUo7UUFBYVEsR0FBR0QsT0FBTyxLQUFNTCxPQUFRRjtJQUFZO0lBQzVFLE9BQU87UUFBRU0sR0FBR0MsT0FBTyxLQUFNTCxPQUFRRixjQUFjO1FBQUdRLEdBQUdELE9BQU9ILElBQUlKLGNBQWM7SUFBRTtBQUNwRjtBQUNBLFNBQVNTLE1BQU1DLEdBQUcsRUFBRUwsS0FBSyxLQUFLO0lBQzFCLElBQUlNLEtBQUssSUFBSUMsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFJQyxLQUFLLElBQUlGLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFBSztRQUNqQyxNQUFNLEVBQUVULENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdMLFFBQVFPLEdBQUcsQ0FBQ0ssRUFBRSxFQUFFVjtRQUNqQyxDQUFDTSxFQUFFLENBQUNJLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDVDtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDRztRQUFJRztLQUFHO0FBQ25CO0FBQ0EsTUFBTUUsUUFBUSxDQUFDVixHQUFHRSxJQUFNLE9BQVFGLE1BQU0sTUFBTUosT0FBUUQsT0FBT08sTUFBTTtBQUNqRSx1QkFBdUI7QUFDdkIsTUFBTVMsUUFBUSxDQUFDWCxHQUFHWSxJQUFJQyxJQUFNYixNQUFNYTtBQUNsQyxNQUFNQyxRQUFRLENBQUNkLEdBQUdFLEdBQUdXLElBQU0sS0FBTyxLQUFLQSxJQUFPWCxNQUFNVztBQUNwRCxvQ0FBb0M7QUFDcEMsTUFBTUUsU0FBUyxDQUFDZixHQUFHRSxHQUFHVyxJQUFNLE1BQU9BLElBQU1YLEtBQU0sS0FBS1c7QUFDcEQsTUFBTUcsU0FBUyxDQUFDaEIsR0FBR0UsR0FBR1csSUFBTSxLQUFPLEtBQUtBLElBQU9YLE1BQU1XO0FBQ3JELGdFQUFnRTtBQUNoRSxNQUFNSSxTQUFTLENBQUNqQixHQUFHRSxHQUFHVyxJQUFNLEtBQU8sS0FBS0EsSUFBT1gsTUFBT1csSUFBSTtBQUMxRCxNQUFNSyxTQUFTLENBQUNsQixHQUFHRSxHQUFHVyxJQUFNLE1BQVFBLElBQUksS0FBUVgsS0FBTSxLQUFLVztBQUMzRCwrQ0FBK0M7QUFDL0MsTUFBTU0sVUFBVSxDQUFDQyxJQUFJbEIsSUFBTUE7QUFDM0IsTUFBTW1CLFVBQVUsQ0FBQ3JCLEdBQUdZLEtBQU9aO0FBQzNCLG1DQUFtQztBQUNuQyxNQUFNc0IsU0FBUyxDQUFDdEIsR0FBR0UsR0FBR1csSUFBTSxLQUFNQSxJQUFNWCxNQUFPLEtBQUtXO0FBQ3BELE1BQU1VLFNBQVMsQ0FBQ3ZCLEdBQUdFLEdBQUdXLElBQU0sS0FBTUEsSUFBTWIsTUFBTyxLQUFLYTtBQUNwRCwrREFBK0Q7QUFDL0QsTUFBTVcsU0FBUyxDQUFDeEIsR0FBR0UsR0FBR1csSUFBTSxLQUFPQSxJQUFJLEtBQVFiLE1BQU8sS0FBS2E7QUFDM0QsTUFBTVksU0FBUyxDQUFDekIsR0FBR0UsR0FBR1csSUFBTSxLQUFPQSxJQUFJLEtBQVFYLE1BQU8sS0FBS1c7QUFDM0QsOEVBQThFO0FBQzlFLDBFQUEwRTtBQUMxRSxTQUFTYSxJQUFJckIsRUFBRSxFQUFFRyxFQUFFLEVBQUVtQixFQUFFLEVBQUVDLEVBQUU7SUFDdkIsTUFBTTFCLElBQUksQ0FBQ00sT0FBTyxLQUFNb0IsQ0FBQUEsT0FBTztJQUMvQixPQUFPO1FBQUU1QixHQUFHLEtBQU0yQixLQUFNLEtBQUssS0FBSyxLQUFNLEtBQU07UUFBR3pCLEdBQUdBLElBQUk7SUFBRTtBQUM5RDtBQUNBLHFDQUFxQztBQUNyQyxNQUFNMkIsUUFBUSxDQUFDckIsSUFBSW9CLElBQUlFLEtBQU8sQ0FBQ3RCLE9BQU8sS0FBTW9CLENBQUFBLE9BQU8sS0FBTUUsQ0FBQUEsT0FBTztBQUNoRSxNQUFNQyxRQUFRLENBQUNDLEtBQUszQixJQUFJc0IsSUFBSU0sS0FBTyxLQUFNTixLQUFLTSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDNUUsTUFBTUMsUUFBUSxDQUFDMUIsSUFBSW9CLElBQUlFLElBQUlLLEtBQU8sQ0FBQzNCLE9BQU8sS0FBTW9CLENBQUFBLE9BQU8sS0FBTUUsQ0FBQUEsT0FBTyxLQUFNSyxDQUFBQSxPQUFPO0FBQ2pGLE1BQU1DLFFBQVEsQ0FBQ0osS0FBSzNCLElBQUlzQixJQUFJTSxJQUFJSSxLQUFPLEtBQU1WLEtBQUtNLEtBQUtJLEtBQU0sT0FBTyxLQUFLLEtBQU0sS0FBTTtBQUNyRixNQUFNQyxRQUFRLENBQUM5QixJQUFJb0IsSUFBSUUsSUFBSUssSUFBSUksS0FBTyxDQUFDL0IsT0FBTyxLQUFNb0IsQ0FBQUEsT0FBTyxLQUFNRSxDQUFBQSxPQUFPLEtBQU1LLENBQUFBLE9BQU8sS0FBTUksQ0FBQUEsT0FBTztBQUNsRyxNQUFNQyxRQUFRLENBQUNSLEtBQUszQixJQUFJc0IsSUFBSU0sSUFBSUksSUFBSUksS0FBTyxLQUFNZCxLQUFLTSxLQUFLSSxLQUFLSSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDOUYsa0JBQWtCO0FBQytKO0FBQ2pMLGtCQUFrQjtBQUNsQixNQUFNQyxNQUFNO0lBQ1I3QztJQUFTTTtJQUFPTztJQUNoQkM7SUFBT0c7SUFDUEM7SUFBUUM7SUFBUUM7SUFBUUM7SUFDeEJDO0lBQVNFO0lBQ1RDO0lBQVFDO0lBQVFDO0lBQVFDO0lBQ3hCQztJQUFLRztJQUFPRTtJQUFPRztJQUFPRTtJQUFPSTtJQUFPRjtBQUM1QztBQUNBLGlFQUFlSSxHQUFHQSxFQUFDLENBQ25CLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz9hYzNhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOlsiVTMyX01BU0s2NCIsIkJpZ0ludCIsIl8zMm4iLCJmcm9tQmlnIiwibiIsImxlIiwiaCIsIk51bWJlciIsImwiLCJzcGxpdCIsImxzdCIsIkFoIiwiVWludDMyQXJyYXkiLCJsZW5ndGgiLCJBbCIsImkiLCJ0b0JpZyIsInNoclNIIiwiX2wiLCJzIiwic2hyU0wiLCJyb3RyU0giLCJyb3RyU0wiLCJyb3RyQkgiLCJyb3RyQkwiLCJyb3RyMzJIIiwiX2giLCJyb3RyMzJMIiwicm90bFNIIiwicm90bFNMIiwicm90bEJIIiwicm90bEJMIiwiYWRkIiwiQmgiLCJCbCIsImFkZDNMIiwiQ2wiLCJhZGQzSCIsImxvdyIsIkNoIiwiYWRkNEwiLCJEbCIsImFkZDRIIiwiRGgiLCJhZGQ1TCIsIkVsIiwiYWRkNUgiLCJFaCIsInU2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9GQUFvRjtBQUNwRiw0QkFBNEI7QUFDNUIsaURBQWlEO0FBQ2pELGFBQWE7QUFDcUI7QUFDM0IsTUFBTUMsU0FBU0QsMk1BQUVBLElBQUksT0FBT0EsMk1BQUVBLEtBQUssWUFBWSwwTkFBaUJBLEdBQUdBLGtEQUFZLEdBQUdHLFVBQVUsQ0FDbkcsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzPzIzMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4vLyBUaGUgZmlsZSB3aWxsIHRocm93IG9uIG5vZGUuanMgMTQgYW5kIGVhcmxpZXIuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyBuYyBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgY29uc3QgY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuYyA/IG5jLndlYmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbIm5jIiwiY3J5cHRvIiwid2ViY3J5cHRvIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0Msa0JBQWtCO0FBQ1gsTUFBTVEsYUFBYUYsMkNBQUlBO0lBQzFCRyxZQUFZVCxJQUFJLEVBQUVVLElBQUksQ0FBRTtRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakJYLGdEQUFVQSxDQUFDRDtRQUNYLE1BQU1hLE1BQU1OLGtEQUFPQSxDQUFDRztRQUNwQixJQUFJLENBQUNJLEtBQUssR0FBR2QsS0FBS2UsTUFBTTtRQUN4QixJQUFJLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNFLE1BQU0sS0FBSyxZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNJLFFBQVE7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLFNBQVM7UUFDckMsTUFBTUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXSDtRQUMzQix3Q0FBd0M7UUFDeENFLElBQUlFLEdBQUcsQ0FBQ1QsSUFBSVUsTUFBTSxHQUFHTCxXQUFXbEIsS0FBS2UsTUFBTSxHQUFHQyxNQUFNLENBQUNILEtBQUtXLE1BQU0sS0FBS1g7UUFDckUsSUFBSyxJQUFJWSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFDNUJMLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJO1FBQ2QsSUFBSSxDQUFDWCxLQUFLLENBQUNFLE1BQU0sQ0FBQ0k7UUFDbEIsbUhBQW1IO1FBQ25ILElBQUksQ0FBQ00sS0FBSyxHQUFHMUIsS0FBS2UsTUFBTTtRQUN4Qix1Q0FBdUM7UUFDdkMsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFDNUJMLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJLE9BQU87UUFDckIsSUFBSSxDQUFDQyxLQUFLLENBQUNWLE1BQU0sQ0FBQ0k7UUFDbEJBLElBQUlPLElBQUksQ0FBQztJQUNiO0lBQ0FYLE9BQU9ZLEdBQUcsRUFBRTtRQUNSdkIsa0RBQVlBLENBQUMsSUFBSTtRQUNqQixJQUFJLENBQUNTLEtBQUssQ0FBQ0UsTUFBTSxDQUFDWTtRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBQyxXQUFXQyxHQUFHLEVBQUU7UUFDWnpCLGtEQUFZQSxDQUFDLElBQUk7UUFDakJGLGlEQUFXQSxDQUFDMkIsS0FBSyxJQUFJLENBQUNYLFNBQVM7UUFDL0IsSUFBSSxDQUFDUixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRyxLQUFLLENBQUNlLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDSixLQUFLLENBQUNWLE1BQU0sQ0FBQ2M7UUFDbEIsSUFBSSxDQUFDSixLQUFLLENBQUNHLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDQyxPQUFPO0lBQ2hCO0lBQ0FQLFNBQVM7UUFDTCxNQUFNTSxNQUFNLElBQUlULFdBQVcsSUFBSSxDQUFDSyxLQUFLLENBQUNQLFNBQVM7UUFDL0MsSUFBSSxDQUFDVSxVQUFVLENBQUNDO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUUsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsbUdBQW1HO1FBQ25HQSxNQUFPQSxDQUFBQSxLQUFLQyxPQUFPbkIsTUFBTSxDQUFDbUIsT0FBT0MsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFVCxLQUFLLEVBQUVaLEtBQUssRUFBRUgsUUFBUSxFQUFFQyxTQUFTLEVBQUVNLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RWMsS0FBS0E7UUFDTEEsR0FBR3RCLFFBQVEsR0FBR0E7UUFDZHNCLEdBQUdyQixTQUFTLEdBQUdBO1FBQ2ZxQixHQUFHZixRQUFRLEdBQUdBO1FBQ2RlLEdBQUdkLFNBQVMsR0FBR0E7UUFDZmMsR0FBR1AsS0FBSyxHQUFHQSxNQUFNTSxVQUFVLENBQUNDLEdBQUdQLEtBQUs7UUFDcENPLEdBQUduQixLQUFLLEdBQUdBLE1BQU1rQixVQUFVLENBQUNDLEdBQUduQixLQUFLO1FBQ3BDLE9BQU9tQjtJQUNYO0lBQ0FGLFVBQVU7UUFDTixJQUFJLENBQUNuQixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDYyxLQUFLLENBQUNLLE9BQU87UUFDbEIsSUFBSSxDQUFDakIsS0FBSyxDQUFDaUIsT0FBTztJQUN0QjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNSyxPQUFPLENBQUNwQyxNQUFNYSxLQUFLd0IsVUFBWSxJQUFJN0IsS0FBS1IsTUFBTWEsS0FBS0csTUFBTSxDQUFDcUIsU0FBU2IsTUFBTSxHQUFHO0FBQ3pGWSxLQUFLckIsTUFBTSxHQUFHLENBQUNmLE1BQU1hLE1BQVEsSUFBSUwsS0FBS1IsTUFBTWEsTUFDNUMsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzP2Y0ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImhhc2giLCJhc3NlcnRIYXNoIiwiYnl0ZXMiLCJhc3NlcnRCeXRlcyIsImV4aXN0cyIsImFzc2VydEV4aXN0cyIsIkhhc2giLCJ0b0J5dGVzIiwiSE1BQyIsImNvbnN0cnVjdG9yIiwiX2tleSIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwia2V5IiwiaUhhc2giLCJjcmVhdGUiLCJ1cGRhdGUiLCJFcnJvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkIiwiVWludDhBcnJheSIsInNldCIsImxlbmd0aCIsImRpZ2VzdCIsImkiLCJvSGFzaCIsImZpbGwiLCJidWYiLCJkaWdlc3RJbnRvIiwib3V0IiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaG1hYyIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRCxnRUFBZ0U7QUFDaEUsMERBQTBEO0FBQzFELG9CQUFvQjtBQUNwQixNQUFNRyxNQUFNLENBQUNDLEdBQUdDLEdBQUdDLElBQU0sSUFBS0QsSUFBTSxDQUFDRCxJQUFJRTtBQUN6QyxvREFBb0Q7QUFDcEQsTUFBTUMsTUFBTSxDQUFDSCxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDO0FBQ2xELG1CQUFtQjtBQUNuQix5RkFBeUY7QUFDekYsa0JBQWtCO0FBQ2xCLE1BQU1FLFdBQVcsYUFBYSxHQUFHLElBQUlDLFlBQVk7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QseUdBQXlHO0FBQ3pHLGtCQUFrQjtBQUNsQixNQUFNQyxLQUFLLGFBQWEsR0FBRyxJQUFJRCxZQUFZO0lBQ3ZDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCw0REFBNEQ7QUFDNUQsbURBQW1EO0FBQ25ELE1BQU1FLFdBQVcsYUFBYSxHQUFHLElBQUlGLFlBQVk7QUFDakQsTUFB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UUFDOUIsSUFBSSxDQUFDaUIsTUFBTSxDQUFDRixJQUFJLENBQUM7SUFDckI7QUFDSjtBQUNBLDRFQUE0RTtBQUM1RSxNQUFNRyxlQUFlN0I7SUFDakJDLGFBQWM7UUFDVixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ3FCLFNBQVMsR0FBRztJQUNyQjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsU0FBUyxhQUFhLEdBQUd6QywwREFBZUEsQ0FBQyxJQUFNLElBQUlVLFVBQVU7QUFDbkUsTUFBTWdDLFNBQVMsYUFBYSxHQUFHMUMsMERBQWVBLENBQUMsSUFBTSxJQUFJdUMsVUFBVSxDQUMxRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz85OTZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOlsiU0hBMiIsInJvdHIiLCJ3cmFwQ29uc3RydWN0b3IiLCJDaGkiLCJhIiwiYiIsImMiLCJNYWoiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiSVYiLCJTSEEyNTZfVyIsIlNIQTI1NiIsImNvbnN0cnVjdG9yIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTUiLCJXMiIsInMwIiwiczEiLCJzaWdtYTEiLCJUMSIsInNpZ21hMCIsIlQyIiwicm91bmRDbGVhbiIsImZpbGwiLCJkZXN0cm95IiwiYnVmZmVyIiwiU0hBMjI0Iiwib3V0cHV0TGVuIiwic2hhMjU2Iiwic2hhMjI0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta \n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUNLO0FBQzRCO0FBQzlGLG9HQUFvRztBQUNwRyxpQ0FBaUM7QUFDakMsMkNBQTJDO0FBQzNDLE1BQU0sQ0FBQ2MsU0FBU0MsV0FBV0MsV0FBVyxHQUFHO0lBQUMsRUFBRTtJQUFFLEVBQUU7SUFBRSxFQUFFO0NBQUM7QUFDckQsTUFBTUMsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDbkMsTUFBTUUsTUFBTSxhQUFhLEdBQUdGLE9BQU87QUFDbkMsTUFBTUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDbkMsTUFBTUksUUFBUSxhQUFhLEdBQUdKLE9BQU87QUFDckMsTUFBTUssU0FBUyxhQUFhLEdBQUdMLE9BQU87QUFDdEMsSUFBSyxJQUFJTSxRQUFRLEdBQUdDLElBQUlOLEtBQUtPLElBQUksR0FBR0MsSUFBSSxHQUFHSCxRQUFRLElBQUlBLFFBQVM7SUFDNUQsS0FBSztJQUNMLENBQUNFLEdBQUdDLEVBQUUsR0FBRztRQUFDQTtRQUFJLEtBQUlELElBQUksSUFBSUMsQ0FBQUEsSUFBSztLQUFFO0lBQ2pDYixRQUFRYyxJQUFJLENBQUMsSUFBSyxLQUFJRCxJQUFJRCxDQUFBQTtJQUMxQixhQUFhO0lBQ2JYLFVBQVVhLElBQUksQ0FBQyxDQUFHSixRQUFRLEtBQU1BLENBQUFBLFFBQVEsS0FBTSxJQUFLO0lBQ25ELE9BQU87SUFDUCxJQUFJSyxJQUFJWjtJQUNSLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJMLElBQUksQ0FBQyxLQUFNTixNQUFRLENBQUNNLEtBQUtKLEdBQUUsSUFBS0UsTUFBTSxJQUFLRDtRQUMzQyxJQUFJRyxJQUFJTCxLQUNKUyxLQUFLVixPQUFRLENBQUNBLE9B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QUFDbEU7OztDQUdDLEdBQ00sTUFBTU0sYUFBYSxhQUFhLEdBQUdOLElBQUksTUFBTSxLQUFLLE1BQU0sR0FBRztBQUMzRCxNQUFNTyxhQUFhLGFBQWEsR0FBR1AsSUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNELE1BQU1RLGFBQWEsYUFBYSxHQUFHUixJQUFJLE1BQU0sSUFBSSxNQUFNLEdBQUc7QUFDakUsTUFBTVMsV0FBVyxDQUFDMUMsUUFBUUQsVUFBVUUsWUFBYzVDLHFFQUEwQkEsQ0FBQyxDQUFDc0YsT0FBTyxDQUFDLENBQUMsR0FBSyxJQUFJOUMsT0FBT0UsVUFBVUMsUUFBUTJDLEtBQUtDLEtBQUssS0FBS0MsWUFBWTVDLFlBQVkwQyxLQUFLQyxLQUFLLEVBQUU7QUFDckssTUFBTUUsV0FBVyxhQUFhLEdBQUdKLFNBQVMsTUFBTSxLQUFLLE1BQU0sR0FBRztBQUM5RCxNQUFNSyxXQUFXLGFBQWEsR0FBR0wsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHLENBQ3JFLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz85NjZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ5dGVzLCBleGlzdHMsIG51bWJlciwgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdTMyLCB0b0J5dGVzLCB3cmFwQ29uc3RydWN0b3IsIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzLCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMyAoa2VjY2FrKSBpcyBiYXNlZCBvbiBhIG5ldyBkZXNpZ246IGJhc2ljYWxseSwgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuLy8gSXQncyBjYWxsZWQgYSBzcG9uZ2UgZnVuY3Rpb24uXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gLyogQF9fUFVSRV9fICovIHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLy8gU2FtZSBhcyBrZWNjYWtmMTYwMCwgYnV0IGFsbG93cyB0byBza2lwIHNvbWUgcm91bmRzXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0IGNsYXNzIEtlY2NhayBleHRlbmRzIEhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCA3MiwgNTEyIC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbImJ5dGVzIiwiZXhpc3RzIiwibnVtYmVyIiwib3V0cHV0Iiwicm90bEJIIiwicm90bEJMIiwicm90bFNIIiwicm90bFNMIiwic3BsaXQiLCJIYXNoIiwidTMyIiwidG9CeXRlcyIsIndyYXBDb25zdHJ1Y3RvciIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImZpbGwiLCJLZWNjYWsiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiZGlnZXN0SW50byIsImRlc3Ryb3kiLCJkaWdlc3QiLCJfY2xvbmVJbnRvIiwidG8iLCJnZW4iLCJzaGEzXzIyNCIsInNoYTNfMjU2Iiwic2hhM18zODQiLCJzaGEzXzUxMiIsImtlY2Nha18yMjQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiLCJnZW5TaGFrZSIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCIsInNoYWtlMTI4Iiwic2hha2UyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsOERBQThEO0FBQ2hCO0FBQzlDLE1BQU1DLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsK0JBQStCO0FBQ3hCLE1BQU1DLEtBQUssQ0FBQ0MsTUFBUSxJQUFJRixXQUFXRSxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQy9FLE1BQU1DLE1BQU0sQ0FBQ0osTUFBUSxJQUFJSyxZQUFZTCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUksS0FBS0MsS0FBSyxDQUFDUCxJQUFJRyxVQUFVLEdBQUcsSUFBSTtBQUN4RyxxQkFBcUI7QUFDZCxNQUFNSyxhQUFhLENBQUNSLE1BQVEsSUFBSVMsU0FBU1QsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVUsRUFBRTtBQUM1RiwrREFBK0Q7QUFDeEQsTUFBTU8sT0FBTyxDQUFDQyxNQUFNQyxRQUFVLFFBQVUsS0FBS0EsUUFBV0QsU0FBU0MsTUFBTztBQUMvRSxpRkFBaUY7QUFDakYsd0RBQXdEO0FBQ2pELE1BQU1DLE9BQU8sSUFBSWYsV0FBVyxJQUFJTyxZQUFZO0lBQUM7Q0FBVyxFQUFFSixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSztBQUNyRixJQUFJLENBQUNZLE1BQ0QsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCLE1BQU1DLFFBQVEsYUFBYSxHQUFHQyxNQUFNQyxJQUFJLENBQUM7SUFBRUMsUUFBUTtBQUFJLEdBQUcsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsUUFBUSxDQUFDLElBQUlD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QUcsQ0FBQ2YsT0FBU08sU0FBU1A7SUFDbEMsT0FBT1E7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU1UsWUFBWUMsY0FBYyxFQUFFO0lBQ3hDLElBQUl6Rix3REFBTUEsSUFBSSxPQUFPQSx3REFBTUEsQ0FBQzBGLGVBQWUsS0FBSyxZQUFZO1FBQ3hELE9BQU8xRix3REFBTUEsQ0FBQzBGLGVBQWUsQ0FBQyxJQUFJdkYsV0FBV3NGO0lBQ2pEO0lBQ0EsTUFBTSxJQUFJdEUsTUFBTTtBQUNwQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/ZTM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiY3J5cHRvIiwidThhIiwiYSIsIlVpbnQ4QXJyYXkiLCJ1OCIsImFyciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwidTMyIiwiVWludDMyQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJjcmVhdGVWaWV3IiwiRGF0YVZpZXciLCJyb3RyIiwid29yZCIsInNoaWZ0IiwiaXNMRSIsIkVycm9yIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJoZXgiLCJoZXhUb0J5dGVzIiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJuZXh0VGljayIsImFzeW5jTG9vcCIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJ0b0J5dGVzIiwiZGF0YSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwiciIsInJlZHVjZSIsInN1bSIsInBhZCIsImZvckVhY2giLCJzZXQiLCJIYXNoIiwiY2xvbmUiLCJfY2xvbmVJbnRvIiwidG9TdHIiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJ1bmRlZmluZWQiLCJjYWxsIiwibWVyZ2VkIiwiT2JqZWN0IiwiYXNzaWduIiwid3JhcENvbnN0cnVjdG9yIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiY3JlYXRlIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;