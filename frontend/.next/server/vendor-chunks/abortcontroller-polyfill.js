/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/abortcontroller-polyfill";
exports.ids = ["vendor-chunks/abortcontroller-polyfill"];
exports.modules = {

/***/ "(ssr)/./node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js":
/*!****************************************************************************!*\
  !*** ./node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(factory) {\n     true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n})(function() {\n    \"use strict\";\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n    function _defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        Object.defineProperty(Constructor, \"prototype\", {\n            writable: false\n        });\n        return Constructor;\n    }\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true\n            }\n        });\n        Object.defineProperty(subClass, \"prototype\", {\n            writable: false\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n    function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n    }\n    function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n        };\n        return _setPrototypeOf(o, p);\n    }\n    function _isNativeReflectConstruct() {\n        if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === \"function\") return true;\n        try {\n            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    function _assertThisInitialized(self1) {\n        if (self1 === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n        return self1;\n    }\n    function _possibleConstructorReturn(self1, call) {\n        if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n            return call;\n        } else if (call !== void 0) {\n            throw new TypeError(\"Derived constructors may only return object or undefined\");\n        }\n        return _assertThisInitialized(self1);\n    }\n    function _createSuper(Derived) {\n        var hasNativeReflectConstruct = _isNativeReflectConstruct();\n        return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived), result;\n            if (hasNativeReflectConstruct) {\n                var NewTarget = _getPrototypeOf(this).constructor;\n                result = Reflect.construct(Super, arguments, NewTarget);\n            } else {\n                result = Super.apply(this, arguments);\n            }\n            return _possibleConstructorReturn(this, result);\n        };\n    }\n    function _superPropBase(object, property) {\n        while(!Object.prototype.hasOwnProperty.call(object, property)){\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n        }\n        return object;\n    }\n    function _get() {\n        if (typeof Reflect !== \"undefined\" && Reflect.get) {\n            _get = Reflect.get.bind();\n        } else {\n            _get = function _get(target, property, receiver) {\n                var base = _superPropBase(target, property);\n                if (!base) return;\n                var desc = Object.getOwnPropertyDescriptor(base, property);\n                if (desc.get) {\n                    return desc.get.call(arguments.length < 3 ? target : receiver);\n                }\n                return desc.value;\n            };\n        }\n        return _get.apply(this, arguments);\n    }\n    var Emitter = /*#__PURE__*/ function() {\n        function Emitter() {\n            _classCallCheck(this, Emitter);\n            Object.defineProperty(this, \"listeners\", {\n                value: {},\n                writable: true,\n                configurable: true\n            });\n        }\n        _createClass(Emitter, [\n            {\n                key: \"addEventListener\",\n                value: function addEventListener(type, callback, options) {\n                    if (!(type in this.listeners)) {\n                        this.listeners[type] = [];\n                    }\n                    this.listeners[type].push({\n                        callback: callback,\n                        options: options\n                    });\n                }\n            },\n            {\n                key: \"removeEventListener\",\n                value: function removeEventListener(type, callback) {\n                    if (!(type in this.listeners)) {\n                        return;\n                    }\n                    var stack = this.listeners[type];\n                    for(var i = 0, l = stack.length; i < l; i++){\n                        if (stack[i].callback === callback) {\n                            stack.splice(i, 1);\n                            return;\n                        }\n                    }\n                }\n            },\n            {\n                key: \"dispatchEvent\",\n                value: function dispatchEvent(event) {\n                    if (!(event.type in this.listeners)) {\n                        return;\n                    }\n                    var stack = this.listeners[event.type];\n                    var stackToCall = stack.slice();\n                    for(var i = 0, l = stackToCall.length; i < l; i++){\n                        var listener = stackToCall[i];\n                        try {\n                            listener.callback.call(this, event);\n                        } catch (e) {\n                            Promise.resolve().then(function() {\n                                throw e;\n                            });\n                        }\n                        if (listener.options && listener.options.once) {\n                            this.removeEventListener(event.type, listener.callback);\n                        }\n                    }\n                    return !event.defaultPrevented;\n                }\n            }\n        ]);\n        return Emitter;\n    }();\n    var AbortSignal = /*#__PURE__*/ function(_Emitter) {\n        _inherits(AbortSignal, _Emitter);\n        var _super = _createSuper(AbortSignal);\n        function AbortSignal() {\n            var _this;\n            _classCallCheck(this, AbortSignal);\n            _this = _super.call(this); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent\n            // constructor has failed to run, then \"this.listeners\" will still be undefined and then we call\n            // the parent constructor directly instead as a workaround. For general details, see babel bug:\n            // https://github.com/babel/babel/issues/3041\n            // This hack was added as a fix for the issue described here:\n            // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042\n            if (!_this.listeners) {\n                Emitter.call(_assertThisInitialized(_this));\n            } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n            // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl\n            Object.defineProperty(_assertThisInitialized(_this), \"aborted\", {\n                value: false,\n                writable: true,\n                configurable: true\n            });\n            Object.defineProperty(_assertThisInitialized(_this), \"onabort\", {\n                value: null,\n                writable: true,\n                configurable: true\n            });\n            Object.defineProperty(_assertThisInitialized(_this), \"reason\", {\n                value: undefined,\n                writable: true,\n                configurable: true\n            });\n            return _this;\n        }\n        _createClass(AbortSignal, [\n            {\n                key: \"toString\",\n                value: function toString() {\n                    return \"[object AbortSignal]\";\n                }\n            },\n            {\n                key: \"dispatchEvent\",\n                value: function dispatchEvent(event) {\n                    if (event.type === \"abort\") {\n                        this.aborted = true;\n                        if (typeof this.onabort === \"function\") {\n                            this.onabort.call(this, event);\n                        }\n                    }\n                    _get(_getPrototypeOf(AbortSignal.prototype), \"dispatchEvent\", this).call(this, event);\n                }\n            }\n        ]);\n        return AbortSignal;\n    }(Emitter);\n    var AbortController = /*#__PURE__*/ function() {\n        function AbortController() {\n            _classCallCheck(this, AbortController);\n            // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n            // we want Object.keys(new AbortController()) to be [] for compat with the native impl\n            Object.defineProperty(this, \"signal\", {\n                value: new AbortSignal(),\n                writable: true,\n                configurable: true\n            });\n        }\n        _createClass(AbortController, [\n            {\n                key: \"abort\",\n                value: function abort(reason) {\n                    var event;\n                    try {\n                        event = new Event(\"abort\");\n                    } catch (e) {\n                        if (typeof document !== \"undefined\") {\n                            if (!document.createEvent) {\n                                // For Internet Explorer 8:\n                                event = document.createEventObject();\n                                event.type = \"abort\";\n                            } else {\n                                // For Internet Explorer 11:\n                                event = document.createEvent(\"Event\");\n                                event.initEvent(\"abort\", false, false);\n                            }\n                        } else {\n                            // Fallback where document isn't available:\n                            event = {\n                                type: \"abort\",\n                                bubbles: false,\n                                cancelable: false\n                            };\n                        }\n                    }\n                    var signalReason = reason;\n                    if (signalReason === undefined) {\n                        if (typeof document === \"undefined\") {\n                            signalReason = new Error(\"This operation was aborted\");\n                            signalReason.name = \"AbortError\";\n                        } else {\n                            try {\n                                signalReason = new DOMException(\"signal is aborted without reason\");\n                            } catch (err) {\n                                // IE 11 does not support calling the DOMException constructor, use a\n                                // regular error object on it instead.\n                                signalReason = new Error(\"This operation was aborted\");\n                                signalReason.name = \"AbortError\";\n                            }\n                        }\n                    }\n                    this.signal.reason = signalReason;\n                    this.signal.dispatchEvent(event);\n                }\n            },\n            {\n                key: \"toString\",\n                value: function toString() {\n                    return \"[object AbortController]\";\n                }\n            }\n        ]);\n        return AbortController;\n    }();\n    if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n        // These are necessary to make sure that we get correct output for:\n        // Object.prototype.toString.call(new AbortController())\n        AbortController.prototype[Symbol.toStringTag] = \"AbortController\";\n        AbortSignal.prototype[Symbol.toStringTag] = \"AbortSignal\";\n    }\n    function polyfillNeeded(self1) {\n        if (self1.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n            console.log(\"__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill\");\n            return true;\n        } // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n        // defining window.Request, and this polyfill need to work on top of unfetch\n        // so the below feature detection needs the !self.AbortController part.\n        // The Request.prototype check is also needed because Safari versions 11.1.2\n        // up to and including 12.1.x has a window.AbortController present but still\n        // does NOT correctly implement abortable fetch:\n        // https://bugs.webkit.org/show_bug.cgi?id=174980#c2\n        return typeof self1.Request === \"function\" && !self1.Request.prototype.hasOwnProperty(\"signal\") || !self1.AbortController;\n    }\n    /**\n   * Note: the \"fetch.Request\" default value is available for fetch imported from\n   * the \"node-fetch\" package and not in browsers. This is OK since browsers\n   * will be importing umd-polyfill.js from that path \"self\" is passed the\n   * decorator so the default value will not be used (because browsers that define\n   * fetch also has Request). One quirky setup where self.fetch exists but\n   * self.Request does not is when the \"unfetch\" minimal fetch polyfill is used\n   * on top of IE11; for this case the browser will try to use the fetch.Request\n   * default value which in turn will be undefined but then then \"if (Request)\"\n   * will ensure that you get a patched fetch but still no Request (as expected).\n   * @param {fetch, Request = fetch.Request}\n   * @returns {fetch: abortableFetch, Request: AbortableRequest}\n   */ function abortableFetchDecorator(patchTargets) {\n        if (\"function\" === typeof patchTargets) {\n            patchTargets = {\n                fetch: patchTargets\n            };\n        }\n        var _patchTargets = patchTargets, fetch = _patchTargets.fetch, _patchTargets$Request = _patchTargets.Request, NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request, NativeAbortController = _patchTargets.AbortController, _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;\n        if (!polyfillNeeded({\n            fetch: fetch,\n            Request: NativeRequest,\n            AbortController: NativeAbortController,\n            __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL\n        })) {\n            return {\n                fetch: fetch,\n                Request: Request\n            };\n        }\n        var Request = NativeRequest; // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n        // defining window.Request, and this polyfill need to work on top of unfetch\n        // hence we only patch it if it's available. Also we don't patch it if signal\n        // is already available on the Request prototype because in this case support\n        // is present and the patching below can cause a crash since it assigns to\n        // request.signal which is technically a read-only property. This latter error\n        // happens when you run the main5.js node-fetch example in the repo\n        // \"abortcontroller-polyfill-examples\". The exact error is:\n        //   request.signal = init.signal;\n        //   ^\n        // TypeError: Cannot set property signal of #<Request> which has only a getter\n        if (Request && !Request.prototype.hasOwnProperty(\"signal\") || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n            Request = function Request(input, init) {\n                var signal;\n                if (init && init.signal) {\n                    signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has\n                    // been installed because if we're running on top of a browser with a\n                    // working native AbortController (i.e. the polyfill was installed due to\n                    // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n                    // fake AbortSignal to the native fetch will trigger:\n                    // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.\n                    delete init.signal;\n                }\n                var request = new NativeRequest(input, init);\n                if (signal) {\n                    Object.defineProperty(request, \"signal\", {\n                        writable: false,\n                        enumerable: false,\n                        configurable: true,\n                        value: signal\n                    });\n                }\n                return request;\n            };\n            Request.prototype = NativeRequest.prototype;\n        }\n        var realFetch = fetch;\n        var abortableFetch = function abortableFetch(input, init) {\n            var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;\n            if (signal) {\n                var abortError;\n                try {\n                    abortError = new DOMException(\"Aborted\", \"AbortError\");\n                } catch (err) {\n                    // IE 11 does not support calling the DOMException constructor, use a\n                    // regular error object on it instead.\n                    abortError = new Error(\"Aborted\");\n                    abortError.name = \"AbortError\";\n                } // Return early if already aborted, thus avoiding making an HTTP request\n                if (signal.aborted) {\n                    return Promise.reject(abortError);\n                } // Turn an event into a promise, reject it once `abort` is dispatched\n                var cancellation = new Promise(function(_, reject) {\n                    signal.addEventListener(\"abort\", function() {\n                        return reject(abortError);\n                    }, {\n                        once: true\n                    });\n                });\n                if (init && init.signal) {\n                    // Never pass .signal to the native implementation when the polyfill has\n                    // been installed because if we're running on top of a browser with a\n                    // working native AbortController (i.e. the polyfill was installed due to\n                    // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n                    // fake AbortSignal to the native fetch will trigger:\n                    // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.\n                    delete init.signal;\n                } // Return the fastest promise (don't need to wait for request to finish)\n                return Promise.race([\n                    cancellation,\n                    realFetch(input, init)\n                ]);\n            }\n            return realFetch(input, init);\n        };\n        return {\n            fetch: abortableFetch,\n            Request: Request\n        };\n    }\n    (function(self1) {\n        if (!polyfillNeeded(self1)) {\n            return;\n        }\n        if (!self1.fetch) {\n            console.warn(\"fetch() is not available, cannot install abortcontroller-polyfill\");\n            return;\n        }\n        var _abortableFetch = abortableFetchDecorator(self1), fetch = _abortableFetch.fetch, Request = _abortableFetch.Request;\n        self1.fetch = fetch;\n        self1.Request = Request;\n        Object.defineProperty(self1, \"AbortController\", {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value: AbortController\n        });\n        Object.defineProperty(self1, \"AbortSignal\", {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value: AbortSignal\n        });\n    })(typeof self !== \"undefined\" ? self : global);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvcG9seWZpbGwtcGF0Y2gtZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUMsNEVBQVVBLE9BQU87SUFDaEIsS0FBMEMsR0FBR0Msb0NBQU9ELE9BQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUNBLEdBQzVEQSxDQUFTQTtBQUNYLEdBQUk7SUFBYztJQUVoQixTQUFTRyxnQkFBZ0JDLFFBQVEsRUFBRUMsV0FBVztRQUM1QyxJQUFJLENBQUVELENBQUFBLG9CQUFvQkMsV0FBVSxHQUFJO1lBQ3RDLE1BQU0sSUFBSUMsVUFBVTtRQUN0QjtJQUNGO0lBRUEsU0FBU0Msa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7UUFDdEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7WUFDekJFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1lBQ2pERCxXQUFXRSxZQUFZLEdBQUc7WUFDMUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7WUFDakRDLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUUksV0FBV00sR0FBRyxFQUFFTjtRQUNoRDtJQUNGO0lBRUEsU0FBU08sYUFBYWQsV0FBVyxFQUFFZSxVQUFVLEVBQUVDLFdBQVc7UUFDeEQsSUFBSUQsWUFBWWIsa0JBQWtCRixZQUFZaUIsU0FBUyxFQUFFRjtRQUN6RCxJQUFJQyxhQUFhZCxrQkFBa0JGLGFBQWFnQjtRQUNoREwsT0FBT0MsY0FBYyxDQUFDWixhQUFhLGFBQWE7WUFDOUNVLFVBQVU7UUFDWjtRQUNBLE9BQU9WO0lBQ1Q7SUFFQSxTQUFTa0IsVUFBVUMsUUFBUSxFQUFFQyxVQUFVO1FBQ3JDLElBQUksT0FBT0EsZUFBZSxjQUFjQSxlQUFlLE1BQU07WUFDM0QsTUFBTSxJQUFJbkIsVUFBVTtRQUN0QjtRQUVB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RUEsT0FBT0UsVUFBVUgsT0FBT0M7UUFDMUI7UUFFQSxPQUFPO1lBQ0xQLE9BQU9VO1lBQ1BiLFNBQVNBO1FBQ1g7SUFDRjtJQUVDLFVBQVV6RSxLQUFJO1FBRWIsSUFBSSxDQUFDcUUsZUFBZXJFLFFBQU87WUFDekI7UUFDRjtRQUVBLElBQUksQ0FBQ0EsTUFBSzRFLEtBQUssRUFBRTtZQUNmTCxRQUFRc0IsSUFBSSxDQUFDO1lBQ2I7UUFDRjtRQUVBLElBQUlDLGtCQUFrQnBCLHdCQUF3QjFFLFFBQzFDNEUsUUFBUWtCLGdCQUFnQmxCLEtBQUssRUFDN0JILFVBQVVxQixnQkFBZ0JyQixPQUFPO1FBRXJDekUsTUFBSzRFLEtBQUssR0FBR0E7UUFDYjVFLE1BQUt5RSxPQUFPLEdBQUdBO1FBQ2Z4RyxPQUFPQyxjQUFjLENBQUM4QixPQUFNLG1CQUFtQjtZQUM3Q2hDLFVBQVU7WUFDVkYsWUFBWTtZQUNaQyxjQUFjO1lBQ2RjLE9BQU9zRTtRQUNUO1FBQ0FsRixPQUFPQyxjQUFjLENBQUM4QixPQUFNLGVBQWU7WUFDekNoQyxVQUFVO1lBQ1ZGLFlBQVk7WUFDWkMsY0FBYztZQUNkYyxPQUFPOEQ7UUFDVDtJQUNGLEdBQUcsT0FBTzNDLFNBQVMsY0FBY0EsT0FBTytGO0FBRTFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvcG9seWZpbGwtcGF0Y2gtZmV0Y2guanM/MmIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgpO1xufSkoKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXQoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB2YXIgRW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyKTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsaXN0ZW5lcnMnLCB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIsIFt7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFjay5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoc3RhY2tbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHZhciBzdGFja1RvQ2FsbCA9IHN0YWNrLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFja1RvQ2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBzdGFja1RvQ2FsbFtpXTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVtaXR0ZXI7XG4gIH0oKTtcblxuICB2YXIgQWJvcnRTaWduYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKEFib3J0U2lnbmFsLCBfRW1pdHRlcik7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFib3J0U2lnbmFsKTtcblxuICAgIGZ1bmN0aW9uIEFib3J0U2lnbmFsKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwpO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLyBTb21lIHZlcnNpb25zIG9mIGJhYmVsIGRvZXMgbm90IHRyYW5zcGlsZSBzdXBlcigpIGNvcnJlY3RseSBmb3IgSUUgPD0gMTAsIGlmIHRoZSBwYXJlbnRcbiAgICAgIC8vIGNvbnN0cnVjdG9yIGhhcyBmYWlsZWQgdG8gcnVuLCB0aGVuIFwidGhpcy5saXN0ZW5lcnNcIiB3aWxsIHN0aWxsIGJlIHVuZGVmaW5lZCBhbmQgdGhlbiB3ZSBjYWxsXG4gICAgICAvLyB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGRpcmVjdGx5IGluc3RlYWQgYXMgYSB3b3JrYXJvdW5kLiBGb3IgZ2VuZXJhbCBkZXRhaWxzLCBzZWUgYmFiZWwgYnVnOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy8zMDQxXG4gICAgICAvLyBUaGlzIGhhY2sgd2FzIGFkZGVkIGFzIGEgZml4IGZvciB0aGUgaXNzdWUgZGVzY3JpYmVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLWxpYnJhcnkvcHVsbC81OSNpc3N1ZWNvbW1lbnQtNDc3NTU4MDQyXG5cbiAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgIEVtaXR0ZXIuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICB9IC8vIENvbXBhcmVkIHRvIGFzc2lnbm1lbnQsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBtYWtlcyBwcm9wZXJ0aWVzIG5vbi1lbnVtZXJhYmxlIGJ5IGRlZmF1bHQgYW5kXG4gICAgICAvLyB3ZSB3YW50IE9iamVjdC5rZXlzKG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpIHRvIGJlIFtdIGZvciBjb21wYXQgd2l0aCB0aGUgbmF0aXZlIGltcGxcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICdhYm9ydGVkJywge1xuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnb25hYm9ydCcsIHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAncmVhc29uJywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWJvcnRTaWduYWwsIFt7XG4gICAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdbb2JqZWN0IEFib3J0U2lnbmFsXSc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbmFib3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uYWJvcnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQWJvcnRTaWduYWwucHJvdG90eXBlKSwgXCJkaXNwYXRjaEV2ZW50XCIsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBYm9ydFNpZ25hbDtcbiAgfShFbWl0dGVyKTtcbiAgdmFyIEFib3J0Q29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJvcnRDb250cm9sbGVyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3J0Q29udHJvbGxlcik7XG5cbiAgICAgIC8vIENvbXBhcmVkIHRvIGFzc2lnbm1lbnQsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBtYWtlcyBwcm9wZXJ0aWVzIG5vbi1lbnVtZXJhYmxlIGJ5IGRlZmF1bHQgYW5kXG4gICAgICAvLyB3ZSB3YW50IE9iamVjdC5rZXlzKG5ldyBBYm9ydENvbnRyb2xsZXIoKSkgdG8gYmUgW10gZm9yIGNvbXBhdCB3aXRoIHRoZSBuYXRpdmUgaW1wbFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaWduYWwnLCB7XG4gICAgICAgIHZhbHVlOiBuZXcgQWJvcnRTaWduYWwoKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEFib3J0Q29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJhYm9ydFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICB2YXIgZXZlbnQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBldmVudCA9IG5ldyBFdmVudCgnYWJvcnQnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgIC8vIEZvciBJbnRlcm5ldCBFeHBsb3JlciA4OlxuICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSAnYWJvcnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRm9yIEludGVybmV0IEV4cGxvcmVyIDExOlxuICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2Fib3J0JywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgd2hlcmUgZG9jdW1lbnQgaXNuJ3QgYXZhaWxhYmxlOlxuICAgICAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdhYm9ydCcsXG4gICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lnbmFsUmVhc29uID0gcmVhc29uO1xuXG4gICAgICAgIGlmIChzaWduYWxSZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoJ1RoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IERPTUV4Y2VwdGlvbignc2lnbmFsIGlzIGFib3J0ZWQgd2l0aG91dCByZWFzb24nKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAvLyBJRSAxMSBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmcgdGhlIERPTUV4Y2VwdGlvbiBjb25zdHJ1Y3RvciwgdXNlIGFcbiAgICAgICAgICAgICAgLy8gcmVndWxhciBlcnJvciBvYmplY3Qgb24gaXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgc2lnbmFsUmVhc29uID0gbmV3IEVycm9yKCdUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgICBzaWduYWxSZWFzb24ubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSBzaWduYWxSZWFzb247XG4gICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRDb250cm9sbGVyXSc7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAvLyBUaGVzZSBhcmUgbmVjZXNzYXJ5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGdldCBjb3JyZWN0IG91dHB1dCBmb3I6XG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBBYm9ydENvbnRyb2xsZXIoKSlcbiAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQWJvcnRDb250cm9sbGVyJztcbiAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdBYm9ydFNpZ25hbCc7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmKSB7XG4gICAgaWYgKHNlbGYuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkge1xuICAgICAgY29uc29sZS5sb2coJ19fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3RlIHRoYXQgdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgZGVmaW5lcyBmZXRjaCgpIHdpdGhvdXRcbiAgICAvLyBkZWZpbmluZyB3aW5kb3cuUmVxdWVzdCwgYW5kIHRoaXMgcG9seWZpbGwgbmVlZCB0byB3b3JrIG9uIHRvcCBvZiB1bmZldGNoXG4gICAgLy8gc28gdGhlIGJlbG93IGZlYXR1cmUgZGV0ZWN0aW9uIG5lZWRzIHRoZSAhc2VsZi5BYm9ydENvbnRyb2xsZXIgcGFydC5cbiAgICAvLyBUaGUgUmVxdWVzdC5wcm90b3R5cGUgY2hlY2sgaXMgYWxzbyBuZWVkZWQgYmVjYXVzZSBTYWZhcmkgdmVyc2lvbnMgMTEuMS4yXG4gICAgLy8gdXAgdG8gYW5kIGluY2x1ZGluZyAxMi4xLnggaGFzIGEgd2luZG93LkFib3J0Q29udHJvbGxlciBwcmVzZW50IGJ1dCBzdGlsbFxuICAgIC8vIGRvZXMgTk9UIGNvcnJlY3RseSBpbXBsZW1lbnQgYWJvcnRhYmxlIGZldGNoOlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzQ5ODAjYzJcblxuXG4gICAgcmV0dXJuIHR5cGVvZiBzZWxmLlJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgIXNlbGYuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NpZ25hbCcpIHx8ICFzZWxmLkFib3J0Q29udHJvbGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlOiB0aGUgXCJmZXRjaC5SZXF1ZXN0XCIgZGVmYXVsdCB2YWx1ZSBpcyBhdmFpbGFibGUgZm9yIGZldGNoIGltcG9ydGVkIGZyb21cbiAgICogdGhlIFwibm9kZS1mZXRjaFwiIHBhY2thZ2UgYW5kIG5vdCBpbiBicm93c2Vycy4gVGhpcyBpcyBPSyBzaW5jZSBicm93c2Vyc1xuICAgKiB3aWxsIGJlIGltcG9ydGluZyB1bWQtcG9seWZpbGwuanMgZnJvbSB0aGF0IHBhdGggXCJzZWxmXCIgaXMgcGFzc2VkIHRoZVxuICAgKiBkZWNvcmF0b3Igc28gdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBub3QgYmUgdXNlZCAoYmVjYXVzZSBicm93c2VycyB0aGF0IGRlZmluZVxuICAgKiBmZXRjaCBhbHNvIGhhcyBSZXF1ZXN0KS4gT25lIHF1aXJreSBzZXR1cCB3aGVyZSBzZWxmLmZldGNoIGV4aXN0cyBidXRcbiAgICogc2VsZi5SZXF1ZXN0IGRvZXMgbm90IGlzIHdoZW4gdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgaXMgdXNlZFxuICAgKiBvbiB0b3Agb2YgSUUxMTsgZm9yIHRoaXMgY2FzZSB0aGUgYnJvd3NlciB3aWxsIHRyeSB0byB1c2UgdGhlIGZldGNoLlJlcXVlc3RcbiAgICogZGVmYXVsdCB2YWx1ZSB3aGljaCBpbiB0dXJuIHdpbGwgYmUgdW5kZWZpbmVkIGJ1dCB0aGVuIHRoZW4gXCJpZiAoUmVxdWVzdClcIlxuICAgKiB3aWxsIGVuc3VyZSB0aGF0IHlvdSBnZXQgYSBwYXRjaGVkIGZldGNoIGJ1dCBzdGlsbCBubyBSZXF1ZXN0IChhcyBleHBlY3RlZCkuXG4gICAqIEBwYXJhbSB7ZmV0Y2gsIFJlcXVlc3QgPSBmZXRjaC5SZXF1ZXN0fVxuICAgKiBAcmV0dXJucyB7ZmV0Y2g6IGFib3J0YWJsZUZldGNoLCBSZXF1ZXN0OiBBYm9ydGFibGVSZXF1ZXN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHBhdGNoVGFyZ2V0cykge1xuICAgICAgcGF0Y2hUYXJnZXRzID0ge1xuICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfcGF0Y2hUYXJnZXRzID0gcGF0Y2hUYXJnZXRzLFxuICAgICAgICBmZXRjaCA9IF9wYXRjaFRhcmdldHMuZmV0Y2gsXG4gICAgICAgIF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMuUmVxdWVzdCxcbiAgICAgICAgTmF0aXZlUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9PT0gdm9pZCAwID8gZmV0Y2guUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCxcbiAgICAgICAgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCxcbiAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7XG5cbiAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHtcbiAgICAgIGZldGNoOiBmZXRjaCxcbiAgICAgIFJlcXVlc3Q6IE5hdGl2ZVJlcXVlc3QsXG4gICAgICBBYm9ydENvbnRyb2xsZXI6IE5hdGl2ZUFib3J0Q29udHJvbGxlcixcbiAgICAgIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw6IF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTExcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2g6IGZldGNoLFxuICAgICAgICBSZXF1ZXN0OiBSZXF1ZXN0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBSZXF1ZXN0ID0gTmF0aXZlUmVxdWVzdDsgLy8gTm90ZSB0aGF0IHRoZSBcInVuZmV0Y2hcIiBtaW5pbWFsIGZldGNoIHBvbHlmaWxsIGRlZmluZXMgZmV0Y2goKSB3aXRob3V0XG4gICAgLy8gZGVmaW5pbmcgd2luZG93LlJlcXVlc3QsIGFuZCB0aGlzIHBvbHlmaWxsIG5lZWQgdG8gd29yayBvbiB0b3Agb2YgdW5mZXRjaFxuICAgIC8vIGhlbmNlIHdlIG9ubHkgcGF0Y2ggaXQgaWYgaXQncyBhdmFpbGFibGUuIEFsc28gd2UgZG9uJ3QgcGF0Y2ggaXQgaWYgc2lnbmFsXG4gICAgLy8gaXMgYWxyZWFkeSBhdmFpbGFibGUgb24gdGhlIFJlcXVlc3QgcHJvdG90eXBlIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHN1cHBvcnRcbiAgICAvLyBpcyBwcmVzZW50IGFuZCB0aGUgcGF0Y2hpbmcgYmVsb3cgY2FuIGNhdXNlIGEgY3Jhc2ggc2luY2UgaXQgYXNzaWducyB0b1xuICAgIC8vIHJlcXVlc3Quc2lnbmFsIHdoaWNoIGlzIHRlY2huaWNhbGx5IGEgcmVhZC1vbmx5IHByb3BlcnR5LiBUaGlzIGxhdHRlciBlcnJvclxuICAgIC8vIGhhcHBlbnMgd2hlbiB5b3UgcnVuIHRoZSBtYWluNS5qcyBub2RlLWZldGNoIGV4YW1wbGUgaW4gdGhlIHJlcG9cbiAgICAvLyBcImFib3J0Y29udHJvbGxlci1wb2x5ZmlsbC1leGFtcGxlc1wiLiBUaGUgZXhhY3QgZXJyb3IgaXM6XG4gICAgLy8gICByZXF1ZXN0LnNpZ25hbCA9IGluaXQuc2lnbmFsO1xuICAgIC8vICAgXlxuICAgIC8vIFR5cGVFcnJvcjogQ2Fubm90IHNldCBwcm9wZXJ0eSBzaWduYWwgb2YgIzxSZXF1ZXN0PiB3aGljaCBoYXMgb25seSBhIGdldHRlclxuXG4gICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzaWduYWwnKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7XG4gICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgaW5pdCkge1xuICAgICAgICB2YXIgc2lnbmFsO1xuXG4gICAgICAgIGlmIChpbml0ICYmIGluaXQuc2lnbmFsKSB7XG4gICAgICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWw7IC8vIE5ldmVyIHBhc3MgaW5pdC5zaWduYWwgdG8gdGhlIG5hdGl2ZSBSZXF1ZXN0IGltcGxlbWVudGF0aW9uIHdoZW4gdGhlIHBvbHlmaWxsIGhhc1xuICAgICAgICAgIC8vIGJlZW4gaW5zdGFsbGVkIGJlY2F1c2UgaWYgd2UncmUgcnVubmluZyBvbiB0b3Agb2YgYSBicm93c2VyIHdpdGggYVxuICAgICAgICAgIC8vIHdvcmtpbmcgbmF0aXZlIEFib3J0Q29udHJvbGxlciAoaS5lLiB0aGUgcG9seWZpbGwgd2FzIGluc3RhbGxlZCBkdWUgdG9cbiAgICAgICAgICAvLyBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMIGJlaW5nIHNldCksIHRoZW4gcGFzc2luZyBvdXJcbiAgICAgICAgICAvLyBmYWtlIEFib3J0U2lnbmFsIHRvIHRoZSBuYXRpdmUgZmV0Y2ggd2lsbCB0cmlnZ2VyOlxuICAgICAgICAgIC8vIFR5cGVFcnJvcjogRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXG5cbiAgICAgICAgICBkZWxldGUgaW5pdC5zaWduYWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICdzaWduYWwnLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgfTtcblxuICAgICAgUmVxdWVzdC5wcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2g7XG5cbiAgICB2YXIgYWJvcnRhYmxlRmV0Y2ggPSBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaChpbnB1dCwgaW5pdCkge1xuICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0ID8gaW5pdC5zaWduYWwgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgdmFyIGFib3J0RXJyb3I7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIElFIDExIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyB0aGUgRE9NRXhjZXB0aW9uIGNvbnN0cnVjdG9yLCB1c2UgYVxuICAgICAgICAgIC8vIHJlZ3VsYXIgZXJyb3Igb2JqZWN0IG9uIGl0IGluc3RlYWQuXG4gICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgfSAvLyBSZXR1cm4gZWFybHkgaWYgYWxyZWFkeSBhYm9ydGVkLCB0aHVzIGF2b2lkaW5nIG1ha2luZyBhbiBIVFRQIHJlcXVlc3RcblxuXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcbiAgICAgICAgfSAvLyBUdXJuIGFuIGV2ZW50IGludG8gYSBwcm9taXNlLCByZWplY3QgaXQgb25jZSBgYWJvcnRgIGlzIGRpc3BhdGNoZWRcblxuXG4gICAgICAgIHZhciBjYW5jZWxsYXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhYm9ydEVycm9yKTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbml0ICYmIGluaXQuc2lnbmFsKSB7XG4gICAgICAgICAgLy8gTmV2ZXIgcGFzcyAuc2lnbmFsIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gd2hlbiB0aGUgcG9seWZpbGwgaGFzXG4gICAgICAgICAgLy8gYmVlbiBpbnN0YWxsZWQgYmVjYXVzZSBpZiB3ZSdyZSBydW5uaW5nIG9uIHRvcCBvZiBhIGJyb3dzZXIgd2l0aCBhXG4gICAgICAgICAgLy8gd29ya2luZyBuYXRpdmUgQWJvcnRDb250cm9sbGVyIChpLmUuIHRoZSBwb2x5ZmlsbCB3YXMgaW5zdGFsbGVkIGR1ZSB0b1xuICAgICAgICAgIC8vIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgYmVpbmcgc2V0KSwgdGhlbiBwYXNzaW5nIG91clxuICAgICAgICAgIC8vIGZha2UgQWJvcnRTaWduYWwgdG8gdGhlIG5hdGl2ZSBmZXRjaCB3aWxsIHRyaWdnZXI6XG4gICAgICAgICAgLy8gVHlwZUVycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSAnZmV0Y2gnIG9uICdXaW5kb3cnOiBtZW1iZXIgc2lnbmFsIGlzIG5vdCBvZiB0eXBlIEFib3J0U2lnbmFsLlxuICAgICAgICAgIGRlbGV0ZSBpbml0LnNpZ25hbDtcbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGZhc3Rlc3QgcHJvbWlzZSAoZG9uJ3QgbmVlZCB0byB3YWl0IGZvciByZXF1ZXN0IHRvIGZpbmlzaClcblxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0KV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhbEZldGNoKGlucHV0LCBpbml0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZldGNoOiBhYm9ydGFibGVGZXRjaCxcbiAgICAgIFJlcXVlc3Q6IFJlcXVlc3RcbiAgICB9O1xuICB9XG5cbiAgKGZ1bmN0aW9uIChzZWxmKSB7XG5cbiAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHNlbGYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmZldGNoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2ZldGNoKCkgaXMgbm90IGF2YWlsYWJsZSwgY2Fubm90IGluc3RhbGwgYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hYm9ydGFibGVGZXRjaCA9IGFib3J0YWJsZUZldGNoRGVjb3JhdG9yKHNlbGYpLFxuICAgICAgICBmZXRjaCA9IF9hYm9ydGFibGVGZXRjaC5mZXRjaCxcbiAgICAgICAgUmVxdWVzdCA9IF9hYm9ydGFibGVGZXRjaC5SZXF1ZXN0O1xuXG4gICAgc2VsZi5mZXRjaCA9IGZldGNoO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICdBYm9ydENvbnRyb2xsZXInLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEFib3J0Q29udHJvbGxlclxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnQWJvcnRTaWduYWwnLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEFib3J0U2lnbmFsXG4gICAgfSk7XG4gIH0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiBnbG9iYWwpO1xuXG59KSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJfc2V0UHJvdG90eXBlT2YiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJwIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImNhbGwiLCJlIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfc3VwZXJQcm9wQmFzZSIsIm9iamVjdCIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJfZ2V0IiwiZ2V0IiwicmVjZWl2ZXIiLCJiYXNlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIkVtaXR0ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwidHlwZSIsImNhbGxiYWNrIiwib3B0aW9ucyIsImxpc3RlbmVycyIsInB1c2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3RhY2siLCJsIiwic3BsaWNlIiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50Iiwic3RhY2tUb0NhbGwiLCJzbGljZSIsImxpc3RlbmVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwib25jZSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJBYm9ydFNpZ25hbCIsIl9FbWl0dGVyIiwiX3N1cGVyIiwiX3RoaXMiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImFib3J0ZWQiLCJvbmFib3J0IiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnQiLCJyZWFzb24iLCJFdmVudCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJjcmVhdGVFdmVudE9iamVjdCIsImluaXRFdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwic2lnbmFsUmVhc29uIiwiRXJyb3IiLCJuYW1lIiwiRE9NRXhjZXB0aW9uIiwiZXJyIiwic2lnbmFsIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJwb2x5ZmlsbE5lZWRlZCIsIl9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwiLCJjb25zb2xlIiwibG9nIiwiUmVxdWVzdCIsImFib3J0YWJsZUZldGNoRGVjb3JhdG9yIiwicGF0Y2hUYXJnZXRzIiwiZmV0Y2giLCJfcGF0Y2hUYXJnZXRzIiwiX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0IiwiTmF0aXZlUmVxdWVzdCIsIk5hdGl2ZUFib3J0Q29udHJvbGxlciIsIl9wYXRjaFRhcmdldHMkX19GT1JDRSIsImlucHV0IiwiaW5pdCIsInJlcXVlc3QiLCJyZWFsRmV0Y2giLCJhYm9ydGFibGVGZXRjaCIsImlzUHJvdG90eXBlT2YiLCJhYm9ydEVycm9yIiwicmVqZWN0IiwiY2FuY2VsbGF0aW9uIiwiXyIsInJhY2UiLCJ3YXJuIiwiX2Fib3J0YWJsZUZldGNoIiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js\n");

/***/ })

};
;